{
  "title": "Autonomous Programming Basics",
  "sections": [
    {
      "title": "Introduction to Autonomous Programming",
      "content": "Autonomous mode is when your robot operates independently without driver input. This is the first 30 seconds of FTC matches and can give your team a significant advantage. In this lesson, you'll learn the fundamentals of creating reliable autonomous programs."
    },
    {
      "title": "Autonomous Structure",
      "content": "Every autonomous program follows a specific structure:\n\n```java\n@Autonomous(name=\"Basic Auto\")\npublic class BasicAuto extends OpMode {\n    // Hardware declarations\n    private DcMotor leftMotor;\n    private DcMotor rightMotor;\n    private ElapsedTime runtime;\n    \n    @Override\n    public void init() {\n        // Initialize hardware\n        leftMotor = hardwareMap.get(DcMotor.class, \"left_motor\");\n        rightMotor = hardwareMap.get(DcMotor.class, \"right_motor\");\n        runtime = new ElapsedTime();\n        \n        // Configure motors\n        leftMotor.setDirection(DcMotor.Direction.FORWARD);\n        rightMotor.setDirection(DcMotor.Direction.REVERSE);\n        leftMotor.setZeroPowerBehavior(DcMotor.ZeroPowerBehavior.BRAKE);\n        rightMotor.setZeroPowerBehavior(DcMotor.ZeroPowerBehavior.BRAKE);\n    }\n    \n    @Override\n    public void start() {\n        // Called when autonomous starts\n        runtime.reset();\n        telemetry.addData(\"Status\", \"Autonomous Started\");\n        telemetry.update();\n    }\n    \n    @Override\n    public void loop() {\n        // Main autonomous logic runs here\n        // This method is called repeatedly during autonomous\n    }\n}\n```"
    },
    {
      "title": "Basic Autonomous Sequences",
      "content": "Start with simple time-based sequences:\n\n```java\n@Override\npublic void loop() {\n    double time = runtime.seconds();\n    \n    if (time < 2.0) {\n        // Drive forward for 2 seconds\n        leftMotor.setPower(0.5);\n        rightMotor.setPower(0.5);\n        telemetry.addData(\"Action\", \"Driving Forward\");\n    } else if (time < 4.0) {\n        // Turn right for 2 seconds\n        leftMotor.setPower(0.3);\n        rightMotor.setPower(-0.3);\n        telemetry.addData(\"Action\", \"Turning Right\");\n    } else if (time < 6.0) {\n        // Drive forward again\n        leftMotor.setPower(0.5);\n        rightMotor.setPower(0.5);\n        telemetry.addData(\"Action\", \"Driving Forward Again\");\n    } else {\n        // Stop\n        leftMotor.setPower(0);\n        rightMotor.setPower(0);\n        telemetry.addData(\"Action\", \"Stopped\");\n    }\n    \n    telemetry.addData(\"Time\", time);\n    telemetry.update();\n}\n```\n\nThis approach is simple but not very reliable because timing can vary with battery level, surface conditions, and other factors."
    },
    {
      "title": "State Machines",
      "content": "State machines are more reliable than time-based sequences. They transition based on conditions rather than time:\n\n```java\nprivate enum AutoState {\n    DRIVE_FORWARD,\n    TURN_RIGHT,\n    DRIVE_TO_LINE,\n    FOLLOW_LINE,\n    STOP\n}\n\nprivate AutoState currentState = AutoState.DRIVE_FORWARD;\nprivate ElapsedTime stateTimer = new ElapsedTime();\n\n@Override\npublic void start() {\n    runtime.reset();\n    stateTimer.reset();\n    currentState = AutoState.DRIVE_FORWARD;\n}\n\n@Override\npublic void loop() {\n    switch (currentState) {\n        case DRIVE_FORWARD:\n            leftMotor.setPower(0.5);\n            rightMotor.setPower(0.5);\n            \n            // Transition to next state after 3 seconds\n            if (stateTimer.seconds() > 3.0) {\n                currentState = AutoState.TURN_RIGHT;\n                stateTimer.reset();\n            }\n            break;\n            \n        case TURN_RIGHT:\n            leftMotor.setPower(0.3);\n            rightMotor.setPower(-0.3);\n            \n            // Turn for 2 seconds\n            if (stateTimer.seconds() > 2.0) {\n                currentState = AutoState.DRIVE_TO_LINE;\n                stateTimer.reset();\n            }\n            break;\n            \n        case DRIVE_TO_LINE:\n            leftMotor.setPower(0.3);\n            rightMotor.setPower(0.3);\n            \n            // Check for line (assuming you have a color sensor)\n            if (colorSensor.alpha() < 100) { // Dark line detected\n                currentState = AutoState.FOLLOW_LINE;\n                stateTimer.reset();\n            }\n            break;\n            \n        case FOLLOW_LINE:\n            // Simple line following\n            if (colorSensor.alpha() < 50) {\n                leftMotor.setPower(-0.2);\n                rightMotor.setPower(0.2);\n            } else {\n                leftMotor.setPower(0.2);\n                rightMotor.setPower(0.2);\n            }\n            \n            // Follow line for 5 seconds\n            if (stateTimer.seconds() > 5.0) {\n                currentState = AutoState.STOP;\n            }\n            break;\n            \n        case STOP:\n            leftMotor.setPower(0);\n            rightMotor.setPower(0);\n            break;\n    }\n    \n    telemetry.addData(\"State\", currentState);\n    telemetry.addData(\"State Time\", stateTimer.seconds());\n    telemetry.update();\n}\n```"
    },
    {
      "title": "Sensor-Based Autonomous",
      "content": "Using sensors makes autonomous much more reliable:\n\n```java\n@Autonomous(name=\"Sensor-Based Auto\")\npublic class SensorBasedAuto extends OpMode {\n    private DcMotor leftMotor, rightMotor;\n    private ColorSensor colorSensor;\n    private DistanceSensor distanceSensor;\n    private BNO055IMU imu;\n    private ElapsedTime runtime;\n    \n    private enum State {\n        DRIVE_TO_WALL,\n        TURN_90_DEGREES,\n        FOLLOW_LINE,\n        STOP\n    }\n    \n    private State currentState = State.DRIVE_TO_WALL;\n    \n    @Override\n    public void init() {\n        // Initialize hardware\n        leftMotor = hardwareMap.get(DcMotor.class, \"left_motor\");\n        rightMotor = hardwareMap.get(DcMotor.class, \"right_motor\");\n        colorSensor = hardwareMap.get(ColorSensor.class, \"color_sensor\");\n        distanceSensor = hardwareMap.get(DistanceSensor.class, \"distance_sensor\");\n        imu = hardwareMap.get(BNO055IMU.class, \"imu\");\n        runtime = new ElapsedTime();\n        \n        // Initialize IMU\n        BNO055IMU.Parameters parameters = new BNO055IMU.Parameters();\n        parameters.angleUnit = BNO055IMU.AngleUnit.DEGREES;\n        imu.initialize(parameters);\n    }\n    \n    @Override\n    public void start() {\n        runtime.reset();\n    }\n    \n    @Override\n    public void loop() {\n        // Read sensors\n        double distance = distanceSensor.getDistance(DistanceUnit.CM);\n        int lightLevel = colorSensor.alpha();\n        Orientation angles = imu.getAngularOrientation(AxesReference.INTRINSIC, AxesOrder.ZYX, AngleUnit.DEGREES);\n        double heading = angles.firstAngle;\n        \n        switch (currentState) {\n            case DRIVE_TO_WALL:\n                if (distance > 10) {\n                    leftMotor.setPower(0.3);\n                    rightMotor.setPower(0.3);\n                } else {\n                    leftMotor.setPower(0);\n                    rightMotor.setPower(0);\n                    currentState = State.TURN_90_DEGREES;\n                }\n                break;\n                \n            case TURN_90_DEGREES:\n                double targetHeading = heading + 90;\n                if (targetHeading > 180) targetHeading -= 360;\n                \n                if (Math.abs(heading - targetHeading) > 5) {\n                    leftMotor.setPower(0.2);\n                    rightMotor.setPower(-0.2);\n                } else {\n                    leftMotor.setPower(0);\n                    rightMotor.setPower(0);\n                    currentState = State.FOLLOW_LINE;\n                }\n                break;\n                \n            case FOLLOW_LINE:\n                if (lightLevel < 100) {\n                    // Line detected - follow it\n                    if (lightLevel < 50) {\n                        leftMotor.setPower(-0.2);\n                        rightMotor.setPower(0.2);\n                    } else {\n                        leftMotor.setPower(0.2);\n                        rightMotor.setPower(0.2);\n                    }\n                } else {\n                    // No line - search for it\n                    leftMotor.setPower(0.1);\n                    rightMotor.setPower(0.1);\n                }\n                \n                // Stop after 10 seconds\n                if (runtime.seconds() > 10) {\n                    currentState = State.STOP;\n                }\n                break;\n                \n            case STOP:\n                leftMotor.setPower(0);\n                rightMotor.setPower(0);\n                break;\n        }\n        \n        telemetry.addData(\"State\", currentState);\n        telemetry.addData(\"Distance\", distance);\n        telemetry.addData(\"Light Level\", lightLevel);\n        telemetry.addData(\"Heading\", heading);\n        telemetry.update();\n    }\n}\n```"
    },
    {
      "title": "Autonomous Strategy",
      "content": "Good autonomous strategy involves:\n\n1. **Start Position**: Know exactly where your robot starts\n2. **Game Analysis**: Understand what tasks give the most points\n3. **Reliability**: Focus on completing simple tasks consistently\n4. **Speed**: Optimize for speed once reliability is achieved\n\n**Example Strategy**:\n```java\n// Strategy: Drive to scoring position, score, park\nprivate enum Strategy {\n    DRIVE_TO_SCORING,\n    SCORE_ELEMENT,\n    PARK,\n    STOP\n}\n\nprivate Strategy currentStrategy = Strategy.DRIVE_TO_SCORING;\n\n@Override\npublic void loop() {\n    switch (currentStrategy) {\n        case DRIVE_TO_SCORING:\n            // Use encoders to drive exact distance\n            driveToPosition(24, 0.5); // 24 inches\n            currentStrategy = Strategy.SCORE_ELEMENT;\n            break;\n            \n        case SCORE_ELEMENT:\n            // Activate scoring mechanism\n            armServo.setPosition(1.0);\n            sleep(1000); // Wait 1 second\n            armServo.setPosition(0.0);\n            currentStrategy = Strategy.PARK;\n            break;\n            \n        case PARK:\n            // Drive to parking zone\n            driveToPosition(12, 0.3); // 12 inches\n            currentStrategy = Strategy.STOP;\n            break;\n            \n        case STOP:\n            // Stop all motors\n            stopAllMotors();\n            break;\n    }\n}\n```"
    },
    {
      "title": "Error Handling and Recovery",
      "content": "Robust autonomous programs handle errors gracefully:\n\n```java\npublic class AutoErrorHandler {\n    private int errorCount = 0;\n    private ElapsedTime errorTimer = new ElapsedTime();\n    \n    public boolean handleError(String errorType) {\n        errorCount++;\n        telemetry.addData(\"Error\", errorType + \" (Count: \" + errorCount + \")\");\n        \n        if (errorCount > 3) {\n            // Too many errors - stop autonomous\n            telemetry.addData(\"Status\", \"Too many errors - stopping\");\n            return false;\n        }\n        \n        // Wait before retrying\n        sleep(500);\n        return true;\n    }\n    \n    public void reset() {\n        errorCount = 0;\n        errorTimer.reset();\n    }\n}\n\n// Usage in autonomous\nAutoErrorHandler errorHandler = new AutoErrorHandler();\n\n// Example: Handle sensor failure\nif (distanceSensor.getDistance(DistanceUnit.CM) < 0) {\n    if (!errorHandler.handleError(\"Distance sensor failure\")) {\n        currentState = State.STOP;\n    }\n}\n```"
    },
    {
      "title": "Practice Exercise",
      "content": "Create an autonomous program that:\n\n1. **Starts in a known position** (e.g., against a wall)\n2. **Drives forward 18 inches** using encoders\n3. **Turns 90 degrees** using the gyroscope\n4. **Follows a line** for 5 seconds using a color sensor\n5. **Stops in a designated area**\n\n**Requirements**:\n- Use a state machine for reliable operation\n- Include error handling for sensor failures\n- Add comprehensive telemetry for debugging\n- Test multiple times to ensure consistency\n\n**Advanced Challenge**:\n- Add multiple scoring positions\n- Implement different strategies based on game elements\n- Add time-based fallbacks for sensor failures"
    },
    {
      "title": "Common Issues and Solutions",
      "content": "**Problem**: Autonomous behavior is inconsistent\n- **Solution**: Use sensors instead of time, add error handling\n\n**Problem**: Robot doesn't complete tasks in time\n- **Solution**: Optimize for speed, reduce unnecessary movements\n\n**Problem**: Sensors give false readings\n- **Solution**: Add filtering, use multiple sensors, implement fallbacks\n\n**Problem**: Robot gets stuck or confused\n- **Solution**: Add timeout mechanisms, implement recovery behaviors\n\n**Problem**: Autonomous works in practice but fails in matches\n- **Solution**: Test under match conditions, account for field variations"
    },
    {
      "title": "Next Steps",
      "content": "You now have the basics of autonomous programming! In the next lessons, you'll learn about:\n\n- Advanced autonomous with complex state machines\n- Computer vision integration\n- Advanced control systems and PID tuning\n- Performance optimization and debugging\n\nPractice creating reliable autonomous programs and experiment with different strategies to build your skills."
    }
  ]
} 