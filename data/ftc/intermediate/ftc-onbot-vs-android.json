{
  "title": "OnBot Java vs Android Studio",
  "sections": [
    {
      "type": "text",
      "title": "Understanding the Differences",
      "content": "Both OnBot Java and Android Studio are valid development environments for FTC programming, but they serve different purposes and have distinct advantages. Understanding when to use each is crucial for effective robot development."
    },
    {
      "type": "rules-box",
      "title": "Quick Comparison",
      "items": [
        "<strong>OnBot Java:</strong> Web-based, immediate deployment, simple setup, limited debugging",
        "<strong>Android Studio:</strong> Desktop IDE, advanced debugging, version control, professional features",
        "<strong>OnBot Java:</strong> Perfect for beginners and rapid prototyping",
        "<strong>Android Studio:</strong> Essential for advanced development and team collaboration"
      ],
      "subtitle": "Key differences between OnBot Java and Android Studio:"
    },
    {
      "type": "text",
      "title": "OnBot Java Advantages",
      "content": "OnBot Java is ideal for specific scenarios and has several key advantages:"
    },
    {
      "type": "list",
      "title": "When to Use OnBot Java",
      "items": [
        "<strong>Beginner Learning:</strong> No complex setup required, immediate feedback",
        "<strong>Rapid Prototyping:</strong> Quick code changes and testing",
        "<strong>Field Testing:</strong> Easy to modify code during competitions",
        "<strong>Simple Programs:</strong> Basic teleop and autonomous routines",
        "<strong>Limited Resources:</strong> Works on any device with a web browser",
        "<strong>Quick Fixes:</strong> Emergency code changes during matches"
      ]
    },
    {
      "type": "code",
      "title": "OnBot Java Example",
      "content": "// Simple OnBot Java OpMode - quick and straightforward\n@TeleOp(name=\"Quick Test\", group=\"Test\")\npublic class QuickTest extends LinearOpMode {\n    \n    private DcMotor leftMotor, rightMotor;\n    \n    @Override\n    public void runOpMode() {\n        // Quick hardware setup\n        leftMotor = hardwareMap.get(DcMotor.class, \"leftMotor\");\n        rightMotor = hardwareMap.get(DcMotor.class, \"rightMotor\");\n        \n        waitForStart();\n        \n        while (opModeIsActive()) {\n            // Simple tank drive\n            leftMotor.setPower(-gamepad1.left_stick_y);\n            rightMotor.setPower(-gamepad1.right_stick_y);\n            \n            // Basic telemetry\n            telemetry.addData(\"Left Power\", leftMotor.getPower());\n            telemetry.addData(\"Right Power\", rightMotor.getPower());\n            telemetry.update();\n        }\n    }\n}"
    },
    {
      "type": "text",
      "title": "Android Studio Advantages",
      "content": "Android Studio provides professional development features essential for advanced FTC programming:"
    },
    {
      "type": "list",
      "title": "When to Use Android Studio",
      "items": [
        "<strong>Complex Programs:</strong> Multi-class projects with proper organization",
        "<strong>Team Development:</strong> Version control and collaboration features",
        "<strong>Advanced Debugging:</strong> Step-through debugging and variable inspection",
        "<strong>Performance Optimization:</strong> Profiling tools and performance analysis",
        "<strong>Code Reusability:</strong> Proper package structure and inheritance",
        "<strong>Professional Development:</strong> Industry-standard tools and workflows"
      ]
    },
    {
      "type": "code",
      "title": "Android Studio Example",
      "content": "// Professional Android Studio structure\npackage org.firstinspires.ftc.teamcode.teleop;\n\nimport org.firstinspires.ftc.teamcode.hardware.RobotHardware;\nimport org.firstinspires.ftc.teamcode.utils.PIDController;\nimport org.firstinspires.ftc.teamcode.utils.StateMachine;\n\n@TeleOp(name=\"Advanced TeleOp\", group=\"Advanced\")\npublic class AdvancedTeleOp extends LinearOpMode {\n    \n    // Professional hardware abstraction\n    private RobotHardware robot;\n    \n    // Advanced utilities\n    private PIDController drivePID;\n    private StateMachine stateMachine;\n    \n    // Configuration constants\n    private static final double DRIVE_KP = 0.1;\n    private static final double DRIVE_KI = 0.01;\n    private static final double DRIVE_KD = 0.001;\n    \n    @Override\n    public void runOpMode() {\n        // Initialize with proper error handling\n        try {\n            initializeRobot();\n            telemetry.addData(\"Status\", \"Robot initialized successfully\");\n        } catch (Exception e) {\n            telemetry.addData(\"Error\", \"Failed to initialize: \" + e.getMessage());\n            telemetry.update();\n            return;\n        }\n        \n        waitForStart();\n        \n        // Main loop with state management\n        while (opModeIsActive()) {\n            updateStateMachine();\n            driveRobot();\n            updateTelemetry();\n            sleep(10); // Consistent loop timing\n        }\n    }\n    \n    private void initializeRobot() {\n        // Initialize hardware abstraction\n        robot = new RobotHardware(hardwareMap);\n        \n        // Initialize PID controllers\n        drivePID = new PIDController(DRIVE_KP, DRIVE_KI, DRIVE_KD);\n        \n        // Initialize state machine\n        stateMachine = new StateMachine();\n        stateMachine.addState(\"IDLE\", this::idleState);\n        stateMachine.addState(\"DRIVING\", this::drivingState);\n        stateMachine.addState(\"MANIPULATING\", this::manipulatingState);\n    }\n    \n    private void updateStateMachine() {\n        // Update state based on gamepad inputs\n        if (gamepad1.a) {\n            stateMachine.setState(\"DRIVING\");\n        } else if (gamepad1.b) {\n            stateMachine.setState(\"MANIPULATING\");\n        } else {\n            stateMachine.setState(\"IDLE\");\n        }\n        \n        // Execute current state\n        stateMachine.execute();\n    }\n    \n    private void driveRobot() {\n        // Advanced drive logic with PID control\n        double targetHeading = Math.atan2(gamepad1.left_stick_x, gamepad1.left_stick_y);\n        double currentHeading = robot.getIMU().getHeading();\n        \n        double correction = drivePID.calculate(currentHeading, targetHeading);\n        \n        // Apply correction to drive\n        robot.drive(gamepad1.left_stick_y, gamepad1.left_stick_x, correction);\n    }\n    \n    // State methods\n    private void idleState() {\n        robot.stop();\n    }\n    \n    private void drivingState() {\n        // Driving logic\n    }\n    \n    private void manipulatingState() {\n        // Mechanism control logic\n    }\n    \n    private void updateTelemetry() {\n        telemetry.addData(\"State\", stateMachine.getCurrentState());\n        telemetry.addData(\"Heading\", robot.getIMU().getHeading());\n        telemetry.addData(\"Battery\", robot.getBatteryVoltage());\n        telemetry.update();\n    }\n}"
    },
    {
      "type": "text",
      "title": "Development Workflow Comparison",
      "content": "The development workflow differs significantly between the two environments:"
    },
    {
      "type": "rules-box",
      "title": "OnBot Java Workflow",
      "items": [
        "Connect to robot WiFi",
        "Open web browser to OnBot Java",
        "Write or edit code directly in browser",
        "Save and immediately deploy to robot",
        "Test and iterate quickly",
        "No version control or backup management"
      ],
      "subtitle": "Simple and immediate development process:"
    },
    {
      "type": "rules-box",
      "title": "Android Studio Workflow",
      "items": [
        "Open Android Studio project",
        "Write code with full IDE features",
        "Use version control (Git) for changes",
        "Build and deploy to robot",
        "Debug using breakpoints and Logcat",
        "Organize code into packages and classes"
      ],
      "subtitle": "Professional development process:"
    },
    {
      "type": "text",
      "title": "Code Organization Comparison",
      "content": "Code organization capabilities differ significantly between the environments:"
    },
    {
      "type": "code",
      "title": "OnBot Java Organization (Limited)",
      "content": "// OnBot Java - everything in one file\n@TeleOp(name=\"Simple Robot\", group=\"Basic\")\npublic class SimpleRobot extends LinearOpMode {\n    \n    // All hardware declarations in one place\n    private DcMotor leftFront, rightFront, leftBack, rightBack;\n    private DcMotor armMotor, liftMotor;\n    private Servo clawServo;\n    \n    // All methods in one class\n    @Override\n    public void runOpMode() {\n        initializeHardware();\n        waitForStart();\n        \n        while (opModeIsActive()) {\n            driveRobot();\n            controlMechanisms();\n            updateTelemetry();\n        }\n    }\n    \n    private void initializeHardware() {\n        // Hardware initialization\n    }\n    \n    private void driveRobot() {\n        // Drive logic\n    }\n    \n    private void controlMechanisms() {\n        // Mechanism control\n    }\n    \n    private void updateTelemetry() {\n        // Telemetry\n    }\n}"
    },
    {
      "type": "code",
      "title": "Android Studio Organization (Professional)",
      "content": "// Android Studio - organized into multiple files and packages\n\n// RobotHardware.java - Hardware abstraction\npackage org.firstinspires.ftc.teamcode.hardware;\n\npublic class RobotHardware {\n    private Drivetrain drivetrain;\n    private Mechanisms mechanisms;\n    private Sensors sensors;\n    \n    public RobotHardware(HardwareMap hardwareMap) {\n        drivetrain = new Drivetrain(hardwareMap);\n        mechanisms = new Mechanisms(hardwareMap);\n        sensors = new Sensors(hardwareMap);\n    }\n    \n    public void drive(double forward, double strafe, double turn) {\n        drivetrain.drive(forward, strafe, turn);\n    }\n    \n    public void stop() {\n        drivetrain.stop();\n    }\n}\n\n// Drivetrain.java - Drivetrain-specific logic\npackage org.firstinspires.ftc.teamcode.hardware;\n\npublic class Drivetrain {\n    private DcMotor leftFront, rightFront, leftBack, rightBack;\n    \n    public Drivetrain(HardwareMap hardwareMap) {\n        // Initialize drivetrain motors\n    }\n    \n    public void drive(double forward, double strafe, double turn) {\n        // Advanced drive logic with PID control\n    }\n}\n\n// Main TeleOp - Clean and focused\npackage org.firstinspires.ftc.teamcode.teleop;\n\n@TeleOp(name=\"Professional TeleOp\", group=\"Advanced\")\npublic class ProfessionalTeleOp extends LinearOpMode {\n    private RobotHardware robot;\n    \n    @Override\n    public void runOpMode() {\n        robot = new RobotHardware(hardwareMap);\n        waitForStart();\n        \n        while (opModeIsActive()) {\n            robot.drive(gamepad1.left_stick_y, gamepad1.left_stick_x, gamepad1.right_stick_x);\n        }\n    }\n}"
    },
    {
      "type": "text",
      "title": "Debugging Capabilities",
      "content": "Debugging is where Android Studio truly shines over OnBot Java:"
    },
    {
      "type": "rules-box",
      "title": "OnBot Java Debugging",
      "items": [
        "Basic telemetry output",
        "Console error messages",
        "No step-through debugging",
        "No variable inspection",
        "No breakpoints",
        "Limited error handling"
      ],
      "subtitle": "Limited debugging capabilities:"
    },
    {
      "type": "rules-box",
      "title": "Android Studio Debugging",
      "items": [
        "Step-through debugging with breakpoints",
        "Variable inspection and modification",
        "Call stack analysis",
        "Conditional breakpoints",
        "Logcat for detailed logging",
        "Performance profiling tools"
      ],
      "subtitle": "Professional debugging features:"
    },
    {
      "type": "code",
      "title": "Debugging Examples",
      "content": "// OnBot Java - Limited debugging\nprivate void debugOnBot() {\n    // Only telemetry available\n    telemetry.addData(\"Motor Power\", motor.getPower());\n    telemetry.addData(\"Encoder Value\", motor.getCurrentPosition());\n    telemetry.update();\n    \n    // No way to pause execution or inspect variables\n}\n\n// Android Studio - Advanced debugging\nprivate void debugAndroidStudio() {\n    // Set breakpoints by clicking in the left margin\n    int currentPosition = motor.getCurrentPosition();\n    \n    // Conditional breakpoint: only break if position > 1000\n    if (currentPosition > 1000) {\n        // This will only break if condition is met\n        motor.setPower(0);\n    }\n    \n    // Use Log.d for debug messages (visible in Logcat)\n    Log.d(\"Debug\", \"Motor position: \" + currentPosition);\n    \n    // Use Log.e for error messages\n    try {\n        motor.setTargetPosition(2000);\n    } catch (Exception e) {\n        Log.e(\"Error\", \"Failed to set target position: \" + e.getMessage());\n    }\n}"
    },
    {
      "type": "text",
      "title": "When to Switch Between Environments",
      "content": "Knowing when to use each environment is crucial for effective development:"
    },
    {
      "type": "list",
      "title": "Use OnBot Java When:",
      "items": [
        "Learning FTC programming basics",
        "Quick prototyping and testing",
        "Simple robot programs",
        "Field testing and quick fixes",
        "Limited computer resources",
        "Emergency code changes during competitions"
      ]
    },
    {
      "type": "list",
      "title": "Use Android Studio When:",
      "items": [
        "Developing complex robot programs",
        "Working in a team environment",
        "Need advanced debugging capabilities",
        "Creating reusable code libraries",
        "Professional development practices",
        "Long-term project maintenance"
      ]
    },
    {
      "type": "rules-box",
      "title": "Hybrid Approach",
      "items": [
        "<strong>Development:</strong> Use Android Studio for main development",
        "<strong>Testing:</strong> Use OnBot Java for quick field tests",
        "<strong>Competition:</strong> Keep OnBot Java available for emergency changes",
        "<strong>Learning:</strong> Start with OnBot Java, graduate to Android Studio"
      ],
      "subtitle": "Many successful teams use both environments:"
    },
    {
      "type": "exercise-box",
      "title": "Environment Comparison Practice",
      "description": "Create the same OpMode in both OnBot Java and Android Studio to experience the differences firsthand.",
      "tasks": [
        "Create a simple tank drive OpMode in OnBot Java",
        "Create the same OpMode in Android Studio with proper organization",
        "Add debugging features in Android Studio (breakpoints, logging)",
        "Compare the development experience between both environments",
        "Test deployment and testing workflows in both environments",
        "Document the pros and cons of each approach for your team"
      ],
      "code": "// Challenge: Create identical functionality in both environments\n// OnBot Java version: Simple, single file\n// Android Studio version: Organized, documented, with error handling\n\n// Compare:\n// 1. Development time\n// 2. Code quality\n// 3. Debugging capabilities\n// 4. Deployment process\n// 5. Team collaboration features"
    }
  ]
}