{
  "title": "Game Controllers & TeleOp",
  "sections": [
    { "type": "text", "title": "Understanding TeleOp", "content": "TeleOp (Teleoperated) mode is when you control your robot using game controllers. This is the main part of FTC matches where drivers control the robot to complete game tasks. Understanding how to read controller input and translate it to robot movement is crucial for success." },
    { "type": "text", "title": "Game Controller Basics", "content": "FTC uses game controllers (typically Logitech F310 or similar) that provide:\n\n- **Analog Sticks**: For continuous control (movement, speed)\n- **Buttons**: For discrete actions (toggle mechanisms, activate features)\n- **Triggers**: For variable control (gradual speed, precision)\n- **D-pad**: For directional input\n\nEach controller has two analog sticks (left and right) and multiple buttons that you can map to different robot functions." },
    { "type": "text", "title": "Reading Controller Input", "content": "Here's how to read controller input in your code:\n\n```java\n@TeleOp(name=\"Basic TeleOp\")\npublic class BasicTeleOp extends OpMode {\n    private DcMotor leftMotor;\n    private DcMotor rightMotor;\n    \n    @Override\n    public void init() {\n        leftMotor = hardwareMap.get(DcMotor.class, \"left_motor\");\n        rightMotor = hardwareMap.get(DcMotor.class, \"right_motor\");\n    }\n    \n    @Override\n    public void loop() {\n        // Read controller values\n        double leftStickY = gamepad1.left_stick_y;\n        double rightStickY = gamepad1.right_stick_y;\n        \n        // Apply to motors (tank drive)\n        leftMotor.setPower(leftStickY);\n        rightMotor.setPower(rightStickY);\n        \n        // Read button presses\n        if (gamepad1.a) {\n            // Do something when A button is pressed\n            telemetry.addData(\"Status\", \"A button pressed!\");\n        }\n        \n        telemetry.update();\n    }\n}\n```" },
    { "type": "text", "title": "Tank Drive vs Arcade Drive", "content": "There are two main driving styles in FTC:\n\n**Tank Drive**:\n```java\n// Left stick controls left side, right stick controls right side\ndouble leftPower = gamepad1.left_stick_y;\ndouble rightPower = gamepad1.right_stick_y;\n\nleftMotor.setPower(leftPower);\nrightMotor.setPower(rightPower);\n```\n\n**Arcade Drive**:\n```java\n// Left stick forward/backward, right stick left/right\ndouble forward = gamepad1.left_stick_y;\ndouble turn = gamepad1.right_stick_x;\n\ndouble leftPower = forward + turn;\ndouble rightPower = forward - turn;\n\n// Clamp values to valid range\nleftPower = Math.max(-1.0, Math.min(1.0, leftPower));\nrightPower = Math.max(-1.0, Math.min(1.0, rightPower));\n\nleftMotor.setPower(leftPower);\nrightMotor.setPower(rightPower);\n```\n\nMost teams use arcade drive as it's more intuitive for new drivers." },
    { "type": "text", "title": "Button Mapping and Control Schemes", "content": "Good button mapping is essential for effective robot control:\n\n```java\n@Override\npublic void loop() {\n    // Driving controls\n    double forward = gamepad1.left_stick_y;\n    double turn = gamepad1.right_stick_x;\n    \n    // Mechanism controls\n    boolean armUp = gamepad1.y;           // Y button raises arm\n    boolean armDown = gamepad1.a;         // A button lowers arm\n    boolean clawOpen = gamepad1.b;        // B button opens claw\n    boolean clawClose = gamepad1.x;       // X button closes claw\n    \n    // Speed control\n    double speedMultiplier = gamepad1.right_trigger; // Right trigger for speed control\n    if (speedMultiplier < 0.1) speedMultiplier = 0.3; // Default to 30% speed\n    \n    // Apply speed multiplier to driving\n    double leftPower = (forward + turn) * speedMultiplier;\n    double rightPower = (forward - turn) * speedMultiplier;\n    \n    // Clamp values\n    leftPower = Math.max(-1.0, Math.min(1.0, leftPower));\n    rightPower = Math.max(-1.0, Math.min(1.0, rightPower));\n    \n    // Set motor powers\n    leftMotor.setPower(leftPower);\n    rightMotor.setPower(rightPower);\n    \n    // Control mechanisms\n    if (armUp) armServo.setPosition(1.0);\n    if (armDown) armServo.setPosition(0.0);\n    if (clawOpen) clawServo.setPosition(0.0);\n    if (clawClose) clawServo.setPosition(1.0);\n}\n```" },
    { "type": "text", "title": "Smooth Driving and Control", "content": "Smooth control makes your robot easier to drive and more precise:\n\n```java\n// Add deadzone to prevent drift\nprivate double applyDeadzone(double value, double deadzone) {\n    if (Math.abs(value) < deadzone) {\n        return 0.0;\n    }\n    return value;\n}\n\n@Override\npublic void loop() {\n    // Apply deadzone to controller input\n    double forward = applyDeadzone(gamepad1.left_stick_y, 0.1);\n    double turn = applyDeadzone(gamepad1.right_stick_x, 0.1);\n    \n    // Smooth acceleration (optional)\n    double targetLeftPower = forward + turn;\n    double targetRightPower = forward - turn;\n    \n    // Gradually approach target power\n    double currentLeftPower = leftMotor.getPower();\n    double currentRightPower = rightMotor.getPower();\n    \n    double newLeftPower = currentLeftPower + (targetLeftPower - currentLeftPower) * 0.1;\n    double newRightPower = currentRightPower + (targetRightPower - currentRightPower) * 0.1;\n    \n    leftMotor.setPower(newLeftPower);\n    rightMotor.setPower(newRightPower);\n}\n```" },
    { "type": "text", "title": "Telemetry and Debugging", "content": "Use telemetry to help debug and monitor your robot:\n\n```java\n@Override\npublic void loop() {\n    // Your control code here...\n    \n    // Display useful information\n    telemetry.addData(\"Left Motor Power\", leftMotor.getPower());\n    telemetry.addData(\"Right Motor Power\", rightMotor.getPower());\n    telemetry.addData(\"Arm Position\", armServo.getPosition());\n    telemetry.addData(\"Battery Voltage\", getBatteryVoltage());\n    telemetry.addData(\"Game Time\", getRuntime());\n    \n    // Show controller input for debugging\n    telemetry.addData(\"Left Stick Y\", gamepad1.left_stick_y);\n    telemetry.addData(\"Right Stick X\", gamepad1.right_stick_x);\n    telemetry.addData(\"A Button\", gamepad1.a);\n    \n    telemetry.update();\n}\n\nprivate double getBatteryVoltage() {\n    return hardwareMap.voltageSensor.iterator().next().getVoltage();\n}\n```" },
    { "type": "text", "title": "Practice Exercise", "content": "Create a TeleOp program that includes:\n\n1. **Arcade drive** using left stick (forward/backward) and right stick (turning)\n2. **Speed control** using the right trigger (0.3 to 1.0 speed range)\n3. **Arm control** using Y button (up) and A button (down)\n4. **Claw control** using B button (open) and X button (close)\n5. **Telemetry** showing motor powers, servo positions, and battery voltage\n\nTest your program and make sure all controls feel smooth and responsive!" },
    { "type": "text", "title": "Advanced Control Features", "content": "Once you have basic TeleOp working, consider adding these features:\n\n**Toggle Controls**:\n```java\nboolean lastAButton = false;\nboolean clawOpen = false;\n\nif (gamepad1.a && !lastAButton) {\n    clawOpen = !clawOpen; // Toggle claw state\n}\nlastAButton = gamepad1.a;\n\nclawServo.setPosition(clawOpen ? 1.0 : 0.0);\n```\n\n**Multiple Control Modes**:\n```java\nif (gamepad1.left_bumper) {\n    // Precision mode - slower movement\n    speedMultiplier = 0.3;\n} else if (gamepad1.right_bumper) {\n    // Turbo mode - faster movement\n    speedMultiplier = 1.0;\n} else {\n    // Normal mode\n    speedMultiplier = 0.7;\n}\n```" },
    { "type": "text", "title": "Common Issues and Solutions", "content": "**Problem**: Robot doesn't respond to controller\n- **Solution**: Check that your OpMode is marked with `@TeleOp` annotation\n\n**Problem**: Controls feel jerky or unresponsive\n- **Solution**: Add deadzone and smooth acceleration\n\n**Problem**: Robot moves too fast/slow\n- **Solution**: Add speed multiplier and adjust sensitivity\n\n**Problem**: Buttons don't work as expected\n- **Solution**: Check button mapping and add telemetry to debug\n\n**Problem**: Robot drifts when controller is centered\n- **Solution**: Increase deadzone or check for controller calibration issues" },
    { "type": "text", "title": "Next Steps", "content": "You now have a solid foundation in TeleOp programming! In the next phase, you'll learn about:\n\n- Advanced motor control with encoders\n- Sensor integration for autonomous\n- More sophisticated control schemes\n- Performance optimization\n\nPractice your TeleOp skills and experiment with different control schemes to find what works best for your team and robot design." }
  ]
} 