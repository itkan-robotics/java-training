{
  "title": "Advanced Control Systems",
  "sections": [
    {
      "title": "Introduction to Advanced Control Systems",
      "content": "Advanced control systems are the foundation of precise robot movement and behavior. This lesson covers advanced PID tuning, Kalman filtering, predictive control, and adaptive control systems that enable world-class robot performance."
    },
    {
      "title": "Advanced PID Tuning",
      "content": "Mastering PID control for precise robot movement:\n\n```java\npublic class AdvancedPIDController {\n    private double kP, kI, kD;\n    private double integral = 0;\n    private double lastError = 0;\n    private double target = 0;\n    private double integralLimit = 1.0;\n    private double outputLimit = 1.0;\n    private boolean integralReset = false;\n    \n    public AdvancedPIDController(double kP, double kI, double kD) {\n        this.kP = kP;\n        this.kI = kI;\n        this.kD = kD;\n    }\n    \n    public void setTarget(double target) {\n        this.target = target;\n        if (integralReset) {\n            this.integral = 0;\n            this.lastError = 0;\n        }\n    }\n    \n    public double update(double currentValue) {\n        double error = target - currentValue;\n        \n        // Proportional term\n        double proportional = kP * error;\n        \n        // Integral term with anti-windup\n        integral += error;\n        integral = Math.max(-integralLimit, Math.min(integralLimit, integral));\n        double integralTerm = kI * integral;\n        \n        // Derivative term with filtering\n        double derivative = error - lastError;\n        double derivativeTerm = kD * derivative;\n        \n        // Calculate output\n        double output = proportional + integralTerm + derivativeTerm;\n        output = Math.max(-outputLimit, Math.min(outputLimit, output));\n        \n        lastError = error;\n        return output;\n    }\n    \n    public void setIntegralLimit(double limit) {\n        this.integralLimit = limit;\n    }\n    \n    public void setOutputLimit(double limit) {\n        this.outputLimit = limit;\n    }\n    \n    public void reset() {\n        integral = 0;\n        lastError = 0;\n    }\n}\n\n// Usage for motor speed control\nAdvancedPIDController speedPID = new AdvancedPIDController(0.01, 0.001, 0.0001);\nspeedPID.setIntegralLimit(100);\nspeedPID.setOutputLimit(1.0);\n\n// In your control loop\nspeedPID.setTarget(1000); // Target speed in encoder ticks per second\ndouble currentSpeed = motor.getVelocity();\ndouble motorPower = speedPID.update(currentSpeed);\nmotor.setPower(motorPower);\n```"
    },
    {
      "title": "Kalman Filtering",
      "content": "Using Kalman filters for sensor fusion and noise reduction:\n\n```java\npublic class KalmanFilter {\n    private double x; // State estimate\n    private double P; // Estimate error covariance\n    private double Q; // Process noise covariance\n    private double R; // Measurement noise covariance\n    \n    public KalmanFilter(double initialValue, double initialP, double Q, double R) {\n        this.x = initialValue;\n        this.P = initialP;\n        this.Q = Q;\n        this.R = R;\n    }\n    \n    public double update(double measurement) {\n        // Prediction step\n        double xPred = x; // Assuming no control input\n        double PPred = P + Q;\n        \n        // Update step\n        double K = PPred / (PPred + R); // Kalman gain\n        x = xPred + K * (measurement - xPred);\n        P = (1 - K) * PPred;\n        \n        return x;\n    }\n    \n    public double getEstimate() {\n        return x;\n    }\n}\n\n// Usage for sensor fusion\nKalmanFilter positionFilter = new KalmanFilter(0, 1, 0.1, 0.5);\nKalmanFilter velocityFilter = new KalmanFilter(0, 1, 0.1, 0.3);\n\n// In your control loop\ndouble rawPosition = encoder.getCurrentPosition();\ndouble filteredPosition = positionFilter.update(rawPosition);\n\ndouble rawVelocity = encoder.getVelocity();\ndouble filteredVelocity = velocityFilter.update(rawVelocity);\n```"
    },
    {
      "title": "Predictive Control",
      "content": "Implementing predictive control for better performance:\n\n```java\npublic class PredictiveController {\n    private double[] positionHistory = new double[10];\n    private double[] velocityHistory = new double[10];\n    private int historyIndex = 0;\n    private AdvancedPIDController pidController;\n    \n    public PredictiveController(double kP, double kI, double kD) {\n        this.pidController = new AdvancedPIDController(kP, kI, kD);\n    }\n    \n    public double predictPosition(double currentPosition, double currentVelocity, double dt) {\n        // Simple linear prediction\n        return currentPosition + currentVelocity * dt;\n    }\n    \n    public double predictVelocity(double currentVelocity, double acceleration, double dt) {\n        return currentVelocity + acceleration * dt;\n    }\n    \n    public double update(double currentPosition, double currentVelocity, double targetPosition) {\n        // Update history\n        positionHistory[historyIndex] = currentPosition;\n        velocityHistory[historyIndex] = currentVelocity;\n        historyIndex = (historyIndex + 1) % 10;\n        \n        // Predict future position\n        double predictedPosition = predictPosition(currentPosition, currentVelocity, 0.1);\n        \n        // Calculate predicted error\n        double predictedError = targetPosition - predictedPosition;\n        \n        // Use PID controller with predicted error\n        return pidController.update(predictedPosition);\n    }\n    \n    public double getAverageVelocity() {\n        double sum = 0;\n        for (double velocity : velocityHistory) {\n            sum += velocity;\n        }\n        return sum / velocityHistory.length;\n    }\n}\n```"
    },
    {
      "title": "Adaptive Control Systems",
      "content": "Creating adaptive control systems that adjust to changing conditions:\n\n```java\npublic class AdaptiveController {\n    private double kP, kI, kD;\n    private double baseKP, baseKI, baseKD;\n    private double adaptationRate = 0.01;\n    private double[] errorHistory = new double[50];\n    private int errorIndex = 0;\n    \n    public AdaptiveController(double kP, double kI, double kD) {\n        this.kP = kP;\n        this.kI = kI;\n        this.kD = kD;\n        this.baseKP = kP;\n        this.baseKI = kI;\n        this.baseKD = kD;\n    }\n    \n    public double update(double currentValue, double target) {\n        double error = target - currentValue;\n        \n        // Update error history\n        errorHistory[errorIndex] = error;\n        errorIndex = (errorIndex + 1) % errorHistory.length;\n        \n        // Calculate performance metrics\n        double averageError = getAverageError();\n        double errorVariance = getErrorVariance();\n        \n        // Adapt gains based on performance\n        adaptGains(averageError, errorVariance);\n        \n        // Calculate control output\n        double proportional = kP * error;\n        double integral = kI * getIntegralError();\n        double derivative = kD * getDerivativeError();\n        \n        return proportional + integral + derivative;\n    }\n    \n    private void adaptGains(double averageError, double errorVariance) {\n        // Simple adaptation rules\n        if (Math.abs(averageError) > 0.1) {\n            // Increase proportional gain if error is large\n            kP = baseKP * (1 + adaptationRate * Math.abs(averageError));\n        } else {\n            // Return to base value if error is small\n            kP = baseKP;\n        }\n        \n        if (errorVariance > 0.01) {\n            // Increase derivative gain if oscillations are present\n            kD = baseKD * (1 + adaptationRate * errorVariance);\n        } else {\n            kD = baseKD;\n        }\n    }\n    \n    private double getAverageError() {\n        double sum = 0;\n        for (double error : errorHistory) {\n            sum += error;\n        }\n        return sum / errorHistory.length;\n    }\n    \n    private double getErrorVariance() {\n        double average = getAverageError();\n        double sum = 0;\n        for (double error : errorHistory) {\n            sum += (error - average) * (error - average);\n        }\n        return sum / errorHistory.length;\n    }\n    \n    private double getIntegralError() {\n        double sum = 0;\n        for (double error : errorHistory) {\n            sum += error;\n        }\n        return sum;\n    }\n    \n    private double getDerivativeError() {\n        if (errorIndex < 2) return 0;\n        int prevIndex = (errorIndex - 1 + errorHistory.length) % errorHistory.length;\n        int prevPrevIndex = (errorIndex - 2 + errorHistory.length) % errorHistory.length;\n        return errorHistory[prevIndex] - errorHistory[prevPrevIndex];\n    }\n}\n```"
    },
    {
      "title": "Practice Exercise",
      "content": "Create an advanced control system that:\n\n1. **Implements advanced PID control** with anti-windup and filtering\n2. **Uses Kalman filtering** for sensor fusion\n3. **Implements predictive control** for better performance\n4. **Creates adaptive control** that adjusts to changing conditions\n\n**Requirements**:\n- Implement all control algorithms with proper tuning\n- Add comprehensive telemetry for monitoring\n- Include performance metrics and analysis\n- Test under various conditions and loads\n- Optimize for real-time performance\n\n**Advanced Challenge**:\n- Implement multi-variable control systems\n- Add machine learning for gain adaptation\n- Create fault detection and recovery\n- Integrate with vision-based control"
    },
    {
      "title": "Common Issues and Solutions",
      "content": "**Problem**: PID oscillations\n- **Solution**: Reduce kP, increase kD, add filtering\n\n**Problem**: Slow response time\n- **Solution**: Increase kP, reduce kI, check for mechanical issues\n\n**Problem**: Steady-state error\n- **Solution**: Increase kI, check for friction or mechanical limits\n\n**Problem**: Sensor noise affecting control\n- **Solution**: Implement Kalman filtering, reduce sensor noise\n\n**Problem**: Control performance degrades over time\n- **Solution**: Implement adaptive control, monitor system changes"
    },
    {
      "title": "Next Steps",
      "content": "You now have advanced control system skills! In the final lesson, you'll learn about:\n\n- Performance optimization and debugging\n\nPractice implementing these advanced control systems and experiment with different algorithms to achieve world-class robot performance."
    }
  ]
} 