{
  "title": "Advanced Motor Control",
  "sections": [
    {
      "title": "Introduction to Advanced Motor Control",
      "content": "In this lesson, you'll learn how to use encoders and implement more sophisticated motor control techniques. Encoders allow you to control your robot's movement with precision, making autonomous programming much more reliable."
    },
    {
      "title": "Understanding Encoders",
      "content": "Encoders are sensors built into motors that track how many times the motor shaft has rotated. This allows you to:\n\n- **Measure distance traveled** by counting encoder ticks\n- **Control speed** by monitoring encoder rate\n- **Move to specific positions** with precision\n- **Maintain consistent speeds** regardless of battery level or load\n\nEach motor revolution typically produces 1440 encoder ticks (for REV HD Hex Motors), though this varies by motor type."
    },
    {
      "title": "Encoder Basics",
      "content": "Here's how to work with encoders:\n\n```java\n@TeleOp(name=\"Encoder Test\")\npublic class EncoderTest extends OpMode {\n    private DcMotor leftMotor;\n    private DcMotor rightMotor;\n    \n    @Override\n    public void init() {\n        leftMotor = hardwareMap.get(DcMotor.class, \"left_motor\");\n        rightMotor = hardwareMap.get(DcMotor.class, \"right_motor\");\n        \n        // Set motor modes\n        leftMotor.setMode(DcMotor.RunMode.STOP_AND_RESET_ENCODER);\n        rightMotor.setMode(DcMotor.RunMode.STOP_AND_RESET_ENCODER);\n        \n        // Set to run using encoders\n        leftMotor.setMode(DcMotor.RunMode.RUN_USING_ENCODER);\n        rightMotor.setMode(DcMotor.RunMode.RUN_USING_ENCODER);\n    }\n    \n    @Override\n    public void loop() {\n        // Read encoder values\n        int leftPosition = leftMotor.getCurrentPosition();\n        int rightPosition = rightMotor.getCurrentPosition();\n        \n        // Display encoder values\n        telemetry.addData(\"Left Encoder\", leftPosition);\n        telemetry.addData(\"Right Encoder\", rightPosition);\n        telemetry.update();\n    }\n}\n```"
    },
    {
      "title": "Moving to Specific Positions",
      "content": "Using encoders, you can move motors to exact positions:\n\n```java\npublic void moveToPosition(int targetPosition, double power) {\n    // Set target position\n    leftMotor.setTargetPosition(targetPosition);\n    rightMotor.setTargetPosition(targetPosition);\n    \n    // Set to run to position mode\n    leftMotor.setMode(DcMotor.RunMode.RUN_TO_POSITION);\n    rightMotor.setMode(DcMotor.RunMode.RUN_TO_POSITION);\n    \n    // Set power\n    leftMotor.setPower(power);\n    rightMotor.setPower(power);\n    \n    // Wait until motors reach target\n    while (leftMotor.isBusy() && rightMotor.isBusy()) {\n        // Wait\n    }\n    \n    // Stop motors\n    leftMotor.setPower(0);\n    rightMotor.setPower(0);\n}\n\n// Usage example\nmoveToPosition(1440, 0.5); // Move 1 revolution at 50% power\n```"
    },
    {
      "title": "PID Control Basics",
      "content": "PID (Proportional-Integral-Derivative) control helps maintain consistent speed and position:\n\n```java\npublic class PIDController {\n    private double kP, kI, kD;\n    private double integral = 0;\n    private double lastError = 0;\n    private double target = 0;\n    \n    public PIDController(double kP, double kI, double kD) {\n        this.kP = kP;\n        this.kI = kI;\n        this.kD = kD;\n    }\n    \n    public void setTarget(double target) {\n        this.target = target;\n        this.integral = 0;\n        this.lastError = 0;\n    }\n    \n    public double update(double currentValue) {\n        double error = target - currentValue;\n        integral += error;\n        double derivative = error - lastError;\n        \n        double output = kP * error + kI * integral + kD * derivative;\n        \n        lastError = error;\n        return output;\n    }\n}\n\n// Usage in your OpMode\nPIDController leftPID = new PIDController(0.01, 0.0, 0.001);\nPIDController rightPID = new PIDController(0.01, 0.0, 0.001);\n\n// Set target speed (encoder ticks per second)\nleftPID.setTarget(1000);\nrightPID.setTarget(1000);\n\n// In your loop\ndouble leftSpeed = leftMotor.getVelocity();\ndouble rightSpeed = rightMotor.getVelocity();\n\ndouble leftPower = leftPID.update(leftSpeed);\ndouble rightPower = rightPID.update(rightSpeed);\n\nleftMotor.setPower(leftPower);\nrightMotor.setPower(rightPower);\n```"
    },
    {
      "title": "Speed Ramping and Acceleration",
      "content": "Gradual acceleration and deceleration make robot movement smoother:\n\n```java\npublic class SpeedRamp {\n    private double currentSpeed = 0;\n    private double maxAcceleration = 0.1; // Speed change per loop\n    \n    public double update(double targetSpeed) {\n        if (targetSpeed > currentSpeed) {\n            currentSpeed = Math.min(targetSpeed, currentSpeed + maxAcceleration);\n        } else if (targetSpeed < currentSpeed) {\n            currentSpeed = Math.max(targetSpeed, currentSpeed - maxAcceleration);\n        }\n        return currentSpeed;\n    }\n}\n\n// Usage\nSpeedRamp leftRamp = new SpeedRamp();\nSpeedRamp rightRamp = new SpeedRamp();\n\n@Override\npublic void loop() {\n    double targetLeftSpeed = gamepad1.left_stick_y;\n    double targetRightSpeed = gamepad1.right_stick_y;\n    \n    double smoothLeftSpeed = leftRamp.update(targetLeftSpeed);\n    double smoothRightSpeed = rightRamp.update(targetRightSpeed);\n    \n    leftMotor.setPower(smoothLeftSpeed);\n    rightMotor.setPower(smoothRightSpeed);\n}\n```"
    },
    {
      "title": "Multi-Motor Coordination",
      "content": "Coordinating multiple motors ensures smooth robot movement:\n\n```java\npublic void driveDistance(double distanceInches, double power) {\n    // Convert inches to encoder ticks\n    // Assuming 1440 ticks per revolution and 4-inch wheels\n    double circumference = 4 * Math.PI; // inches\n    int ticksPerInch = (int)(1440 / circumference);\n    int targetTicks = (int)(distanceInches * ticksPerInch);\n    \n    // Reset encoders\n    leftMotor.setMode(DcMotor.RunMode.STOP_AND_RESET_ENCODER);\n    rightMotor.setMode(DcMotor.RunMode.STOP_AND_RESET_ENCODER);\n    \n    // Set target positions\n    leftMotor.setTargetPosition(targetTicks);\n    rightMotor.setTargetPosition(targetTicks);\n    \n    // Set to run to position\n    leftMotor.setMode(DcMotor.RunMode.RUN_TO_POSITION);\n    rightMotor.setMode(DcMotor.RunMode.RUN_TO_POSITION);\n    \n    // Start moving\n    leftMotor.setPower(power);\n    rightMotor.setPower(power);\n    \n    // Wait for completion\n    while (leftMotor.isBusy() && rightMotor.isBusy()) {\n        telemetry.addData(\"Left Position\", leftMotor.getCurrentPosition());\n        telemetry.addData(\"Right Position\", rightMotor.getCurrentPosition());\n        telemetry.update();\n    }\n    \n    // Stop\n    leftMotor.setPower(0);\n    rightMotor.setPower(0);\n}\n```"
    },
    {
      "title": "Motor Direction and Zero Power Behavior",
      "content": "Understanding motor direction and behavior is crucial:\n\n```java\n@Override\npublic void init() {\n    leftMotor = hardwareMap.get(DcMotor.class, \"left_motor\");\n    rightMotor = hardwareMap.get(DcMotor.class, \"right_motor\");\n    \n    // Set motor directions (may need to reverse one side)\n    leftMotor.setDirection(DcMotor.Direction.FORWARD);\n    rightMotor.setDirection(DcMotor.Direction.REVERSE);\n    \n    // Set zero power behavior\n    leftMotor.setZeroPowerBehavior(DcMotor.ZeroPowerBehavior.BRAKE);\n    rightMotor.setZeroPowerBehavior(DcMotor.ZeroPowerBehavior.BRAKE);\n    \n    // Initialize encoders\n    leftMotor.setMode(DcMotor.RunMode.STOP_AND_RESET_ENCODER);\n    rightMotor.setMode(DcMotor.RunMode.STOP_AND_RESET_ENCODER);\n    leftMotor.setMode(DcMotor.RunMode.RUN_USING_ENCODER);\n    rightMotor.setMode(DcMotor.RunMode.RUN_USING_ENCODER);\n}\n```\n\n**Zero Power Behavior**:\n- `BRAKE`: Motor actively resists movement when power is 0\n- `FLOAT`: Motor coasts freely when power is 0\n\nUse BRAKE for more precise control, especially in autonomous."
    },
    {
      "title": "Practice Exercise",
      "content": "Create a program that:\n\n1. **Moves forward exactly 12 inches** using encoder control\n2. **Turns 90 degrees** using encoder control (calculate the encoder ticks needed)\n3. **Maintains a constant speed** of 500 encoder ticks per second using PID control\n4. **Uses smooth acceleration** when starting and stopping\n\n**Calculations you'll need**:\n- Wheel circumference = π × wheel diameter\n- Encoder ticks per inch = encoder ticks per revolution ÷ wheel circumference\n- For 90° turn: calculate arc length based on wheelbase\n\nTest your program and measure the actual distance/angle to see how accurate your encoder control is!"
    },
    {
      "title": "Common Issues and Solutions",
      "content": "**Problem**: Encoders show wrong values\n- **Solution**: Check motor direction and encoder direction settings\n\n**Problem**: Robot doesn't move to exact position\n- **Solution**: Calibrate encoder ticks per inch/degree for your specific robot\n\n**Problem**: Motors oscillate or shake\n- **Solution**: Reduce PID gains (especially kP) or add deadzone\n\n**Problem**: Robot moves too slowly\n- **Solution**: Increase power or check if motors are in correct mode\n\n**Problem**: Encoders reset unexpectedly\n- **Solution**: Don't call `STOP_AND_RESET_ENCODER` during movement"
    },
    {
      "title": "Next Steps",
      "content": "You now have advanced motor control skills! In the next lessons, you'll learn about:\n\n- Sensor integration for autonomous navigation\n- Advanced autonomous programming with state machines\n- Computer vision and advanced sensors\n- Performance optimization techniques\n\nPractice these encoder and PID techniques until you can reliably control your robot's movement with precision."
    }
  ]
} 