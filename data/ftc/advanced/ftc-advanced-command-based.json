{
  "title": "Advanced Command-Based Programming",
  "sections": [
    {
      "type": "text",
      "title": "Advanced Command Patterns",
      "content": "Advanced command-based programming introduces sophisticated patterns for complex robot behaviors, including command composition, conditional execution, and advanced scheduling strategies."
    },
    {
      "type": "rules-box",
      "title": "Advanced Features",
      "items": [
        "<strong>Command Composition:</strong> Complex commands built from simpler ones",
        "<strong>Conditional Commands:</strong> Commands that execute based on robot state",
        "<strong>Parallel Command Groups:</strong> Multiple commands running simultaneously",
        "<strong>Command Interruption:</strong> Graceful handling of command cancellation",
        "<strong>State-Based Commands:</strong> Commands that respond to robot state changes",
        "<strong>Advanced Scheduling:</strong> Sophisticated command execution strategies"
      ],
      "subtitle": "Advanced command-based programming includes:"
    },
    {
      "type": "text",
      "title": "Command Composition",
      "content": "Command composition allows you to build complex behaviors by combining simpler commands in sophisticated ways."
    },
    {
      "type": "code",
      "title": "Complex Command Composition",
      "content": "package org.firstinspires.ftc.teamcode.commands.advanced;\n\nimport org.firstinspires.ftc.teamcode.commands.*;\nimport org.firstinspires.ftc.teamcode.subsystems.*;\nimport java.util.function.BooleanSupplier;\nimport java.util.function.Supplier;\n\npublic class AdvancedCommandComposition {\n    \n    // Conditional command that executes based on a condition\n    public static class ConditionalCommand implements Command {\n        private Command command;\n        private BooleanSupplier condition;\n        private boolean hasExecuted = false;\n        \n        public ConditionalCommand(Command command, BooleanSupplier condition) {\n            this.command = command;\n            this.condition = condition;\n        }\n        \n        @Override\n        public void initialize() {\n            if (condition.getAsBoolean()) {\n                command.initialize();\n            }\n        }\n        \n        @Override\n        public void execute() {\n            if (condition.getAsBoolean() && !hasExecuted) {\n                command.execute();\n                if (command.isFinished()) {\n                    hasExecuted = true;\n                }\n            }\n        }\n        \n        @Override\n        public void end() {\n            if (condition.getAsBoolean()) {\n                command.end();\n            }\n        }\n        \n        @Override\n        public boolean isFinished() {\n            return !condition.getAsBoolean() || hasExecuted;\n        }\n        \n        @Override\n        public void interrupted() {\n            command.interrupted();\n        }\n    }\n    \n    // Command that repeats until a condition is met\n    public static class RepeatUntilCommand implements Command {\n        private Command command;\n        private BooleanSupplier stopCondition;\n        private boolean isFinished = false;\n        \n        public RepeatUntilCommand(Command command, BooleanSupplier stopCondition) {\n            this.command = command;\n            this.stopCondition = stopCondition;\n        }\n        \n        @Override\n        public void initialize() {\n            command.initialize();\n        }\n        \n        @Override\n        public void execute() {\n            if (stopCondition.getAsBoolean()) {\n                isFinished = true;\n                return;\n            }\n            \n            command.execute();\n            if (command.isFinished()) {\n                command.initialize(); // Restart the command\n            }\n        }\n        \n        @Override\n        public void end() {\n            command.end();\n        }\n        \n        @Override\n        public boolean isFinished() {\n            return isFinished;\n        }\n        \n        @Override\n        public void interrupted() {\n            command.interrupted();\n        }\n    }\n    \n    // Command that selects from multiple options\n    public static class SelectCommand implements Command {\n        private Command[] commands;\n        private Supplier<Integer> selector;\n        private int currentCommandIndex = -1;\n        private boolean isFinished = false;\n        \n        public SelectCommand(Supplier<Integer> selector, Command... commands) {\n            this.commands = commands;\n            this.selector = selector;\n        }\n        \n        @Override\n        public void initialize() {\n            currentCommandIndex = selector.get();\n            if (currentCommandIndex >= 0 && currentCommandIndex < commands.length) {\n                commands[currentCommandIndex].initialize();\n            } else {\n                isFinished = true;\n            }\n        }\n        \n        @Override\n        public void execute() {\n            if (currentCommandIndex >= 0 && currentCommandIndex < commands.length) {\n                commands[currentCommandIndex].execute();\n                if (commands[currentCommandIndex].isFinished()) {\n                    isFinished = true;\n                }\n            }\n        }\n        \n        @Override\n        public void end() {\n            if (currentCommandIndex >= 0 && currentCommandIndex < commands.length) {\n                commands[currentCommandIndex].end();\n            }\n        }\n        \n        @Override\n        public boolean isFinished() {\n            return isFinished;\n        }\n        \n        @Override\n        public void interrupted() {\n            if (currentCommandIndex >= 0 && currentCommandIndex < commands.length) {\n                commands[currentCommandIndex].interrupted();\n            }\n        }\n    }\n}\n\n// Example usage:\n// Command complexRoutine = new ConditionalCommand(\n//     new SequentialCommandGroup(\n//         new DriveForwardCommand(drivetrain, 24, 0.5),\n//         new TurnCommand(drivetrain, 90, 0.3),\n//         new DriveForwardCommand(drivetrain, 12, 0.5)\n//     ),\n//     () -> robot.hasGameElement() // Only execute if robot has game element\n// );"
    },
    {
      "type": "text",
      "title": "State-Based Commands",
      "content": "State-based commands respond to changes in robot state and can adapt their behavior accordingly."
    },
    {
      "type": "code",
      "title": "State-Based Command Implementation",
      "content": "package org.firstinspires.ftc.teamcode.commands.state;\n\nimport org.firstinspires.ftc.teamcode.subsystems.*;\nimport java.util.HashMap;\nimport java.util.Map;\n\npublic class StateBasedCommand implements Command {\n    \n    private Map<String, Command> stateCommands;\n    private Supplier<String> stateProvider;\n    private String currentState;\n    private Command currentCommand;\n    private boolean isFinished = false;\n    \n    public StateBasedCommand(Supplier<String> stateProvider) {\n        this.stateCommands = new HashMap<>();\n        this.stateProvider = stateProvider;\n        this.currentState = null;\n        this.currentCommand = null;\n    }\n    \n    public StateBasedCommand addState(String state, Command command) {\n        stateCommands.put(state, command);\n        return this;\n    }\n    \n    @Override\n    public void initialize() {\n        currentState = stateProvider.get();\n        currentCommand = stateCommands.get(currentState);\n        if (currentCommand != null) {\n            currentCommand.initialize();\n        }\n    }\n    \n    @Override\n    public void execute() {\n        String newState = stateProvider.get();\n        \n        // State changed\n        if (!newState.equals(currentState)) {\n            if (currentCommand != null) {\n                currentCommand.end();\n            }\n            currentState = newState;\n            currentCommand = stateCommands.get(currentState);\n            if (currentCommand != null) {\n                currentCommand.initialize();\n            }\n        }\n        \n        // Execute current command\n        if (currentCommand != null) {\n            currentCommand.execute();\n            if (currentCommand.isFinished()) {\n                isFinished = true;\n            }\n        } else {\n            isFinished = true;\n        }\n    }\n    \n    @Override\n    public void end() {\n        if (currentCommand != null) {\n            currentCommand.end();\n        }\n    }\n    \n    @Override\n    public boolean isFinished() {\n        return isFinished;\n    }\n    \n    @Override\n    public void interrupted() {\n        if (currentCommand != null) {\n            currentCommand.interrupted();\n        }\n    }\n}\n\n// Example usage:\n// StateBasedCommand autonomousRoutine = new StateBasedCommand(\n//     () -> robot.getCurrentState()\n// )\n// .addState(\"STARTING\", new InitializeCommand(robot))\n// .addState(\"SCORING\", new ScoreElementCommand(robot))\n// .addState(\"COLLECTING\", new CollectElementCommand(robot))\n// .addState(\"RETURNING\", new ReturnToStartCommand(robot));"
    },
    {
      "type": "text",
      "title": "Advanced Command Groups",
      "content": "Advanced command groups provide sophisticated ways to combine and coordinate multiple commands."
    },
    {
      "type": "code",
      "title": "Advanced Command Groups",
      "content": "package org.firstinspires.ftc.teamcode.commands.groups;\n\nimport org.firstinspires.ftc.teamcode.commands.*;\nimport java.util.ArrayList;\nimport java.util.List;\nimport java.util.function.BooleanSupplier;\n\npublic class AdvancedCommandGroups {\n    \n    // Race command group - first command to finish wins\n    public static class RaceCommandGroup implements Command {\n        private List<Command> commands;\n        private boolean isFinished = false;\n        private int winnerIndex = -1;\n        \n        public RaceCommandGroup(Command... commands) {\n            this.commands = new ArrayList<>();\n            for (Command command : commands) {\n                this.commands.add(command);\n            }\n        }\n        \n        @Override\n        public void initialize() {\n            isFinished = false;\n            winnerIndex = -1;\n            for (Command command : commands) {\n                command.initialize();\n            }\n        }\n        \n        @Override\n        public void execute() {\n            for (int i = 0; i < commands.size(); i++) {\n                Command command = commands.get(i);\n                if (!command.isFinished()) {\n                    command.execute();\n                    if (command.isFinished()) {\n                        winnerIndex = i;\n                        isFinished = true;\n                        break;\n                    }\n                }\n            }\n        }\n        \n        @Override\n        public void end() {\n            for (Command command : commands) {\n                if (!command.isFinished()) {\n                    command.interrupted();\n                }\n            }\n        }\n        \n        @Override\n        public boolean isFinished() {\n            return isFinished;\n        }\n        \n        @Override\n        public void interrupted() {\n            end();\n        }\n        \n        public int getWinnerIndex() {\n            return winnerIndex;\n        }\n    }\n    \n    // Deadline command group - all commands must finish within time limit\n    public static class DeadlineCommandGroup implements Command {\n        private List<Command> commands;\n        private double deadline;\n        private double startTime;\n        private boolean isFinished = false;\n        \n        public DeadlineCommandGroup(double deadlineSeconds, Command... commands) {\n            this.commands = new ArrayList<>();\n            for (Command command : commands) {\n                this.commands.add(command);\n            }\n            this.deadline = deadlineSeconds;\n        }\n        \n        @Override\n        public void initialize() {\n            startTime = System.currentTimeMillis() / 1000.0;\n            isFinished = false;\n            for (Command command : commands) {\n                command.initialize();\n            }\n        }\n        \n        @Override\n        public void execute() {\n            double currentTime = System.currentTimeMillis() / 1000.0;\n            \n            // Check deadline\n            if (currentTime - startTime > deadline) {\n                isFinished = true;\n                return;\n            }\n            \n            // Execute all commands\n            boolean allFinished = true;\n            for (Command command : commands) {\n                if (!command.isFinished()) {\n                    command.execute();\n                    allFinished = false;\n                }\n            }\n            \n            if (allFinished) {\n                isFinished = true;\n            }\n        }\n        \n        @Override\n        public void end() {\n            for (Command command : commands) {\n                if (!command.isFinished()) {\n                    command.interrupted();\n                }\n            }\n        }\n        \n        @Override\n        public boolean isFinished() {\n            return isFinished;\n        }\n        \n        @Override\n        public void interrupted() {\n            end();\n        }\n    }\n    \n    // Conditional parallel command group\n    public static class ConditionalParallelGroup implements Command {\n        private List<Command> commands;\n        private List<BooleanSupplier> conditions;\n        private boolean isFinished = false;\n        \n        public ConditionalParallelGroup() {\n            this.commands = new ArrayList<>();\n            this.conditions = new ArrayList<>();\n        }\n        \n        public ConditionalParallelGroup addCommand(Command command, BooleanSupplier condition) {\n            commands.add(command);\n            conditions.add(condition);\n            return this;\n        }\n        \n        @Override\n        public void initialize() {\n            isFinished = false;\n            for (int i = 0; i < commands.size(); i++) {\n                if (conditions.get(i).getAsBoolean()) {\n                    commands.get(i).initialize();\n                }\n            }\n        }\n        \n        @Override\n        public void execute() {\n            boolean allFinished = true;\n            \n            for (int i = 0; i < commands.size(); i++) {\n                if (conditions.get(i).getAsBoolean()) {\n                    Command command = commands.get(i);\n                    if (!command.isFinished()) {\n                        command.execute();\n                        allFinished = false;\n                    }\n                }\n            }\n            \n            if (allFinished) {\n                isFinished = true;\n            }\n        }\n        \n        @Override\n        public void end() {\n            for (int i = 0; i < commands.size(); i++) {\n                if (conditions.get(i).getAsBoolean() && !commands.get(i).isFinished()) {\n                    commands.get(i).interrupted();\n                }\n            }\n        }\n        \n        @Override\n        public boolean isFinished() {\n            return isFinished;\n        }\n        \n        @Override\n        public void interrupted() {\n            end();\n        }\n    }\n}\n\n// Example usage:\n// RaceCommandGroup raceCommands = new RaceCommandGroup(\n//     new DriveToTargetCommand(drivetrain, target1),\n//     new DriveToTargetCommand(drivetrain, target2)\n// );\n// \n// DeadlineCommandGroup timedCommands = new DeadlineCommandGroup(5.0,\n//     new ScoreElementCommand(robot),\n//     new ReturnToStartCommand(robot)\n// );\n// \n// ConditionalParallelGroup conditionalCommands = new ConditionalParallelGroup()\n//     .addCommand(new DriveCommand(drivetrain), () -> gamepad1.left_stick_y != 0)\n//     .addCommand(new ArmCommand(arm), () -> gamepad2.right_stick_y != 0)\n//     .addCommand(new IntakeCommand(intake), () -> gamepad2.a);"
    },
    {
      "type": "text",
      "title": "Advanced Command Scheduler",
      "content": "An advanced command scheduler provides sophisticated command management and execution strategies."
    },
    {
      "type": "code",
      "title": "Advanced Command Scheduler",
      "content": "package org.firstinspires.ftc.teamcode.scheduler;\n\nimport org.firstinspires.ftc.teamcode.commands.*;\nimport org.firstinspires.ftc.teamcode.subsystems.*;\nimport java.util.*;\nimport java.util.concurrent.PriorityBlockingQueue;\n\npublic class AdvancedCommandScheduler {\n    \n    private static AdvancedCommandScheduler instance;\n    private PriorityBlockingQueue<ScheduledCommand> commandQueue;\n    private Map<Subsystem, Command> subsystemCommands;\n    private List<Command> runningCommands;\n    private Map<String, Integer> commandPriorities;\n    private boolean enabled = true;\n    \n    private AdvancedCommandScheduler() {\n        commandQueue = new PriorityBlockingQueue<>();\n        subsystemCommands = new HashMap<>();\n        runningCommands = new ArrayList<>();\n        commandPriorities = new HashMap<>();\n    }\n    \n    public static AdvancedCommandScheduler getInstance() {\n        if (instance == null) {\n            instance = new AdvancedCommandScheduler();\n        }\n        return instance;\n    }\n    \n    public void scheduleCommand(Command command, int priority) {\n        if (!enabled) return;\n        \n        ScheduledCommand scheduledCommand = new ScheduledCommand(command, priority);\n        commandQueue.offer(scheduledCommand);\n    }\n    \n    public void scheduleCommand(Command command) {\n        scheduleCommand(command, 0);\n    }\n    \n    public void run() {\n        if (!enabled) return;\n        \n        // Process new commands\n        while (!commandQueue.isEmpty()) {\n            ScheduledCommand scheduledCommand = commandQueue.poll();\n            Command command = scheduledCommand.command;\n            \n            if (canScheduleCommand(command)) {\n                runningCommands.add(command);\n                command.initialize();\n            }\n        }\n        \n        // Execute running commands\n        Iterator<Command> iterator = runningCommands.iterator();\n        while (iterator.hasNext()) {\n            Command command = iterator.next();\n            \n            if (command.isFinished()) {\n                command.end();\n                iterator.remove();\n                removeSubsystemCommands(command);\n            } else {\n                command.execute();\n            }\n        }\n        \n        // Update subsystems\n        for (Subsystem subsystem : subsystemCommands.keySet()) {\n            subsystem.periodic();\n        }\n    }\n    \n    private boolean canScheduleCommand(Command command) {\n        // Check for subsystem conflicts\n        for (Subsystem subsystem : command.getRequirements()) {\n            if (subsystemCommands.containsKey(subsystem)) {\n                Command existingCommand = subsystemCommands.get(subsystem);\n                if (!existingCommand.isFinished()) {\n                    return false; // Conflict detected\n                }\n            }\n        }\n        \n        // Add command to subsystems\n        for (Subsystem subsystem : command.getRequirements()) {\n            subsystemCommands.put(subsystem, command);\n        }\n        \n        return true;\n    }\n    \n    private void removeSubsystemCommands(Command command) {\n        for (Subsystem subsystem : command.getRequirements()) {\n            if (subsystemCommands.get(subsystem) == command) {\n                subsystemCommands.remove(subsystem);\n            }\n        }\n    }\n    \n    public void cancelAll() {\n        for (Command command : runningCommands) {\n            command.interrupted();\n        }\n        runningCommands.clear();\n        subsystemCommands.clear();\n        commandQueue.clear();\n    }\n    \n    public void setEnabled(boolean enabled) {\n        this.enabled = enabled;\n        if (!enabled) {\n            cancelAll();\n        }\n    }\n    \n    public int getRunningCommandCount() {\n        return runningCommands.size();\n    }\n    \n    public List<Command> getRunningCommands() {\n        return new ArrayList<>(runningCommands);\n    }\n    \n    // Helper class for priority scheduling\n    private static class ScheduledCommand implements Comparable<ScheduledCommand> {\n        Command command;\n        int priority;\n        long timestamp;\n        \n        public ScheduledCommand(Command command, int priority) {\n            this.command = command;\n            this.priority = priority;\n            this.timestamp = System.currentTimeMillis();\n        }\n        \n        @Override\n        public int compareTo(ScheduledCommand other) {\n            // Higher priority first, then FIFO\n            if (this.priority != other.priority) {\n                return Integer.compare(other.priority, this.priority);\n            }\n            return Long.compare(this.timestamp, other.timestamp);\n        }\n    }\n}"
    },
    {
      "type": "text",
      "title": "Command Factory Pattern",
      "content": "The command factory pattern provides a clean way to create complex commands with different configurations."
    },
    {
      "type": "code",
      "title": "Command Factory Implementation",
      "content": "package org.firstinspires.ftc.teamcode.commands.factory;\n\nimport org.firstinspires.ftc.teamcode.commands.*;\nimport org.firstinspires.ftc.teamcode.subsystems.*;\n\npublic class CommandFactory {\n    \n    private Drivetrain drivetrain;\n    private Arm arm;\n    private Intake intake;\n    private Vision vision;\n    \n    public CommandFactory(Drivetrain drivetrain, Arm arm, Intake intake, Vision vision) {\n        this.drivetrain = drivetrain;\n        this.arm = arm;\n        this.intake = intake;\n        this.vision = vision;\n    }\n    \n    // Create autonomous routines\n    public Command createAutonomousRoutine(AutonomousStrategy strategy) {\n        switch (strategy) {\n            case SCORE_AND_COLLECT:\n                return new SequentialCommandGroup(\n                    createScoreSequence(),\n                    createCollectSequence(),\n                    createReturnSequence()\n                );\n            case COLLECT_AND_SCORE:\n                return new SequentialCommandGroup(\n                    createCollectSequence(),\n                    createScoreSequence()\n                );\n            case VISION_BASED:\n                return createVisionBasedRoutine();\n            default:\n                return new SequentialCommandGroup(\n                    createScoreSequence()\n                );\n        }\n    }\n    \n    // Create scoring sequence\n    public Command createScoreSequence() {\n        return new SequentialCommandGroup(\n            new DriveToPositionCommand(drivetrain, 24, 0, 0.5),\n            new RaiseArmCommand(arm, 1000, 0.5),\n            new WaitCommand(0.5),\n            new DropElementCommand(arm),\n            new WaitCommand(0.5),\n            new LowerArmCommand(arm, 0, 0.5)\n        );\n    }\n    \n    // Create collection sequence\n    public Command createCollectSequence() {\n        return new SequentialCommandGroup(\n            new DriveToPositionCommand(drivetrain, 48, 0, 0.5),\n            new StartIntakeCommand(intake, 1.0),\n            new WaitCommand(2.0),\n            new StopIntakeCommand(intake)\n        );\n    }\n    \n    // Create return sequence\n    public Command createReturnSequence() {\n        return new SequentialCommandGroup(\n            new DriveToPositionCommand(drivetrain, 0, 0, 0.5),\n            new TurnToHeadingCommand(drivetrain, 0, 0.3)\n        );\n    }\n    \n    // Create vision-based routine\n    public Command createVisionBasedRoutine() {\n        return new StateBasedCommand(() -> vision.getDetectedTarget())\n            .addState(\"RED\", createRedTargetRoutine())\n            .addState(\"BLUE\", createBlueTargetRoutine())\n            .addState(\"NONE\", createDefaultRoutine());\n    }\n    \n    // Create teleop commands\n    public Command createTeleopDriveCommand() {\n        return new ConditionalCommand(\n            new DriveCommand(drivetrain),\n            () -> true // Always execute\n        );\n    }\n    \n    public Command createTeleopArmCommand() {\n        return new ConditionalCommand(\n            new ArmCommand(arm),\n            () -> arm.isOperational()\n        );\n    }\n    \n    public Command createTeleopIntakeCommand() {\n        return new ConditionalCommand(\n            new IntakeCommand(intake),\n            () -> intake.isOperational()\n        );\n    }\n    \n    // Create emergency commands\n    public Command createEmergencyStopCommand() {\n        return new ParallelCommandGroup(\n            new StopDrivetrainCommand(drivetrain),\n            new StopArmCommand(arm),\n            new StopIntakeCommand(intake)\n        );\n    }\n    \n    public Command createSafeModeCommand() {\n        return new SequentialCommandGroup(\n            createEmergencyStopCommand(),\n            new WaitCommand(1.0),\n            new LowerArmCommand(arm, 0, 0.3)\n        );\n    }\n    \n    // Enum for autonomous strategies\n    public enum AutonomousStrategy {\n        SCORE_AND_COLLECT,\n        COLLECT_AND_SCORE,\n        VISION_BASED,\n        SIMPLE_SCORE\n    }\n}\n\n// Example usage:\n// CommandFactory factory = new CommandFactory(drivetrain, arm, intake, vision);\n// \n// // Create autonomous routine\n// Command autonomousRoutine = factory.createAutonomousRoutine(\n//     CommandFactory.AutonomousStrategy.VISION_BASED\n// );\n// \n// // Create teleop commands\n// Command driveCommand = factory.createTeleopDriveCommand();\n// Command armCommand = factory.createTeleopArmCommand();\n// Command intakeCommand = factory.createTeleopIntakeCommand();\n// \n// // Schedule commands\n// scheduler.scheduleCommand(autonomousRoutine);\n// scheduler.scheduleCommand(driveCommand);\n// scheduler.scheduleCommand(armCommand);\n// scheduler.scheduleCommand(intakeCommand);"
    },
    {
      "type": "rules-box",
      "title": "Advanced Command-Based Best Practices",
      "items": [
        "<strong>Use composition over inheritance:</strong> Build complex commands from simpler ones",
        "<strong>Implement proper error handling:</strong> Handle command failures gracefully",
        "<strong>Use state-based commands:</strong> Adapt behavior based on robot state",
        "<strong>Optimize command scheduling:</strong> Use priority queues for important commands",
        "<strong>Test commands individually:</strong> Ensure each command works before combining",
        "<strong>Document command requirements:</strong> Clearly specify subsystem dependencies"
      ],
      "subtitle": "Follow these best practices for advanced command-based programming:"
    },
    {
      "type": "exercise-box",
      "title": "Advanced Command-Based Practice",
      "description": "Implement advanced command-based programming patterns for complex robot behaviors.",
      "tasks": [
        "Create conditional commands that respond to robot state",
        "Implement state-based command systems",
        "Build complex command compositions",
        "Create advanced command groups (race, deadline, conditional parallel)",
        "Implement an advanced command scheduler with priorities",
        "Use the command factory pattern for creating routines",
        "Test complex command interactions",
        "Optimize command execution for performance"
      ],
      "code": "// Example: Complete advanced command-based system\n// 1. Create command factory\n// CommandFactory factory = new CommandFactory(drivetrain, arm, intake, vision);\n// \n// 2. Create complex autonomous routine\n// Command autonomousRoutine = factory.createAutonomousRoutine(\n//     CommandFactory.AutonomousStrategy.VISION_BASED\n// );\n// \n// 3. Create teleop commands with conditions\n// Command driveCommand = factory.createTeleopDriveCommand();\n// Command armCommand = factory.createTeleopArmCommand();\n// \n// 4. Schedule with priorities\n// scheduler.scheduleCommand(autonomousRoutine, 10);\n// scheduler.scheduleCommand(driveCommand, 5);\n// scheduler.scheduleCommand(armCommand, 5);\n// \n// 5. Run scheduler\n// while (opModeIsActive()) {\n//     scheduler.run();\n//     sleep(10);\n// }"
    }
  ]
}