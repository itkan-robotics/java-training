{
  "title": "Advanced TeleOp Features",
  "sections": [
    {
      "title": "Introduction to Advanced TeleOp",
      "content": "Advanced TeleOp features make your robot more efficient and easier to control. These features include multiple control modes, automated sequences, safety features, and performance optimizations that separate good teams from great teams."
    },
    {
      "title": "Multiple Control Modes",
      "content": "Different control modes allow drivers to adapt to different situations:\n\n```java\n@TeleOp(name=\"Advanced TeleOp\")\npublic class AdvancedTeleOp extends OpMode {\n    private DcMotor leftMotor, rightMotor;\n    private Servo armServo, clawServo;\n    \n    private enum ControlMode {\n        NORMAL,\n        PRECISION,\n        TURBO,\n        AUTOMATED\n    }\n    \n    private ControlMode currentMode = ControlMode.NORMAL;\n    \n    @Override\n    public void loop() {\n        // Mode switching\n        if (gamepad1.start) {\n            switchMode();\n        }\n        \n        // Get base inputs\n        double forward = gamepad1.left_stick_y;\n        double turn = gamepad1.right_stick_x;\n        \n        // Apply mode-specific modifications\n        double speedMultiplier = getSpeedMultiplier();\n        \n        // Calculate motor powers\n        double leftPower = (forward + turn) * speedMultiplier;\n        double rightPower = (forward - turn) * speedMultiplier;\n        \n        // Clamp values\n        leftPower = Math.max(-1.0, Math.min(1.0, leftPower));\n        rightPower = Math.max(-1.0, Math.min(1.0, rightPower));\n        \n        // Set motor powers\n        leftMotor.setPower(leftPower);\n        rightMotor.setPower(rightPower);\n        \n        // Handle mechanisms based on mode\n        handleMechanisms();\n        \n        // Display current mode\n        telemetry.addData(\"Control Mode\", currentMode);\n        telemetry.addData(\"Speed Multiplier\", speedMultiplier);\n        telemetry.update();\n    }\n    \n    private void switchMode() {\n        switch (currentMode) {\n            case NORMAL:\n                currentMode = ControlMode.PRECISION;\n                break;\n            case PRECISION:\n                currentMode = ControlMode.TURBO;\n                break;\n            case TURBO:\n                currentMode = ControlMode.AUTOMATED;\n                break;\n            case AUTOMATED:\n                currentMode = ControlMode.NORMAL;\n                break;\n        }\n    }\n    \n    private double getSpeedMultiplier() {\n        switch (currentMode) {\n            case NORMAL:\n                return 0.7;\n            case PRECISION:\n                return 0.3;\n            case TURBO:\n                return 1.0;\n            case AUTOMATED:\n                return 0.5;\n            default:\n                return 0.7;\n        }\n    }\n}\n```"
    },
    {
      "title": "Automated Sequences",
      "content": "Automated sequences reduce driver workload and improve consistency:\n\n```java\npublic class AutomatedSequences {\n    private DcMotor armMotor;\n    private Servo clawServo;\n    private ElapsedTime sequenceTimer = new ElapsedTime();\n    private boolean sequenceRunning = false;\n    \n    public enum Sequence {\n        PICKUP_ELEMENT,\n        SCORE_ELEMENT,\n        PARK_ROBOT,\n        NONE\n    }\n    \n    private Sequence currentSequence = Sequence.NONE;\n    \n    public void startSequence(Sequence sequence) {\n        if (!sequenceRunning) {\n            currentSequence = sequence;\n            sequenceRunning = true;\n            sequenceTimer.reset();\n        }\n    }\n    \n    public void updateSequence() {\n        if (!sequenceRunning) return;\n        \n        switch (currentSequence) {\n            case PICKUP_ELEMENT:\n                executePickupSequence();\n                break;\n            case SCORE_ELEMENT:\n                executeScoreSequence();\n                break;\n            case PARK_ROBOT:\n                executeParkSequence();\n                break;\n        }\n    }\n    \n    private void executePickupSequence() {\n        double time = sequenceTimer.seconds();\n        \n        if (time < 1.0) {\n            // Lower arm\n            armMotor.setPower(-0.5);\n        } else if (time < 2.0) {\n            // Stop arm and open claw\n            armMotor.setPower(0);\n            clawServo.setPosition(1.0);\n        } else if (time < 3.0) {\n            // Close claw\n            clawServo.setPosition(0.0);\n        } else if (time < 4.0) {\n            // Raise arm\n            armMotor.setPower(0.5);\n        } else {\n            // Sequence complete\n            armMotor.setPower(0);\n            sequenceRunning = false;\n        }\n    }\n    \n    private void executeScoreSequence() {\n        double time = sequenceTimer.seconds();\n        \n        if (time < 1.0) {\n            // Position arm for scoring\n            armMotor.setPower(0.3);\n        } else if (time < 2.0) {\n            // Stop and open claw\n            armMotor.setPower(0);\n            clawServo.setPosition(1.0);\n        } else if (time < 3.0) {\n            // Close claw and lower arm\n            clawServo.setPosition(0.0);\n            armMotor.setPower(-0.3);\n        } else {\n            // Sequence complete\n            armMotor.setPower(0);\n            sequenceRunning = false;\n        }\n    }\n    \n    private void executeParkSequence() {\n        // Simple parking sequence\n        if (sequenceTimer.seconds() < 2.0) {\n            // Drive forward slowly\n            // This would be handled by the main drive code\n        } else {\n            sequenceRunning = false;\n        }\n    }\n}\n\n// Usage in TeleOp\nAutomatedSequences sequences = new AutomatedSequences();\n\n@Override\npublic void loop() {\n    // Check for sequence triggers\n    if (gamepad1.x) {\n        sequences.startSequence(AutomatedSequences.Sequence.PICKUP_ELEMENT);\n    } else if (gamepad1.y) {\n        sequences.startSequence(AutomatedSequences.Sequence.SCORE_ELEMENT);\n    } else if (gamepad1.b) {\n        sequences.startSequence(AutomatedSequences.Sequence.PARK_ROBOT);\n    }\n    \n    // Update sequences\n    sequences.updateSequence();\n}\n```"
    },
    {
      "title": "Safety Features and Failsafes",
      "content": "Safety features prevent damage to your robot and improve reliability:\n\n```java\npublic class SafetyManager {\n    private DcMotor armMotor;\n    private DigitalChannel limitSwitchTop, limitSwitchBottom;\n    private double maxArmPower = 0.8;\n    private double currentArmPower = 0;\n    \n    public SafetyManager(DcMotor armMotor, DigitalChannel limitSwitchTop, DigitalChannel limitSwitchBottom) {\n        this.armMotor = armMotor;\n        this.limitSwitchTop = limitSwitchTop;\n        this.limitSwitchBottom = limitSwitchBottom;\n    }\n    \n    public void setArmPower(double power) {\n        // Apply safety limits\n        power = Math.max(-maxArmPower, Math.min(maxArmPower, power));\n        \n        // Check limit switches\n        if (power > 0 && limitSwitchTop.getState()) {\n            // Trying to go up but at top limit\n            power = 0;\n        } else if (power < 0 && limitSwitchBottom.getState()) {\n            // Trying to go down but at bottom limit\n            power = 0;\n        }\n        \n        // Apply gradual power changes for safety\n        double powerChange = 0.1; // Maximum power change per loop\n        if (power > currentArmPower) {\n            currentArmPower = Math.min(power, currentArmPower + powerChange);\n        } else if (power < currentArmPower) {\n            currentArmPower = Math.max(power, currentArmPower - powerChange);\n        }\n        \n        armMotor.setPower(currentArmPower);\n    }\n    \n    public void emergencyStop() {\n        armMotor.setPower(0);\n        currentArmPower = 0;\n    }\n}\n\n// Usage\nSafetyManager safetyManager = new SafetyManager(armMotor, limitSwitchTop, limitSwitchBottom);\n\n@Override\npublic void loop() {\n    // Emergency stop\n    if (gamepad1.back) {\n        safetyManager.emergencyStop();\n        return;\n    }\n    \n    // Safe arm control\n    double armPower = 0;\n    if (gamepad1.dpad_up) armPower = 0.5;\n    if (gamepad1.dpad_down) armPower = -0.5;\n    \n    safetyManager.setArmPower(armPower);\n}\n```"
    },
    {
      "title": "Performance Optimization",
      "content": "Optimizing performance ensures smooth operation and responsiveness:\n\n```java\npublic class PerformanceOptimizer {\n    private ElapsedTime loopTimer = new ElapsedTime();\n    private double lastLoopTime = 0;\n    private int loopCount = 0;\n    private double averageLoopTime = 0;\n    \n    public void startLoop() {\n        loopTimer.reset();\n    }\n    \n    public void endLoop() {\n        double loopTime = loopTimer.milliseconds();\n        lastLoopTime = loopTime;\n        loopCount++;\n        \n        // Calculate running average\n        averageLoopTime = (averageLoopTime * (loopCount - 1) + loopTime) / loopCount;\n    }\n    \n    public void displayPerformance() {\n        telemetry.addData(\"Last Loop Time\", \"%.2f ms\", lastLoopTime);\n        telemetry.addData(\"Average Loop Time\", \"%.2f ms\", averageLoopTime);\n        telemetry.addData(\"Loop Rate\", \"%.1f Hz\", 1000.0 / averageLoopTime);\n    }\n    \n    public boolean isPerformanceGood() {\n        return averageLoopTime < 20; // Less than 20ms per loop (50+ Hz)\n    }\n}\n\n// Usage\nPerformanceOptimizer optimizer = new PerformanceOptimizer();\n\n@Override\npublic void loop() {\n    optimizer.startLoop();\n    \n    // Your TeleOp code here\n    \n    optimizer.endLoop();\n    optimizer.displayPerformance();\n    \n    if (!optimizer.isPerformanceGood()) {\n        telemetry.addData(\"Warning\", \"Performance is poor!\");\n    }\n    \n    telemetry.update();\n}\n```"
    },
    {
      "title": "Advanced Control Schemes",
      "content": "Advanced control schemes provide more intuitive robot control:\n\n```java\npublic class AdvancedControls {\n    private DcMotor leftMotor, rightMotor;\n    private Servo armServo;\n    \n    // Toggle states\n    private boolean clawOpen = false;\n    private boolean lastClawButton = false;\n    \n    // Variable speed control\n    private double speedMultiplier = 0.7;\n    private double lastSpeedButton = false;\n    \n    public void updateDriveControls() {\n        // Arcade drive with variable speed\n        double forward = gamepad1.left_stick_y;\n        double turn = gamepad1.right_stick_x;\n        \n        // Speed control with right trigger\n        double triggerSpeed = gamepad1.right_trigger;\n        if (triggerSpeed > 0.1) {\n            speedMultiplier = 0.3 + (triggerSpeed * 0.7); // 0.3 to 1.0\n        }\n        \n        // Apply speed multiplier\n        double leftPower = (forward + turn) * speedMultiplier;\n        double rightPower = (forward - turn) * speedMultiplier;\n        \n        // Clamp values\n        leftPower = Math.max(-1.0, Math.min(1.0, leftPower));\n        rightPower = Math.max(-1.0, Math.min(1.0, rightPower));\n        \n        leftMotor.setPower(leftPower);\n        rightMotor.setPower(rightPower);\n    }\n    \n    public void updateMechanismControls() {\n        // Toggle claw with button press\n        boolean clawButton = gamepad1.a;\n        if (clawButton && !lastClawButton) {\n            clawOpen = !clawOpen;\n            armServo.setPosition(clawOpen ? 1.0 : 0.0);\n        }\n        lastClawButton = clawButton;\n        \n        // Arm control with D-pad\n        if (gamepad1.dpad_up) {\n            // Move arm up\n        } else if (gamepad1.dpad_down) {\n            // Move arm down\n        }\n    }\n}\n```"
    },
    {
      "title": "Practice Exercise",
      "content": "Create an advanced TeleOp program that includes:\n\n1. **Three control modes**: Normal (70% speed), Precision (30% speed), Turbo (100% speed)\n2. **Automated sequence**: One-button pickup sequence\n3. **Safety features**: Arm limits, emergency stop, gradual acceleration\n4. **Performance monitoring**: Loop time tracking and warnings\n5. **Advanced controls**: Toggle claw, variable speed with trigger, D-pad arm control\n\n**Requirements**:\n- Use proper state management for control modes\n- Implement smooth transitions between modes\n- Add comprehensive telemetry for debugging\n- Include error handling and recovery\n\nTest your program and refine the control schemes based on driver feedback!"
    },
    {
      "title": "Common Issues and Solutions",
      "content": "**Problem**: Controls feel unresponsive\n- **Solution**: Optimize loop performance, reduce unnecessary calculations\n\n**Problem**: Automated sequences interfere with manual control\n- **Solution**: Add sequence override buttons, implement proper state management\n\n**Problem**: Safety features are too restrictive\n- **Solution**: Adjust limits based on testing, add override options\n\n**Problem**: Multiple control modes confuse drivers\n- **Solution**: Clear visual feedback, simple mode switching\n\n**Problem**: Performance degrades over time\n- **Solution**: Monitor memory usage, optimize sensor reading frequency"
    },
    {
      "title": "Next Steps",
      "content": "You now have advanced TeleOp programming skills! In the next lessons, you'll learn about:\n\n- Advanced autonomous programming with complex state machines\n- Computer vision integration\n- Advanced control systems and PID tuning\n- Performance optimization and debugging\n\nPractice these advanced features and experiment with different control schemes to find what works best for your team."
    }
  ]
} 