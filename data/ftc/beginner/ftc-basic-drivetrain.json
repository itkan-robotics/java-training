{
  "title": "Basic Drivetrain Programming",
  "sections": [
    {
      "type": "text",
      "title": "Understanding Drivetrains",
      "content": "The drivetrain is the foundation of your robot's movement. In FTC, most robots use a four-wheel drive system with either mecanum wheels or standard wheels. Understanding how to program different drive modes is essential for effective robot control."
    },
    {
      "type": "rules-box",
      "title": "Common Drivetrain Types",
      "items": [
        "<strong>Tank Drive:</strong> Left and right sides controlled independently (like a tank)",
        "<strong>Arcade Drive:</strong> Forward/backward and turning controlled by separate sticks",
        "<strong>Mecanum Drive:</strong> Four-wheel drive with special wheels for omnidirectional movement",
        "<strong>X-Drive:</strong> Four wheels arranged in an X pattern for enhanced maneuverability"
      ],
      "subtitle": "FTC robots typically use one of these drivetrain configurations:"
    },
    {
      "type": "text",
      "title": "Tank Drive Implementation",
      "content": "Tank drive is the simplest and most reliable drive mode. It uses the left stick for the left side of the robot and the right stick for the right side."
    },
    {
      "type": "code",
      "title": "Tank Drive Code",
      "content": "private void tankDrive() {\n    // Get gamepad inputs\n    double leftPower = -gamepad1.left_stick_y;\n    double rightPower = -gamepad1.right_stick_y;\n    \n    // Apply deadzone to prevent drift\n    if (Math.abs(leftPower) < 0.1) leftPower = 0;\n    if (Math.abs(rightPower) < 0.1) rightPower = 0;\n    \n    // Set motor powers\n    leftFront.setPower(leftPower);\n    leftBack.setPower(leftPower);\n    rightFront.setPower(rightPower);\n    rightBack.setPower(rightPower);\n}"
    },
    {
      "type": "text",
      "title": "Arcade Drive Implementation",
      "content": "Arcade drive uses one stick for forward/backward movement and another for turning. This is more intuitive for many drivers."
    },
    {
      "type": "code",
      "title": "Arcade Drive Code",
      "content": "private void arcadeDrive() {\n    // Get gamepad inputs\n    double forward = -gamepad1.left_stick_y;\n    double turn = gamepad1.right_stick_x;\n    \n    // Apply deadzone\n    if (Math.abs(forward) < 0.1) forward = 0;\n    if (Math.abs(turn) < 0.1) turn = 0;\n    \n    // Calculate motor powers\n    double leftPower = forward + turn;\n    double rightPower = forward - turn;\n    \n    // Normalize powers\n    double maxPower = Math.max(Math.abs(leftPower), Math.abs(rightPower));\n    if (maxPower > 1.0) {\n        leftPower /= maxPower;\n        rightPower /= maxPower;\n    }\n    \n    // Set motor powers\n    leftFront.setPower(leftPower);\n    leftBack.setPower(leftPower);\n    rightFront.setPower(rightPower);\n    rightBack.setPower(rightPower);\n}"
    },
    {
      "type": "text",
      "title": "Mecanum Drive Implementation",
      "content": "Mecanum drive allows for omnidirectional movement, including strafing (moving sideways). This requires special mecanum wheels and more complex control logic."
    },
    {
      "type": "code",
      "title": "Mecanum Drive Code",
      "content": "private void mecanumDrive() {\n    // Get gamepad inputs\n    double forward = -gamepad1.left_stick_y;\n    double strafe = gamepad1.left_stick_x;\n    double turn = gamepad1.right_stick_x;\n    \n    // Apply deadzone\n    if (Math.abs(forward) < 0.1) forward = 0;\n    if (Math.abs(strafe) < 0.1) strafe = 0;\n    if (Math.abs(turn) < 0.1) turn = 0;\n    \n    // Calculate motor powers for mecanum drive\n    double leftFrontPower = forward + strafe + turn;\n    double rightFrontPower = forward - strafe - turn;\n    double leftBackPower = forward - strafe + turn;\n    double rightBackPower = forward + strafe - turn;\n    \n    // Normalize powers\n    double maxPower = Math.max(Math.max(Math.abs(leftFrontPower), Math.abs(rightFrontPower)),\n                              Math.max(Math.abs(leftBackPower), Math.abs(rightBackPower)));\n    if (maxPower > 1.0) {\n        leftFrontPower /= maxPower;\n        rightFrontPower /= maxPower;\n        leftBackPower /= maxPower;\n        rightBackPower /= maxPower;\n    }\n    \n    // Set motor powers\n    leftFront.setPower(leftFrontPower);\n    rightFront.setPower(rightFrontPower);\n    leftBack.setPower(leftBackPower);\n    rightBack.setPower(rightBackPower);\n}"
    },
    {
      "type": "text",
      "title": "Speed Control and Scaling",
      "content": "Adding speed control allows drivers to switch between different speed modes for precision and power."
    },
    {
      "type": "code",
      "title": "Speed Control Implementation",
      "content": "private void driveWithSpeedControl() {\n    // Get base inputs\n    double forward = -gamepad1.left_stick_y;\n    double turn = gamepad1.right_stick_x;\n    \n    // Apply deadzone\n    if (Math.abs(forward) < 0.1) forward = 0;\n    if (Math.abs(turn) < 0.1) turn = 0;\n    \n    // Speed control\n    double speedMultiplier = 1.0;\n    if (gamepad1.left_bumper) {\n        speedMultiplier = 0.3; // Slow mode\n    } else if (gamepad1.right_bumper) {\n        speedMultiplier = 0.7; // Medium mode\n    }\n    \n    // Apply speed scaling\n    forward *= speedMultiplier;\n    turn *= speedMultiplier;\n    \n    // Calculate motor powers\n    double leftPower = forward + turn;\n    double rightPower = forward - turn;\n    \n    // Normalize powers\n    double maxPower = Math.max(Math.abs(leftPower), Math.abs(rightPower));\n    if (maxPower > 1.0) {\n        leftPower /= maxPower;\n        rightPower /= maxPower;\n    }\n    \n    // Set motor powers\n    leftFront.setPower(leftPower);\n    leftBack.setPower(leftPower);\n    rightFront.setPower(rightPower);\n    rightBack.setPower(rightPower);\n}"
    },
    {
      "type": "rules-box",
      "title": "Important Concepts",
      "items": [
        "<strong>Deadzone:</strong> Prevents motor drift when sticks are near center",
        "<strong>Power Normalization:</strong> Ensures no motor exceeds maximum power",
        "<strong>Motor Direction:</strong> May need to be reversed based on robot design",
        "<strong>Speed Scaling:</strong> Allows for precision control at different speeds"
      ],
      "subtitle": "Key concepts to understand when programming drivetrains:"
    },
    {
      "type": "exercise-box",
      "title": "Drivetrain Practice",
      "description": "Implement different drive modes and test them on your robot. Try switching between drive modes using gamepad buttons.",
      "tasks": [
        "Implement tank drive and test basic movement",
        "Add arcade drive as an alternative control scheme",
        "Implement speed control with different multipliers",
        "Add a button to switch between drive modes",
        "Test mecanum drive if your robot has mecanum wheels",
        "Add telemetry to display current drive mode and motor powers"
      ],
      "code": "// Add this to your class variables:\n// private boolean tankDriveMode = true;\n\n// Add this to driveRobot():\n// if (gamepad1.start) {\n//     tankDriveMode = !tankDriveMode;\n// }\n// \n// if (tankDriveMode) {\n//     tankDrive();\n// } else {\n//     arcadeDrive();\n// }\n\n// Add this to updateTelemetry():\n// telemetry.addData(\"Drive Mode\", tankDriveMode ? \"Tank\" : \"Arcade\");"
    }
  ]
}