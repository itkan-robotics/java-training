{
  "title": "Advanced Autonomous",
  "sections": [
    {
      "title": "Introduction to Advanced Autonomous",
      "content": "Advanced autonomous programming involves complex path planning, multi-step sequences, dynamic obstacle avoidance, and game strategy integration. This level of autonomous can give your team a significant competitive advantage."
    },
    {
      "title": "Complex Path Planning",
      "content": "Advanced path planning involves precise movement with multiple waypoints and dynamic adjustments:\n\n```java\npublic class PathPlanner {\n    private DcMotor leftMotor, rightMotor;\n    private BNO055IMU imu;\n    private ElapsedTime runtime;\n    \n    public class Waypoint {\n        double x, y, heading;\n        double speed;\n        String action;\n        \n        public Waypoint(double x, double y, double heading, double speed, String action) {\n            this.x = x;\n            this.y = y;\n            this.heading = heading;\n            this.speed = speed;\n            this.action = action;\n        }\n    }\n    \n    private List<Waypoint> path = new ArrayList<>();\n    private int currentWaypoint = 0;\n    private double robotX = 0, robotY = 0, robotHeading = 0;\n    \n    public void addWaypoint(double x, double y, double heading, double speed, String action) {\n        path.add(new Waypoint(x, y, heading, speed, action));\n    }\n    \n    public void executePath() {\n        if (currentWaypoint >= path.size()) return;\n        \n        Waypoint target = path.get(currentWaypoint);\n        \n        // Calculate distance and angle to target\n        double dx = target.x - robotX;\n        double dy = target.y - robotY;\n        double distance = Math.sqrt(dx * dx + dy * dy);\n        double targetAngle = Math.atan2(dy, dx) * 180 / Math.PI;\n        \n        // Calculate heading error\n        double headingError = targetAngle - robotHeading;\n        while (headingError > 180) headingError -= 360;\n        while (headingError < -180) headingError += 360;\n        \n        if (distance < 2.0 && Math.abs(headingError) < 5.0) {\n            // Reached waypoint - execute action\n            executeAction(target.action);\n            currentWaypoint++;\n        } else {\n            // Move toward waypoint\n            driveToWaypoint(target, distance, headingError);\n        }\n    }\n    \n    private void driveToWaypoint(Waypoint target, double distance, double headingError) {\n        // PID control for heading\n        double headingCorrection = headingError * 0.01; // kP = 0.01\n        \n        // Base forward power based on distance\n        double forwardPower = Math.min(target.speed, distance * 0.1);\n        \n        // Calculate motor powers\n        double leftPower = forwardPower - headingCorrection;\n        double rightPower = forwardPower + headingCorrection;\n        \n        // Clamp values\n        leftPower = Math.max(-1.0, Math.min(1.0, leftPower));\n        rightPower = Math.max(-1.0, Math.min(1.0, rightPower));\n        \n        leftMotor.setPower(leftPower);\n        rightMotor.setPower(rightPower);\n    }\n    \n    private void executeAction(String action) {\n        switch (action) {\n            case \"SCORE\":\n                // Execute scoring sequence\n                break;\n            case \"PICKUP\":\n                // Execute pickup sequence\n                break;\n            case \"WAIT\":\n                sleep(1000);\n                break;\n        }\n    }\n}\n```"
    },
    {
      "title": "Multi-Step Sequences",
      "content": "Complex autonomous sequences involve multiple coordinated actions:\n\n```java\npublic class AutonomousSequence {\n    private enum SequenceState {\n        INIT,\n        DRIVE_TO_STARTING_POSITION,\n        SCAN_FOR_ELEMENTS,\n        PICKUP_ELEMENT,\n        DRIVE_TO_SCORING,\n        SCORE_ELEMENT,\n        RETURN_TO_PICKUP,\n        PARK,\n        COMPLETE\n    }\n    \n    private SequenceState currentState = SequenceState.INIT;\n    private ElapsedTime stateTimer = new ElapsedTime();\n    private int elementsScored = 0;\n    private int maxElements = 3;\n    \n    public void updateSequence() {\n        switch (currentState) {\n            case INIT:\n                // Initialize robot position and sensors\n                initializeRobot();\n                currentState = SequenceState.DRIVE_TO_STARTING_POSITION;\n                stateTimer.reset();\n                break;\n                \n            case DRIVE_TO_STARTING_POSITION:\n                if (driveToPosition(0, 0, 0)) {\n                    currentState = SequenceState.SCAN_FOR_ELEMENTS;\n                    stateTimer.reset();\n                }\n                break;\n                \n            case SCAN_FOR_ELEMENTS:\n                // Use vision or sensors to find game elements\n                if (scanForElements()) {\n                    currentState = SequenceState.PICKUP_ELEMENT;\n                    stateTimer.reset();\n                } else if (stateTimer.seconds() > 5.0) {\n                    // Timeout - move to next state\n                    currentState = SequenceState.PARK;\n                    stateTimer.reset();\n                }\n                break;\n                \n            case PICKUP_ELEMENT:\n                if (executePickupSequence()) {\n                    currentState = SequenceState.DRIVE_TO_SCORING;\n                    stateTimer.reset();\n                } else if (stateTimer.seconds() > 3.0) {\n                    // Pickup failed - try again or move on\n                    currentState = SequenceState.SCAN_FOR_ELEMENTS;\n                    stateTimer.reset();\n                }\n                break;\n                \n            case DRIVE_TO_SCORING:\n                if (driveToPosition(24, 0, 90)) {\n                    currentState = SequenceState.SCORE_ELEMENT;\n                    stateTimer.reset();\n                }\n                break;\n                \n            case SCORE_ELEMENT:\n                if (executeScoreSequence()) {\n                    elementsScored++;\n                    if (elementsScored >= maxElements) {\n                        currentState = SequenceState.PARK;\n                    } else {\n                        currentState = SequenceState.RETURN_TO_PICKUP;\n                    }\n                    stateTimer.reset();\n                }\n                break;\n                \n            case RETURN_TO_PICKUP:\n                if (driveToPosition(0, 0, 0)) {\n                    currentState = SequenceState.SCAN_FOR_ELEMENTS;\n                    stateTimer.reset();\n                }\n                break;\n                \n            case PARK:\n                if (driveToPosition(12, 12, 45)) {\n                    currentState = SequenceState.COMPLETE;\n                }\n                break;\n                \n            case COMPLETE:\n                // Stop all motors and end autonomous\n                stopAllMotors();\n                break;\n        }\n    }\n    \n    private boolean driveToPosition(double targetX, double targetY, double targetHeading) {\n        // Implementation of precise positioning\n        // Returns true when position is reached\n        return false; // Placeholder\n    }\n    \n    private boolean scanForElements() {\n        // Implementation of element detection\n        return false; // Placeholder\n    }\n    \n    private boolean executePickupSequence() {\n        // Implementation of pickup sequence\n        return false; // Placeholder\n    }\n    \n    private boolean executeScoreSequence() {\n        // Implementation of scoring sequence\n        return false; // Placeholder\n    }\n}\n```"
    },
    {
      "title": "Dynamic Obstacle Avoidance",
      "content": "Dynamic obstacle avoidance allows the robot to navigate around unexpected obstacles:\n\n```java\npublic class ObstacleAvoidance {\n    private DistanceSensor frontSensor, leftSensor, rightSensor;\n    private DcMotor leftMotor, rightMotor;\n    private BNO055IMU imu;\n    \n    private double safeDistance = 15.0; // cm\n    private double criticalDistance = 8.0; // cm\n    \n    public boolean checkForObstacles() {\n        double frontDistance = frontSensor.getDistance(DistanceUnit.CM);\n        double leftDistance = leftSensor.getDistance(DistanceUnit.CM);\n        double rightDistance = rightSensor.getDistance(DistanceUnit.CM);\n        \n        if (frontDistance < criticalDistance) {\n            // Emergency stop\n            emergencyStop();\n            return true;\n        } else if (frontDistance < safeDistance) {\n            // Obstacle detected - plan avoidance\n            planAvoidance(leftDistance, rightDistance);\n            return true;\n        }\n        \n        return false; // No obstacles\n    }\n    \n    private void planAvoidance(double leftDistance, double rightDistance) {\n        // Choose direction with more space\n        if (leftDistance > rightDistance && leftDistance > safeDistance) {\n            // Turn left to avoid\n            leftMotor.setPower(-0.3);\n            rightMotor.setPower(0.3);\n        } else if (rightDistance > safeDistance) {\n            // Turn right to avoid\n            leftMotor.setPower(0.3);\n            rightMotor.setPower(-0.3);\n        } else {\n            // No clear path - back up\n            leftMotor.setPower(-0.2);\n            rightMotor.setPower(-0.2);\n        }\n    }\n    \n    private void emergencyStop() {\n        leftMotor.setPower(0);\n        rightMotor.setPower(0);\n    }\n    \n    public void resumePath() {\n        // Resume normal path following after obstacle is cleared\n        // This would integrate with your path planner\n    }\n}\n```"
    },
    {
      "title": "Game Strategy Integration",
      "content": "Integrating game strategy into autonomous makes your robot more competitive:\n\n```java\npublic class GameStrategy {\n    private enum AllianceColor {\n        RED, BLUE\n    }\n    \n    private enum StartingPosition {\n        LEFT, CENTER, RIGHT\n    }\n    \n    private AllianceColor allianceColor;\n    private StartingPosition startingPosition;\n    private int teamNumber;\n    \n    public GameStrategy(AllianceColor color, StartingPosition position, int team) {\n        this.allianceColor = color;\n        this.startingPosition = position;\n        this.teamNumber = team;\n    }\n    \n    public void executeStrategy() {\n        switch (allianceColor) {\n            case RED:\n                executeRedStrategy();\n                break;\n            case BLUE:\n                executeBlueStrategy();\n                break;\n        }\n    }\n    \n    private void executeRedStrategy() {\n        switch (startingPosition) {\n            case LEFT:\n                // Red alliance, left starting position strategy\n                executeRedLeftStrategy();\n                break;\n            case CENTER:\n                executeRedCenterStrategy();\n                break;\n            case RIGHT:\n                executeRedRightStrategy();\n                break;\n        }\n    }\n    \n    private void executeRedLeftStrategy() {\n        // Example strategy for red alliance, left position\n        // 1. Drive to scoring position\n        // 2. Score preloaded element\n        // 3. Collect additional elements\n        // 4. Score collected elements\n        // 5. Park in designated area\n        \n        PathPlanner planner = new PathPlanner();\n        \n        // Define waypoints for this strategy\n        planner.addWaypoint(12, 0, 0, 0.5, \"DRIVE\");\n        planner.addWaypoint(24, 0, 90, 0.3, \"SCORE\");\n        planner.addWaypoint(12, 12, 45, 0.4, \"COLLECT\");\n        planner.addWaypoint(24, 0, 90, 0.3, \"SCORE\");\n        planner.addWaypoint(36, 36, 0, 0.5, \"PARK\");\n        \n        // Execute the path\n        while (planner.hasMoreWaypoints()) {\n            planner.executePath();\n            sleep(10); // Small delay for smooth operation\n        }\n    }\n    \n    public void adaptToGameConditions() {\n        // Monitor game conditions and adapt strategy\n        // This could include:\n        // - Detecting opponent robot positions\n        // - Adjusting scoring priorities based on time\n        // - Changing paths based on field conditions\n    }\n}\n```"
    },
    {
      "title": "Practice Exercise",
      "content": "Create an advanced autonomous program that:\n\n1. **Implements a complete game strategy** for your specific starting position\n2. **Uses path planning** with multiple waypoints and precise positioning\n3. **Includes obstacle avoidance** that can handle unexpected obstacles\n4. **Adapts to game conditions** based on sensor feedback\n5. **Implements error recovery** for failed actions\n\n**Requirements**:\n- Use a sophisticated state machine for sequence management\n- Include comprehensive telemetry for debugging\n- Implement timeout mechanisms for all actions\n- Add fallback strategies for common failure modes\n\n**Advanced Challenge**:\n- Create multiple strategies for different starting positions\n- Implement alliance coordination (if applicable)\n- Add vision-based element detection and tracking\n- Optimize for maximum scoring efficiency"
    },
    {
      "title": "Common Issues and Solutions",
      "content": "**Problem**: Robot gets lost or confused during complex sequences\n- **Solution**: Add more sensor feedback, implement position tracking\n\n**Problem**: Autonomous takes too long to complete\n- **Solution**: Optimize paths, reduce unnecessary movements, parallelize actions\n\n**Problem**: Obstacle avoidance interferes with path following\n- **Solution**: Implement smooth transitions, use predictive avoidance\n\n**Problem**: Strategy doesn't adapt to changing conditions\n- **Solution**: Add more sensor inputs, implement dynamic decision making\n\n**Problem**: Complex sequences are unreliable\n- **Solution**: Break into smaller, testable components, add comprehensive error handling"
    },
    {
      "title": "Next Steps",
      "content": "You now have advanced autonomous programming skills! In the next lessons, you'll learn about:\n\n- Computer vision and advanced sensors\n- Advanced control systems and PID tuning\n- Performance optimization and debugging\n- Android Studio development environment\n\nPractice these advanced techniques and experiment with different strategies to maximize your autonomous performance."
    }
  ]
} 