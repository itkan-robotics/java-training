{
  "title": "Code Organization",
  "sections": [
    {
      "type": "text",
      "title": "Introduction to Code Organization",
      "content": "Well-organized code is easier to debug, maintain, and extend. This lesson covers best practices for organizing FTC robot code to make debugging more efficient and effective."
    },
    {
      "type": "rules-box",
      "title": "Why Code Organization Matters",
      "subtitle": "Good code organization provides:",
      "items": [
        "Easier debugging and problem identification",
        "Faster code maintenance and updates",
        "Better team collaboration and code sharing",
        "Reduced bugs and programming errors",
        "Clearer understanding of robot behavior",
        "Easier testing and validation"
      ]
    },
    {
      "type": "text",
      "title": "Code Organization Principles",
      "content": "Effective code organization follows several key principles: separation of concerns, modularity, readability, and consistency. These principles make code easier to understand and debug."
    },
    {
      "type": "code",
      "title": "Well-Organized OpMode Structure",
      "language": "java",
      "content": "// Well-organized OpMode structure\n@TeleOp(name=\"Organized Example\", group=\"Examples\")\npublic class OrganizedExample extends LinearOpMode {\n    \n    // ===== HARDWARE DECLARATIONS =====\n    private DcMotor leftMotor, rightMotor;\n    private Servo armServo, clawServo;\n    private TouchSensor touchSensor;\n    private ColorSensor colorSensor;\n    \n    // ===== CONSTANTS =====\n    private static final double MOTOR_POWER = 0.5;\n    private static final double SERVO_OPEN_POSITION = 0.0;\n    private static final double SERVO_CLOSED_POSITION = 1.0;\n    private static final double ARM_UP_POSITION = 0.8;\n    private static final double ARM_DOWN_POSITION = 0.2;\n    \n    // ===== STATE VARIABLES =====\n    private boolean clawOpen = true;\n    private boolean armUp = false;\n    private double lastButtonPressTime = 0;\n    \n    @Override\n    public void runOpMode() {\n        // ===== INITIALIZATION =====\n        initializeHardware();\n        displayInitializationTelemetry();\n        \n        // Wait for start\n        waitForStart();\n        \n        // ===== MAIN LOOP =====\n        while (opModeIsActive()) {\n            // Process inputs\n            processGamepadInputs();\n            \n            // Update robot behavior\n            updateRobotBehavior();\n            \n            // Update telemetry\n            updateTelemetry();\n        }\n        \n        // ===== CLEANUP =====\n        cleanup();\n    }\n    \n    // ===== INITIALIZATION METHODS =====\n    private void initializeHardware() {\n        // Initialize motors\n        leftMotor = hardwareMap.get(DcMotor.class, \"left_motor\");\n        rightMotor = hardwareMap.get(DcMotor.class, \"right_motor\");\n        \n        // Set motor directions\n        leftMotor.setDirection(DcMotor.Direction.FORWARD);\n        rightMotor.setDirection(DcMotor.Direction.REVERSE);\n        \n        // Initialize servos\n        armServo = hardwareMap.get(Servo.class, \"arm_servo\");\n        clawServo = hardwareMap.get(Servo.class, \"claw_servo\");\n        \n        // Initialize sensors\n        touchSensor = hardwareMap.get(TouchSensor.class, \"touch_sensor\");\n        colorSensor = hardwareMap.get(ColorSensor.class, \"color_sensor\");\n        \n        // Set initial positions\n        armServo.setPosition(ARM_DOWN_POSITION);\n        clawServo.setPosition(SERVO_OPEN_POSITION);\n    }\n    \n    private void displayInitializationTelemetry() {\n        telemetry.addData(\"=== INITIALIZATION STATUS ===\", \"\");\n        telemetry.addData(\"Left Motor\", leftMotor != null ? \"OK\" : \"FAILED\");\n        telemetry.addData(\"Right Motor\", rightMotor != null ? \"OK\" : \"FAILED\");\n        telemetry.addData(\"Arm Servo\", armServo != null ? \"OK\" : \"FAILED\");\n        telemetry.addData(\"Claw Servo\", clawServo != null ? \"OK\" : \"FAILED\");\n        telemetry.addData(\"Touch Sensor\", touchSensor != null ? \"OK\" : \"FAILED\");\n        telemetry.addData(\"Color Sensor\", colorSensor != null ? \"OK\" : \"FAILED\");\n        telemetry.addData(\"Battery Voltage\", \"%.1f volts\", getBatteryVoltage());\n        telemetry.update();\n        sleep(2000); // Give time to read\n    }\n    \n    // ===== INPUT PROCESSING METHODS =====\n    private void processGamepadInputs() {\n        // Process drive inputs\n        processDriveInputs();\n        \n        // Process arm controls\n        processArmControls();\n        \n        // Process claw controls\n        processClawControls();\n        \n        // Process special functions\n        processSpecialFunctions();\n    }\n    \n    private void processDriveInputs() {\n        double leftStickY = -gamepad1.left_stick_y;\n        double rightStickY = -gamepad1.right_stick_y;\n        \n        // Apply deadzone\n        leftStickY = applyDeadzone(leftStickY, 0.1);\n        rightStickY = applyDeadzone(rightStickY, 0.1);\n        \n        // Set motor powers\n        leftMotor.setPower(leftStickY * MOTOR_POWER);\n        rightMotor.setPower(rightStickY * MOTOR_POWER);\n    }\n    \n    private void processArmControls() {\n        if (gamepad1.dpad_up && !armUp) {\n            armServo.setPosition(ARM_UP_POSITION);\n            armUp = true;\n        } else if (gamepad1.dpad_down && armUp) {\n            armServo.setPosition(ARM_DOWN_POSITION);\n            armUp = false;\n        }\n    }\n    \n    private void processClawControls() {\n        if (gamepad1.a && canToggleClaw()) {\n            if (clawOpen) {\n                clawServo.setPosition(SERVO_CLOSED_POSITION);\n                clawOpen = false;\n            } else {\n                clawServo.setPosition(SERVO_OPEN_POSITION);\n                clawOpen = true;\n            }\n            lastButtonPressTime = getRuntime().seconds();\n        }\n    }\n    \n    private void processSpecialFunctions() {\n        if (gamepad1.b) {\n            performEmergencyStop();\n        }\n        \n        if (gamepad1.x) {\n            performCalibration();\n        }\n    }\n    \n    // ===== BEHAVIOR UPDATE METHODS =====\n    private void updateRobotBehavior() {\n        // Update safety checks\n        performSafetyChecks();\n        \n        // Update sensor monitoring\n        updateSensorMonitoring();\n        \n        // Update performance monitoring\n        updatePerformanceMonitoring();\n    }\n    \n    private void performSafetyChecks() {\n        // Check battery voltage\n        double batteryVoltage = getBatteryVoltage();\n        if (batteryVoltage < 11.0) {\n            telemetry.addData(\"WARNING\", \"Low battery: %.1f volts\", batteryVoltage);\n        }\n        \n        // Check for stuck conditions\n        if (touchSensor.isPressed() && Math.abs(leftMotor.getPower()) > 0.1) {\n            telemetry.addData(\"WARNING\", \"Touch sensor pressed while moving\");\n        }\n    }\n    \n    private void updateSensorMonitoring() {\n        // Monitor color sensor\n        if (colorSensor.alpha() > 100) { // Object detected\n            telemetry.addData(\"SENSOR\", \"Object detected by color sensor\");\n        }\n    }\n    \n    private void updatePerformanceMonitoring() {\n        // Monitor loop performance\n        double loopTime = getLoopTime();\n        if (loopTime > 0.05) { // More than 50ms per loop\n            telemetry.addData(\"PERFORMANCE\", \"Slow loop: %.3f seconds\", loopTime);\n        }\n    }\n    \n    // ===== UTILITY METHODS =====\n    private double applyDeadzone(double value, double deadzone) {\n        if (Math.abs(value) < deadzone) {\n            return 0.0;\n        }\n        return value;\n    }\n    \n    private boolean canToggleClaw() {\n        return getRuntime().seconds() - lastButtonPressTime > 0.5; // 500ms debounce\n    }\n    \n    private void performEmergencyStop() {\n        leftMotor.setPower(0);\n        rightMotor.setPower(0);\n        telemetry.addData(\"EMERGENCY\", \"Emergency stop activated\");\n    }\n    \n    private void performCalibration() {\n        telemetry.addData(\"CALIBRATION\", \"Performing sensor calibration...\");\n        // Add calibration logic here\n        sleep(1000);\n        telemetry.addData(\"CALIBRATION\", \"Calibration complete\");\n    }\n    \n    private double getBatteryVoltage() {\n        return hardwareMap.voltageSensor.iterator().next().getVoltage();\n    }\n    \n    private double getLoopTime() {\n        double currentTime = getRuntime().seconds();\n        double loopTime = currentTime - lastLoopTime;\n        lastLoopTime = currentTime;\n        return loopTime;\n    }\n    \n    // ===== TELEMETRY METHODS =====\n    private void updateTelemetry() {\n        // Display robot status\n        displayRobotStatus();\n        \n        // Display sensor data\n        displaySensorData();\n        \n        // Display performance data\n        displayPerformanceData();\n        \n        telemetry.update();\n    }\n    \n    private void displayRobotStatus() {\n        telemetry.addData(\"=== ROBOT STATUS ===\", \"\");\n        telemetry.addData(\"Claw State\", clawOpen ? \"Open\" : \"Closed\");\n        telemetry.addData(\"Arm State\", armUp ? \"Up\" : \"Down\");\n        telemetry.addData(\"Left Motor Power\", \"%.2f\", leftMotor.getPower());\n        telemetry.addData(\"Right Motor Power\", \"%.2f\", rightMotor.getPower());\n    }\n    \n    private void displaySensorData() {\n        telemetry.addData(\"=== SENSOR DATA ===\", \"\");\n        telemetry.addData(\"Touch Sensor\", touchSensor.isPressed());\n        telemetry.addData(\"Color Sensor Alpha\", colorSensor.alpha());\n        telemetry.addData(\"Battery Voltage\", \"%.1f volts\", getBatteryVoltage());\n    }\n    \n    private void displayPerformanceData() {\n        telemetry.addData(\"=== PERFORMANCE ===\", \"\");\n        telemetry.addData(\"Runtime\", \"%.1f seconds\", getRuntime().seconds());\n        telemetry.addData(\"Loop Time\", \"%.3f seconds\", getLoopTime());\n        telemetry.addData(\"Loop Frequency\", \"%.1f Hz\", 1.0 / getLoopTime());\n    }\n    \n    // ===== CLEANUP METHODS =====\n    private void cleanup() {\n        // Stop all motors\n        leftMotor.setPower(0);\n        rightMotor.setPower(0);\n        \n        // Reset servos to safe positions\n        armServo.setPosition(ARM_DOWN_POSITION);\n        clawServo.setPosition(SERVO_OPEN_POSITION);\n        \n        telemetry.addData(\"CLEANUP\", \"Robot safely stopped\");\n        telemetry.update();\n    }\n    \n    // Performance tracking variables\n    private double lastLoopTime = 0;\n}"
    },
    {
      "type": "text",
      "title": "Modular Code Organization",
      "content": "Breaking code into modules makes it easier to debug and maintain. Each module should have a single responsibility and clear interfaces."
    },
    {
      "type": "code",
      "title": "Modular Code Example",
      "language": "java",
      "content": "// Modular code organization example\n@TeleOp(name=\"Modular Example\", group=\"Examples\")\npublic class ModularExample extends LinearOpMode {\n    \n    // ===== MODULE INSTANCES =====\n    private DriveModule driveModule;\n    private ArmModule armModule;\n    private SensorModule sensorModule;\n    private TelemetryModule telemetryModule;\n    \n    @Override\n    public void runOpMode() {\n        // Initialize modules\n        initializeModules();\n        \n        waitForStart();\n        \n        while (opModeIsActive()) {\n            // Update all modules\n            driveModule.update(gamepad1);\n            armModule.update(gamepad1);\n            sensorModule.update();\n            telemetryModule.update();\n        }\n        \n        // Cleanup modules\n        cleanupModules();\n    }\n    \n    private void initializeModules() {\n        driveModule = new DriveModule(hardwareMap);\n        armModule = new ArmModule(hardwareMap);\n        sensorModule = new SensorModule(hardwareMap);\n        telemetryModule = new TelemetryModule(telemetry);\n    }\n    \n    private void cleanupModules() {\n        driveModule.cleanup();\n        armModule.cleanup();\n        sensorModule.cleanup();\n    }\n}\n\n// ===== DRIVE MODULE =====\nclass DriveModule {\n    private DcMotor leftMotor, rightMotor;\n    private static final double MOTOR_POWER = 0.5;\n    \n    public DriveModule(HardwareMap hardwareMap) {\n        leftMotor = hardwareMap.get(DcMotor.class, \"left_motor\");\n        rightMotor = hardwareMap.get(DcMotor.class, \"right_motor\");\n        \n        leftMotor.setDirection(DcMotor.Direction.FORWARD);\n        rightMotor.setDirection(DcMotor.Direction.REVERSE);\n    }\n    \n    public void update(Gamepad gamepad) {\n        double leftStickY = -gamepad.left_stick_y;\n        double rightStickY = -gamepad.right_stick_y;\n        \n        leftStickY = applyDeadzone(leftStickY, 0.1);\n        rightStickY = applyDeadzone(rightStickY, 0.1);\n        \n        leftMotor.setPower(leftStickY * MOTOR_POWER);\n        rightMotor.setPower(rightStickY * MOTOR_POWER);\n    }\n    \n    public void cleanup() {\n        leftMotor.setPower(0);\n        rightMotor.setPower(0);\n    }\n    \n    private double applyDeadzone(double value, double deadzone) {\n        return Math.abs(value) < deadzone ? 0.0 : value;\n    }\n}\n\n// ===== ARM MODULE =====\nclass ArmModule {\n    private Servo armServo, clawServo;\n    private boolean clawOpen = true;\n    private double lastButtonPressTime = 0;\n    \n    public ArmModule(HardwareMap hardwareMap) {\n        armServo = hardwareMap.get(Servo.class, \"arm_servo\");\n        clawServo = hardwareMap.get(Servo.class, \"claw_servo\");\n    }\n    \n    public void update(Gamepad gamepad) {\n        // Handle arm controls\n        if (gamepad.dpad_up) {\n            armServo.setPosition(0.8);\n        } else if (gamepad.dpad_down) {\n            armServo.setPosition(0.2);\n        }\n        \n        // Handle claw controls\n        if (gamepad.a && canToggleClaw()) {\n            if (clawOpen) {\n                clawServo.setPosition(1.0);\n                clawOpen = false;\n            } else {\n                clawServo.setPosition(0.0);\n                clawOpen = true;\n            }\n            lastButtonPressTime = getRuntime().seconds();\n        }\n    }\n    \n    public void cleanup() {\n        armServo.setPosition(0.2);\n        clawServo.setPosition(0.0);\n    }\n    \n    private boolean canToggleClaw() {\n        return getRuntime().seconds() - lastButtonPressTime > 0.5;\n    }\n}\n\n// ===== SENSOR MODULE =====\nclass SensorModule {\n    private TouchSensor touchSensor;\n    private ColorSensor colorSensor;\n    \n    public SensorModule(HardwareMap hardwareMap) {\n        touchSensor = hardwareMap.get(TouchSensor.class, \"touch_sensor\");\n        colorSensor = hardwareMap.get(ColorSensor.class, \"color_sensor\");\n    }\n    \n    public void update() {\n        // Monitor sensors for safety\n        if (touchSensor.isPressed()) {\n            // Handle touch sensor activation\n        }\n        \n        if (colorSensor.alpha() > 100) {\n            // Handle object detection\n        }\n    }\n    \n    public void cleanup() {\n        // No cleanup needed for sensors\n    }\n}\n\n// ===== TELEMETRY MODULE =====\nclass TelemetryModule {\n    private Telemetry telemetry;\n    private double lastUpdateTime = 0;\n    \n    public TelemetryModule(Telemetry telemetry) {\n        this.telemetry = telemetry;\n    }\n    \n    public void update() {\n        double currentTime = getRuntime().seconds();\n        \n        telemetry.addData(\"Runtime\", \"%.1f seconds\", currentTime);\n        telemetry.addData(\"Update Rate\", \"%.1f Hz\", 1.0 / (currentTime - lastUpdateTime));\n        \n        lastUpdateTime = currentTime;\n        telemetry.update();\n    }\n}"
    },
    {
      "type": "text",
      "title": "Code Organization Debugging",
      "content": "When debugging organized code, you can isolate problems to specific modules or sections. This makes debugging much more efficient."
    },
    {
      "type": "code",
      "title": "Debugging Organized Code",
      "language": "java",
      "content": "// Debugging organized code example\nprivate void debugOrganizedCode() {\n    telemetry.addData(\"=== CODE ORGANIZATION DEBUG ===\", \"\");\n    \n    // Debug each module separately\n    debugDriveModule();\n    debugArmModule();\n    debugSensorModule();\n    debugTelemetryModule();\n    \n    // Debug module interactions\n    debugModuleInteractions();\n    \n    telemetry.update();\n}\n\nprivate void debugDriveModule() {\n    telemetry.addData(\"=== DRIVE MODULE DEBUG ===\", \"\");\n    \n    // Check hardware connections\n    telemetry.addData(\"Left Motor Connected\", leftMotor != null);\n    telemetry.addData(\"Right Motor Connected\", rightMotor != null);\n    \n    // Check motor behavior\n    telemetry.addData(\"Left Motor Power\", \"%.2f\", leftMotor.getPower());\n    telemetry.addData(\"Right Motor Power\", \"%.2f\", rightMotor.getPower());\n    telemetry.addData(\"Left Motor Direction\", leftMotor.getDirection());\n    telemetry.addData(\"Right Motor Direction\", rightMotor.getDirection());\n    \n    // Check input processing\n    double leftStickY = -gamepad1.left_stick_y;\n    double rightStickY = -gamepad1.right_stick_y;\n    telemetry.addData(\"Raw Left Stick\", \"%.2f\", leftStickY);\n    telemetry.addData(\"Raw Right Stick\", \"%.2f\", rightStickY);\n    telemetry.addData(\"Processed Left Stick\", \"%.2f\", applyDeadzone(leftStickY, 0.1));\n    telemetry.addData(\"Processed Right Stick\", \"%.2f\", applyDeadzone(rightStickY, 0.1));\n}\n\nprivate void debugArmModule() {\n    telemetry.addData(\"=== ARM MODULE DEBUG ===\", \"\");\n    \n    // Check hardware connections\n    telemetry.addData(\"Arm Servo Connected\", armServo != null);\n    telemetry.addData(\"Claw Servo Connected\", clawServo != null);\n    \n    // Check servo positions\n    telemetry.addData(\"Arm Position\", \"%.2f\", armServo.getPosition());\n    telemetry.addData(\"Claw Position\", \"%.2f\", clawServo.getPosition());\n    \n    // Check state variables\n    telemetry.addData(\"Claw Open State\", clawOpen);\n    telemetry.addData(\"Arm Up State\", armUp);\n    telemetry.addData(\"Button Debounce Time\", \"%.1f seconds\", getRuntime().seconds() - lastButtonPressTime);\n    \n    // Check input processing\n    telemetry.addData(\"D-pad Up Pressed\", gamepad1.dpad_up);\n    telemetry.addData(\"D-pad Down Pressed\", gamepad1.dpad_down);\n    telemetry.addData(\"A Button Pressed\", gamepad1.a);\n    telemetry.addData(\"Can Toggle Claw\", canToggleClaw());\n}\n\nprivate void debugSensorModule() {\n    telemetry.addData(\"=== SENSOR MODULE DEBUG ===\", \"\");\n    \n    // Check hardware connections\n    telemetry.addData(\"Touch Sensor Connected\", touchSensor != null);\n    telemetry.addData(\"Color Sensor Connected\", colorSensor != null);\n    \n    // Check sensor readings\n    telemetry.addData(\"Touch Sensor Pressed\", touchSensor.isPressed());\n    telemetry.addData(\"Color Sensor Alpha\", colorSensor.alpha());\n    telemetry.addData(\"Color Sensor Red\", colorSensor.red());\n    telemetry.addData(\"Color Sensor Green\", colorSensor.green());\n    telemetry.addData(\"Color Sensor Blue\", colorSensor.blue());\n    \n    // Check sensor thresholds\n    telemetry.addData(\"Object Detected\", colorSensor.alpha() > 100);\n}\n\nprivate void debugTelemetryModule() {\n    telemetry.addData(\"=== TELEMETRY MODULE DEBUG ===\", \"\");\n    \n    // Check telemetry performance\n    double currentTime = getRuntime().seconds();\n    double updateRate = 1.0 / (currentTime - lastLoopTime);\n    telemetry.addData(\"Telemetry Update Rate\", \"%.1f Hz\", updateRate);\n    telemetry.addData(\"Last Update Time\", \"%.3f seconds\", lastLoopTime);\n    \n    // Check battery status\n    double batteryVoltage = getBatteryVoltage();\n    telemetry.addData(\"Battery Voltage\", \"%.1f volts\", batteryVoltage);\n    telemetry.addData(\"Battery Status\", batteryVoltage < 11.0 ? \"LOW\" : \"OK\");\n}\n\nprivate void debugModuleInteractions() {\n    telemetry.addData(\"=== MODULE INTERACTIONS ===\", \"\");\n    \n    // Check for conflicts between modules\n    if (touchSensor.isPressed() && Math.abs(leftMotor.getPower()) > 0.1) {\n        telemetry.addData(\"CONFLICT\", \"Touch sensor pressed while driving\");\n    }\n    \n    if (armUp && clawOpen) {\n        telemetry.addData(\"CONFLICT\", \"Arm up with claw open\");\n    }\n    \n    // Check overall system health\n    telemetry.addData(\"System Health\", \"GOOD\");\n    telemetry.addData(\"All Modules Active\", true);\n    telemetry.addData(\"No Conflicts Detected\", true);\n}"
    },
    {
      "type": "text",
      "title": "Common Code Organization Problems",
      "content": "Poor code organization can lead to debugging difficulties, maintenance issues, and team collaboration problems. Understanding these issues helps you avoid them."
    },
    {
      "type": "list",
      "title": "Common Organization Issues",
      "items": [
        "<strong>Monolithic Code:</strong> Everything in one large method making debugging difficult",
        "<strong>Inconsistent Naming:</strong> Variables and methods with unclear or inconsistent names",
        "<strong>Mixed Responsibilities:</strong> Methods that do multiple unrelated tasks",
        "<strong>Poor Separation:</strong> Hardware initialization mixed with logic",
        "<strong>No Comments:</strong> Code without explanations of complex logic",
        "<strong>Inconsistent Formatting:</strong> Code that's hard to read due to poor formatting",
        "<strong>No Error Handling:</strong> Code that doesn't handle potential failures gracefully",
        "<strong>Hard-coded Values:</strong> Magic numbers scattered throughout code"
      ]
    },
    {
      "type": "code",
      "title": "Problematic vs. Well-Organized Code",
      "language": "java",
      "content": "// PROBLEMATIC CODE - Don't do this!\n@TeleOp(name=\"Bad Example\", group=\"Examples\")\npublic class BadExample extends LinearOpMode {\n    private DcMotor m1, m2;\n    private Servo s1, s2;\n    private TouchSensor ts;\n    \n    @Override\n    public void runOpMode() {\n        m1 = hardwareMap.get(DcMotor.class, \"left_motor\");\n        m2 = hardwareMap.get(DcMotor.class, \"right_motor\");\n        s1 = hardwareMap.get(Servo.class, \"arm_servo\");\n        s2 = hardwareMap.get(Servo.class, \"claw_servo\");\n        ts = hardwareMap.get(TouchSensor.class, \"touch_sensor\");\n        \n        m1.setDirection(DcMotor.Direction.FORWARD);\n        m2.setDirection(DcMotor.Direction.REVERSE);\n        \n        waitForStart();\n        \n        while (opModeIsActive()) {\n            // Everything mixed together - hard to debug!\n            double ly = -gamepad1.left_stick_y;\n            double ry = -gamepad1.right_stick_y;\n            if (Math.abs(ly) < 0.1) ly = 0;\n            if (Math.abs(ry) < 0.1) ry = 0;\n            m1.setPower(ly * 0.5);\n            m2.setPower(ry * 0.5);\n            \n            if (gamepad1.dpad_up) s1.setPosition(0.8);\n            if (gamepad1.dpad_down) s1.setPosition(0.2);\n            if (gamepad1.a) s2.setPosition(1.0);\n            if (gamepad1.b) s2.setPosition(0.0);\n            \n            telemetry.addData(\"m1\", m1.getPower());\n            telemetry.addData(\"m2\", m2.getPower());\n            telemetry.addData(\"s1\", s1.getPosition());\n            telemetry.addData(\"s2\", s2.getPosition());\n            telemetry.addData(\"ts\", ts.isPressed());\n            telemetry.update();\n        }\n    }\n}\n\n// WELL-ORGANIZED CODE - Do this instead!\n@TeleOp(name=\"Good Example\", group=\"Examples\")\npublic class GoodExample extends LinearOpMode {\n    \n    // Clear hardware declarations\n    private DcMotor leftMotor, rightMotor;\n    private Servo armServo, clawServo;\n    private TouchSensor touchSensor;\n    \n    // Constants for easy modification\n    private static final double MOTOR_POWER = 0.5;\n    private static final double DEADZONE = 0.1;\n    private static final double ARM_UP_POSITION = 0.8;\n    private static final double ARM_DOWN_POSITION = 0.2;\n    \n    @Override\n    public void runOpMode() {\n        initializeHardware();\n        waitForStart();\n        \n        while (opModeIsActive()) {\n            processDriveInputs();\n            processArmControls();\n            updateTelemetry();\n        }\n        \n        cleanup();\n    }\n    \n    private void initializeHardware() {\n        // Clear initialization with error checking\n        leftMotor = hardwareMap.get(DcMotor.class, \"left_motor\");\n        rightMotor = hardwareMap.get(DcMotor.class, \"right_motor\");\n        armServo = hardwareMap.get(Servo.class, \"arm_servo\");\n        clawServo = hardwareMap.get(Servo.class, \"claw_servo\");\n        touchSensor = hardwareMap.get(TouchSensor.class, \"touch_sensor\");\n        \n        if (leftMotor == null || rightMotor == null) {\n            telemetry.addData(\"ERROR\", \"Motors not found!\");\n        }\n        \n        leftMotor.setDirection(DcMotor.Direction.FORWARD);\n        rightMotor.setDirection(DcMotor.Direction.REVERSE);\n    }\n    \n    private void processDriveInputs() {\n        // Clear, focused method for drive logic\n        double leftStickY = applyDeadzone(-gamepad1.left_stick_y, DEADZONE);\n        double rightStickY = applyDeadzone(-gamepad1.right_stick_y, DEADZONE);\n        \n        leftMotor.setPower(leftStickY * MOTOR_POWER);\n        rightMotor.setPower(rightStickY * MOTOR_POWER);\n    }\n    \n    private void processArmControls() {\n        // Clear, focused method for arm logic\n        if (gamepad1.dpad_up) {\n            armServo.setPosition(ARM_UP_POSITION);\n        } else if (gamepad1.dpad_down) {\n            armServo.setPosition(ARM_DOWN_POSITION);\n        }\n        \n        if (gamepad1.a) {\n            clawServo.setPosition(1.0); // Close claw\n        } else if (gamepad1.b) {\n            clawServo.setPosition(0.0); // Open claw\n        }\n    }\n    \n    private void updateTelemetry() {\n        // Clear telemetry with organized sections\n        telemetry.addData(\"=== DRIVE STATUS ===\", \"\");\n        telemetry.addData(\"Left Motor Power\", \"%.2f\", leftMotor.getPower());\n        telemetry.addData(\"Right Motor Power\", \"%.2f\", rightMotor.getPower());\n        \n        telemetry.addData(\"=== ARM STATUS ===\", \"\");\n        telemetry.addData(\"Arm Position\", \"%.2f\", armServo.getPosition());\n        telemetry.addData(\"Claw Position\", \"%.2f\", clawServo.getPosition());\n        \n        telemetry.addData(\"=== SENSOR STATUS ===\", \"\");\n        telemetry.addData(\"Touch Sensor\", touchSensor.isPressed());\n        \n        telemetry.update();\n    }\n    \n    private double applyDeadzone(double value, double deadzone) {\n        return Math.abs(value) < deadzone ? 0.0 : value;\n    }\n    \n    private void cleanup() {\n        // Safe cleanup\n        leftMotor.setPower(0);\n        rightMotor.setPower(0);\n    }\n}"
    },
    {
      "type": "text",
      "title": "Code Organization Best Practices",
      "content": "Following these best practices will make your code easier to debug, maintain, and extend."
    },
    {
      "type": "rules-box",
      "title": "Code Organization Best Practices",
      "subtitle": "Follow these guidelines for well-organized code:",
      "items": [
        "Use clear, descriptive names for variables, methods, and classes",
        "Separate concerns - each method should have a single responsibility",
        "Group related functionality into logical sections with comments",
        "Use constants for magic numbers and configuration values",
        "Add comprehensive comments explaining complex logic",
        "Follow consistent formatting and indentation",
        "Include error handling and validation",
        "Organize hardware initialization separately from logic",
        "Use modular design for complex systems",
        "Include cleanup methods for proper resource management"
      ]
    },
    {
      "type": "text",
      "title": "Debugging Organized Code",
      "content": "When debugging well-organized code, you can systematically test each component and isolate problems quickly."
    },
    {
      "type": "code",
      "title": "Systematic Debugging Approach",
      "language": "java",
      "content": "// Systematic debugging approach for organized code\nprivate void systematicDebugging() {\n    telemetry.addData(\"=== SYSTEMATIC DEBUGGING ===\", \"\");\n    \n    // Step 1: Test hardware initialization\n    debugHardwareInitialization();\n    \n    // Step 2: Test input processing\n    debugInputProcessing();\n    \n    // Step 3: Test behavior logic\n    debugBehaviorLogic();\n    \n    // Step 4: Test output generation\n    debugOutputGeneration();\n    \n    // Step 5: Test error handling\n    debugErrorHandling();\n    \n    telemetry.update();\n}\n\nprivate void debugHardwareInitialization() {\n    telemetry.addData(\"=== HARDWARE INITIALIZATION ===\", \"\");\n    \n    // Check if hardware is properly initialized\n    boolean allHardwareOK = true;\n    \n    if (leftMotor == null) {\n        telemetry.addData(\"ERROR\", \"Left motor not initialized\");\n        allHardwareOK = false;\n    }\n    \n    if (rightMotor == null) {\n        telemetry.addData(\"ERROR\", \"Right motor not initialized\");\n        allHardwareOK = false;\n    }\n    \n    if (armServo == null) {\n        telemetry.addData(\"ERROR\", \"Arm servo not initialized\");\n        allHardwareOK = false;\n    }\n    \n    if (clawServo == null) {\n        telemetry.addData(\"ERROR\", \"Claw servo not initialized\");\n        allHardwareOK = false;\n    }\n    \n    if (touchSensor == null) {\n        telemetry.addData(\"ERROR\", \"Touch sensor not initialized\");\n        allHardwareOK = false;\n    }\n    \n    telemetry.addData(\"Hardware Status\", allHardwareOK ? \"OK\" : \"FAILED\");\n}\n\nprivate void debugInputProcessing() {\n    telemetry.addData(\"=== INPUT PROCESSING ===\", \"\");\n    \n    // Test gamepad input processing\n    double rawLeftStick = gamepad1.left_stick_y;\n    double processedLeftStick = applyDeadzone(-rawLeftStick, 0.1);\n    \n    telemetry.addData(\"Raw Left Stick\", \"%.2f\", rawLeftStick);\n    telemetry.addData(\"Processed Left Stick\", \"%.2f\", processedLeftStick);\n    telemetry.addData(\"Deadzone Applied\", Math.abs(rawLeftStick) < 0.1 ? \"YES\" : \"NO\");\n    \n    // Test button processing\n    telemetry.addData(\"A Button\", gamepad1.a);\n    telemetry.addData(\"B Button\", gamepad1.b);\n    telemetry.addData(\"D-pad Up\", gamepad1.dpad_up);\n    telemetry.addData(\"D-pad Down\", gamepad1.dpad_down);\n}\n\nprivate void debugBehaviorLogic() {\n    telemetry.addData(\"=== BEHAVIOR LOGIC ===\", \"\");\n    \n    // Test drive logic\n    double leftPower = leftMotor.getPower();\n    double rightPower = rightMotor.getPower();\n    \n    telemetry.addData(\"Left Motor Power\", \"%.2f\", leftPower);\n    telemetry.addData(\"Right Motor Power\", \"%.2f\", rightPower);\n    telemetry.addData(\"Motors Moving\", Math.abs(leftPower) > 0.1 || Math.abs(rightPower) > 0.1);\n    \n    // Test arm logic\n    double armPosition = armServo.getPosition();\n    double clawPosition = clawServo.getPosition();\n    \n    telemetry.addData(\"Arm Position\", \"%.2f\", armPosition);\n    telemetry.addData(\"Claw Position\", \"%.2f\", clawPosition);\n    telemetry.addData(\"Arm Up\", armPosition > 0.5);\n    telemetry.addData(\"Claw Closed\", clawPosition > 0.5);\n}\n\nprivate void debugOutputGeneration() {\n    telemetry.addData(\"=== OUTPUT GENERATION ===\", \"\");\n    \n    // Test motor outputs\n    telemetry.addData(\"Left Motor Direction\", leftMotor.getDirection());\n    telemetry.addData(\"Right Motor Direction\", rightMotor.getDirection());\n    telemetry.addData(\"Left Motor Mode\", leftMotor.getMode());\n    telemetry.addData(\"Right Motor Mode\", rightMotor.getMode());\n    \n    // Test servo outputs\n    telemetry.addData(\"Arm Servo Connected\", armServo != null);\n    telemetry.addData(\"Claw Servo Connected\", clawServo != null);\n}\n\nprivate void debugErrorHandling() {\n    telemetry.addData(\"=== ERROR HANDLING ===\", \"\");\n    \n    // Test battery voltage monitoring\n    double batteryVoltage = getBatteryVoltage();\n    telemetry.addData(\"Battery Voltage\", \"%.1f volts\", batteryVoltage);\n    telemetry.addData(\"Battery OK\", batteryVoltage > 11.0);\n    \n    // Test sensor error detection\n    boolean touchSensorWorking = touchSensor != null && (touchSensor.isPressed() || !touchSensor.isPressed());\n    telemetry.addData(\"Touch Sensor Working\", touchSensorWorking);\n    \n    // Test motor error detection\n    boolean motorsResponding = leftMotor != null && rightMotor != null && \n                               Math.abs(leftMotor.getPower()) >= 0 && Math.abs(rightMotor.getPower()) >= 0;\n    telemetry.addData(\"Motors Responding\", motorsResponding);\n}"
    },
    {
      "type": "link-grid",
      "title": "Related Topics",
      "links": [
        {
          "label": "Basic Debugging Techniques",
          "id": "basic-debugging-techniques"
        },
        {
          "label": "State Machines",
          "id": "state-machines"
        },
        {
          "label": "Telemetry Logging",
          "id": "telemetry-logging"
        },
        {
          "label": "Advanced Debugging",
          "id": "advanced-debugging"
        }
      ]
    },
    {
      "type": "exercise-box",
      "title": "Code Organization Practice",
      "description": "Complete these exercises to master code organization:",
      "tasks": [
        "Refactor a poorly organized OpMode into well-structured code",
        "Create modular code with separate classes for different robot functions",
        "Add comprehensive comments and documentation to existing code",
        "Implement error handling and validation in organized code",
        "Create constants and configuration sections for easy modification",
        "Organize telemetry into logical sections with clear labels",
        "Practice debugging organized code systematically",
        "Create cleanup methods for proper resource management"
      ],
      "content": "// Practice Exercise: Complete Code Organization System\n// Refactor an existing OpMode to include:\n// - Clear hardware declarations with descriptive names\n// - Constants for all configuration values\n// - Separate methods for initialization, input processing, and behavior\n// - Comprehensive error handling and validation\n// - Organized telemetry with clear sections\n// - Proper cleanup methods\n// - Clear comments explaining complex logic\n// - Consistent formatting and naming conventions"
    }
  ]
} 