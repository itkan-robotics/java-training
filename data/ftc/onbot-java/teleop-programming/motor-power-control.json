{
  "title": "Motor Power Control",
  "sections": [
    {
      "type": "text",
      "title": "Introduction to Motor Power Control",
      "content": "Motor power control is fundamental to creating responsive and safe robot movement. Understanding how to properly control motor power levels, implement ramping, and handle different power scenarios is essential for effective teleop programming."
    },
    {
      "type": "rules-box",
      "title": "What is Motor Power Control?",
      "subtitle": "Key concepts for motor power control:",
      "items": [
        "Power scaling and limiting for safe operation",
        "Ramping to prevent sudden movements",
        "Direction control and reversing",
        "Zero power behavior (brake vs. float)",
        "Power curves for fine control",
        "Safety limits and emergency stops"
      ]
    },
    {
      "type": "text",
      "title": "Power Scaling and Limiting",
      "content": "Controlling motor power levels ensures safe operation and prevents damage to hardware. Power scaling allows for fine control while limiting prevents dangerous situations."
    },
    {
      "type": "code",
      "title": "Basic Power Control",
      "content": "// Basic motor power control\n@TeleOp(name=\"Motor Power Control\", group=\"Teleop\")\npublic class MotorPowerControl extends LinearOpMode {\n    \n    private DcMotor leftDrive, rightDrive;\n    private double maxPower = 0.8; // Limit maximum power\n    \n    @Override\n    public void runOpMode() {\n        // Initialize motors\n        leftDrive = hardwareMap.get(DcMotor.class, \"left_drive\");\n        rightDrive = hardwareMap.get(DcMotor.class, \"right_drive\");\n        \n        // Configure motors\n        leftDrive.setDirection(DcMotor.Direction.FORWARD);\n        rightDrive.setDirection(DcMotor.Direction.REVERSE);\n        leftDrive.setZeroPowerBehavior(DcMotor.ZeroPowerBehavior.BRAKE);\n        rightDrive.setZeroPowerBehavior(DcMotor.ZeroPowerBehavior.BRAKE);\n        \n        waitForStart();\n        \n        while (opModeIsActive()) {\n            // Read gamepad inputs\n            double leftInput = -gamepad1.left_stick_y;\n            double rightInput = -gamepad1.right_stick_y;\n            \n            // Apply power scaling\n            double leftPower = scalePower(leftInput);\n            double rightPower = scalePower(rightInput);\n            \n            // Apply to motors\n            leftDrive.setPower(leftPower);\n            rightDrive.setPower(rightPower);\n            \n            // Display power levels\n            telemetry.addData(\"Left Power\", \"%.2f\", leftPower);\n            telemetry.addData(\"Right Power\", \"%.2f\", rightPower);\n            telemetry.update();\n        }\n    }\n    \n    private double scalePower(double input) {\n        // Apply power curve for better low-speed control\n        double scaled = Math.signum(input) * Math.pow(Math.abs(input), 2.0);\n        \n        // Limit to maximum power\n        return Math.max(-maxPower, Math.min(maxPower, scaled));\n    }\n}"
    },
    {
      "type": "text",
      "title": "Power Ramping",
      "content": "Power ramping prevents sudden motor movements that can cause jerky robot behavior and potential damage. Gradual power changes create smooth and predictable robot movement."
    },
    {
      "type": "code",
      "title": "Power Ramping Implementation",
      "content": "// Power ramping for smooth motor control\npublic class PowerRamping {\n    private double currentLeftPower = 0;\n    private double currentRightPower = 0;\n    private double rampRate = 0.05; // Power change per loop\n    \n    public double[] rampPower(double targetLeft, double targetRight) {\n        // Ramp left motor\n        if (targetLeft > currentLeftPower) {\n            currentLeftPower = Math.min(targetLeft, currentLeftPower + rampRate);\n        } else if (targetLeft < currentLeftPower) {\n            currentLeftPower = Math.max(targetLeft, currentLeftPower - rampRate);\n        }\n        \n        // Ramp right motor\n        if (targetRight > currentRightPower) {\n            currentRightPower = Math.min(targetRight, currentRightPower + rampRate);\n        } else if (targetRight < currentRightPower) {\n            currentRightPower = Math.max(targetRight, currentRightPower - rampRate);\n        }\n        \n        return new double[]{currentLeftPower, currentRightPower};\n    }\n    \n    public void setRampRate(double rate) {\n        this.rampRate = rate;\n    }\n    \n    public void reset() {\n        currentLeftPower = 0;\n        currentRightPower = 0;\n    }\n}\n\n// Usage in OpMode\n@TeleOp(name=\"Ramped Motor Control\", group=\"Teleop\")\npublic class RampedMotorControl extends LinearOpMode {\n    \n    private DcMotor leftDrive, rightDrive;\n    private PowerRamping ramping;\n    \n    @Override\n    public void runOpMode() {\n        leftDrive = hardwareMap.get(DcMotor.class, \"left_drive\");\n        rightDrive = hardwareMap.get(DcMotor.class, \"right_drive\");\n        ramping = new PowerRamping();\n        \n        waitForStart();\n        \n        while (opModeIsActive()) {\n            // Read inputs\n            double leftInput = -gamepad1.left_stick_y;\n            double rightInput = -gamepad1.right_stick_y;\n            \n            // Apply ramping\n            double[] rampedPower = ramping.rampPower(leftInput, rightInput);\n            \n            // Apply to motors\n            leftDrive.setPower(rampedPower[0]);\n            rightDrive.setPower(rampedPower[1]);\n            \n            // Display ramped vs target power\n            telemetry.addData(\"Target Left\", \"%.2f\", leftInput);\n            telemetry.addData(\"Ramped Left\", \"%.2f\", rampedPower[0]);\n            telemetry.addData(\"Target Right\", \"%.2f\", rightInput);\n            telemetry.addData(\"Ramped Right\", \"%.2f\", rampedPower[1]);\n            telemetry.update();\n        }\n    }\n}"
    },
    {
      "type": "text",
      "title": "Advanced Power Control",
      "content": "Advanced power control techniques include variable power curves, speed modes, and intelligent power management for different robot configurations and scenarios."
    },
    {
      "type": "code",
      "title": "Advanced Power Control Features",
      "content": "// Advanced motor power control system\npublic class AdvancedMotorControl {\n    private DcMotor leftMotor, rightMotor;\n    private double maxPower = 1.0;\n    private double slowModePower = 0.3;\n    private double precisionModePower = 0.1;\n    \n    // Control modes\n    private enum SpeedMode {\n        NORMAL, SLOW, PRECISION\n    }\n    \n    private SpeedMode currentMode = SpeedMode.NORMAL;\n    \n    public AdvancedMotorControl(DcMotor left, DcMotor right) {\n        this.leftMotor = left;\n        this.rightMotor = right;\n    }\n    \n    public void setSpeedMode(SpeedMode mode) {\n        currentMode = mode;\n    }\n    \n    public void tankDrive(double leftPower, double rightPower) {\n        // Apply speed mode scaling\n        double scaleFactor = getScaleFactor();\n        leftPower *= scaleFactor;\n        rightPower *= scaleFactor;\n        \n        // Apply power curve\n        leftPower = applyPowerCurve(leftPower, 2.0);\n        rightPower = applyPowerCurve(rightPower, 2.0);\n        \n        // Apply limits\n        leftPower = limitPower(leftPower);\n        rightPower = limitPower(rightPower);\n        \n        // Apply to motors\n        leftMotor.setPower(leftPower);\n        rightMotor.setPower(rightPower);\n    }\n    \n    private double getScaleFactor() {\n        switch (currentMode) {\n            case NORMAL: return 1.0;\n            case SLOW: return slowModePower;\n            case PRECISION: return precisionModePower;\n            default: return 1.0;\n        }\n    }\n    \n    private double applyPowerCurve(double power, double curve) {\n        return Math.signum(power) * Math.pow(Math.abs(power), curve);\n    }\n    \n    private double limitPower(double power) {\n        return Math.max(-maxPower, Math.min(maxPower, power));\n    }\n    \n    public void setMaxPower(double power) {\n        this.maxPower = power;\n    }\n}\n\n// Usage with advanced features\n@TeleOp(name=\"Advanced Motor Control\", group=\"Teleop\")\npublic class AdvancedMotorControlOpMode extends LinearOpMode {\n    \n    private AdvancedMotorControl motorControl;\n    \n    @Override\n    public void runOpMode() {\n        DcMotor leftDrive = hardwareMap.get(DcMotor.class, \"left_drive\");\n        DcMotor rightDrive = hardwareMap.get(DcMotor.class, \"right_drive\");\n        \n        motorControl = new AdvancedMotorControl(leftDrive, rightDrive);\n        \n        waitForStart();\n        \n        while (opModeIsActive()) {\n            // Speed mode switching\n            if (gamepad1.a) {\n                motorControl.setSpeedMode(AdvancedMotorControl.SpeedMode.NORMAL);\n            } else if (gamepad1.b) {\n                motorControl.setSpeedMode(AdvancedMotorControl.SpeedMode.SLOW);\n            } else if (gamepad1.x) {\n                motorControl.setSpeedMode(AdvancedMotorControl.SpeedMode.PRECISION);\n            }\n            \n            // Read inputs and apply control\n            double leftPower = -gamepad1.left_stick_y;\n            double rightPower = -gamepad1.right_stick_y;\n            \n            motorControl.tankDrive(leftPower, rightPower);\n            \n            // Display current mode\n            telemetry.addData(\"Speed Mode\", motorControl.getCurrentMode());\n            telemetry.addData(\"Left Power\", \"%.2f\", leftPower);\n            telemetry.addData(\"Right Power\", \"%.2f\", rightPower);\n            telemetry.update();\n        }\n    }\n}"
    },
    {
      "type": "text",
      "title": "Safety and Best Practices",
      "content": "Implementing safety features and following best practices ensures reliable motor operation and prevents damage to hardware."
    },
    {
      "type": "rules-box",
      "title": "Motor Power Safety Guidelines",
      "subtitle": "Essential safety practices for motor power control:",
      "items": [
        "Always implement power limits and maximum values",
        "Use ramping to prevent sudden movements",
        "Monitor motor temperature and current draw",
        "Implement emergency stop functionality",
        "Test power levels at low speeds first",
        "Use appropriate zero power behavior"
      ]
    },
    {
      "type": "code",
      "title": "Safety Implementation",
      "content": "// Safety features for motor power control\npublic class MotorSafety {\n    private double maxPower = 0.8;\n    private double lowBatteryThreshold = 11.0;\n    private boolean emergencyStop = false;\n    private long lastSafetyCheck = 0;\n    \n    public double limitPower(double power) {\n        if (emergencyStop) {\n            return 0.0;\n        }\n        \n        // Check battery voltage\n        if (getBatteryVoltage() < lowBatteryThreshold) {\n            power *= 0.5; // Reduce power if battery is low\n        }\n        \n        // Limit to maximum power\n        return Math.max(-maxPower, Math.min(maxPower, power));\n    }\n    \n    public boolean checkSystemHealth() {\n        boolean healthy = true;\n        \n        // Check battery voltage\n        if (getBatteryVoltage() < lowBatteryThreshold) {\n            telemetry.addData(\"WARNING\", \"Low battery voltage!\");\n            healthy = false;\n        }\n        \n        // Check for excessive power usage\n        if (Math.abs(getCurrentDraw()) > 20.0) { // Amps\n            telemetry.addData(\"WARNING\", \"High current draw!\");\n            healthy = false;\n        }\n        \n        return healthy;\n    }\n    \n    public void setEmergencyStop(boolean stop) {\n        emergencyStop = stop;\n    }\n    \n    private double getBatteryVoltage() {\n        return hardwareMap.voltageSensor.iterator().next().getVoltage();\n    }\n    \n    private double getCurrentDraw() {\n        // This would be implemented based on your current sensor\n        // For now, return a safe default value\n        return 5.0;\n    }\n}\n\n// Safe motor control\npublic class SafeMotorControl {\n    private DcMotor leftMotor, rightMotor;\n    private MotorSafety safety;\n    private PowerRamping ramping;\n    \n    public SafeMotorControl(DcMotor left, DcMotor right) {\n        this.leftMotor = left;\n        this.rightMotor = right;\n        this.safety = new MotorSafety();\n        this.ramping = new PowerRamping();\n    }\n    \n    public void tankDrive(double leftPower, double rightPower) {\n        // Check safety first\n        if (!safety.checkSystemHealth()) {\n            // Reduce power or stop if safety issues detected\n            leftPower *= 0.3;\n            rightPower *= 0.3;\n        }\n        \n        // Apply safety limits\n        leftPower = safety.limitPower(leftPower);\n        rightPower = safety.limitPower(rightPower);\n        \n        // Apply ramping\n        double[] rampedPower = ramping.rampPower(leftPower, rightPower);\n        \n        // Apply to motors\n        leftMotor.setPower(rampedPower[0]);\n        rightMotor.setPower(rampedPower[1]);\n    }\n    \n    public void emergencyStop() {\n        safety.setEmergencyStop(true);\n        leftMotor.setPower(0);\n        rightMotor.setPower(0);\n    }\n}"
    },
    {
      "type": "text",
      "title": "Troubleshooting Common Issues",
      "content": "Common issues with motor power control and their solutions help teams quickly resolve problems."
    },
    {
      "type": "rules-box",
      "title": "Common Motor Power Issues",
      "subtitle": "Troubleshooting guide:",
      "items": [
        "Uneven motor speeds: Calibrate power levels and check for mechanical binding",
        "Jerky movement: Implement power ramping and smoothing",
        "Motors not responding: Verify configuration and check wiring",
        "Excessive power draw: Check for mechanical resistance and reduce power limits",
        "Battery drain: Monitor voltage and implement power management"
      ]
    },
    {
      "type": "link-grid",
      "title": "Related Topics",
      "links": [
        {
          "label": "Basic Robot Control",
          "id": "basic-robot-control"
        },
        {
          "label": "Teleop Programming",
          "id": "teleop-programming"
        },
        {
          "label": "Gamepad Controls",
          "id": "gamepad-controls"
        },
        {
          "label": "Servo Control",
          "id": "servo-control"
        }
      ]
    },
    {
      "type": "exercise-box",
      "title": "Motor Power Control Practice",
      "description": "Practice these exercises to master motor power control:",
      "tasks": [
        "Create a basic motor power control OpMode",
        "Implement power ramping for smooth movement",
        "Add speed modes (normal, slow, precision)",
        "Create safety features and emergency stop",
        "Practice troubleshooting motor power issues",
        "Test different power curves and scaling",
        "Implement battery monitoring and power management"
      ],
      "content": "// Practice Exercise: Complete Motor Power System\n// Create a comprehensive motor power control system\n// Include ramping, safety, and multiple speed modes\n// Test with different power levels and conditions\n\n@TeleOp(name=\"Motor Power Practice\", group=\"Practice\")\npublic class MotorPowerPractice extends LinearOpMode {\n    \n    private SafeMotorControl motorControl;\n    \n    @Override\n    public void runOpMode() {\n        DcMotor leftDrive = hardwareMap.get(DcMotor.class, \"left_drive\");\n        DcMotor rightDrive = hardwareMap.get(DcMotor.class, \"right_drive\");\n        \n        motorControl = new SafeMotorControl(leftDrive, rightDrive);\n        \n        waitForStart();\n        \n        while (opModeIsActive()) {\n            // Read inputs\n            double leftPower = -gamepad1.left_stick_y;\n            double rightPower = -gamepad1.right_stick_y;\n            \n            // Apply safe motor control\n            motorControl.tankDrive(leftPower, rightPower);\n            \n            // Emergency stop with back button\n            if (gamepad1.back) {\n                motorControl.emergencyStop();\n            }\n            \n            // Display status\n            telemetry.addData(\"Left Power\", \"%.2f\", leftPower);\n            telemetry.addData(\"Right Power\", \"%.2f\", rightPower);\n            telemetry.addData(\"Status\", \"Motor control active\");\n            telemetry.update();\n        }\n    }\n}"
    }
  ]
} 