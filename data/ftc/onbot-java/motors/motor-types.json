{
  "title": "Motor Types",
  "sections": [
    {
      "type": "text",
      "title": "Introduction to Motor Types",
      "content": "FTC teams have access to various motor types, each with unique characteristics that make them suitable for different applications. Understanding motor specifications and capabilities helps teams choose the right motor for their robot's needs."
    },
    {
      "type": "rules-box",
      "title": "Motor Selection Factors",
      "subtitle": "Consider these factors when choosing motors:",
      "items": [
        "Speed requirements (RPM) for your application",
        "Torque requirements for load handling",
        "Size and weight constraints",
        "Power consumption and efficiency",
        "Built-in encoder availability",
        "Cost and availability"
      ]
    },
    {
      "type": "text",
      "title": "AndyMark Neverest Motors",
      "content": "AndyMark Neverest motors are popular choices in FTC due to their reliability and variety of options. They come in different series with varying speed and torque characteristics."
    },
    {
      "type": "list",
      "title": "Neverest Motor Series",
      "items": [
        "<strong>Neverest 20:</strong> ~3000 RPM, low torque - Good for fast mechanisms",
        "<strong>Neverest 40:</strong> ~1600 RPM, medium torque - Balanced performance",
        "<strong>Neverest 60:</strong> ~1050 RPM, high torque - Good for heavy loads",
        "<strong>Neverest Orbital 20:</strong> ~2800 RPM, planetary gearbox design"
      ]
    },
    {
      "type": "code",
      "title": "Neverest Motor Specifications",
      "language": "java",
      "content": "// Neverest motor specifications and applications\n\n// Neverest 20 - Fast, low torque\n// Applications: Intakes, conveyors, fast mechanisms\n// RPM: ~3000\n// Torque: Low\n// Best for: Light loads, high speed requirements\n\n// Neverest 40 - Balanced performance\n// Applications: Drivetrains, medium-duty mechanisms\n// RPM: ~1600\n// Torque: Medium\n// Best for: General purpose, balanced speed/torque\n\n// Neverest 60 - High torque, low speed\n// Applications: Lifts, arms, heavy mechanisms\n// RPM: ~1050\n// Torque: High\n// Best for: Heavy loads, precise control\n\n// Example: Choosing motors for different applications\nDcMotor intakeMotor; // Neverest 20 for fast intake\nDcMotor driveMotor;  // Neverest 40 for drivetrain\nDcMotor liftMotor;   // Neverest 60 for lift mechanism"
    },
    {
      "type": "text",
      "title": "REV HD Hex Motors",
      "content": "REV HD Hex motors are high-precision motors with built-in encoders, making them excellent for applications requiring precise control and position feedback."
    },
    {
      "type": "list",
      "title": "REV HD Hex Characteristics",
      "items": [
        "<strong>Built-in Encoder:</strong> 1440 counts per revolution for precise control",
        "<strong>High Precision:</strong> Excellent for position and speed control",
        "<strong>Multiple Options:</strong> Various gear ratios available",
        "<strong>Reliability:</strong> Durable construction for competition use"
      ]
    },
    {
      "type": "code",
      "title": "REV HD Hex Motor Setup",
      "language": "java",
      "content": "// REV HD Hex Motor configuration\nDcMotor hdHexMotor = hardwareMap.get(DcMotor.class, \"hd_hex_motor\");\n\n// REV HD Hex specifications\nfinal int HD_HEX_COUNTS_PER_REV = 1440;\nfinal double HD_HEX_GEAR_RATIO = 1.0; // Adjust based on your motor\n\n// Configure for precise control\nhdHexMotor.setDirection(DcMotor.Direction.FORWARD);\nhdHexMotor.setZeroPowerBehavior(DcMotor.ZeroPowerBehavior.BRAKE);\nhdHexMotor.setMode(DcMotor.RunMode.RUN_USING_ENCODER);\n\n// Position control example\npublic void moveToPrecisePosition(int targetCounts) {\n    hdHexMotor.setTargetPosition(targetCounts);\nhdHexMotor.setMode(DcMotor.RunMode.RUN_TO_POSITION);\nhdHexMotor.setPower(0.5);\n\n    while (hdHexMotor.isBusy()) {\n        telemetry.addData(\"Current Position\", hdHexMotor.getCurrentPosition());\n        telemetry.addData(\"Target Position\", targetCounts);\n        telemetry.update();\n    }\n}"
    },
    {
      "type": "text",
      "title": "GoBilda Yellow Jacket Motors",
      "content": "GoBilda Yellow Jacket motors offer a wide range of options with different gear ratios and performance characteristics, allowing teams to find the perfect motor for their specific needs."
    },
    {
      "type": "list",
      "title": "Yellow Jacket Options",
      "items": [
        "<strong>Speed Options:</strong> Various RPM ratings from 30 to 6000+",
        "<strong>Gear Ratios:</strong> Multiple gear ratios for different applications",
        "<strong>Built-in Encoders:</strong> Some models include encoders",
        "<strong>Modular Design:</strong> Easy to integrate with GoBilda building system"
      ]
    },
    {
      "type": "code",
      "title": "Yellow Jacket Motor Applications",
      "language": "java",
      "content": "// Yellow Jacket motor selection guide\n\n// High-speed applications (intakes, conveyors)\n// Yellow Jacket 6000 RPM or similar\nDcMotor highSpeedMotor = hardwareMap.get(DcMotor.class, \"high_speed_motor\");\nhighSpeedMotor.setPower(0.3); // Lower power for high-speed motors\n\n// Medium-speed applications (drivetrains)\n// Yellow Jacket 1000-2000 RPM range\nDcMotor mediumSpeedMotor = hardwareMap.get(DcMotor.class, \"medium_speed_motor\");\nmediumSpeedMotor.setPower(0.5); // Standard power for drivetrain\n\n// Low-speed, high-torque applications (lifts, arms)\n// Yellow Jacket 100-500 RPM range\nDcMotor highTorqueMotor = hardwareMap.get(DcMotor.class, \"high_torque_motor\");\nhighTorqueMotor.setPower(0.7); // Higher power for heavy loads\n\n// Example: Different power levels for different motor types\npublic void setMotorPowerByType(DcMotor motor, String motorType, double basePower) {\n    switch (motorType) {\n        case \"high_speed\":\n            motor.setPower(basePower * 0.3); // Reduce power for high-speed motors\n            break;\n        case \"medium_speed\":\n            motor.setPower(basePower * 0.5); // Standard power\n            break;\n        case \"high_torque\":\n            motor.setPower(basePower * 0.7); // Higher power for heavy loads\n            break;\n    }\n}"
    },
    {
      "type": "text",
      "title": "REV Core Hex Motors",
      "content": "REV Core Hex motors are compact motors designed for space-constrained applications while still providing good performance and reliability."
    },
    {
      "type": "list",
      "title": "Core Hex Characteristics",
      "items": [
        "<strong>Compact Size:</strong> Smaller footprint than other motors",
        "<strong>Built-in Encoder:</strong> 288 counts per revolution",
        "<strong>Good Performance:</strong> Reliable operation in tight spaces",
        "<strong>Easy Integration:</strong> Works well with REV building system"
      ]
    },
    {
      "type": "code",
      "title": "Core Hex Motor Configuration",
      "language": "java",
      "content": "// REV Core Hex Motor setup\nDcMotor coreHexMotor = hardwareMap.get(DcMotor.class, \"core_hex_motor\");\n\n// Core Hex specifications\nfinal int CORE_HEX_COUNTS_PER_REV = 288;\n\n// Configure for compact applications\ncoreHexMotor.setDirection(DcMotor.Direction.FORWARD);\ncoreHexMotor.setZeroPowerBehavior(DcMotor.ZeroPowerBehavior.BRAKE);\ncoreHexMotor.setMode(DcMotor.RunMode.RUN_USING_ENCODER);\n\n// Compact mechanism control\npublic void controlCompactMechanism(double power) {\n    // Core Hex motors work well in tight spaces\n    coreHexMotor.setPower(power);\n    \n    // Monitor for overheating in compact spaces\n    if (getRuntime().seconds() > 30) {\n        // Reduce power after extended use\n        coreHexMotor.setPower(power * 0.8);\n    }\n}"
    },
    {
      "type": "text",
      "title": "Motor Selection Guide",
      "content": "Choosing the right motor for your application requires understanding the requirements and motor characteristics."
    },
    {
      "type": "rules-box",
      "title": "Motor Selection Guidelines",
      "subtitle": "Choose motors based on application:",
      "items": [
        "Drivetrains: Neverest 40, REV HD Hex, or Yellow Jacket 1000-2000 RPM",
        "Lifts and Arms: Neverest 60, REV HD Hex, or Yellow Jacket 100-500 RPM",
        "Intakes and Conveyors: Neverest 20, Yellow Jacket 3000+ RPM",
        "Precise Mechanisms: REV HD Hex with encoders",
        "Space-Constrained: REV Core Hex for compact applications"
      ]
    },
    {
      "type": "code",
      "title": "Motor Selection Helper",
      "language": "java",
      "content": "// Motor selection helper method\npublic String recommendMotor(String application, double loadWeight, boolean needPrecision) {\n    if (needPrecision) {\n        return \"REV HD Hex Motor\";\n    }\n    \n    switch (application) {\n        case \"drivetrain\":\n            return \"Neverest 40 or REV HD Hex\";\n        case \"lift\":\n            if (loadWeight > 10) {\n                return \"Neverest 60\";\n            } else {\n                return \"Neverest 40 or REV HD Hex\";\n            }\n        case \"intake\":\n            return \"Neverest 20 or Yellow Jacket 3000+ RPM\";\n        case \"conveyor\":\n            return \"Neverest 20 or Yellow Jacket 3000+ RPM\";\n        case \"compact\":\n            return \"REV Core Hex\";\n        default:\n            return \"Neverest 40 (general purpose)\";\n    }\n}\n\n// Example usage\nString drivetrainMotor = recommendMotor(\"drivetrain\", 5.0, true);\nString liftMotor = recommendMotor(\"lift\", 15.0, false);\nString intakeMotor = recommendMotor(\"intake\", 2.0, false);"
    },
    {
      "type": "text",
      "title": "Motor Testing and Validation",
      "content": "Testing motors helps verify they meet your application requirements and operate reliably."
    },
    {
      "type": "list",
      "title": "Testing Procedures",
      "items": [
        "<strong>Speed Testing:</strong> Measure actual RPM under load",
        "<strong>Torque Testing:</strong> Test lifting capacity and stall torque",
        "<strong>Encoder Testing:</strong> Verify encoder accuracy and resolution",
        "<strong>Temperature Testing:</strong> Monitor motor temperature during extended use",
        "<strong>Noise Testing:</strong> Check for unusual sounds indicating problems"
      ]
    },
    {
      "type": "code",
      "title": "Motor Testing OpMode",
      "language": "java",
      "content": "// Motor testing and validation\n@TeleOp(name=\"Motor Test\", group=\"Testing\")\npublic class MotorTestOpMode extends LinearOpMode {\n    \n    private DcMotor testMotor;\n    private double startTime;\n    private int startPosition;\n    \n    @Override\n    public void runOpMode() {\n        testMotor = hardwareMap.get(DcMotor.class, \"test_motor\");\n        testMotor.setDirection(DcMotor.Direction.FORWARD);\n        testMotor.setZeroPowerBehavior(DcMotor.ZeroPowerBehavior.BRAKE);\n        \n        waitForStart();\n        \n        while (opModeIsActive()) {\n            // Speed test\n            if (gamepad1.a) {\n                startSpeedTest();\n            }\n            \n            // Torque test\n            if (gamepad1.b) {\n                startTorqueTest();\n            }\n            \n            // Encoder test\n            if (gamepad1.x) {\n                startEncoderTest();\n            }\n            \n            // Display current status\n            telemetry.addData(\"Motor Power\", testMotor.getPower());\n            telemetry.addData(\"Encoder Position\", testMotor.getCurrentPosition());\n            telemetry.addData(\"Battery Voltage\", \"%.1f volts\", getBatteryVoltage());\n            telemetry.update();\n        }\n    }\n    \n    private void startSpeedTest() {\n        startTime = getRuntime().seconds();\n        startPosition = testMotor.getCurrentPosition();\n        testMotor.setPower(0.5);\n        \n        // Run for 5 seconds and calculate RPM\n        sleep(5000);\n        \n        double endTime = getRuntime().seconds();\n        int endPosition = testMotor.getCurrentPosition();\n        \n        double timeElapsed = endTime - startTime;\n        int positionChange = endPosition - startPosition;\n        double rpm = (positionChange / 1440.0) * (60.0 / timeElapsed);\n        \n        telemetry.addData(\"Test Result\", \"RPM: %.1f\", rpm);\n        testMotor.setPower(0);\n    }\n}"
    },
    {
      "type": "link-grid",
      "title": "Related Topics",
      "links": [
        {
          "label": "DC Motors",
          "id": "dc-motors"
        },
        {
          "label": "Basic Motor Control",
          "id": "basic-motor-control"
        },
        {
          "label": "Motor Encoders",
          "id": "motor-encoders"
        }
      ]
    },
    {
      "type": "exercise-box",
      "title": "Motor Types Practice",
      "description": "Practice these exercises to understand motor selection:",
      "tasks": [
        "Identify motor types on your robot and their specifications",
        "Test different motor types with the same load",
        "Compare speed and torque characteristics",
        "Practice motor selection for different applications",
        "Test encoder accuracy on different motor types",
        "Create a motor testing and validation procedure",
        "Document motor performance characteristics"
      ],
      "content": "// Practice Exercise: Motor Comparison\n// Create an OpMode that tests different motor types\n// Compare speed, torque, and encoder performance\n// Document the results for future reference\n\n@TeleOp(name=\"Motor Comparison\", group=\"Testing\")\npublic class MotorComparisonOpMode extends LinearOpMode {\n    \n    private DcMotor motor1, motor2;\n    \n    @Override\n    public void runOpMode() {\n        // Initialize two different motor types\n        motor1 = hardwareMap.get(DcMotor.class, \"motor_type_1\");\n        motor2 = hardwareMap.get(DcMotor.class, \"motor_type_2\");\n        \n        // Configure both motors the same way\n        motor1.setDirection(DcMotor.Direction.FORWARD);\n        motor2.setDirection(DcMotor.Direction.FORWARD);\n        motor1.setZeroPowerBehavior(DcMotor.ZeroPowerBehavior.BRAKE);\n        motor2.setZeroPowerBehavior(DcMotor.ZeroPowerBehavior.BRAKE);\n        \n        waitForStart();\n        \n        while (opModeIsActive()) {\n            // Test both motors with same power\n            double power = -gamepad1.left_stick_y;\n            motor1.setPower(power);\n            motor2.setPower(power);\n            \n            // Compare performance\n            telemetry.addData(\"Motor 1 Position\", motor1.getCurrentPosition());\n            telemetry.addData(\"Motor 2 Position\", motor2.getCurrentPosition());\n            telemetry.addData(\"Power Applied\", power);\n            telemetry.update();\n        }\n    }\n}"
    }
  ]
} 
