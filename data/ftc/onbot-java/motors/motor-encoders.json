{
  "title": "Motor Encoders",
  "sections": [
    {
      "type": "text",
      "title": "Introduction to Motor Encoders",
      "content": "Motor encoders are sensors that measure the rotation of motors, providing precise feedback for position control, speed regulation, and autonomous movement. Understanding encoders is essential for advanced FTC robot programming."
    },
    {
      "type": "rules-box",
      "title": "What are Encoders?",
      "subtitle": "Key encoder concepts:",
      "items": [
        "Measure motor shaft rotation in counts or ticks",
        "Provide precise position and speed feedback",
        "Enable closed-loop control for accurate movement",
        "Can detect stalls, slippage, and mechanical issues",
        "Essential for autonomous navigation and precise mechanisms"
      ]
    },
    {
      "type": "text",
      "title": "Encoder Basics",
      "content": "Encoders work by counting the number of rotations or partial rotations of the motor shaft. This count can be converted to distance, position, or speed measurements."
    },
    {
      "type": "list",
      "title": "Encoder Types in FTC",
      "items": [
        "<strong>Built-in Encoders:</strong> Integrated into REV HD Hex and Core Hex motors",
        "<strong>External Encoders:</strong> Separate encoders attached to other motors",
        "<strong>Quadrature Encoders:</strong> Most common type, provides direction and position",
        "<strong>Resolution:</strong> Typically 1440 counts per revolution for REV motors"
      ]
    },
    {
      "type": "code",
      "title": "Encoder Resolution and Conversion",
      "language": "java",
      "content": "// REV HD Hex Motor encoder specifications\nfinal int COUNTS_PER_MOTOR_REV = 1440; // Encoder counts per motor revolution\nfinal double DRIVE_GEAR_REDUCTION = 1.0; // Gear ratio (1:1 for direct drive)\nfinal double WHEEL_DIAMETER_INCHES = 4.0; // Wheel diameter\nfinal double COUNTS_PER_INCH = (COUNTS_PER_MOTOR_REV * DRIVE_GEAR_REDUCTION) / \n                                 (WHEEL_DIAMETER_INCHES * Math.PI);\n\n// Convert distance to encoder counts\nint targetCounts = (int) (distanceInches * COUNTS_PER_INCH);\n\n// Convert encoder counts to distance\ndouble distanceInches = motor.getCurrentPosition() / COUNTS_PER_INCH;"
    },
    {
      "type": "text",
      "title": "Encoder Initialization",
      "content": "Proper encoder initialization is crucial for reliable operation. This includes resetting encoders and setting appropriate run modes."
    },
    {
      "type": "code",
      "title": "Encoder Setup and Initialization",
      "language": "java",
      "content": "// Initialize motors with encoders\nDcMotor leftDrive = hardwareMap.get(DcMotor.class, \"left_drive\");\nDcMotor rightDrive = hardwareMap.get(DcMotor.class, \"right_drive\");\n\n// Set motor directions\nleftDrive.setDirection(DcMotor.Direction.FORWARD);\nrightDrive.setDirection(DcMotor.Direction.REVERSE);\n\n// Reset encoders to zero\nleftDrive.setMode(DcMotor.RunMode.STOP_AND_RESET_ENCODER);\nrightDrive.setMode(DcMotor.RunMode.STOP_AND_RESET_ENCODER);\n\n// Set to encoder mode for position control\nleftDrive.setMode(DcMotor.RunMode.RUN_USING_ENCODER);\nrightDrive.setMode(DcMotor.RunMode.RUN_USING_ENCODER);\n\n// Or set to position control mode\nleftDrive.setMode(DcMotor.RunMode.RUN_TO_POSITION);\nrightDrive.setMode(DcMotor.RunMode.RUN_TO_POSITION);"
    },
    {
      "type": "text",
      "title": "Position Control",
      "content": "Position control allows motors to move to specific encoder positions, enabling precise mechanism control and autonomous movement."
    },
    {
      "type": "code",
      "title": "Position Control Examples",
      "language": "java",
      "content": "// Move motor to specific position\npublic void moveToPosition(DcMotor motor, int targetPosition, double power) {\n    motor.setTargetPosition(targetPosition);\n    motor.setMode(DcMotor.RunMode.RUN_TO_POSITION);\n    motor.setPower(power);\n    \n    // Wait for motor to reach position\n    while (motor.isBusy()) {\n        telemetry.addData(\"Current Position\", motor.getCurrentPosition());\n        telemetry.addData(\"Target Position\", targetPosition);\n        telemetry.update();\n    }\n    \n    // Stop motor\n    motor.setPower(0);\n}\n\n// Move arm to specific angle\npublic void moveArmToAngle(double angleDegrees) {\n    // Convert angle to encoder counts\n    int targetCounts = (int) (angleDegrees * COUNTS_PER_DEGREE);\n    moveToPosition(armMotor, targetCounts, 0.5);\n}\n\n// Drive specific distance\npublic void driveDistance(double distanceInches, double power) {\n    int targetCounts = (int) (distanceInches * COUNTS_PER_INCH);\n    \n    leftDrive.setTargetPosition(targetCounts);\n    rightDrive.setTargetPosition(targetCounts);\n    \n    leftDrive.setMode(DcMotor.RunMode.RUN_TO_POSITION);\n    rightDrive.setMode(DcMotor.RunMode.RUN_TO_POSITION);\n    \n    leftDrive.setPower(power);\n    rightDrive.setPower(power);\n    \n    while (leftDrive.isBusy() && rightDrive.isBusy()) {\n        // Wait for completion\n    }\n}"
    },
    {
      "type": "text",
      "title": "Speed Control",
      "content": "Encoders enable precise speed control by providing feedback for closed-loop control systems."
    },
    {
      "type": "code",
      "title": "Speed Control Implementation",
      "language": "java",
      "content": "// Speed control using encoders\npublic void setMotorSpeed(DcMotor motor, double targetSpeed) {\n    motor.setMode(DcMotor.RunMode.RUN_USING_ENCODER);\n    \n    // Simple proportional control\n    double currentSpeed = getMotorSpeed(motor);\n    double error = targetSpeed - currentSpeed;\n    double power = motor.getPower() + (error * 0.1); // P gain\n    \n    power = Math.max(-1.0, Math.min(1.0, power));\n    motor.setPower(power);\n}\n\n// Calculate motor speed (counts per second)\nprivate double getMotorSpeed(DcMotor motor) {\n    int currentPosition = motor.getCurrentPosition();\n    double currentTime = getRuntime().seconds();\n    \n    // Calculate speed over time\n    double speed = (currentPosition - lastPosition) / (currentTime - lastTime);\n    \n    lastPosition = currentPosition;\n    lastTime = currentTime;\n    \n    return speed;\n}\n\n// Maintain constant speed\npublic void maintainSpeed(double targetSpeed) {\n    while (opModeIsActive()) {\n        setMotorSpeed(leftDrive, targetSpeed);\n        setMotorSpeed(rightDrive, targetSpeed);\n        \n        telemetry.addData(\"Target Speed\", targetSpeed);\n        telemetry.addData(\"Left Speed\", getMotorSpeed(leftDrive));\n        telemetry.addData(\"Right Speed\", getMotorSpeed(rightDrive));\n        telemetry.update();\n    }\n}"
    },
    {
      "type": "text",
      "title": "PID Control",
      "content": "PID (Proportional-Integral-Derivative) control uses encoder feedback to achieve precise position and speed control."
    },
    {
      "type": "list",
      "title": "PID Components",
      "items": [
        "<strong>Proportional (P):</strong> Response proportional to current error",
        "<strong>Integral (I):</strong> Response to accumulated error over time",
        "<strong>Derivative (D):</strong> Response to rate of change of error"
      ]
    },
    {
      "type": "code",
      "title": "PID Control Implementation",
      "language": "java",
      "content": "// PID Controller class\npublic class PIDController {\n    private double kP, kI, kD;\n    private double setpoint;\n    private double integral = 0;\n    private double lastError = 0;\n    private double lastTime = 0;\n    \n    public PIDController(double kP, double kI, double kD) {\n        this.kP = kP;\n        this.kI = kI;\n        this.kD = kD;\n    }\n    \n    public void setSetpoint(double setpoint) {\n        this.setpoint = setpoint;\n        this.integral = 0;\n    }\n    \n    public double calculate(double currentValue) {\n        double currentTime = getRuntime().seconds();\n        double dt = currentTime - lastTime;\n        \n        double error = setpoint - currentValue;\n        integral += error * dt;\n        double derivative = (error - lastError) / dt;\n        \n        double output = kP * error + kI * integral + kD * derivative;\n        \n        lastError = error;\n        lastTime = currentTime;\n        \n        return output;\n    }\n}\n\n// Using PID for position control\nPIDController pidController = new PIDController(0.01, 0.0, 0.001);\n\npublic void driveToPositionPID(int targetPosition) {\n    pidController.setSetpoint(targetPosition);\n    \n    while (opModeIsActive()) {\n        int currentPosition = leftDrive.getCurrentPosition();\n        double power = pidController.calculate(currentPosition);\n        \n        power = Math.max(-1.0, Math.min(1.0, power));\n        leftDrive.setPower(power);\n        \n        telemetry.addData(\"Target\", targetPosition);\n        telemetry.addData(\"Current\", currentPosition);\n        telemetry.addData(\"Power\", power);\n        telemetry.update();\n        \n        if (Math.abs(targetPosition - currentPosition) < 10) {\n            break; // Close enough to target\n        }\n    }\n}"
    },
    {
      "type": "text",
      "title": "Encoder Troubleshooting",
      "content": "Common encoder issues and their solutions help teams maintain reliable robot operation."
    },
    {
      "type": "rules-box",
      "title": "Common Encoder Issues",
      "subtitle": "Troubleshooting guide:",
      "items": [
        "Encoder counts not changing: Check wiring and configuration",
        "Incorrect position readings: Verify encoder resolution settings",
        "Motor not reaching target: Check power limits and mechanical binding",
        "Inconsistent behavior: Reset encoders before each use",
        "Wrong direction: Adjust encoder direction or motor direction"
      ]
    },
    {
      "type": "code",
      "title": "Encoder Diagnostics",
      "language": "java",
      "content": "// Encoder diagnostic method\npublic void diagnoseEncoder(DcMotor motor, String motorName) {\n    telemetry.addData(motorName + \" Encoder Position\", motor.getCurrentPosition());\n    telemetry.addData(motorName + \" Target Position\", motor.getTargetPosition());\n    telemetry.addData(motorName + \" Is Busy\", motor.isBusy());\n    telemetry.addData(motorName + \" Power\", motor.getPower());\n    telemetry.addData(motorName + \" Mode\", motor.getMode());\n    telemetry.addData(motorName + \" Direction\", motor.getDirection());\n    \n    // Test encoder functionality\n    if (gamepad1.a) {\n        motor.setMode(DcMotor.RunMode.STOP_AND_RESET_ENCODER);\n        telemetry.addData(\"Action\", \"Reset encoder\");\n    }\n    \n    if (gamepad1.b) {\n        motor.setTargetPosition(1000);\n        motor.setMode(DcMotor.RunMode.RUN_TO_POSITION);\n        motor.setPower(0.5);\n        telemetry.addData(\"Action\", \"Move to position 1000\");\n    }\n}\n\n// Use in main loop\nwhile (opModeIsActive()) {\n    diagnoseEncoder(leftDrive, \"Left Drive\");\n    diagnoseEncoder(rightDrive, \"Right Drive\");\n    telemetry.update();\n}"
    },
    {
      "type": "text",
      "title": "Best Practices",
      "content": "Following best practices ensures reliable encoder operation and accurate robot control."
    },
    {
      "type": "list",
      "title": "Encoder Best Practices",
      "items": [
        "<strong>Always reset encoders:</strong> Before starting position control operations",
        "<strong>Use appropriate run modes:</strong> Choose the right mode for your application",
        "<strong>Monitor encoder values:</strong> Use telemetry to verify encoder operation",
        "<strong>Handle encoder limits:</strong> Prevent motors from trying to move beyond limits",
        "<strong>Test thoroughly:</strong> Verify encoder behavior in various conditions"
      ]
    },
    {
      "type": "link-grid",
      "title": "Related Topics",
      "links": [
        {
          "label": "DC Motors",
          "id": "dc-motors"
        },
        {
          "label": "Basic Motor Control",
          "id": "basic-motor-control"
        },
        {
          "label": "Motor Types",
          "id": "motor-types"
        }
      ]
    },
    {
      "type": "exercise-box",
      "title": "Encoder Practice",
      "description": "Practice these exercises to master encoder control:",
      "tasks": [
        "Create an OpMode that moves a motor to specific positions",
        "Implement PID control for precise positioning",
        "Create a drivetrain that drives specific distances",
        "Test encoder diagnostics and troubleshooting",
        "Practice speed control using encoders",
        "Create autonomous movement sequences",
        "Test encoder behavior with different run modes"
      ],
      "content": "// Practice Exercise: Position Control\n// Create an OpMode that demonstrates encoder position control\n// Include diagnostics and safety features\n// Test different positioning scenarios\n\n@TeleOp(name=\"Encoder Test\", group=\"Testing\")\npublic class EncoderTestOpMode extends LinearOpMode {\n    \n    private DcMotor testMotor;\n    private PIDController pidController;\n    \n    @Override\n    public void runOpMode() {\n        // Initialize motor and PID controller\n        testMotor = hardwareMap.get(DcMotor.class, \"test_motor\");\n        testMotor.setDirection(DcMotor.Direction.FORWARD);\n        testMotor.setZeroPowerBehavior(DcMotor.ZeroPowerBehavior.BRAKE);\n        \n        pidController = new PIDController(0.01, 0.0, 0.001);\n        \n        waitForStart();\n        \n        while (opModeIsActive()) {\n            // Reset encoder\n            if (gamepad1.a) {\n                testMotor.setMode(DcMotor.RunMode.STOP_AND_RESET_ENCODER);\n            }\n            \n            // Move to position 1000\n            if (gamepad1.b) {\n                driveToPosition(1000);\n            }\n            \n            // Move to position -1000\n            if (gamepad1.x) {\n                driveToPosition(-1000);\n            }\n            \n            // Display encoder information\n            telemetry.addData(\"Position\", testMotor.getCurrentPosition());\n            telemetry.addData(\"Target\", testMotor.getTargetPosition());\n            telemetry.addData(\"Is Busy\", testMotor.isBusy());\n            telemetry.update();\n        }\n    }\n    \n    private void driveToPosition(int targetPosition) {\n        testMotor.setTargetPosition(targetPosition);\n        testMotor.setMode(DcMotor.RunMode.RUN_TO_POSITION);\n        testMotor.setPower(0.5);\n    }\n}"
    }
  ]
} 
