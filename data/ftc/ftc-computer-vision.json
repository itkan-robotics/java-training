{
  "title": "Computer Vision",
  "sections": [
    {
      "title": "Introduction to Computer Vision",
      "content": "Computer vision allows your robot to 'see' and understand its environment using cameras. This is a game-changer for autonomous programming, enabling precise navigation, object detection, and game element recognition."
    },
    {
      "title": "Camera Setup and Configuration",
      "content": "Setting up cameras for FTC:\n\n```java\npublic class CameraSetup {\n    private WebcamName webcam;\n    private OpenCvCamera camera;\n    private VisionProcessor visionProcessor;\n    \n    public void initializeCamera() {\n        // Get camera from hardware map\n        webcam = hardwareMap.get(WebcamName.class, \"Webcam 1\");\n        \n        // Create camera instance\n        camera = OpenCvCameraFactory.getInstance().createWebcam(webcam);\n        \n        // Set up vision processor\n        visionProcessor = new MyVisionProcessor();\n        camera.setPipeline(visionProcessor);\n        \n        // Start camera\n        camera.openCameraDeviceAsync(new OpenCvCamera.AsyncCameraOpenListener() {\n            @Override\n            public void onOpened() {\n                // Camera is ready\n                camera.startStreaming(640, 480, OpenCvCameraRotation.UPRIGHT);\n            }\n            \n            @Override\n            public void onError(int errorCode) {\n                // Handle camera error\n                telemetry.addData(\"Camera Error\", errorCode);\n            }\n        });\n    }\n}\n```"
    },
    {
      "title": "Basic Image Processing",
      "content": "Fundamental image processing techniques:\n\n```java\npublic class BasicImageProcessor extends OpenCvPipeline {\n    private Mat output = new Mat();\n    \n    @Override\n    public Mat processFrame(Mat input) {\n        // Convert to different color spaces\n        Mat hsv = new Mat();\n        Imgproc.cvtColor(input, hsv, Imgproc.COLOR_RGB2HSV);\n        \n        // Create mask for specific color\n        Mat mask = new Mat();\n        Scalar lowerBound = new Scalar(0, 100, 100); // Red lower bound\n        Scalar upperBound = new Scalar(10, 255, 255); // Red upper bound\n        Core.inRange(hsv, lowerBound, upperBound, mask);\n        \n        // Apply mask to original image\n        Core.bitwise_and(input, input, output, mask);\n        \n        return output;\n    }\n}\n```"
    },
    {
      "title": "Object Detection and Recognition",
      "content": "Detecting and recognizing objects in images:\n\n```java\npublic class ObjectDetector extends OpenCvPipeline {\n    private Mat output = new Mat();\n    private List<Rect> detectedObjects = new ArrayList<>();\n    \n    @Override\n    public Mat processFrame(Mat input) {\n        // Convert to grayscale\n        Mat gray = new Mat();\n        Imgproc.cvtColor(input, gray, Imgproc.COLOR_RGB2GRAY);\n        \n        // Apply Gaussian blur\n        Mat blurred = new Mat();\n        Imgproc.GaussianBlur(gray, blurred, new Size(5, 5), 0);\n        \n        // Edge detection\n        Mat edges = new Mat();\n        Imgproc.Canny(blurred, edges, 50, 150);\n        \n        // Find contours\n        List<MatOfPoint> contours = new ArrayList<>();\n        Mat hierarchy = new Mat();\n        Imgproc.findContours(edges, contours, hierarchy, Imgproc.RETR_EXTERNAL, Imgproc.CHAIN_APPROX_SIMPLE);\n        \n        // Filter contours by area\n        detectedObjects.clear();\n        for (MatOfPoint contour : contours) {\n            double area = Imgproc.contourArea(contour);\n            if (area > 1000) { // Minimum area threshold\n                Rect boundingRect = Imgproc.boundingRect(contour);\n                detectedObjects.add(boundingRect);\n            }\n        }\n        \n        // Draw bounding boxes\n        input.copyTo(output);\n        for (Rect rect : detectedObjects) {\n            Imgproc.rectangle(output, rect, new Scalar(0, 255, 0), 2);\n        }\n        \n        return output;\n    }\n    \n    public List<Rect> getDetectedObjects() {\n        return detectedObjects;\n    }\n}\n```"
    },
    {
      "title": "Color and Shape Detection",
      "content": "Detecting specific colors and shapes:\n\n```java\npublic class ColorShapeDetector extends OpenCvPipeline {\n    private Mat output = new Mat();\n    private List<DetectedObject> detectedObjects = new ArrayList<>();\n    \n    public static class DetectedObject {\n        public String color;\n        public String shape;\n        public Point center;\n        public double area;\n        \n        public DetectedObject(String color, String shape, Point center, double area) {\n            this.color = color;\n            this.shape = shape;\n            this.center = center;\n            this.area = area;\n        }\n    }\n    \n    @Override\n    public Mat processFrame(Mat input) {\n        detectedObjects.clear();\n        input.copyTo(output);\n        \n        // Define color ranges\n        Scalar[] colorRanges = {\n            new Scalar(0, 100, 100), new Scalar(10, 255, 255), // Red\n            new Scalar(35, 100, 100), new Scalar(85, 255, 255), // Green\n            new Scalar(100, 100, 100), new Scalar(130, 255, 255) // Blue\n        };\n        \n        String[] colorNames = {\"Red\", \"Green\", \"Blue\"};\n        \n        // Process each color\n        for (int i = 0; i < colorRanges.length; i += 2) {\n            Mat hsv = new Mat();\n            Imgproc.cvtColor(input, hsv, Imgproc.COLOR_RGB2HSV);\n            \n            Mat mask = new Mat();\n            Core.inRange(hsv, colorRanges[i], colorRanges[i + 1], mask);\n            \n            // Find contours for this color\n            List<MatOfPoint> contours = new ArrayList<>();\n            Imgproc.findContours(mask, contours, new Mat(), Imgproc.RETR_EXTERNAL, Imgproc.CHAIN_APPROX_SIMPLE);\n            \n            for (MatOfPoint contour : contours) {\n                double area = Imgproc.contourArea(contour);\n                if (area > 500) { // Minimum area\n                    // Analyze shape\n                    String shape = analyzeShape(contour);\n                    \n                    // Find center\n                    Moments moments = Imgproc.moments(contour);\n                    Point center = new Point(moments.m10 / moments.m00, moments.m01 / moments.m00);\n                    \n                    // Create detected object\n                    DetectedObject obj = new DetectedObject(colorNames[i/2], shape, center, area);\n                    detectedObjects.add(obj);\n                    \n                    // Draw on output\n                    Imgproc.circle(output, center, 5, new Scalar(255, 255, 255), -1);\n                    Imgproc.putText(output, colorNames[i/2] + \" \" + shape, \n                                   new Point(center.x + 10, center.y), \n                                   Imgproc.FONT_HERSHEY_SIMPLEX, 0.5, new Scalar(255, 255, 255), 1);\n                }\n            }\n        }\n        \n        return output;\n    }\n    \n    private String analyzeShape(MatOfPoint contour) {\n        // Approximate contour to polygon\n        MatOfPoint2f contour2f = new MatOfPoint2f(contour.toArray());\n        double epsilon = 0.02 * Imgproc.arcLength(contour2f, true);\n        MatOfPoint2f approx = new MatOfPoint2f();\n        Imgproc.approxPolyDP(contour2f, approx, epsilon, true);\n        \n        int vertices = approx.total();\n        \n        if (vertices == 3) return \"Triangle\";\n        else if (vertices == 4) return \"Rectangle\";\n        else if (vertices == 5) return \"Pentagon\";\n        else if (vertices > 8) return \"Circle\";\n        else return \"Unknown\";\n    }\n    \n    public List<DetectedObject> getDetectedObjects() {\n        return detectedObjects;\n    }\n}\n```"
    },
    {
      "title": "AprilTag Detection",
      "content": "AprilTags are fiducial markers used for precise positioning:\n\n```java\npublic class AprilTagDetector extends OpenCvPipeline {\n    private AprilTagDetectionPipeline aprilTagDetectionPipeline;\n    private List<AprilTagDetection> detections = new ArrayList<>();\n    \n    public void initializeAprilTag() {\n        // Create AprilTag detection pipeline\n        aprilTagDetectionPipeline = new AprilTagDetectionPipeline(\n            0.166, // Tag size in meters\n            578.272, // Camera focal length\n            578.272, // Camera focal length\n            402.145, // Camera center x\n            221.506  // Camera center y\n        );\n        \n        // Set camera pipeline\n        camera.setPipeline(aprilTagDetectionPipeline);\n    }\n    \n    @Override\n    public Mat processFrame(Mat input) {\n        // Get AprilTag detections\n        detections = aprilTagDetectionPipeline.getLatestDetections();\n        \n        // Draw detections on image\n        for (AprilTagDetection detection : detections) {\n            // Draw bounding box\n            Point[] corners = detection.corners;\n            for (int i = 0; i < 4; i++) {\n                Imgproc.line(input, corners[i], corners[(i + 1) % 4], new Scalar(0, 255, 0), 2);\n            }\n            \n            // Draw tag ID\n            Point center = detection.center;\n            Imgproc.putText(input, \"Tag \" + detection.id, \n                           new Point(center.x - 20, center.y - 20), \n                           Imgproc.FONT_HERSHEY_SIMPLEX, 0.5, new Scalar(0, 255, 0), 1);\n        }\n        \n        return input;\n    }\n    \n    public List<AprilTagDetection> getDetections() {\n        return detections;\n    }\n    \n    public AprilTagDetection getTagById(int id) {\n        for (AprilTagDetection detection : detections) {\n            if (detection.id == id) {\n                return detection;\n            }\n        }\n        return null;\n    }\n}\n```"
    },
    {
      "title": "Practice Exercise",
      "content": "Create a computer vision system that:\n\n1. **Detects game elements** by color and shape\n2. **Tracks AprilTags** for positioning\n3. **Provides real-time feedback** through telemetry\n4. **Integrates with autonomous** for navigation\n\n**Requirements**:\n- Set up camera and vision pipeline\n- Implement color and shape detection\n- Add AprilTag detection and tracking\n- Create methods to get detected object information\n- Integrate with autonomous navigation\n\n**Advanced Challenge**:\n- Implement multiple camera support\n- Add object tracking over time\n- Create custom vision algorithms\n- Optimize for performance and reliability"
    },
    {
      "title": "Common Issues and Solutions",
      "content": "**Problem**: Camera not detected\n- **Solution**: Check USB connection, verify camera name in hardware config\n\n**Problem**: Poor image quality\n- **Solution**: Adjust camera focus, check lighting conditions\n\n**Problem**: False detections\n- **Solution**: Refine color ranges, add shape validation\n\n**Problem**: Slow performance\n- **Solution**: Reduce image resolution, optimize processing pipeline\n\n**Problem**: AprilTags not detected\n- **Solution**: Check camera calibration, verify tag size and distance"
    },
    {
      "title": "Next Steps",
      "content": "You now have computer vision capabilities! In the next lessons, you'll learn about:\n\n- Vision-based autonomous navigation\n- Advanced control systems and PID tuning\n- Performance optimization and debugging\n\nPractice implementing computer vision and experiment with different detection algorithms to build your understanding."
    }
  ]
} 