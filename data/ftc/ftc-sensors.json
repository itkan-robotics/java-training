{
  "title": "Sensor Integration",
  "sections": [
    {
      "title": "Introduction to Sensors",
      "content": "Sensors are the eyes and ears of your robot. They provide feedback about the robot's environment and position, enabling autonomous behavior and more sophisticated control. In this lesson, you'll learn how to integrate various sensors into your FTC robot."
    },
    {
      "title": "Touch Sensors and Limit Switches",
      "content": "Touch sensors detect when something is pressed or touched, making them perfect for detecting when mechanisms reach their limits.\n\n```java\n@TeleOp(name=\"Touch Sensor Test\")\npublic class TouchSensorTest extends OpMode {\n    private DigitalChannel touchSensor;\n    private DcMotor armMotor;\n    \n    @Override\n    public void init() {\n        touchSensor = hardwareMap.get(DigitalChannel.class, \"touch_sensor\");\n        armMotor = hardwareMap.get(DcMotor.class, \"arm_motor\");\n        \n        // Set touch sensor to input mode\n        touchSensor.setMode(DigitalChannel.Mode.INPUT);\n    }\n    \n    @Override\n    public void loop() {\n        // Read touch sensor state\n        boolean isPressed = touchSensor.getState();\n        \n        // Control arm based on touch sensor\n        if (gamepad1.y && !isPressed) {\n            // Move arm up only if not at limit\n            armMotor.setPower(0.5);\n        } else if (gamepad1.a) {\n            // Move arm down\n            armMotor.setPower(-0.5);\n        } else {\n            armMotor.setPower(0);\n        }\n        \n        telemetry.addData(\"Touch Sensor\", isPressed ? \"Pressed\" : \"Not Pressed\");\n        telemetry.update();\n    }\n}\n```"
    },
    {
      "title": "Color Sensors and Light Sensors",
      "content": "Color sensors detect colors and light intensity, useful for following lines or detecting game elements.\n\n```java\n@TeleOp(name=\"Color Sensor Test\")\npublic class ColorSensorTest extends OpMode {\n    private ColorSensor colorSensor;\n    private DcMotor leftMotor;\n    private DcMotor rightMotor;\n    \n    @Override\n    public void init() {\n        colorSensor = hardwareMap.get(ColorSensor.class, \"color_sensor\");\n        leftMotor = hardwareMap.get(DcMotor.class, \"left_motor\");\n        rightMotor = hardwareMap.get(DcMotor.class, \"right_motor\");\n        \n        // Enable LED on color sensor\n        colorSensor.enableLed(true);\n    }\n    \n    @Override\n    public void loop() {\n        // Read color values\n        int red = colorSensor.red();\n        int green = colorSensor.green();\n        int blue = colorSensor.blue();\n        int alpha = colorSensor.alpha(); // Light intensity\n        \n        // Simple line following logic\n        if (alpha < 100) { // Dark line detected\n            // Turn left\n            leftMotor.setPower(-0.3);\n            rightMotor.setPower(0.3);\n        } else {\n            // Drive forward\n            leftMotor.setPower(0.3);\n            rightMotor.setPower(0.3);\n        }\n        \n        telemetry.addData(\"Red\", red);\n        telemetry.addData(\"Green\", green);\n        telemetry.addData(\"Blue\", blue);\n        telemetry.addData(\"Light Level\", alpha);\n        telemetry.update();\n    }\n}\n```"
    },
    {
      "title": "Distance Sensors",
      "content": "Distance sensors (like the REV 2M Distance Sensor) measure the distance to objects, useful for obstacle avoidance and precise positioning.\n\n```java\n@TeleOp(name=\"Distance Sensor Test\")\npublic class DistanceSensorTest extends OpMode {\n    private DistanceSensor distanceSensor;\n    private DcMotor leftMotor;\n    private DcMotor rightMotor;\n    \n    @Override\n    public void init() {\n        distanceSensor = hardwareMap.get(DistanceSensor.class, \"distance_sensor\");\n        leftMotor = hardwareMap.get(DcMotor.class, \"left_motor\");\n        rightMotor = hardwareMap.get(DcMotor.class, \"right_motor\");\n    }\n    \n    @Override\n    public void loop() {\n        // Read distance in centimeters\n        double distance = distanceSensor.getDistance(DistanceUnit.CM);\n        \n        // Obstacle avoidance logic\n        if (distance < 10) { // Less than 10cm\n            // Stop and back up\n            leftMotor.setPower(-0.3);\n            rightMotor.setPower(-0.3);\n        } else if (distance < 20) { // Less than 20cm\n            // Slow down\n            leftMotor.setPower(0.2);\n            rightMotor.setPower(0.2);\n        } else {\n            // Normal speed\n            leftMotor.setPower(0.5);\n            rightMotor.setPower(0.5);\n        }\n        \n        telemetry.addData(\"Distance (cm)\", distance);\n        telemetry.update();\n    }\n}\n```"
    },
    {
      "title": "Gyroscope and Orientation",
      "content": "Gyroscopes measure rotation and help maintain orientation. The REV Control Hub has a built-in IMU (Inertial Measurement Unit) that includes a gyroscope.\n\n```java\n@TeleOp(name=\"Gyro Test\")\npublic class GyroTest extends OpMode {\n    private BNO055IMU imu;\n    private DcMotor leftMotor;\n    private DcMotor rightMotor;\n    \n    @Override\n    public void init() {\n        // Initialize IMU\n        BNO055IMU.Parameters parameters = new BNO055IMU.Parameters();\n        parameters.angleUnit = BNO055IMU.AngleUnit.DEGREES;\n        parameters.accelUnit = BNO055IMU.AccelUnit.METERS_PERSEC_PERSEC;\n        parameters.calibrationDataFile = \"BNO055IMUCalibration.json\";\n        parameters.loggingEnabled = true;\n        parameters.loggingTag = \"IMU\";\n        \n        imu = hardwareMap.get(BNO055IMU.class, \"imu\");\n        imu.initialize(parameters);\n        \n        leftMotor = hardwareMap.get(DcMotor.class, \"left_motor\");\n        rightMotor = hardwareMap.get(DcMotor.class, \"right_motor\");\n    }\n    \n    @Override\n    public void loop() {\n        // Read gyro angles\n        Orientation angles = imu.getAngularOrientation(AxesReference.INTRINSIC, AxesOrder.ZYX, AngleUnit.DEGREES);\n        double heading = angles.firstAngle; // Z-axis rotation (heading)\n        \n        // Simple turn to heading logic\n        if (gamepad1.x) {\n            // Turn to 0 degrees\n            turnToHeading(0, 0.3);\n        } else if (gamepad1.y) {\n            // Turn to 90 degrees\n            turnToHeading(90, 0.3);\n        } else if (gamepad1.b) {\n            // Turn to 180 degrees\n            turnToHeading(180, 0.3);\n        } else if (gamepad1.a) {\n            // Turn to 270 degrees\n            turnToHeading(270, 0.3);\n        }\n        \n        telemetry.addData(\"Heading\", heading);\n        telemetry.update();\n    }\n    \n    public void turnToHeading(double targetHeading, double power) {\n        Orientation angles = imu.getAngularOrientation(AxesReference.INTRINSIC, AxesOrder.ZYX, AngleUnit.DEGREES);\n        double currentHeading = angles.firstAngle;\n        \n        double error = targetHeading - currentHeading;\n        \n        // Normalize error to -180 to 180 degrees\n        while (error > 180) error -= 360;\n        while (error < -180) error += 360;\n        \n        if (Math.abs(error) > 5) { // Within 5 degrees\n            if (error > 0) {\n                // Turn left\n                leftMotor.setPower(-power);\n                rightMotor.setPower(power);\n            } else {\n                // Turn right\n                leftMotor.setPower(power);\n                rightMotor.setPower(-power);\n            }\n        } else {\n            // Stop\n            leftMotor.setPower(0);\n            rightMotor.setPower(0);\n        }\n    }\n}\n```"
    },
    {
      "title": "Sensor Calibration and Filtering",
      "content": "Sensors often need calibration and filtering for reliable operation:\n\n```java\npublic class SensorFilter {\n    private double[] values;\n    private int index = 0;\n    private int size;\n    \n    public SensorFilter(int size) {\n        this.size = size;\n        this.values = new double[size];\n    }\n    \n    public double update(double newValue) {\n        values[index] = newValue;\n        index = (index + 1) % size;\n        \n        // Return average of stored values\n        double sum = 0;\n        for (double value : values) {\n            sum += value;\n        }\n        return sum / size;\n    }\n}\n\n// Usage in your OpMode\nSensorFilter distanceFilter = new SensorFilter(5); // 5-sample average\n\n@Override\npublic void loop() {\n    double rawDistance = distanceSensor.getDistance(DistanceUnit.CM);\n    double filteredDistance = distanceFilter.update(rawDistance);\n    \n    telemetry.addData(\"Raw Distance\", rawDistance);\n    telemetry.addData(\"Filtered Distance\", filteredDistance);\n    telemetry.update();\n}\n```"
    },
    {
      "title": "Multi-Sensor Integration",
      "content": "Combining multiple sensors creates more robust autonomous behavior:\n\n```java\n@Autonomous(name=\"Multi-Sensor Auto\")\npublic class MultiSensorAuto extends OpMode {\n    private DcMotor leftMotor, rightMotor;\n    private ColorSensor colorSensor;\n    private DistanceSensor distanceSensor;\n    private BNO055IMU imu;\n    private ElapsedTime runtime;\n    \n    private enum State {\n        DRIVE_FORWARD,\n        FOLLOW_LINE,\n        AVOID_OBSTACLE,\n        TURN_TO_HEADING,\n        STOP\n    }\n    \n    private State currentState = State.DRIVE_FORWARD;\n    \n    @Override\n    public void init() {\n        // Initialize all sensors and motors\n        leftMotor = hardwareMap.get(DcMotor.class, \"left_motor\");\n        rightMotor = hardwareMap.get(DcMotor.class, \"right_motor\");\n        colorSensor = hardwareMap.get(ColorSensor.class, \"color_sensor\");\n        distanceSensor = hardwareMap.get(DistanceSensor.class, \"distance_sensor\");\n        imu = hardwareMap.get(BNO055IMU.class, \"imu\");\n        runtime = new ElapsedTime();\n        \n        // Initialize IMU\n        BNO055IMU.Parameters parameters = new BNO055IMU.Parameters();\n        parameters.angleUnit = BNO055IMU.AngleUnit.DEGREES;\n        imu.initialize(parameters);\n    }\n    \n    @Override\n    public void start() {\n        runtime.reset();\n    }\n    \n    @Override\n    public void loop() {\n        // Read all sensors\n        double distance = distanceSensor.getDistance(DistanceUnit.CM);\n        int lightLevel = colorSensor.alpha();\n        Orientation angles = imu.getAngularOrientation(AxesReference.INTRINSIC, AxesOrder.ZYX, AngleUnit.DEGREES);\n        double heading = angles.firstAngle;\n        \n        // State machine logic\n        switch (currentState) {\n            case DRIVE_FORWARD:\n                if (distance < 15) {\n                    currentState = State.AVOID_OBSTACLE;\n                } else if (lightLevel < 100) {\n                    currentState = State.FOLLOW_LINE;\n                } else {\n                    leftMotor.setPower(0.3);\n                    rightMotor.setPower(0.3);\n                }\n                break;\n                \n            case FOLLOW_LINE:\n                if (lightLevel < 50) {\n                    // Turn left to follow line\n                    leftMotor.setPower(-0.2);\n                    rightMotor.setPower(0.2);\n                } else {\n                    currentState = State.DRIVE_FORWARD;\n                }\n                break;\n                \n            case AVOID_OBSTACLE:\n                // Turn right to avoid obstacle\n                leftMotor.setPower(0.3);\n                rightMotor.setPower(-0.3);\n                if (distance > 20) {\n                    currentState = State.DRIVE_FORWARD;\n                }\n                break;\n                \n            case TURN_TO_HEADING:\n                turnToHeading(0, 0.3);\n                if (Math.abs(heading) < 5) {\n                    currentState = State.STOP;\n                }\n                break;\n                \n            case STOP:\n                leftMotor.setPower(0);\n                rightMotor.setPower(0);\n                break;\n        }\n        \n        // Display sensor data\n        telemetry.addData(\"State\", currentState);\n        telemetry.addData(\"Distance\", distance);\n        telemetry.addData(\"Light Level\", lightLevel);\n        telemetry.addData(\"Heading\", heading);\n        telemetry.update();\n    }\n}\n```"
    },
    {
      "title": "Practice Exercise",
      "content": "Create an autonomous program that uses multiple sensors:\n\n1. **Start by driving forward** until a line is detected (color sensor)\n2. **Follow the line** using the color sensor\n3. **Stop when an obstacle** is detected within 10cm (distance sensor)\n4. **Turn 90 degrees** using the gyroscope\n5. **Continue driving** until another line is detected\n\n**Requirements**:\n- Use a state machine to manage different behaviors\n- Implement sensor filtering for smooth operation\n- Add telemetry to monitor all sensor values\n- Handle edge cases (sensor failures, unexpected readings)\n\nTest your program and refine the sensor thresholds for your specific robot and environment!"
    },
    {
      "title": "Common Issues and Solutions",
      "content": "**Problem**: Sensors give inconsistent readings\n- **Solution**: Add filtering/averaging and check for interference\n\n**Problem**: Color sensor doesn't detect lines properly\n- **Solution**: Adjust lighting, calibrate thresholds, and test on actual surface\n\n**Problem**: Distance sensor readings are inaccurate\n- **Solution**: Check mounting angle, clean sensor lens, and calibrate for your environment\n\n**Problem**: Gyroscope drifts over time\n- **Solution**: Recalibrate periodically and use relative angles rather than absolute\n\n**Problem**: Multiple sensors interfere with each other\n- **Solution**: Separate sensors physically and add delays between readings"
    },
    {
      "title": "Next Steps",
      "content": "You now have solid sensor integration skills! In the next lessons, you'll learn about:\n\n- Advanced autonomous programming with state machines\n- Computer vision and camera integration\n- Advanced control systems and PID tuning\n- Performance optimization and debugging\n\nPractice integrating different sensor combinations and experiment with various autonomous behaviors to build your understanding."
    }
  ]
} 