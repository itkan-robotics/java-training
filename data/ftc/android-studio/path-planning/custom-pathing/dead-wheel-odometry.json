{
  "title": "Dead Wheel Odometry",
  "sections": [
    {
      "type": "text",
      "title": "What is Dead Wheel Odometry?",
      "content": "<p>Dead wheel odometry is a precise positioning system that uses unpowered wheels (called 'dead wheels') with encoders to track the robot's position and orientation. Unlike the drive wheels, these wheels are not connected to motors and simply roll along the surface, providing accurate measurements of the robot's movement.</p><p>This system is essential for advanced autonomous navigation, allowing robots to know their exact position on the field and follow complex paths with high precision.</p>"
    },
    {
      "type": "emphasis-box",
      "title": "Benefits of Dead Wheel Odometry",
      "content": "<ul><li><strong>High Precision:</strong> Accurate position tracking within millimeters</li><li><strong>Real-time Feedback:</strong> Continuous position updates during movement</li><li><strong>Path Following:</strong> Enables complex autonomous paths and trajectories</li><li><strong>Field Localization:</strong> Knows exact position relative to field features</li><li><strong>Competitive Advantage:</strong> Essential for advanced autonomous routines</li><li><strong>Consistent Performance:</strong> Reliable positioning regardless of surface conditions</li></ul>"
    },
    {
      "type": "text",
      "title": "Understanding the Three-Wheel System",
      "content": "<p>Dead wheel odometry typically uses a three-wheel configuration to track both position and orientation:</p><ul><li><strong>Left Wheel:</strong> Tracks movement along the left side of the robot</li><li><strong>Right Wheel:</strong> Tracks movement along the right side of the robot</li><li><strong>Center Wheel:</strong> Tracks forward/backward movement and helps with orientation</li></ul><p>By combining the readings from all three wheels, we can calculate the robot's X and Y position as well as its heading angle.</p>"
    },
    {
      "type": "text",
      "title": "Mathematical Foundation",
      "content": "<p>Dead wheel odometry uses mathematical formulas to convert encoder readings into position and orientation. The key equations are:</p><ul><li><strong>Position Update:</strong> Uses the change in encoder values to calculate new X,Y coordinates</li><li><strong>Orientation Update:</strong> Uses the difference between left and right wheel movements to calculate heading</li><li><strong>Center Wheel Correction:</strong> Uses the center wheel to improve accuracy and detect wheel slip</li></ul><p>These calculations happen continuously during robot movement to maintain accurate positioning.</p>"
    },
    {
      "type": "text",
      "title": "Basic Odometry Class Structure",
      "content": "<p>Let's start by understanding the basic structure of an odometry class. We'll build this step by step to make it easier to understand.</p><p>The key components are the wheel positions, robot position, and update calculations.</p>"
    },
    {
      "type": "code",
      "title": "Step 1: Class Variables and Constants",
      "content": "First, let's set up the basic class structure with all the variables we'll need:",
      "code": "public class DeadWheelOdometry {\n    // Hardware components\n    private DcMotor leftEncoder;\n    private DcMotor rightEncoder;\n    private DcMotor centerEncoder;\n    \n    // Robot position and orientation\n    private double x = 0.0;           // X position in mm\n    private double y = 0.0;           // Y position in mm\n    private double heading = 0.0;     // Heading angle in radians\n    \n    // Previous encoder positions\n    private int prevLeftPos = 0;\n    private int prevRightPos = 0;\n    private int prevCenterPos = 0;\n    \n    // Odometry constants\n    private static final double COUNTS_PER_MM = 1440.0 / (90.0 * Math.PI); // Adjust for your wheels\n    private static final double WHEELBASE_MM = 300.0;  // Distance between left and right wheels\n    private static final double CENTER_WHEEL_OFFSET_MM = 150.0; // Distance from center to center wheel\n    \n    public DeadWheelOdometry(DcMotor left, DcMotor right, DcMotor center) {\n        this.leftEncoder = left;\n        this.rightEncoder = right;\n        this.centerEncoder = center;\n        \n        // Reset encoders\n        resetEncoders();\n    }"
    },
    {
      "type": "text",
      "title": "Understanding the Variables",
      "content": "<p>Let's break down what each variable represents:</p><ul><li><strong>Hardware Components:</strong> References to the three encoder motors</li><li><strong>Position Variables:</strong> Current X, Y position and heading angle</li><li><strong>Previous Positions:</strong> Store last encoder readings for calculating changes</li><li><strong>Constants:</strong> Physical measurements and conversion factors</li><li><strong>COUNTS_PER_MM:</strong> Converts encoder counts to millimeters</li><li><strong>WHEELBASE_MM:</strong> Distance between left and right wheels</li><li><strong>CENTER_WHEEL_OFFSET_MM:</strong> Distance from robot center to center wheel</li></ul>"
    },
    {
      "type": "code",
      "title": "Step 2: Encoder Reset Method",
      "content": "Now let's implement the method to reset all encoders:",
      "code": "    public void resetEncoders() {\n        // Reset encoder modes\n        leftEncoder.setMode(DcMotor.RunMode.STOP_AND_RESET_ENCODER);\n        rightEncoder.setMode(DcMotor.RunMode.STOP_AND_RESET_ENCODER);\n        centerEncoder.setMode(DcMotor.RunMode.STOP_AND_RESET_ENCODER);\n        \n        // Wait for reset to complete\n        sleep(50);\n        \n        // Set encoders to run without encoders mode\n        leftEncoder.setMode(DcMotor.RunMode.RUN_WITHOUT_ENCODER);\n        rightEncoder.setMode(DcMotor.RunMode.RUN_WITHOUT_ENCODER);\n        centerEncoder.setMode(DcMotor.RunMode.RUN_WITHOUT_ENCODER);\n        \n        // Reset position variables\n        x = 0.0;\n        y = 0.0;\n        heading = 0.0;\n        \n        // Reset previous positions\n        prevLeftPos = 0;\n        prevRightPos = 0;\n        prevCenterPos = 0;\n    }"
    },
    {
      "type": "text",
      "title": "How Encoder Reset Works",
      "content": "<p>This method performs several important tasks:</p><ul><li><strong>Mode Reset:</strong> Stops and resets all encoders to zero</li><li><strong>Wait Period:</strong> Gives time for the reset operation to complete</li><li><strong>Mode Change:</strong> Sets encoders to run without encoder mode for continuous reading</li><li><strong>Position Reset:</strong> Sets all position variables back to zero</li><li><strong>Previous Reset:</strong> Clears previous encoder positions</li></ul><p>This ensures we start from a known position and can track movement accurately.</p>"
    },
    {
      "type": "code",
      "title": "Step 3: Position Update Method",
      "content": "Now let's implement the core method that updates the robot's position:",
      "code": "    public void updatePosition() {\n        // Get current encoder positions\n        int currentLeftPos = leftEncoder.getCurrentPosition();\n        int currentRightPos = rightEncoder.getCurrentPosition();\n        int currentCenterPos = centerEncoder.getCurrentPosition();\n        \n        // Calculate encoder deltas (changes since last update)\n        int deltaLeft = currentLeftPos - prevLeftPos;\n        int deltaRight = currentRightPos - prevRightPos;\n        int deltaCenter = currentCenterPos - prevCenterPos;\n        \n        // Convert encoder counts to millimeters\n        double deltaLeftMM = deltaLeft / COUNTS_PER_MM;\n        double deltaRightMM = deltaRight / COUNTS_PER_MM;\n        double deltaCenterMM = deltaCenter / COUNTS_PER_MM;\n        \n        // Calculate robot movement\n        double deltaHeading = (deltaRightMM - deltaLeftMM) / WHEELBASE_MM;\n        double deltaForward = (deltaLeftMM + deltaRightMM) / 2.0;\n        \n        // Update heading\n        heading += deltaHeading;\n        \n        // Calculate position change in robot coordinates\n        double deltaX = deltaForward;\n        double deltaY = deltaCenterMM - (deltaHeading * CENTER_WHEEL_OFFSET_MM);\n        \n        // Rotate to field coordinates and update position\n        double cosHeading = Math.cos(heading);\n        double sinHeading = Math.sin(heading);\n        \n        x += deltaX * cosHeading - deltaY * sinHeading;\n        y += deltaX * sinHeading + deltaY * cosHeading;\n        \n        // Update previous positions\n        prevLeftPos = currentLeftPos;\n        prevRightPos = currentRightPos;\n        prevCenterPos = currentCenterPos;\n    }"
    },
    {
      "type": "text",
      "title": "Understanding Position Update",
      "content": "<p>This method performs the core odometry calculations:</p><ul><li><strong>Encoder Reading:</strong> Gets current positions from all three encoders</li><li><strong>Delta Calculation:</strong> Calculates how much each wheel has moved since last update</li><li><strong>Unit Conversion:</strong> Converts encoder counts to millimeters</li><li><strong>Movement Calculation:</strong> Uses wheel differences to calculate heading change and forward movement</li><li><strong>Coordinate Transformation:</strong> Converts robot-relative movement to field coordinates</li><li><strong>Position Update:</strong> Updates the robot's X, Y position and heading</li></ul><p>This creates a continuous position tracking system.</p>"
    },
    {
      "type": "code",
      "title": "Step 4: Getter Methods",
      "content": "Let's add methods to access the current position and orientation:",
      "code": "    public double getX() {\n        return x;\n    }\n    \n    public double getY() {\n        return y;\n    }\n    \n    public double getHeading() {\n        return heading;\n    }\n    \n    public double getHeadingDegrees() {\n        return Math.toDegrees(heading);\n    }\n    \n    public void setPosition(double newX, double newY, double newHeading) {\n        this.x = newX;\n        this.y = newY;\n        this.heading = newHeading;\n    }"
    },
    {
      "type": "text",
      "title": "Understanding the Getter Methods",
      "content": "<p>These methods provide access to the current position data:</p><ul><li><strong>getX() and getY():</strong> Return current position in millimeters</li><li><strong>getHeading():</strong> Returns heading in radians (mathematical standard)</li><li><strong>getHeadingDegrees():</strong> Returns heading in degrees (more intuitive)</li><li><strong>setPosition():</strong> Allows manual setting of position (useful for field calibration)</li></ul><p>These methods make it easy to access position data from other parts of your code.</p>"
    },
    {
      "type": "text",
      "title": "Implementing Dead Wheel Odometry in OpMode",
      "content": "<p>Now let's see how to use our odometry class in an actual OpMode. We'll break this down into manageable steps.</p>"
    },
    {
      "type": "code",
      "title": "Step 1: OpMode Setup with Odometry",
      "content": "First, let's set up the basic OpMode structure with odometry integration:",
      "code": "public class OdometryTest extends LinearOpMode {\n    private DcMotor leftDrive;\n    private DcMotor rightDrive;\n    private DcMotor centerDrive;\n    \n    // Odometry encoders (can be separate motors or the same as drive motors)\n    private DcMotor leftEncoder;\n    private DcMotor rightEncoder;\n    private DcMotor centerEncoder;\n    \n    // Odometry system\n    private DeadWheelOdometry odometry;\n    \n    // Timer for position updates\n    private ElapsedTime runtime;\n    \n    @Override\n    public void runOpMode() {\n        // Initialize drive motors\n        leftDrive = hardwareMap.get(DcMotor.class, \"left_drive\");\n        rightDrive = hardwareMap.get(DcMotor.class, \"right_drive\");\n        centerDrive = hardwareMap.get(DcMotor.class, \"center_drive\");\n        \n        // Initialize odometry encoders (could be the same as drive motors)\n        leftEncoder = hardwareMap.get(DcMotor.class, \"left_encoder\");\n        rightEncoder = hardwareMap.get(DcMotor.class, \"right_encoder\");\n        centerEncoder = hardwareMap.get(DcMotor.class, \"center_encoder\");\n        \n        // Initialize odometry system\n        odometry = new DeadWheelOdometry(leftEncoder, rightEncoder, centerEncoder);\n        \n        // Initialize timer\n        runtime = new ElapsedTime();\n        \n        waitForStart();\n        \n        // Start odometry tracking\n        trackPosition();\n    }"
    },
    {
      "type": "text",
      "title": "Understanding the Setup",
      "content": "<p>Key components of this setup:</p><ul><li><strong>Drive Motors:</strong> Control robot movement</li><li><strong>Odometry Encoders:</strong> Track position (can be separate or same as drive motors)</li><li><strong>Odometry System:</strong> Our custom class that handles position calculations</li><li><strong>Timer:</strong> Used for timing position updates</li><li><strong>Hardware Mapping:</strong> Connects to motors configured in the robot configuration</li></ul><p>Note that odometry encoders can be the same motors as drive motors, or separate dedicated encoders.</p>"
    },
    {
      "type": "code",
      "title": "Step 2: Position Tracking Method",
      "content": "Now let's implement the method that continuously tracks position:",
      "code": "    private void trackPosition() {\n        // Reset odometry to start position\n        odometry.resetEncoders();\n        \n        // Set initial position (adjust based on your starting position)\n        odometry.setPosition(0, 0, 0);\n        \n        runtime.reset();\n        \n        while (opModeIsActive()) {\n            // Update position\n            odometry.updatePosition();\n            \n            // Display position information\n            telemetry.addData(\"X Position\", \"%.1f mm\", odometry.getX());\n            telemetry.addData(\"Y Position\", \"%.1f mm\", odometry.getY());\n            telemetry.addData(\"Heading\", \"%.1f degrees\", odometry.getHeadingDegrees());\n            telemetry.addData(\"Runtime\", \"%.1f seconds\", runtime.seconds());\n            telemetry.update();\n            \n            // Update at 50Hz (every 20ms)\n            sleep(20);\n        }\n    }"
    },
    {
      "type": "text",
      "title": "How Position Tracking Works",
      "content": "<p>This method creates a continuous position tracking system:</p><ul><li><strong>Encoder Reset:</strong> Starts from a known position</li><li><strong>Initial Position:</strong> Sets starting coordinates (adjust for your field)</li><li><strong>Continuous Updates:</strong> Updates position every 20ms (50Hz)</li><li><strong>Real-time Display:</strong> Shows current position and heading</li><li><strong>Timing Control:</strong> Maintains consistent update rate</li></ul><p>This provides real-time position feedback that can be used for navigation.</p>"
    },
    {
      "type": "text",
      "title": "Advanced Odometry with Movement Control",
      "content": "<p>Now let's enhance our odometry system by adding movement control. This will allow us to drive to specific positions using odometry feedback.</p>"
    },
    {
      "type": "code",
      "title": "Step 1: Enhanced OpMode Setup",
      "content": "Let's set up an OpMode that combines odometry with movement control:",
      "code": "public class OdometryMovement extends LinearOpMode {\n    private DcMotor leftDrive;\n    private DcMotor rightDrive;\n    private DcMotor centerDrive;\n    \n    // Odometry encoders\n    private DcMotor leftEncoder;\n    private DcMotor rightEncoder;\n    private DcMotor centerEncoder;\n    \n    // Odometry system\n    private DeadWheelOdometry odometry;\n    \n    // Movement constants\n    private static final double DRIVE_SPEED = 0.6;\n    private static final double TURN_SPEED = 0.4;\n    private static final double POSITION_TOLERANCE_MM = 10.0;  // 10mm tolerance\n    private static final double HEADING_TOLERANCE_DEG = 2.0;   // 2 degree tolerance\n    \n    @Override\n    public void runOpMode() {\n        // Initialize hardware\n        leftDrive = hardwareMap.get(DcMotor.class, \"left_drive\");\n        rightDrive = hardwareMap.get(DcMotor.class, \"right_drive\");\n        centerDrive = hardwareMap.get(DcMotor.class, \"center_drive\");\n        \n        leftEncoder = hardwareMap.get(DcMotor.class, \"left_encoder\");\n        rightEncoder = hardwareMap.get(DcMotor.class, \"right_encoder\");\n        centerEncoder = hardwareMap.get(DcMotor.class, \"center_encoder\");\n        \n        // Initialize odometry\n        odometry = new DeadWheelOdometry(leftEncoder, rightEncoder, centerEncoder);\n        \n        waitForStart();\n        \n        // Execute movement sequence\n        driveToPosition(500, 0, 0);    // Drive forward 500mm\n        driveToPosition(500, 500, 90); // Drive to position (500, 500) facing 90 degrees\n        driveToPosition(0, 0, 180);    // Return to start facing backward\n    }"
    },
    {
      "type": "text",
      "title": "Understanding the Enhanced Setup",
      "content": "<p>This setup includes movement control capabilities:</p><ul><li><strong>Movement Constants:</strong> Define speeds and tolerances for precise movement</li><li><strong>Position Tolerance:</strong> How close the robot needs to get to target position</li><li><strong>Heading Tolerance:</strong> How close the robot needs to get to target heading</li><li><strong>Movement Sequence:</strong> Multiple movements to test the system</li><li><strong>Speed Control:</strong> Different speeds for driving vs turning</li></ul>"
    },
    {
      "type": "code",
      "title": "Step 2: Drive to Position Method",
      "content": "Now let's implement the method that drives to a specific position:",
      "code": "    private void driveToPosition(double targetX, double targetY, double targetHeadingDeg) {\n        double targetHeadingRad = Math.toRadians(targetHeadingDeg);\n        \n        while (opModeIsActive()) {\n            // Update odometry\n            odometry.updatePosition();\n            \n            // Calculate current position and heading\n            double currentX = odometry.getX();\n            double currentY = odometry.getY();\n            double currentHeading = odometry.getHeading();\n            \n            // Calculate distance and angle to target\n            double deltaX = targetX - currentX;\n            double deltaY = targetY - currentY;\n            double distanceToTarget = Math.sqrt(deltaX * deltaX + deltaY * deltaY);\n            double angleToTarget = Math.atan2(deltaY, deltaX);\n            \n            // Calculate heading error\n            double headingError = angleToTarget - currentHeading;\n            double finalHeadingError = targetHeadingRad - currentHeading;\n            \n            // Normalize angles to -π to π\n            headingError = normalizeAngle(headingError);\n            finalHeadingError = normalizeAngle(finalHeadingError);\n            \n            // Determine if we're close enough\n            boolean atPosition = distanceToTarget < POSITION_TOLERANCE_MM;\n            boolean atHeading = Math.abs(finalHeadingError) < Math.toRadians(HEADING_TOLERANCE_DEG);\n            \n            if (atPosition && atHeading) {\n                // We've reached the target\n                stop();\n                break;\n            }\n            \n            // Calculate motor powers\n            double forwardPower = 0;\n            double turnPower = 0;\n            \n            if (!atPosition) {\n                // Drive toward target position\n                forwardPower = DRIVE_SPEED * Math.cos(headingError);\n                turnPower = DRIVE_SPEED * Math.sin(headingError);\n            } else {\n                // Just turn to final heading\n                turnPower = TURN_SPEED * Math.signum(finalHeadingError);\n            }\n            \n            // Apply to motors (adjust for your drive configuration)\n            leftDrive.setPower(forwardPower + turnPower);\n            rightDrive.setPower(forwardPower - turnPower);\n            \n            // Display telemetry\n            telemetry.addData(\"Target\", \"(%.0f, %.0f, %.0f°)\", targetX, targetY, targetHeadingDeg);\n            telemetry.addData(\"Current\", \"(%.1f, %.1f, %.1f°)\", currentX, currentY, Math.toDegrees(currentHeading));\n            telemetry.addData(\"Distance\", \"%.1f mm\", distanceToTarget);\n            telemetry.addData(\"At Position\", atPosition);\n            telemetry.addData(\"At Heading\", atHeading);\n            telemetry.update();\n        }\n    }"
    },
    {
      "type": "text",
      "title": "How Drive to Position Works",
      "content": "<p>This method implements sophisticated position control:</p><ul><li><strong>Position Update:</strong> Continuously updates current position</li><li><strong>Target Calculation:</strong> Calculates distance and angle to target</li><li><strong>Error Calculation:</strong> Determines position and heading errors</li><li><strong>Completion Check:</strong> Checks if robot is within tolerance of target</li><li><strong>Power Calculation:</strong> Calculates motor powers based on errors</li><li><strong>Two-Phase Control:</strong> First drives to position, then adjusts heading</li><li><strong>Real-time Feedback:</strong> Shows progress and current status</li></ul><p>This creates precise autonomous navigation to any position on the field.</p>"
    },
    {
      "type": "code",
      "title": "Step 3: Utility Methods",
      "content": "Let's add the utility methods needed for the drive system:",
      "code": "    private double normalizeAngle(double angle) {\n        while (angle > Math.PI) angle -= 2 * Math.PI;\n        while (angle < -Math.PI) angle += 2 * Math.PI;\n        return angle;\n    }\n    \n    private void stop() {\n        leftDrive.setPower(0);\n        rightDrive.setPower(0);\n        centerDrive.setPower(0);\n    }"
    },
    {
      "type": "text",
      "title": "Understanding Utility Methods",
      "content": "<p>These utility methods provide essential functionality:</p><ul><li><strong>normalizeAngle():</strong> Keeps angles between -π and π radians for consistent calculations</li><li><strong>stop():</strong> Stops all drive motors when target is reached</li></ul><p>The angle normalization is crucial for proper heading calculations and prevents angle wrapping issues.</p>"
    },
    {
      "type": "text",
      "title": "Calibration and Tuning",
      "content": "<p>Dead wheel odometry requires careful calibration to work accurately. Here are the key parameters to tune:</p><ul><li><strong>COUNTS_PER_MM:</strong> Must be measured precisely for your specific wheels</li><li><strong>WHEELBASE_MM:</strong> Distance between left and right wheels</li><li><strong>CENTER_WHEEL_OFFSET_MM:</strong> Distance from robot center to center wheel</li><li><strong>Position Tolerances:</strong> Adjust based on your precision requirements</li><li><strong>Speed Constants:</strong> Tune for smooth, accurate movement</li></ul><p>Always test on the actual field surface and adjust parameters based on performance.</p>"
    },
    {
      "type": "text",
      "title": "Complete Odometry System with Path Following",
      "content": "<p>Now let's create a comprehensive odometry system that can follow complex paths. We'll build this step by step.</p>"
    },
    {
      "type": "code",
      "title": "Step 1: Path Following OpMode Setup",
      "content": "Let's set up an OpMode that can follow predefined paths:",
      "code": "public class PathFollowingOdometry extends LinearOpMode {\n    private DcMotor leftDrive;\n    private DcMotor rightDrive;\n    private DcMotor centerDrive;\n    \n    // Odometry encoders\n    private DcMotor leftEncoder;\n    private DcMotor rightEncoder;\n    private DcMotor centerEncoder;\n    \n    // Odometry system\n    private DeadWheelOdometry odometry;\n    \n    // Path following constants\n    private static final double LOOKAHEAD_DISTANCE_MM = 50.0;  // Distance to look ahead on path\n    private static final double PATH_SPEED = 0.5;\n    private static final double PATH_TOLERANCE_MM = 15.0;\n    \n    // Define a simple path (X, Y, Heading in degrees)\n    private double[][] path = {\n        {0, 0, 0},      // Start position\n        {300, 0, 0},    // Drive forward\n        {300, 300, 90}, // Turn right and drive\n        {0, 300, 180},  // Turn around and drive back\n        {0, 0, 270}     // Return to start\n    };\n    \n    @Override\n    public void runOpMode() {\n        // Initialize hardware\n        leftDrive = hardwareMap.get(DcMotor.class, \"left_drive\");\n        rightDrive = hardwareMap.get(DcMotor.class, \"right_drive\");\n        centerDrive = hardwareMap.get(DcMotor.class, \"center_drive\");\n        \n        leftEncoder = hardwareMap.get(DcMotor.class, \"left_encoder\");\n        rightEncoder = hardwareMap.get(DcMotor.class, \"right_encoder\");\n        centerEncoder = hardwareMap.get(DcMotor.class, \"center_encoder\");\n        \n        // Initialize odometry\n        odometry = new DeadWheelOdometry(leftEncoder, rightEncoder, centerEncoder);\n        \n        waitForStart();\n        \n        // Follow the path\n        followPath();\n    }"
    },
    {
      "type": "text",
      "title": "Understanding Path Following Setup",
      "content": "<p>This setup creates a path following system:</p><ul><li><strong>Path Definition:</strong> Array of waypoints with X, Y, and heading</li><li><strong>Lookahead Distance:</strong> How far ahead to look on the path for smooth following</li><li><strong>Path Speed:</strong> Speed for following the path</li><li><strong>Path Tolerance:</strong> How close to get to each waypoint</li><li><strong>Waypoint Sequence:</strong> Defines a complete path around the field</li></ul><p>The path array defines a square pattern that tests all movement directions.</p>"
    },
    {
      "type": "code",
      "title": "Step 2: Path Following Method",
      "content": "Now let's implement the method that follows the predefined path:",
      "code": "    private void followPath() {\n        // Reset odometry to start position\n        odometry.resetEncoders();\n        odometry.setPosition(0, 0, 0);\n        \n        // Follow each waypoint in the path\n        for (int i = 1; i < path.length; i++) {\n            double targetX = path[i][0];\n            double targetY = path[i][1];\n            double targetHeading = Math.toRadians(path[i][2]);\n            \n            telemetry.addData(\"Following Waypoint\", \"%d of %d\", i, path.length - 1);\n            telemetry.update();\n            \n            // Drive to this waypoint\n            driveToWaypoint(targetX, targetY, targetHeading);\n            \n            // Brief pause between waypoints\n            sleep(200);\n        }\n        \n        telemetry.addData(\"Path Complete\", \"All waypoints reached!\");\n        telemetry.update();\n    }"
    },
    {
      "type": "text",
      "title": "How Path Following Works",
      "content": "<p>This method orchestrates the path following process:</p><ul><li><strong>Initialization:</strong> Resets odometry and sets starting position</li><li><strong>Waypoint Loop:</strong> Processes each waypoint in sequence</li><li><strong>Target Extraction:</strong> Gets X, Y, and heading for current waypoint</li><strong>Progress Display:</strong> Shows which waypoint is being followed</li><li><strong>Movement Execution:</strong> Drives to the current waypoint</li><li><strong>Pause Between Points:</strong> Brief pause for stability</li><li><strong>Completion Notification:</strong> Confirms when path is complete</li></ul>"
    },
    {
      "type": "code",
      "title": "Step 3: Drive to Waypoint Method",
      "content": "Let's implement the method that drives to individual waypoints:",
      "code": "    private void driveToWaypoint(double targetX, double targetY, double targetHeading) {\n        while (opModeIsActive()) {\n            // Update odometry\n            odometry.updatePosition();\n            \n            // Get current position\n            double currentX = odometry.getX();\n            double currentY = odometry.getY();\n            double currentHeading = odometry.getHeading();\n            \n            // Calculate distance to target\n            double deltaX = targetX - currentX;\n            double deltaY = targetY - currentY;\n            double distanceToTarget = Math.sqrt(deltaX * deltaX + deltaY * deltaY);\n            \n            // Check if we're close enough to target\n            if (distanceToTarget < PATH_TOLERANCE_MM) {\n                // Close to target, now adjust heading\n                double headingError = normalizeAngle(targetHeading - currentHeading);\n                \n                if (Math.abs(headingError) < Math.toRadians(5.0)) {\n                    // At target position and heading\n                    stop();\n                    break;\n                } else {\n                    // Just turn to correct heading\n                    double turnPower = PATH_SPEED * 0.5 * Math.signum(headingError);\n                    leftDrive.setPower(turnPower);\n                    rightDrive.setPower(-turnPower);\n                }\n            } else {\n                // Drive toward target\n                double angleToTarget = Math.atan2(deltaY, deltaX);\n                double headingError = normalizeAngle(angleToTarget - currentHeading);\n                \n                // Calculate motor powers for curved path following\n                double forwardPower = PATH_SPEED * Math.cos(headingError);\n                double turnPower = PATH_SPEED * Math.sin(headingError);\n                \n                leftDrive.setPower(forwardPower + turnPower);\n                rightDrive.setPower(forwardPower - turnPower);\n            }\n            \n            // Display telemetry\n            telemetry.addData(\"Target\", \"(%.0f, %.0f)\", targetX, targetY);\n            telemetry.addData(\"Current\", \"(%.1f, %.1f)\", currentX, currentY);\n            telemetry.addData(\"Distance\", \"%.1f mm\", distanceToTarget);\n            telemetry.addData(\"Heading\", \"%.1f°\", Math.toDegrees(currentHeading));\n            telemetry.update();\n        }\n    }"
    },
    {
      "type": "text",
      "title": "How Drive to Waypoint Works",
      "content": "<p>This method implements sophisticated waypoint following:</p><ul><li><strong>Position Update:</strong> Continuously updates current position</li><li><strong>Distance Check:</strong> Determines if robot is close to target</li><li><strong>Two-Phase Control:</strong> First drives to position, then adjusts heading</li><li><strong>Curved Path Following:</strong> Uses heading error to create smooth curved paths</li><li><strong>Power Calculation:</strong> Combines forward and turning power for smooth movement</li><li><strong>Real-time Feedback:</strong> Shows progress toward current waypoint</li><li><strong>Precision Control:</strong> Fine-tunes heading when close to target</li></ul><p>This creates smooth, efficient path following with precise positioning.</p>"
    },
    {
      "type": "code",
      "title": "Step 4: Utility Methods for Path Following",
      "content": "Finally, let's add the utility methods needed for path following:",
      "code": "    private double normalizeAngle(double angle) {\n        while (angle > Math.PI) angle -= 2 * Math.PI;\n        while (angle < -Math.PI) angle += 2 * Math.PI;\n        return angle;\n    }\n    \n    private void stop() {\n        leftDrive.setPower(0);\n        rightDrive.setPower(0);\n        centerDrive.setPower(0);\n    }"
    },
    {
      "type": "exercise-box",
      "title": "Practice Exercise: Dead Wheel Odometry Implementation",
      "description": "Create a dead wheel odometry system for your robot:",
      "tasks": [
        "Implement the DeadWheelOdometry class with three-wheel tracking",
        "Create an OpMode that displays real-time position and heading",
        "Add movement control to drive to specific positions",
        "Implement path following with multiple waypoints",
        "Calibrate the system for your specific robot configuration",
        "Test the system with various movement patterns"
      ],
      "code": "// Start with the DeadWheelOdometry class:\npublic class DeadWheelOdometry {\n    // Add your odometry implementation here\n}\n\n// Then create your OpMode:\npublic class PracticeOdometry extends LinearOpMode {\n    // Add your hardware initialization and odometry usage\n}"
    },
    {
      "type": "text",
      "title": "Troubleshooting Common Issues",
      "content": "<p>Dead wheel odometry can be challenging to set up correctly. Here are common issues and solutions:</p><ul><li><strong>Inaccurate Position Tracking:</strong> Check encoder counts per mm and wheel measurements</li><li><strong>Drifting Position:</strong> Ensure wheels are properly aligned and not slipping</li><li><strong>Heading Errors:</strong> Verify wheelbase measurement and encoder directions</li><li><strong>Slow Updates:</strong> Reduce update frequency or optimize calculations</li><li><strong>Inconsistent Results:</strong> Check for wheel slip and surface conditions</li><li><strong>Initial Position Errors:</strong> Ensure proper field calibration and starting position</li></ul><p>Always test incrementally and verify each component before combining them.</p>"
    },
    {
      "type": "link-grid",
      "title": "Related Topics",
      "links": [
        {
          "title": "Introduction to Manual Pathing",
          "description": "Learn the fundamentals of manual path planning",
          "url": "data/ftc/android-studio/path-planning/custom-pathing/intro-to-manual-pathing.json"
        },
        {
          "title": "Motion Profiling Basics",
          "description": "Understanding smooth velocity control",
          "url": "data/ftc/android-studio/path-planning/custom-pathing/motion-profiling-basics.json"
        },
        {
          "title": "Three Wheel Odometry",
          "description": "Detailed three-wheel odometry implementation",
          "url": "data/ftc/android-studio/odometry/three-wheel-odometry.json"
        },
        {
          "title": "Motor Encoders",
          "description": "Working with encoder feedback and control",
          "url": "data/ftc/onbot-java/motors/motor-encoders.json"
        }
      ]
    },
    {
      "type": "text",
      "title": "External Resources",
      "content": "<p>For more information on dead wheel odometry and advanced positioning systems, check out these resources:</p><ul><li><a href=\"https://gm0.org/en/latest/docs/software/tutorials/odometry.html\" target=\"_blank\">gm0: Odometry</a> - Comprehensive odometry guide</li><li><a href=\"https://docs.revrobotics.com/duo-control/programming/autonomous-examples/odometry\" target=\"_blank\">REV Odometry Guide</a> - REV Robotics odometry documentation</li><li><a href=\"https://docs.revrobotics.com/duo-control/programming/autonomous-examples/odometry\" target=\"_blank\">REV Three-Wheel Odometry</a> - Detailed three-wheel implementation</li><li><a href=\"https://docs.revrobotics.com/duo-control/programming/autonomous-examples/odometry\" target=\"_blank\">REV Path Following</a> - Advanced path following techniques</li><li><a href=\"https://gm0.org/en/latest/docs/software/tutorials/encoders.html\" target=\"_blank\">gm0: Encoder Integration</a> - Working with encoders for precise control</li></ul>"
    }
  ]
}
