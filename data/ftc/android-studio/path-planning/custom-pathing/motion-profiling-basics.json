{
  "title": "Motion Profiling Basics",
  "sections": [
    {
      "type": "text",
      "title": "What is Motion Profiling?",
      "content": "<p>Motion profiling is a technique for creating smooth, controlled robot movements by carefully managing velocity and acceleration over time. Instead of simply setting motor power to a constant value, motion profiling creates a planned trajectory that includes acceleration, constant velocity, and deceleration phases.</p><p>This approach results in more precise, efficient, and professional robot movements that are essential for competitive autonomous performance.</p>"
    },
    {
      "type": "emphasis-box",
      "title": "Benefits of Motion Profiling",
      "content": "<ul><li><strong>Smooth Movement:</strong> Eliminates jerky starts and stops</li><li><strong>Precise Control:</strong> More accurate positioning and timing</li><li><strong>Efficient Operation:</strong> Optimizes power usage and reduces wear</li><li><strong>Professional Performance:</strong> Creates more reliable autonomous routines</li><li><strong>Consistent Results:</strong> More predictable behavior across different conditions</li></ul>"
    },
    {
      "type": "text",
      "title": "Understanding Velocity Profiles",
      "content": "<p>A velocity profile describes how the robot's speed changes over time during a movement. The most common and practical profile for FTC robots is the trapezoidal velocity profile, which consists of three phases:</p><ul><li><strong>Acceleration Phase:</strong> Robot gradually increases speed from zero to target velocity</li><li><strong>Constant Velocity Phase:</strong> Robot maintains target speed for the majority of the movement</li><li><strong>Deceleration Phase:</strong> Robot gradually decreases speed to zero</li></ul><p>This creates a smooth, efficient movement that minimizes jerk and maximizes precision.</p>"
    },
    {
      "type": "text",
      "title": "Basic Motion Profile Structure",
      "content": "<p>Let's start by understanding the basic structure of a motion profile class. We'll build this step by step to make it easier to understand.</p><p>The key components are the profile parameters, timing calculations, and velocity calculations.</p>"
    },
    {
      "type": "code",
      "title": "Step 1: Class Structure and Variables",
      "content": "First, let's set up the basic class structure with all the variables we'll need:",
      "code": "public class MotionProfile {\n    // Profile parameters\n    private double maxVelocity;      // Maximum velocity (power)\n    private double maxAcceleration;  // Maximum acceleration (power change per second)\n    private double distance;         // Total distance to travel\n    \n    // Profile timing phases\n    private double accelerationTime;\n    private double constantTime;\n    private double decelerationTime;\n    private double totalTime;\n    \n    public MotionProfile(double maxVel, double maxAccel, double dist) {\n        this.maxVelocity = maxVel;\n        this.maxAcceleration = maxAccel;\n        this.distance = dist;\n        \n        // Calculate profile timing\n        calculateProfile();\n    }"
    },
    {
      "type": "text",
      "title": "Understanding the Variables",
      "content": "<p>Let's break down what each variable represents:</p><ul><li><strong>maxVelocity:</strong> The highest speed the robot will reach (as a power value from 0 to 1)</li><li><strong>maxAcceleration:</strong> How quickly the robot can change its speed (power change per second)</li><li><strong>distance:</strong> How far the robot needs to travel (in encoder counts or other units)</li><li><strong>Timing Variables:</strong> Store the duration of each phase of the movement</li></ul><p>The constructor takes these parameters and immediately calculates the profile timing.</p>"
    },
    {
      "type": "code",
      "title": "Step 2: Profile Calculation Method",
      "content": "Now let's implement the method that calculates the timing for each phase of the motion profile:",
      "code": "    private void calculateProfile() {\n        // Time to reach max velocity\n        accelerationTime = maxVelocity / maxAcceleration;\n        \n        // Distance covered during acceleration\n        double accelerationDistance = 0.5 * maxVelocity * accelerationTime;\n        \n        // Distance covered during deceleration (same as acceleration)\n        double decelerationDistance = accelerationDistance;\n        \n        // Distance for constant velocity phase\n        double constantDistance = distance - accelerationDistance - decelerationDistance;\n        \n        // Time for constant velocity phase\n        constantTime = constantDistance / maxVelocity;\n        \n        // Total profile time\n        totalTime = accelerationTime + constantTime + accelerationTime;\n        \n        // Handle triangular profile case\n        if (constantTime < 0) {\n            // Can't reach max velocity - adjust for triangular profile\n            accelerationTime = Math.sqrt(distance / maxAcceleration);\n            constantTime = 0;\n            totalTime = accelerationTime * 2;\n        }\n    }"
    },
    {
      "type": "text",
      "title": "How Profile Calculation Works",
      "content": "<p>Let's understand the mathematics behind this calculation:</p><ul><li><strong>Acceleration Time:</strong> Time = Velocity / Acceleration (basic physics formula)</li><li><strong>Acceleration Distance:</strong> Distance = 0.5 × Velocity × Time (area under velocity curve)</li><li><strong>Constant Distance:</strong> Remaining distance after acceleration and deceleration phases</li><li><strong>Constant Time:</strong> Time = Distance / Velocity (simple distance formula)</li><li><strong>Triangular Profile:</strong> If we can't reach max velocity, we use a triangular profile instead</li></ul><p>This creates a smooth trapezoidal velocity profile that's optimal for robot movement.</p>"
    },
    {
      "type": "code",
      "title": "Step 3: Velocity Calculation Method",
      "content": "Now let's implement the method that calculates the velocity at any given time:",
      "code": "    public double getVelocity(double time) {\n        if (time <= 0) return 0;\n        if (time >= totalTime) return 0;\n        \n        if (time <= accelerationTime) {\n            // Acceleration phase - velocity increases linearly\n            return maxAcceleration * time;\n        } else if (time <= accelerationTime + constantTime) {\n            // Constant velocity phase - maintain max velocity\n            return maxVelocity;\n        } else {\n            // Deceleration phase - velocity decreases linearly\n            double decelTime = time - (accelerationTime + constantTime);\n            return maxVelocity - (maxAcceleration * decelTime);\n        }\n    }"
    },
    {
      "type": "text",
      "title": "Understanding Velocity Calculation",
      "content": "<p>This method determines the robot's velocity at any point in time:</p><ul><li><strong>Time Bounds:</strong> Return 0 if time is before start or after end</li><li><strong>Acceleration Phase:</strong> Velocity increases linearly from 0 to maxVelocity</li><li><strong>Constant Phase:</strong> Velocity stays at maxVelocity</li><li><strong>Deceleration Phase:</strong> Velocity decreases linearly from maxVelocity to 0</li></ul><p>The result is a smooth velocity curve that eliminates jerky movements.</p>"
    },
    {
      "type": "code",
      "title": "Step 4: Utility Methods",
      "content": "Let's add some utility methods to make the motion profile easier to use:",
      "code": "    public boolean isComplete(double time) {\n        return time >= totalTime;\n    }\n    \n    public double getTotalTime() {\n        return totalTime;\n    }\n    \n    public double getAccelerationTime() {\n        return accelerationTime;\n    }\n    \n    public double getConstantTime() {\n        return constantTime;\n    }"
    },
    {
      "type": "text",
      "title": "Trapezoidal Velocity Profiles",
      "content": "<p>The trapezoidal velocity profile is the most practical approach for FTC robots because it balances simplicity with effectiveness. It's called 'trapezoidal' because when you plot velocity over time, it forms a trapezoid shape.</p><p>Key characteristics of trapezoidal profiles:</p><ul><li><strong>Controlled Acceleration:</strong> Prevents sudden jerks that can cause wheel slip</li><li><strong>Efficient Operation:</strong> Uses maximum velocity for the majority of movement</li><li><strong>Predictable Deceleration:</strong> Ensures precise stopping at target position</li><li><strong>Adjustable Parameters:</strong> Can be tuned for different robot characteristics</li></ul>"
    },
    {
      "type": "text",
      "title": "Implementing Trapezoidal Motion Profile",
      "content": "<p>Now let's see how to use our motion profile class in an actual OpMode. We'll break this down into manageable steps.</p>"
    },
    {
      "type": "code",
      "title": "Step 1: OpMode Setup",
      "content": "First, let's set up the basic OpMode structure with motion profile parameters:",
      "code": "public class TrapezoidalMotionProfile extends LinearOpMode {\n    private DcMotor leftDrive;\n    private DcMotor rightDrive;\n    private ElapsedTime runtime;\n    \n    // Motion profile parameters\n    private static final double MAX_VELOCITY = 0.6;        // Maximum power\n    private static final double MAX_ACCELERATION = 0.3;    // Power change per second\n    private static final double TARGET_DISTANCE = 1000.0;  // Target distance in encoder counts\n    \n    @Override\n    public void runOpMode() {\n        // Initialize hardware\n        leftDrive = hardwareMap.get(DcMotor.class, \"left_drive\");\n        rightDrive = hardwareMap.get(DcMotor.class, \"right_drive\");\n        runtime = new ElapsedTime();\n        \n        // Set motor directions\n        leftDrive.setDirection(DcMotor.Direction.FORWARD);\n        rightDrive.setDirection(DcMotor.Direction.REVERSE);\n        \n        // Reset encoders\n        leftDrive.setMode(DcMotor.RunMode.STOP_AND_RESET_ENCODER);\n        rightDrive.setMode(DcMotor.RunMode.STOP_AND_RESET_ENCODER);\n        \n        waitForStart();\n        \n        // Execute motion profile\n        executeMotionProfile(TARGET_DISTANCE);\n    }"
    },
    {
      "type": "text",
      "title": "Understanding the Setup",
      "content": "<p>Key components of this setup:</p><ul><li><strong>Motion Profile Parameters:</strong> These control the shape of the velocity curve</li><li><strong>MAX_VELOCITY:</strong> 0.6 means 60% of maximum motor power</li><li><strong>MAX_ACCELERATION:</strong> 0.3 means power can change by 30% per second</li><li><strong>TARGET_DISTANCE:</strong> How far we want to travel (in encoder counts)</li><li><strong>Encoder Reset:</strong> Ensures we start from a known position</li></ul>"
    },
    {
      "type": "code",
      "title": "Step 2: Motion Profile Execution Method",
      "content": "Now let's implement the method that executes the motion profile:",
      "code": "    private void executeMotionProfile(double targetDistance) {\n        // Create motion profile\n        MotionProfile profile = new MotionProfile(MAX_VELOCITY, MAX_ACCELERATION, targetDistance);\n        \n        runtime.reset();\n        \n        while (opModeIsActive() && !profile.isComplete(runtime.seconds())) {\n            // Get current velocity from profile\n            double currentVelocity = profile.getVelocity(runtime.seconds());\n            \n            // Apply velocity to motors\n            leftDrive.setPower(currentVelocity);\n            rightDrive.setPower(currentVelocity);\n            \n            // Display telemetry\n            telemetry.addData(\"Profile Time\", \"%.2f / %.2f\", runtime.seconds(), profile.getTotalTime());\n            telemetry.addData(\"Current Velocity\", \"%.3f\", currentVelocity);\n            telemetry.addData(\"Left Encoder\", leftDrive.getCurrentPosition());\n            telemetry.addData(\"Right Encoder\", rightDrive.getCurrentPosition());\n            telemetry.update();\n        }\n        \n        // Stop motors\n        stop();\n    }"
    },
    {
      "type": "text",
      "title": "How Profile Execution Works",
      "content": "<p>Let's break down the execution process:</p><ul><li><strong>Profile Creation:</strong> Create a new MotionProfile with our parameters</li><li><strong>Timer Reset:</strong> Start timing from zero</li><strong>Main Loop:</strong> Continue until the profile is complete</li><li><strong>Velocity Lookup:</strong> Get the target velocity for the current time</li><li><strong>Motor Control:</strong> Apply the velocity to both motors</li><li><strong>Telemetry:</strong> Display progress and debugging information</li><li><strong>Cleanup:</strong> Stop motors when complete</li></ul>"
    },
    {
      "type": "code",
      "title": "Step 3: Stop Method",
      "content": "Finally, let's add the stop method:",
      "code": "    private void stop() {\n        leftDrive.setPower(0);\n        rightDrive.setPower(0);\n    }"
    },
    {
      "type": "text",
      "title": "Velocity and Acceleration Control",
      "content": "<p>Proper velocity and acceleration control is essential for creating smooth motion profiles. The key is to choose appropriate values that work well with your robot's characteristics.</p><p>Important considerations:</p><ul><li><strong>Robot Weight:</strong> Heavier robots need lower acceleration values</li><li><strong>Surface Conditions:</strong> Slippery surfaces require gentler acceleration</li><li><strong>Motor Power:</strong> More powerful motors can handle higher acceleration</li><li><strong>Gear Ratio:</strong> Different gear ratios affect acceleration characteristics</li><li><strong>Wheel Size:</strong> Larger wheels may require different acceleration curves</li></ul>"
    },
    {
      "type": "text",
      "title": "Advanced Motion Profile with Encoder Feedback",
      "content": "<p>Now let's enhance our motion profile by adding encoder feedback. This will make the movement even more precise by correcting for any deviations from the planned profile.</p>"
    },
    {
      "type": "code",
      "title": "Step 1: Enhanced OpMode Setup",
      "content": "Let's set up an OpMode that combines motion profiling with encoder feedback:",
      "code": "public class EncoderMotionProfile extends LinearOpMode {\n    private DcMotor leftDrive;\n    private DcMotor rightDrive;\n    private ElapsedTime runtime;\n    \n    // Encoder constants\n    private static final double COUNTS_PER_MOTOR_REV = 1440;\n    private static final double WHEEL_DIAMETER_MM = 90.0;\n    private static final double COUNTS_PER_MM = COUNTS_PER_MOTOR_REV / (WHEEL_DIAMETER_MM * Math.PI);\n    \n    // Motion profile parameters\n    private static final double MAX_VELOCITY = 0.6;\n    private static final double MAX_ACCELERATION = 0.3;\n    \n    @Override\n    public void runOpMode() {\n        // Initialize hardware\n        leftDrive = hardwareMap.get(DcMotor.class, \"left_drive\");\n        rightDrive = hardwareMap.get(DcMotor.class, \"right_drive\");\n        runtime = new ElapsedTime();\n        \n        // Reset encoders\n        leftDrive.setMode(DcMotor.RunMode.STOP_AND_RESET_ENCODER);\n        rightDrive.setMode(DcMotor.RunMode.STOP_AND_RESET_ENCODER);\n        \n        waitForStart();\n        \n        // Execute encoder-based motion profile\n        driveDistanceWithProfile(500); // Drive 500mm\n    }"
    },
    {
      "type": "text",
      "title": "Understanding Encoder Integration",
      "content": "<p>This setup combines motion profiling with encoder feedback:</p><ul><li><strong>Encoder Constants:</strong> Convert between encoder counts and real-world distances</li><li><strong>COUNTS_PER_MM:</strong> How many encoder counts equal 1mm of movement</li><li><strong>Distance-Based:</strong> We now work in millimeters instead of encoder counts</li><li><strong>Feedback Ready:</strong> We can read encoder positions to correct the profile</li></ul>"
    },
    {
      "type": "code",
      "title": "Step 2: Enhanced Drive Method with Feedback",
      "content": "Now let's implement the drive method that uses encoder feedback to correct the motion profile:",
      "code": "    private void driveDistanceWithProfile(double distanceMM) {\n        double targetCounts = distanceMM * COUNTS_PER_MM;\n        \n        // Create motion profile based on encoder counts\n        MotionProfile profile = new MotionProfile(MAX_VELOCITY, MAX_ACCELERATION, targetCounts);\n        \n        runtime.reset();\n        \n        while (opModeIsActive() && !profile.isComplete(runtime.seconds())) {\n            // Get current velocity from profile\n            double targetVelocity = profile.getVelocity(runtime.seconds());\n            \n            // Get current encoder positions\n            int leftPosition = leftDrive.getCurrentPosition();\n            int rightPosition = rightDrive.getCurrentPosition();\n            int averagePosition = (leftPosition + rightPosition) / 2;\n            \n            // Calculate position error\n            double positionError = targetCounts - averagePosition;\n            \n            // Simple proportional control to maintain profile\n            double correction = positionError * 0.001; // Small correction factor\n            double adjustedVelocity = targetVelocity + correction;\n            \n            // Clamp velocity to reasonable range\n            adjustedVelocity = Math.max(-1.0, Math.min(1.0, adjustedVelocity));\n            \n            // Apply to motors\n            leftDrive.setPower(adjustedVelocity);\n            rightDrive.setPower(adjustedVelocity);\n            \n            // Telemetry\n            telemetry.addData(\"Target Distance\", \"%.0f mm\", distanceMM);\n            telemetry.addData(\"Current Position\", \"%.0f mm\", averagePosition / COUNTS_PER_MM);\n            telemetry.addData(\"Position Error\", \"%.0f counts\", positionError);\n            telemetry.addData(\"Target Velocity\", \"%.3f\", targetVelocity);\n            telemetry.addData(\"Adjusted Velocity\", \"%.3f\", adjustedVelocity);\n            telemetry.update();\n        }\n        \n        stop();\n    }"
    },
    {
      "type": "text",
      "title": "How Encoder Feedback Works",
      "content": "<p>This enhanced method adds several important features:</p><ul><li><strong>Position Tracking:</strong> We track the actual robot position using encoders</li><li><strong>Error Calculation:</strong> Compare where we are vs where we should be</li><li><strong>Proportional Correction:</strong> Apply a small correction based on the error</li><li><strong>Velocity Clamping:</strong> Ensure the adjusted velocity stays within safe limits</li><li><strong>Enhanced Telemetry:</strong> Display both target and actual values for debugging</li></ul><p>This creates much more precise movement that can adapt to real-world conditions.</p>"
    },
    {
      "type": "text",
      "title": "Integration with Encoders",
      "content": "<p>Combining motion profiling with encoder feedback creates the most precise and reliable autonomous movement. Encoders provide real-time position feedback that can be used to correct any deviations from the planned motion profile.</p><p>Key integration techniques:</p><ul><li><strong>Position Tracking:</strong> Use encoders to track actual robot position</li><li><strong>Error Correction:</strong> Apply small corrections to maintain the planned profile</li><li><strong>Profile Completion:</strong> Use encoder position to determine when movement is complete</li><li><strong>Adaptive Control:</strong> Adjust profile parameters based on actual performance</li></ul>"
    },
    {
      "type": "text",
      "title": "Complete Motion Profile Implementation",
      "content": "<p>Now let's create a comprehensive motion profile system that can handle multiple types of movements. We'll build this step by step.</p>"
    },
    {
      "type": "code",
      "title": "Step 1: Complete OpMode Structure",
      "content": "Let's set up a complete OpMode that can handle both straight movement and turning:",
      "code": "public class CompleteMotionProfile extends LinearOpMode {\n    private DcMotor leftDrive;\n    private DcMotor rightDrive;\n    private ElapsedTime runtime;\n    \n    // Encoder constants\n    private static final double COUNTS_PER_MOTOR_REV = 1440;\n    private static final double WHEEL_DIAMETER_MM = 90.0;\n    private static final double WHEELBASE_MM = 300.0; // Distance between wheels\n    private static final double COUNTS_PER_MM = COUNTS_PER_MOTOR_REV / (WHEEL_DIAMETER_MM * Math.PI);\n    \n    // Motion profile parameters\n    private static final double MAX_VELOCITY = 0.6;\n    private static final double MAX_ACCELERATION = 0.3;\n    \n    @Override\n    public void runOpMode() {\n        // Initialize hardware\n        leftDrive = hardwareMap.get(DcMotor.class, \"left_drive\");\n        rightDrive = hardwareMap.get(DcMotor.class, \"right_drive\");\n        runtime = new ElapsedTime();\n        \n        // Reset encoders\n        leftDrive.setMode(DcMotor.RunMode.STOP_AND_RESET_ENCODER);\n        rightDrive.setMode(DcMotor.RunMode.STOP_AND_RESET_ENCODER);\n        \n        waitForStart();\n        \n        // Execute a sequence of motion profiles\n        driveDistanceWithProfile(500);  // Drive forward 500mm\n        sleep(500);                     // Wait 0.5 seconds\n        turnWithProfile(90);            // Turn 90 degrees\n        sleep(500);                     // Wait 0.5 seconds\n        driveDistanceWithProfile(300);  // Drive forward 300mm\n    }"
    },
    {
      "type": "text",
      "title": "Understanding the Complete Setup",
      "content": "<p>This setup includes all the components needed for a complete motion profile system:</p><ul><li><strong>WHEELBASE_MM:</strong> Distance between the left and right wheels (needed for turning calculations)</li><li><strong>Movement Sequence:</strong> Multiple movements with pauses between them</li><li><strong>Different Movement Types:</strong> Both straight movement and turning</li><li><strong>Timing Control:</strong> Sleep commands to add pauses between movements</li></ul>"
    },
    {
      "type": "code",
      "title": "Step 2: Enhanced Drive Distance Method",
      "content": "Let's implement an enhanced drive distance method with better telemetry:",
      "code": "    private void driveDistanceWithProfile(double distanceMM) {\n        double targetCounts = distanceMM * COUNTS_PER_MM;\n        MotionProfile profile = new MotionProfile(MAX_VELOCITY, MAX_ACCELERATION, targetCounts);\n        \n        runtime.reset();\n        \n        while (opModeIsActive() && !profile.isComplete(runtime.seconds())) {\n            double targetVelocity = profile.getVelocity(runtime.seconds());\n            \n            // Apply to both motors equally\n            leftDrive.setPower(targetVelocity);\n            rightDrive.setPower(targetVelocity);\n            \n            // Enhanced telemetry\n            telemetry.addData(\"Action\", \"Driving Forward\");\n            telemetry.addData(\"Target Distance\", \"%.0f mm\", distanceMM);\n            telemetry.addData(\"Current Velocity\", \"%.3f\", targetVelocity);\n            telemetry.addData(\"Progress\", \"%.1f%%\", (runtime.seconds() / profile.getTotalTime()) * 100);\n            telemetry.update();\n        }\n        \n        stop();\n    }"
    },
    {
      "type": "text",
      "title": "How Enhanced Drive Works",
      "content": "<p>This enhanced drive method includes:</p><ul><li><strong>Progress Tracking:</strong> Shows percentage completion of the movement</li><li><strong>Action Description:</strong> Clear indication of what the robot is doing</li><li><strong>Distance Display:</strong> Shows target distance in millimeters</li><li><strong>Velocity Monitoring:</strong> Displays current velocity for debugging</li><li><strong>Simplified Control:</strong> Both motors get the same velocity for straight movement</li></ul>"
    },
    {
      "type": "code",
      "title": "Step 3: Turn with Profile Method",
      "content": "Now let's implement turning using motion profiles:",
      "code": "    private void turnWithProfile(double degrees) {\n        // Calculate arc distance for turning\n        double arcDistanceMM = (degrees * Math.PI / 180.0) * (WHEELBASE_MM / 2.0);\n        double targetCounts = arcDistanceMM * COUNTS_PER_MM;\n        \n        // Use slightly lower velocity and acceleration for turning\n        MotionProfile profile = new MotionProfile(MAX_VELOCITY * 0.7, MAX_ACCELERATION * 0.7, targetCounts);\n        \n        runtime.reset();\n        \n        while (opModeIsActive() && !profile.isComplete(runtime.seconds())) {\n            double targetVelocity = profile.getVelocity(runtime.seconds());\n            \n            // Apply opposite velocities for turning\n            leftDrive.setPower(targetVelocity);\n            rightDrive.setPower(-targetVelocity);\n            \n            // Enhanced telemetry\n            telemetry.addData(\"Action\", \"Turning\");\n            telemetry.addData(\"Target Angle\", \"%.0f degrees\", degrees);\n            telemetry.addData(\"Current Velocity\", \"%.3f\", targetVelocity);\n            telemetry.addData(\"Progress\", \"%.1f%%\", (runtime.seconds() / profile.getTotalTime()) * 100);\n            telemetry.update();\n        }\n        \n        stop();\n    }"
    },
    {
      "type": "text",
      "title": "How Turn with Profile Works",
      "content": "<p>This turning method includes several important features:</p><ul><li><strong>Arc Distance Calculation:</strong> Converts degrees to distance based on wheelbase</li><li><strong>Reduced Parameters:</strong> Uses 70% of normal velocity/acceleration for smoother turning</li><li><strong>Opposite Velocities:</strong> Left and right motors move in opposite directions</li><li><strong>Angle Display:</strong> Shows target angle in degrees for clarity</li><li><strong>Progress Tracking:</strong> Same progress display as straight movement</li></ul><p>The arc distance calculation is crucial for accurate turning.</p>"
    },
    {
      "type": "code",
      "title": "Step 4: Stop Method",
      "content": "Finally, let's add the stop method:",
      "code": "    private void stop() {\n        leftDrive.setPower(0);\n        rightDrive.setPower(0);\n    }"
    },
    {
      "type": "exercise-box",
      "title": "Practice Exercise: Motion Profile Implementation",
      "description": "Create a motion profile system for your robot:",
      "tasks": [
        "Implement the MotionProfile class with trapezoidal velocity profiles",
        "Create an OpMode that uses motion profiles for forward movement",
        "Add encoder feedback to correct position errors",
        "Implement turning with motion profiles",
        "Create a sequence of movements using motion profiles",
        "Add telemetry to monitor profile progress and performance"
      ],
      "code": "// Start with the MotionProfile class:\npublic class MotionProfile {\n    // Add your motion profile implementation here\n}\n\n// Then create your OpMode:\npublic class PracticeMotionProfile extends LinearOpMode {\n    // Add your hardware initialization and motion profile usage\n}"
    },
    {
      "type": "text",
      "title": "Tuning and Optimization",
      "content": "<p>Motion profiles require careful tuning to work optimally with your specific robot. Here are key parameters to adjust:</p><ul><li><strong>Maximum Velocity:</strong> Start with 0.5-0.7 and adjust based on robot performance</li><li><strong>Maximum Acceleration:</strong> Start with 0.2-0.4 and increase gradually</li><li><strong>Correction Factors:</strong> Small values (0.001-0.01) work best for position correction</li><li><strong>Timing Adjustments:</strong> Fine-tune based on actual robot behavior</li><li><strong>Surface Compensation:</strong> Adjust parameters for different field surfaces</li></ul><p>Always test incrementally and monitor telemetry to ensure smooth operation.</p>"
    },
    {
      "type": "link-grid",
      "title": "Related Topics",
      "links": [
        {
          "title": "Introduction to Manual Pathing",
          "description": "Learn the fundamentals of manual path planning",
          "url": "data/ftc/android-studio/path-planning/custom-pathing/intro-to-manual-pathing.json"
        },
        {
          "title": "Motor Encoders",
          "description": "Understanding encoder feedback and control",
          "url": "data/ftc/onbot-java/motors/motor-encoders.json"
        },
        {
          "title": "Advanced Movement Control",
          "description": "Advanced control theory and techniques",
          "url": "data/ftc/android-studio/advanced-movement-control/advanced-movement-control.json"
        },
        {
          "title": "PID Control",
          "description": "Implementing PID control for precise movement",
          "url": "data/ftc/android-studio/advanced-movement-control/pid-control.json"
        }
      ]
    },
    {
      "type": "text",
      "title": "External Resources",
      "content": "<p>For more information on motion profiling and advanced movement control, check out these resources:</p><ul><li><a href=\"https://gm0.org/en/latest/docs/software/tutorials/motion-profiling.html\" target=\"_blank\">gm0: Motion Profiling</a> - Comprehensive motion profiling guide</li><li><a href=\"https://docs.revrobotics.com/duo-control/programming/autonomous-examples/motion-profiling\" target=\"_blank\">REV Motion Profiling Guide</a> - REV Robotics motion profiling documentation</li><li><a href=\"https://docs.revrobotics.com/duo-control/programming/autonomous-examples/motion-profiling\" target=\"_blank\">REV Trapezoidal Profiles</a> - Detailed trapezoidal profile implementation</li><li><a href=\"https://docs.revrobotics.com/duo-control/programming/autonomous-examples/motion-profiling\" target=\"_blank\">REV Velocity Control</a> - Advanced velocity control techniques</li><li><a href=\"https://gm0.org/en/latest/docs/software/tutorials/encoders.html\" target=\"_blank\">gm0: Encoder Integration</a> - Working with encoders for precise control</li></ul>"
    }
  ]
}
