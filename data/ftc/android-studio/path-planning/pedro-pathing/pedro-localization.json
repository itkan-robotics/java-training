{
  "title": "Pedro Localization",
  "sections": [
    {
      "type": "text",
      "title": "Understanding Robot Localization",
      "content": "<p>Localization is the process of determining where your robot is located on the field at any given time. In autonomous programming, knowing your robot's exact position is crucial for accurate path following and decision-making.</p><p><strong>Why Localization Matters:</strong></p><ul><li><strong>Accurate Path Following:</strong> The robot needs to know where it is to follow paths correctly</li><li><strong>Field Awareness:</strong> Understanding position relative to field elements (game pieces, goals, etc.)</li><li><strong>Error Correction:</strong> Detecting and correcting for drift or positioning errors</li><li><strong>Dynamic Planning:</strong> Adjusting paths based on current position</li></ul><p>Pedro Pathing uses a sophisticated localization system that combines multiple sensors to maintain accurate position tracking throughout autonomous.</p>"
    },
    {
      "type": "text",
      "title": "Relative vs. Absolute Positioning",
      "content": "<p>Understanding the difference between relative and absolute positioning is fundamental to working with localization systems.</p><p><strong>Relative Positioning:</strong> Tracks movement from a starting point without knowing absolute field coordinates. This is what basic encoders provide - they tell you how far you've moved but not where you are on the field.</p><p><strong>Absolute Positioning:</strong> Knows the exact coordinates on the field (like GPS coordinates). Pedro Pathing provides this by combining relative movement data with field coordinate systems.</p><p>Pedro Pathing converts relative movement into absolute positioning, giving you the best of both worlds - accurate movement tracking and field awareness.</p>"
    },
    {
      "type": "emphasis-box",
      "title": "Field Coordinate System",
      "content": "<p>Pedro Pathing uses a standard field coordinate system where:</p><ul><li><strong>Origin (0,0):</strong> Typically the robot's starting position</li><li><strong>X-axis:</strong> Forward/backward movement (positive = forward)</li><li><strong>Y-axis:</strong> Left/right movement (positive = right)</li><li><strong>Heading:</strong> Robot's rotation (0° = forward, 90° = right, etc.)</li></ul><p>This coordinate system makes it easy to plan paths and track position relative to field elements.</p>"
    },
    {
      "type": "text",
      "title": "Pedro's Localization System",
      "content": "<p>Pedro Pathing uses a mathematical approach called \"dead reckoning\" combined with sensor fusion to track robot position. The system integrates data from multiple sources to maintain accurate position information.</p><p><strong>Core Components:</strong></p><ul><li><strong>Encoder Data:</strong> Tracks wheel movement for distance and direction</li><li><strong>IMU Data:</strong> Provides heading information and angular velocity</li><li><strong>Sensor Fusion:</strong> Combines multiple sensor inputs for better accuracy</li><li><strong>Error Correction:</strong> Detects and corrects for sensor drift and errors</li></ul><p>The mathematical foundation uses differential drive kinematics to convert wheel encoder readings into robot position and orientation.</p>"
    },
    {
      "type": "code",
      "title": "Localization Mathematical Concepts",
      "content": "// Understanding the math behind Pedro's localization\npublic class LocalizationMath {\n    \n    // Robot physical parameters\n    private static final double TRACK_WIDTH = 13.5; // inches\n    private static final double WHEEL_DIAMETER = 3.0; // inches\n    private static final double TICKS_PER_REVOLUTION = 537.6;\n    \n    // Calculate distance from encoder ticks\n    public static double ticksToInches(double ticks) {\n        return (ticks / TICKS_PER_REVOLUTION) * (WHEEL_DIAMETER * Math.PI);\n    }\n    \n    // Calculate robot movement from left and right encoder deltas\n    public static RobotMovement calculateMovement(double leftDelta, double rightDelta) {\n        // Convert encoder deltas to distances\n        double leftDistance = ticksToInches(leftDelta);\n        double rightDistance = ticksToInches(rightDelta);\n        \n        // Calculate forward movement (average of left and right)\n        double forward = (leftDistance + rightDistance) / 2.0;\n        \n        // Calculate turning (difference between left and right)\n        double turn = (rightDistance - leftDistance) / TRACK_WIDTH;\n        \n        return new RobotMovement(forward, turn);\n    }\n    \n    // Update position based on movement\n    public static Position updatePosition(Position current, RobotMovement movement, double deltaTime) {\n        double x = current.x;\n        double y = current.y;\n        double heading = current.heading;\n        \n        // Update heading\n        heading += movement.turn;\n        \n        // Update position (assuming small movements)\n        x += movement.forward * Math.cos(heading);\n        y += movement.forward * Math.sin(heading);\n        \n        return new Position(x, y, heading);\n    }\n    \n    // Helper classes\n    public static class RobotMovement {\n        public final double forward;\n        public final double turn;\n        \n        public RobotMovement(double forward, double turn) {\n            this.forward = forward;\n            this.turn = turn;\n        }\n    }\n    \n    public static class Position {\n        public final double x, y, heading;\n        \n        public Position(double x, double y, double heading) {\n            this.x = x;\n            this.y = y;\n            this.heading = heading;\n        }\n    }\n}"
    },
    {
      "type": "text",
      "title": "Setting Up Position Tracking",
      "content": "<p>Proper setup of Pedro's localization system is crucial for accurate position tracking. This involves configuring sensors, setting initial position, and calibrating the system.</p><p><strong>Sensor Configuration:</strong> Pedro needs to know about your robot's encoders, IMU, and physical parameters to accurately track position.</p>"
    },
    {
      "type": "code",
      "title": "Complete Localization Setup",
      "content": "// Complete setup for Pedro localization\npublic class PedroLocalizationSetup extends LinearOpMode {\n    \n    private PedroPathing pedro;\n    private Localization localization;\n    private PathFollower follower;\n    \n    // Hardware configuration\n    private DcMotor leftFront, rightFront, leftBack, rightBack;\n    private DcMotor leftEncoder, rightEncoder, frontEncoder;\n    private IMU imu;\n    \n    @Override\n    public void runOpMode() {\n        // Initialize hardware\n        initializeHardware();\n        \n        // Initialize Pedro Pathing\n        pedro = new PedroPathing(hardwareMap);\n        \n        // Configure robot parameters\n        pedro.setRobotParameters(\n            13.5,   // track width in inches\n            3.0,    // wheel diameter in inches\n            537.6   // encoder ticks per revolution\n        );\n        \n        // Configure motors\n        pedro.configureMotors(\n            \"leftFront\", \"rightFront\", \"leftBack\", \"rightBack\"\n        );\n        \n        // Configure encoders for localization\n        pedro.configureEncoders(\n            \"leftEncoder\", \"rightEncoder\", \"frontEncoder\"\n        );\n        \n        // Configure IMU\n        pedro.configureIMU(\"imu\");\n        \n        // Get localization component\n        localization = pedro.getLocalization();\n        follower = pedro.getPathFollower();\n        \n        // Initialize localization with starting position\n        localization.initialize(0, 0, 0); // Start at origin, facing forward\n        \n        telemetry.addData(\"Status\", \"Localization initialized\");\n        telemetry.update();\n        \n        waitForStart();\n        \n        // Your autonomous code here\n    }\n    \n    private void initializeHardware() {\n        // Initialize motors\n        leftFront = hardwareMap.get(DcMotor.class, \"leftFront\");\n        rightFront = hardwareMap.get(DcMotor.class, \"rightFront\");\n        leftBack = hardwareMap.get(DcMotor.class, \"leftBack\");\n        rightBack = hardwareMap.get(DcMotor.class, \"rightBack\");\n        \n        // Set motor directions\n        leftFront.setDirection(DcMotor.Direction.FORWARD);\n        rightFront.setDirection(DcMotor.Direction.REVERSE);\n        leftBack.setDirection(DcMotor.Direction.FORWARD);\n        rightBack.setDirection(DcMotor.Direction.REVERSE);\n        \n        // Initialize encoders\n        leftEncoder = hardwareMap.get(DcMotor.class, \"leftEncoder\");\n        rightEncoder = hardwareMap.get(DcMotor.class, \"rightEncoder\");\n        frontEncoder = hardwareMap.get(DcMotor.class, \"frontEncoder\");\n        \n        // Initialize IMU\n        imu = hardwareMap.get(IMU.class, \"imu\");\n        \n        // Configure IMU parameters\n        IMU.Parameters parameters = new IMU.Parameters(\n            new RevHubOrientationOnRobot(\n                RevHubOrientationOnRobot.LogoFacingDirection.UP,\n                RevHubOrientationOnRobot.UsbFacingDirection.FORWARD\n            )\n        );\n        imu.initialize(parameters);\n    }\n}"
    },
    {
      "type": "text",
      "title": "Position Tracking During Movement",
      "content": "<p>Once localization is set up, Pedro automatically tracks your robot's position during movement. However, you need to understand how to access this information and handle position updates.</p><p><strong>Getting Current Position:</strong> Pedro provides methods to get the robot's current position, heading, and velocity at any time during autonomous.</p>"
    },
    {
      "type": "code",
      "title": "Accessing Position Information",
      "content": "// Accessing position information during autonomous\npublic class PositionTrackingExample extends LinearOpMode {\n    \n    private PedroPathing pedro;\n    private Localization localization;\n    private PathFollower follower;\n    \n    @Override\n    public void runOpMode() {\n        // Initialize Pedro Pathing (assuming setup from previous example)\n        pedro = new PedroPathing(hardwareMap);\n        // ... configuration code ...\n        \n        localization = pedro.getLocalization();\n        follower = pedro.getPathFollower();\n        \n        // Initialize at starting position\n        localization.initialize(0, 0, 0);\n        \n        waitForStart();\n        \n        // Create a path\n        Path path = pedro.getPathBuilder()\n            .startAt(0, 0)\n            .lineTo(24, 0)\n            .turnTo(90)\n            .lineTo(24, 24)\n            .build();\n        \n        // Follow path while monitoring position\n        boolean pathComplete = follower.followPath(path, new PathFollower.Callback() {\n            @Override\n            public void onPathUpdate() {\n                // This is called periodically during path following\n                updateTelemetry();\n            }\n        });\n        \n        // Final position report\n        updateTelemetry();\n    }\n    \n    private void updateTelemetry() {\n        // Get current position\n        double x = localization.getX();\n        double y = localization.getY();\n        double heading = localization.getHeading();\n        \n        // Get velocity information\n        double velocityX = localization.getVelocityX();\n        double velocityY = localization.getVelocityY();\n        double angularVelocity = localization.getAngularVelocity();\n        \n        // Display position information\n        telemetry.addData(\"Position\", \"X: %.2f, Y: %.2f, Heading: %.1f°\", x, y, Math.toDegrees(heading));\n        telemetry.addData(\"Velocity\", \"X: %.2f, Y: %.2f, Angular: %.2f\", velocityX, velocityY, angularVelocity);\n        telemetry.addData(\"Path Progress\", \"%.1f%%\", follower.getPathProgress() * 100);\n        telemetry.update();\n    }\n}"
    },
    {
      "type": "text",
      "title": "Handling Localization Updates",
      "content": "<p>Pedro's localization system continuously updates position information during movement. Understanding how to handle these updates is important for creating responsive autonomous routines.</p><p><strong>Update Frequency:</strong> Pedro updates position information at a high frequency (typically 50-100 times per second) to ensure smooth path following.</p><p><strong>Position Accuracy:</strong> The system maintains accuracy by combining multiple sensor inputs and applying error correction algorithms.</p>"
    },
    {
      "type": "code",
      "title": "Advanced Position Monitoring",
      "content": "// Advanced position monitoring with error detection\npublic class AdvancedPositionMonitoring extends LinearOpMode {\n    \n    private PedroPathing pedro;\n    private Localization localization;\n    private PathFollower follower;\n    \n    // Position tracking variables\n    private Position lastPosition;\n    private double lastUpdateTime;\n    private static final double POSITION_UPDATE_RATE = 0.02; // 50Hz\n    \n    @Override\n    public void runOpMode() {\n        // Initialize Pedro Pathing\n        pedro = new PedroPathing(hardwareMap);\n        // ... configuration code ...\n        \n        localization = pedro.getLocalization();\n        follower = pedro.getPathFollower();\n        \n        localization.initialize(0, 0, 0);\n        \n        waitForStart();\n        \n        // Create a complex path\n        Path path = createComplexPath();\n        \n        // Follow path with continuous monitoring\n        followPathWithMonitoring(path);\n    }\n    \n    private Path createComplexPath() {\n        return pedro.getPathBuilder()\n            .startAt(0, 0)\n            .lineTo(12, 0)\n            .turnTo(45)\n            .lineTo(24, 12)\n            .turnTo(90)\n            .lineTo(24, 24)\n            .build();\n    }\n    \n    private void followPathWithMonitoring(Path path) {\n        lastUpdateTime = getRuntime();\n        lastPosition = new Position(localization.getX(), localization.getY(), localization.getHeading());\n        \n        boolean pathComplete = follower.followPath(path, new PathFollower.Callback() {\n            @Override\n            public void onPathUpdate() {\n                double currentTime = getRuntime();\n                \n                // Update position at regular intervals\n                if (currentTime - lastUpdateTime >= POSITION_UPDATE_RATE) {\n                    updatePositionMonitoring();\n                    lastUpdateTime = currentTime;\n                }\n            }\n        });\n        \n        // Final position analysis\n        analyzePathCompletion(pathComplete);\n    }\n    \n    private void updatePositionMonitoring() {\n        Position currentPosition = new Position(\n            localization.getX(),\n            localization.getY(),\n            localization.getHeading()\n        );\n        \n        // Calculate movement since last update\n        double deltaX = currentPosition.x - lastPosition.x;\n        double deltaY = currentPosition.y - lastPosition.y;\n        double deltaHeading = currentPosition.heading - lastPosition.heading;\n        \n        // Check for unusual movement (potential errors)\n        if (Math.abs(deltaX) > 2.0 || Math.abs(deltaY) > 2.0) {\n            telemetry.addData(\"Warning\", \"Large position change detected!\");\n        }\n        \n        // Update telemetry\n        telemetry.addData(\"Position\", \"X: %.2f, Y: %.2f, Heading: %.1f°\",\n            currentPosition.x, currentPosition.y, Math.toDegrees(currentPosition.heading));\n        telemetry.addData(\"Movement\", \"ΔX: %.2f, ΔY: %.2f, ΔHeading: %.2f\",\n            deltaX, deltaY, deltaHeading);\n        telemetry.update();\n        \n        lastPosition = currentPosition;\n    }\n    \n    private void analyzePathCompletion(boolean pathComplete) {\n        if (pathComplete) {\n            telemetry.addData(\"Result\", \"Path completed successfully!\");\n            telemetry.addData(\"Final Position\", \"X: %.2f, Y: %.2f, Heading: %.1f°\",\n                localization.getX(), localization.getY(), Math.toDegrees(localization.getHeading()));\n        } else {\n            telemetry.addData(\"Result\", \"Path was interrupted or failed\");\n        }\n        telemetry.update();\n    }\n    \n    private static class Position {\n        final double x, y, heading;\n        \n        Position(double x, double y, double heading) {\n            this.x = x;\n            this.y = y;\n            this.heading = heading;\n        }\n    }\n}"
    },
    {
      "type": "text",
      "title": "Troubleshooting Localization Issues",
      "content": "<p>Localization systems can experience various issues that affect accuracy. Understanding common problems and their solutions is essential for maintaining reliable autonomous performance.</p><p><strong>Common Issues:</strong></p><ul><li><strong>Encoder Drift:</strong> Encoders may report slightly different values over time</li><li><strong>IMU Drift:</strong> Gyroscope heading may drift during long autonomous periods</li><li><strong>Sensor Noise:</strong> Electrical interference can cause sensor readings to fluctuate</li><li><strong>Mechanical Issues:</strong> Wheel slippage, loose connections, or mechanical wear</li></ul>"
    },
    {
      "type": "code",
      "title": "Localization Diagnostics and Troubleshooting",
      "content": "// Diagnostic tools for localization issues\npublic class LocalizationDiagnostics extends LinearOpMode {\n    \n    private PedroPathing pedro;\n    private Localization localization;\n    \n    // Hardware references for diagnostics\n    private DcMotor leftEncoder, rightEncoder, frontEncoder;\n    private IMU imu;\n    \n    @Override\n    public void runOpMode() {\n        // Initialize hardware\n        initializeHardware();\n        \n        // Initialize Pedro Pathing\n        pedro = new PedroPathing(hardwareMap);\n        // ... configuration code ...\n        \n        localization = pedro.getLocalization();\n        \n        telemetry.addData(\"Status\", \"Running localization diagnostics...\");\n        telemetry.update();\n        \n        waitForStart();\n        \n        // Run diagnostic tests\n        runEncoderDiagnostics();\n        runIMUDiagnostics();\n        runPositionTrackingTest();\n        \n        telemetry.addData(\"Status\", \"Diagnostics complete!\");\n        telemetry.update();\n    }\n    \n    private void initializeHardware() {\n        leftEncoder = hardwareMap.get(DcMotor.class, \"leftEncoder\");\n        rightEncoder = hardwareMap.get(DcMotor.class, \"rightEncoder\");\n        frontEncoder = hardwareMap.get(DcMotor.class, \"frontEncoder\");\n        imu = hardwareMap.get(IMU.class, \"imu\");\n    }\n    \n    private void runEncoderDiagnostics() {\n        telemetry.addData(\"=== Encoder Diagnostics ===\", \"\");\n        \n        // Test encoder responsiveness\n        int leftStart = leftEncoder.getCurrentPosition();\n        int rightStart = rightEncoder.getCurrentPosition();\n        int frontStart = frontEncoder.getCurrentPosition();\n        \n        sleep(1000); // Wait 1 second\n        \n        int leftEnd = leftEncoder.getCurrentPosition();\n        int rightEnd = rightEncoder.getCurrentPosition();\n        int frontEnd = frontEncoder.getCurrentPosition();\n        \n        // Check for encoder movement (should be minimal when robot is stationary)\n        int leftDelta = Math.abs(leftEnd - leftStart);\n        int rightDelta = Math.abs(rightEnd - rightStart);\n        int frontDelta = Math.abs(frontEnd - frontStart);\n        \n        telemetry.addData(\"Left Encoder Delta\", leftDelta);\n        telemetry.addData(\"Right Encoder Delta\", rightDelta);\n        telemetry.addData(\"Front Encoder Delta\", frontDelta);\n        \n        // Flag potential issues\n        if (leftDelta > 10 || rightDelta > 10 || frontDelta > 10) {\n            telemetry.addData(\"Warning\", \"Encoder drift detected!\");\n        }\n        \n        telemetry.update();\n        sleep(2000);\n    }\n    \n    private void runIMUDiagnostics() {\n        telemetry.addData(\"=== IMU Diagnostics ===\", \"\");\n        \n        // Test IMU stability\n        double startHeading = imu.getRobotYawPitchRollAngles().getYaw(AngleUnit.DEGREES);\n        \n        sleep(1000); // Wait 1 second\n        \n        double endHeading = imu.getRobotYawPitchRollAngles().getYaw(AngleUnit.DEGREES);\n        double headingDrift = Math.abs(endHeading - startHeading);\n        \n        telemetry.addData(\"IMU Heading Drift\", \"%.2f degrees\", headingDrift);\n        \n        // Check IMU calibration\n        if (headingDrift > 1.0) {\n            telemetry.addData(\"Warning\", \"IMU drift detected! Consider recalibration.\");\n        }\n        \n        // Test angular velocity\n        double angularVelocity = imu.getRobotAngularVelocity(AngleUnit.DEGREES).zRotationRate;\n        telemetry.addData(\"Angular Velocity\", \"%.2f deg/s\", angularVelocity);\n        \n        telemetry.update();\n        sleep(2000);\n    }\n    \n    private void runPositionTrackingTest() {\n        telemetry.addData(\"=== Position Tracking Test ===\", \"\");\n        \n        // Initialize localization\n        localization.initialize(0, 0, 0);\n        \n        // Record initial position\n        double startX = localization.getX();\n        double startY = localization.getY();\n        double startHeading = localization.getHeading();\n        \n        telemetry.addData(\"Initial Position\", \"X: %.2f, Y: %.2f, Heading: %.1f°\",\n            startX, startY, Math.toDegrees(startHeading));\n        \n        // Wait and check for position drift\n        sleep(3000);\n        \n        double endX = localization.getX();\n        double endY = localization.getY();\n        double endHeading = localization.getHeading();\n        \n        double positionDrift = Math.sqrt(Math.pow(endX - startX, 2) + Math.pow(endY - startY, 2));\n        double headingDrift = Math.abs(endHeading - startHeading);\n        \n        telemetry.addData(\"Position Drift\", \"%.2f inches\", positionDrift);\n        telemetry.addData(\"Heading Drift\", \"%.2f degrees\", Math.toDegrees(headingDrift));\n        \n        if (positionDrift > 0.5 || headingDrift > Math.toRadians(1.0)) {\n            telemetry.addData(\"Warning\", \"Significant position drift detected!\");\n        }\n        \n        telemetry.update();\n        sleep(2000);\n    }\n}"
    },
    {
      "type": "exercise-box",
      "title": "Practice: Localization Testing",
      "description": "Test and validate your Pedro localization system",
      "tasks": [
        "Set up Pedro localization with your robot's hardware",
        "Run the diagnostic tests to check for issues",
        "Create a simple square path and monitor position throughout",
        "Compare expected vs. actual final position",
        "Identify and fix any localization issues you find",
        "Test position accuracy with different movement patterns"
      ],
      "content": "// Template for localization testing\npublic class LocalizationTesting extends LinearOpMode {\n    \n    private PedroPathing pedro;\n    private Localization localization;\n    \n    @Override\n    public void runOpMode() {\n        // TODO: Initialize Pedro Pathing and localization\n        \n        waitForStart();\n        \n        // TODO: Run your localization tests here\n        \n        // TODO: Create a test path and monitor position\n        \n        // TODO: Analyze results and identify issues\n    }\n}"
    },
    {
      "type": "text",
      "title": "Best Practices for Localization",
      "content": "<p>Following best practices helps ensure reliable localization performance throughout your autonomous routines.</p><p><strong>Calibration:</strong> Regularly calibrate your IMU and verify encoder accuracy. Pedro provides calibration tools to help with this process.</p><p><strong>Sensor Placement:</strong> Position encoders and IMU to minimize interference and maximize accuracy. Keep sensors away from motors and other electrical components.</p><p><strong>Error Handling:</strong> Always include error detection and recovery mechanisms in your autonomous code. Pedro provides methods to detect and handle localization errors.</p><p><strong>Regular Testing:</strong> Test your localization system regularly, especially after hardware changes or before competitions.</p>"
    },
    {
      "type": "link-grid",
      "title": "Related Topics",
      "content": "<a href=\"#\" onclick=\"loadContent('ftc/path-planning/pedro-pathing/intro-to-pedro-pathing.json')\">Introduction to Pedro Pathing</a><a href=\"#\" onclick=\"loadContent('ftc/path-planning/pedro-pathing/pedro-advanced-configuration.json')\">Pedro Advanced Configuration</a><a href=\"#\" onclick=\"loadContent('ftc/android-studio/odometry/dead-wheel-encoders.json')\">Dead Wheel Encoders</a><a href=\"#\" onclick=\"loadContent('ftc/android-studio/odometry/three-wheel-odometry.json')\">Three Wheel Odometry</a>"
    }
  ]
} 