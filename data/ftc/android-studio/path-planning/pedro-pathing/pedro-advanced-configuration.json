{
  "title": "Pedro Advanced Configuration",
  "sections": [
    {
      "type": "text",
      "title": "Advanced Path Building Techniques",
      "content": "<p>Once you're comfortable with basic Pedro Pathing, you can create sophisticated autonomous routines using advanced path building techniques. These techniques allow you to create complex, multi-segment trajectories that can handle real-world FTC scenarios.</p><p><strong>Advanced Features:</strong></p><ul><li><strong>Complex Path Segments:</strong> Combine multiple movement types in a single path</li><li><strong>Conditional Paths:</strong> Create paths that change based on sensor input</li><li><strong>Dynamic Path Modification:</strong> Adjust paths in real-time based on field conditions</li><li><strong>Path Optimization:</strong> Create efficient paths that minimize time and energy</li></ul><p>These advanced techniques enable you to create autonomous routines that can adapt to changing field conditions and optimize performance.</p>"
    },
    {
      "type": "code",
      "title": "Complex Multi-Segment Paths",
      "content": "// Creating complex paths with multiple segments\npublic class AdvancedPathBuilding extends LinearOpMode {\n    \n    private PedroPathing pedro;\n    private PathBuilder pathBuilder;\n    private PathFollower follower;\n    \n    @Override\n    public void runOpMode() {\n        // Initialize Pedro Pathing\n        pedro = new PedroPathing(hardwareMap);\n        // ... configuration code ...\n        \n        pathBuilder = pedro.getPathBuilder();\n        follower = pedro.getPathFollower();\n        \n        waitForStart();\n        \n        // Create a complex path with multiple segments\n        Path complexPath = createComplexPath();\n        \n        // Follow the complex path\n        boolean success = follower.followPath(complexPath);\n        \n        if (success) {\n            telemetry.addData(\"Status\", \"Complex path completed successfully!\");\n        } else {\n            telemetry.addData(\"Status\", \"Path was interrupted\");\n        }\n        telemetry.update();\n    }\n    \n    private Path createComplexPath() {\n        return pathBuilder\n            .startAt(0, 0)\n            // First segment: Move to game element\n            .lineTo(18, 0)\n            .turnTo(45)\n            .lineTo(24, 6)\n            // Second segment: Collect game element\n            .pause(0.5)  // Pause to collect\n            .turnTo(90)\n            .lineTo(24, 18)\n            // Third segment: Deliver to scoring area\n            .turnTo(180)\n            .lineTo(6, 18)\n            .turnTo(270)\n            .lineTo(6, 24)\n            // Fourth segment: Return to starting area\n            .turnTo(0)\n            .lineTo(0, 24)\n            .turnTo(90)\n            .lineTo(0, 0)\n            .build();\n    }\n}"
    },
    {
      "type": "code",
      "title": "Conditional Path Building",
      "content": "// Creating paths that change based on conditions\npublic class ConditionalPathBuilding extends LinearOpMode {\n    \n    private PedroPathing pedro;\n    private PathBuilder pathBuilder;\n    private PathFollower follower;\n    \n    // Sensors for conditional logic\n    private ColorSensor colorSensor;\n    private DistanceSensor distanceSensor;\n    \n    @Override\n    public void runOpMode() {\n        // Initialize Pedro Pathing\n        pedro = new PedroPathing(hardwareMap);\n        // ... configuration code ...\n        \n        pathBuilder = pedro.getPathBuilder();\n        follower = pedro.getPathFollower();\n        \n        // Initialize sensors\n        colorSensor = hardwareMap.get(ColorSensor.class, \"colorSensor\");\n        distanceSensor = hardwareMap.get(DistanceSensor.class, \"distanceSensor\");\n        \n        waitForStart();\n        \n        // Create conditional path based on sensor input\n        Path conditionalPath = createConditionalPath();\n        \n        follower.followPath(conditionalPath);\n    }\n    \n    private Path createConditionalPath() {\n        // Check distance to obstacle\n        double distance = distanceSensor.getDistance(DistanceUnit.INCH);\n        \n        if (distance < 6.0) {\n            // Obstacle detected - take alternative path\n            telemetry.addData(\"Path Choice\", \"Alternative path (obstacle detected)\");\n            return pathBuilder\n                .startAt(0, 0)\n                .lineTo(12, 0)\n                .turnTo(90)\n                .lineTo(12, 12)\n                .turnTo(0)\n                .lineTo(24, 12)\n                .build();\n        } else {\n            // No obstacle - take direct path\n            telemetry.addData(\"Path Choice\", \"Direct path (no obstacles)\");\n            return pathBuilder\n                .startAt(0, 0)\n                .lineTo(24, 0)\n                .build();\n        }\n    }\n    \n    private Path createColorBasedPath() {\n        // Check color sensor\n        int red = colorSensor.red();\n        int blue = colorSensor.blue();\n        \n        if (red > blue) {\n            // Red detected - go to red scoring area\n            return pathBuilder\n                .startAt(0, 0)\n                .lineTo(0, 24)\n                .build();\n        } else {\n            // Blue detected - go to blue scoring area\n            return pathBuilder\n                .startAt(0, 0)\n                .lineTo(24, 0)\n                .build();\n        }\n    }\n}"
    },
    {
      "type": "text",
      "title": "Custom Path Following Algorithms",
      "content": "<p>Pedro Pathing allows you to customize how the robot follows paths. Different following algorithms can be more suitable for different robots or scenarios.</p><p><strong>Following Algorithm Types:</strong></p><ul><li><strong>Pure Pursuit:</strong> Looks ahead on the path and follows a point ahead of the robot</li><li><strong>PID Following:</strong> Uses PID control to maintain position on the path</li><li><strong>Adaptive Following:</strong> Adjusts following parameters based on path curvature</li><li><strong>Custom Algorithms:</strong> Create your own following logic for specific needs</li></ul><p>Choosing the right following algorithm can significantly improve path following accuracy and smoothness.</p>"
    },
    {
      "type": "code",
      "title": "Custom Path Following Implementation",
      "content": "// Implementing custom path following algorithms\npublic class CustomPathFollowing extends LinearOpMode {\n    \n    private PedroPathing pedro;\n    private PathFollower follower;\n    private Localization localization;\n    \n    // PID controllers for custom following\n    private PIDController xPID, yPID, headingPID;\n    \n    @Override\n    public void runOpMode() {\n        // Initialize Pedro Pathing\n        pedro = new PedroPathing(hardwareMap);\n        // ... configuration code ...\n        \n        follower = pedro.getPathFollower();\n        localization = pedro.getLocalization();\n        \n        // Initialize PID controllers\n        initializePIDControllers();\n        \n        waitForStart();\n        \n        // Create a path\n        Path path = pedro.getPathBuilder()\n            .startAt(0, 0)\n            .lineTo(24, 0)\n            .turnTo(90)\n            .lineTo(24, 24)\n            .build();\n        \n        // Follow path with custom algorithm\n        followPathWithCustomAlgorithm(path);\n    }\n    \n    private void initializePIDControllers() {\n        // X-axis PID controller\n        xPID = new PIDController(0.1, 0.0, 0.01);\n        xPID.setTolerance(0.5); // 0.5 inch tolerance\n        \n        // Y-axis PID controller\n        yPID = new PIDController(0.1, 0.0, 0.01);\n        yPID.setTolerance(0.5);\n        \n        // Heading PID controller\n        headingPID = new PIDController(0.05, 0.0, 0.005);\n        headingPID.setTolerance(Math.toRadians(2.0)); // 2 degree tolerance\n    }\n    \n    private void followPathWithCustomAlgorithm(Path path) {\n        // Get path waypoints\n        List<PathWaypoint> waypoints = path.getWaypoints();\n        int currentWaypoint = 0;\n        \n        while (currentWaypoint < waypoints.size() && opModeIsActive()) {\n            PathWaypoint target = waypoints.get(currentWaypoint);\n            \n            // Get current position\n            double currentX = localization.getX();\n            double currentY = localization.getY();\n            double currentHeading = localization.getHeading();\n            \n            // Calculate errors\n            double xError = target.x - currentX;\n            double yError = target.y - currentY;\n            double headingError = target.heading - currentHeading;\n            \n            // Normalize heading error\n            while (headingError > Math.PI) headingError -= 2 * Math.PI;\n            while (headingError < -Math.PI) headingError += 2 * Math.PI;\n            \n            // Calculate PID outputs\n            double xOutput = xPID.calculate(currentX, target.x);\n            double yOutput = yPID.calculate(currentY, target.y);\n            double headingOutput = headingPID.calculate(currentHeading, target.heading);\n            \n            // Apply motor commands\n            applyMotorCommands(xOutput, yOutput, headingOutput);\n            \n            // Check if waypoint reached\n            double distanceToTarget = Math.sqrt(xError * xError + yError * yError);\n            if (distanceToTarget < 1.0 && Math.abs(headingError) < Math.toRadians(5.0)) {\n                currentWaypoint++;\n                telemetry.addData(\"Waypoint Reached\", \"%d/%d\", currentWaypoint, waypoints.size());\n            }\n            \n            // Update telemetry\n            updateTelemetry(currentX, currentY, currentHeading, target);\n            \n            sleep(20); // 50Hz control loop\n        }\n        \n        // Stop motors\n        stopMotors();\n    }\n    \n    private void applyMotorCommands(double xOutput, double yOutput, double headingOutput) {\n        // Convert to motor commands (simplified example)\n        double leftPower = xOutput + yOutput - headingOutput;\n        double rightPower = xOutput + yOutput + headingOutput;\n        \n        // Clamp to valid range\n        leftPower = Math.max(-1.0, Math.min(1.0, leftPower));\n        rightPower = Math.max(-1.0, Math.min(1.0, rightPower));\n        \n        // Apply to motors (assuming you have motor references)\n        // leftMotor.setPower(leftPower);\n        // rightMotor.setPower(rightPower);\n    }\n    \n    private void updateTelemetry(double x, double y, double heading, PathWaypoint target) {\n        telemetry.addData(\"Current Position\", \"X: %.2f, Y: %.2f, Heading: %.1f°\",\n            x, y, Math.toDegrees(heading));\n        telemetry.addData(\"Target Position\", \"X: %.2f, Y: %.2f, Heading: %.1f°\",\n            target.x, target.y, Math.toDegrees(target.heading));\n        telemetry.update();\n    }\n    \n    private void stopMotors() {\n        // Stop all motors\n        // leftMotor.setPower(0);\n        // rightMotor.setPower(0);\n    }\n    \n    // Helper class for path waypoints\n    private static class PathWaypoint {\n        final double x, y, heading;\n        \n        PathWaypoint(double x, double y, double heading) {\n            this.x = x;\n            this.y = y;\n            this.heading = heading;\n        }\n    }\n}"
    },
    {
      "type": "text",
      "title": "Performance Optimization",
      "content": "<p>Optimizing Pedro Pathing performance is crucial for creating fast, reliable autonomous routines. Performance optimization involves reducing computational overhead and improving path execution speed.</p><p><strong>Optimization Areas:</strong></p><ul><li><strong>Path Simplification:</strong> Reduce unnecessary waypoints while maintaining accuracy</li><li><strong>Control Loop Optimization:</strong> Optimize the frequency and efficiency of control loops</li><li><strong>Memory Management:</strong> Efficiently manage memory usage during path execution</li><li><strong>Sensor Reading Optimization:</strong> Optimize how and when sensor data is read</li></ul>"
    },
    {
      "type": "code",
      "title": "Performance Optimization Techniques",
      "content": "// Performance optimization examples\npublic class PerformanceOptimization extends LinearOpMode {\n    \n    private PedroPathing pedro;\n    private PathFollower follower;\n    private Localization localization;\n    \n    // Performance monitoring variables\n    private long lastUpdateTime;\n    private int updateCount;\n    private double averageUpdateTime;\n    \n    @Override\n    public void runOpMode() {\n        // Initialize Pedro Pathing\n        pedro = new PedroPathing(hardwareMap);\n        // ... configuration code ...\n        \n        follower = pedro.getPathFollower();\n        localization = pedro.getLocalization();\n        \n        waitForStart();\n        \n        // Create optimized path\n        Path optimizedPath = createOptimizedPath();\n        \n        // Follow path with performance monitoring\n        followPathWithOptimization(optimizedPath);\n        \n        // Report performance metrics\n        reportPerformanceMetrics();\n    }\n    \n    private Path createOptimizedPath() {\n        // Use path simplification to reduce waypoints\n        return pedro.getPathBuilder()\n            .startAt(0, 0)\n            // Combine multiple movements into fewer waypoints\n            .lineTo(24, 0)\n            .turnTo(90)\n            .lineTo(24, 24)\n            .turnTo(180)\n            .lineTo(0, 24)\n            .turnTo(270)\n            .lineTo(0, 0)\n            .build()\n            .simplify(0.5); // Simplify path with 0.5 inch tolerance\n    }\n    \n    private void followPathWithOptimization(Path path) {\n        lastUpdateTime = System.nanoTime();\n        updateCount = 0;\n        \n        boolean pathComplete = follower.followPath(path, new PathFollower.Callback() {\n            @Override\n            public void onPathUpdate() {\n                // Optimize update frequency\n                long currentTime = System.nanoTime();\n                long deltaTime = currentTime - lastUpdateTime;\n                \n                // Only update every 20ms (50Hz) for optimal performance\n                if (deltaTime >= 20_000_000) { // 20ms in nanoseconds\n                    updatePerformanceMetrics(deltaTime);\n                    lastUpdateTime = currentTime;\n                }\n            }\n        });\n        \n        if (pathComplete) {\n            telemetry.addData(\"Status\", \"Optimized path completed!\");\n        }\n    }\n    \n    private void updatePerformanceMetrics(long deltaTime) {\n        updateCount++;\n        \n        // Calculate running average of update time\n        averageUpdateTime = ((averageUpdateTime * (updateCount - 1)) + deltaTime) / updateCount;\n        \n        // Update telemetry less frequently to reduce overhead\n        if (updateCount % 10 == 0) {\n            telemetry.addData(\"Performance\", \"Avg Update Time: %.2f ms\", averageUpdateTime / 1_000_000.0);\n            telemetry.addData(\"Update Count\", updateCount);\n            telemetry.update();\n        }\n    }\n    \n    private void reportPerformanceMetrics() {\n        telemetry.addData(\"=== Performance Report ===\", \"\");\n        telemetry.addData(\"Total Updates\", updateCount);\n        telemetry.addData(\"Average Update Time\", \"%.2f ms\", averageUpdateTime / 1_000_000.0);\n        telemetry.addData(\"Update Frequency\", \"%.1f Hz\", 1_000_000_000.0 / averageUpdateTime);\n        \n        // Performance recommendations\n        if (averageUpdateTime > 25_000_000) { // > 25ms\n            telemetry.addData(\"Recommendation\", \"Consider reducing update frequency or simplifying path\");\n        } else if (averageUpdateTime < 15_000_000) { // < 15ms\n            telemetry.addData(\"Recommendation\", \"Good performance! Can increase update frequency if needed\");\n        } else {\n            telemetry.addData(\"Recommendation\", \"Optimal performance achieved\");\n        }\n        \n        telemetry.update();\n        sleep(3000);\n    }\n}"
    },
    {
      "type": "text",
      "title": "Integration with Vision Systems",
      "content": "<p>Combining Pedro Pathing with vision systems creates powerful autonomous routines that can adapt to real-time field conditions. Vision integration allows your robot to modify paths based on what it sees.</p><p><strong>Vision Integration Benefits:</strong></p><ul><li><strong>Dynamic Path Modification:</strong> Change paths based on detected game elements</li><li><strong>Obstacle Avoidance:</strong> Detect and avoid obstacles in real-time</li><li><strong>Precise Positioning:</strong> Use vision targets for accurate positioning</li><li><strong>Game Element Detection:</strong> Identify and interact with game-specific elements</li></ul>"
    },
    {
      "type": "code",
      "title": "Vision Integration with Pedro Pathing",
      "content": "// Integrating vision systems with Pedro Pathing\npublic class VisionIntegration extends LinearOpMode {\n    \n    private PedroPathing pedro;\n    private PathFollower follower;\n    private Localization localization;\n    \n    // Vision components\n    private Webcam webcam;\n    private OpenCvCamera camera;\n    private AprilTagDetectionPipeline aprilTagPipeline;\n    \n    @Override\n    public void runOpMode() {\n        // Initialize Pedro Pathing\n        pedro = new PedroPathing(hardwareMap);\n        // ... configuration code ...\n        \n        follower = pedro.getPathFollower();\n        localization = pedro.getLocalization();\n        \n        // Initialize vision system\n        initializeVisionSystem();\n        \n        waitForStart();\n        \n        // Create vision-based autonomous routine\n        runVisionBasedAutonomous();\n    }\n    \n    private void initializeVisionSystem() {\n        // Initialize webcam\n        webcam = hardwareMap.get(Webcam.class, \"webcam\");\n        \n        // Create AprilTag detection pipeline\n        aprilTagPipeline = new AprilTagDetectionPipeline(\n            0.166, // Tag size in meters\n            578.272, // fx\n            578.272, // fy\n            402.145, // cx\n            221.506  // cy\n        );\n        \n        // Set camera pipeline\n        webcam.setPipeline(aprilTagPipeline);\n        webcam.openCameraDeviceAsync(new OpenCvCamera.AsyncCameraOpenListener() {\n            @Override\n            public void onOpened() {\n                webcam.startStreaming(640, 480, OpenCvCameraRotation.UPRIGHT);\n            }\n            \n            @Override\n            public void onError(int errorCode) {\n                telemetry.addData(\"Camera Error\", \"Error code: \" + errorCode);\n            }\n        });\n    }\n    \n    private void runVisionBasedAutonomous() {\n        // Start with basic path\n        Path basePath = pedro.getPathBuilder()\n            .startAt(0, 0)\n            .lineTo(24, 0)\n            .build();\n        \n        // Follow path while monitoring vision\n        boolean pathComplete = follower.followPath(basePath, new PathFollower.Callback() {\n            @Override\n            public void onPathUpdate() {\n                // Check for AprilTags\n                List<AprilTagDetection> detections = aprilTagPipeline.getLatestDetections();\n                \n                if (detections.size() > 0) {\n                    // Vision target detected - modify path\n                    AprilTagDetection detection = detections.get(0);\n                    modifyPathForVisionTarget(detection);\n                }\n            }\n        });\n        \n        if (pathComplete) {\n            telemetry.addData(\"Status\", \"Vision-based autonomous completed!\");\n        }\n    }\n    \n    private void modifyPathForVisionTarget(AprilTagDetection detection) {\n        // Get target position from AprilTag\n        double targetX = detection.pose.x;\n        double targetY = detection.pose.y;\n        \n        // Get current robot position\n        double currentX = localization.getX();\n        double currentY = localization.getY();\n        \n        // Calculate path to target\n        Path visionPath = pedro.getPathBuilder()\n            .startAt(currentX, currentY)\n            .lineTo(targetX, targetY)\n            .build();\n        \n        // Interrupt current path and follow vision path\n        follower.interruptPath();\n        follower.followPath(visionPath);\n        \n        telemetry.addData(\"Vision Target\", \"Detected AprilTag ID: \" + detection.id);\n        telemetry.addData(\"Target Position\", \"X: %.2f, Y: %.2f\", targetX, targetY);\n        telemetry.update();\n    }\n    \n    // AprilTag detection pipeline (simplified)\n    private static class AprilTagDetectionPipeline extends OpenCvPipeline {\n        private List<AprilTagDetection> detections;\n        \n        public AprilTagDetectionPipeline(double tagSize, double fx, double fy, double cx, double cy) {\n            // Initialize AprilTag detector\n            detections = new ArrayList<>();\n        }\n        \n        @Override\n        public Mat processFrame(Mat input) {\n            // Process frame for AprilTag detection\n            // This is a simplified version - actual implementation would use AprilTag library\n            return input;\n        }\n        \n        public List<AprilTagDetection> getLatestDetections() {\n            return detections;\n        }\n    }\n    \n    // Simplified AprilTag detection class\n    private static class AprilTagDetection {\n        public int id;\n        public AprilTagPose pose;\n    }\n    \n    private static class AprilTagPose {\n        public double x, y, z;\n    }\n}"
    },
    {
      "type": "text",
      "title": "Advanced Error Handling and Recovery",
      "content": "<p>Robust autonomous routines must handle unexpected situations gracefully. Pedro Pathing provides comprehensive error handling and recovery mechanisms.</p><p><strong>Common Error Scenarios:</strong></p><ul><li><strong>Path Following Failures:</strong> Robot gets stuck or deviates significantly from path</li><li><strong>Sensor Failures:</strong> Encoders or IMU stop providing accurate data</li><li><strong>Hardware Issues:</strong> Motors fail or mechanical problems occur</li><li><strong>Environmental Issues:</strong> Obstacles or unexpected field conditions</li></ul><p>Implementing proper error handling ensures your autonomous routine can recover from problems and complete its mission.</p>"
    },
    {
      "type": "code",
      "title": "Advanced Error Handling Implementation",
      "content": "// Comprehensive error handling and recovery\npublic class AdvancedErrorHandling extends LinearOpMode {\n    \n    private PedroPathing pedro;\n    private PathFollower follower;\n    private Localization localization;\n    \n    // Error handling variables\n    private int errorCount = 0;\n    private static final int MAX_ERRORS = 3;\n    private boolean recoveryMode = false;\n    \n    @Override\n    public void runOpMode() {\n        // Initialize Pedro Pathing\n        pedro = new PedroPathing(hardwareMap);\n        // ... configuration code ...\n        \n        follower = pedro.getPathFollower();\n        localization = pedro.getLocalization();\n        \n        waitForStart();\n        \n        // Create path with error handling\n        Path path = createPathWithErrorHandling();\n        \n        // Follow path with comprehensive error handling\n        followPathWithErrorHandling(path);\n    }\n    \n    private Path createPathWithErrorHandling() {\n        return pedro.getPathBuilder()\n            .startAt(0, 0)\n            .lineTo(24, 0)\n            .turnTo(90)\n            .lineTo(24, 24)\n            .build();\n    }\n    \n    private void followPathWithErrorHandling(Path path) {\n        boolean pathComplete = false;\n        \n        while (!pathComplete && errorCount < MAX_ERRORS && opModeIsActive()) {\n            try {\n                // Attempt to follow path\n                pathComplete = follower.followPath(path, new PathFollower.Callback() {\n                    @Override\n                    public void onPathUpdate() {\n                        // Monitor for potential errors\n                        if (detectPathFollowingError()) {\n                            throw new PathFollowingException(\"Path following error detected\");\n                        }\n                        \n                        // Monitor sensor health\n                        if (detectSensorError()) {\n                            throw new SensorException(\"Sensor error detected\");\n                        }\n                        \n                        // Update telemetry\n                        updateErrorHandlingTelemetry();\n                    }\n                });\n                \n            } catch (PathFollowingException e) {\n                handlePathFollowingError(e);\n            } catch (SensorException e) {\n                handleSensorError(e);\n            } catch (Exception e) {\n                handleGeneralError(e);\n            }\n        }\n        \n        // Final status report\n        reportFinalStatus(pathComplete);\n    }\n    \n    private boolean detectPathFollowingError() {\n        // Check if robot is significantly off path\n        double pathError = follower.getPathError();\n        return pathError > 3.0; // More than 3 inches off path\n    }\n    \n    private boolean detectSensorError() {\n        // Check sensor health\n        double x = localization.getX();\n        double y = localization.getY();\n        double heading = localization.getHeading();\n        \n        // Check for NaN or infinite values\n        return Double.isNaN(x) || Double.isNaN(y) || Double.isNaN(heading) ||\n               Double.isInfinite(x) || Double.isInfinite(y) || Double.isInfinite(heading);\n    }\n    \n    private void handlePathFollowingError(PathFollowingException e) {\n        errorCount++;\n        telemetry.addData(\"Error\", \"Path following error: \" + e.getMessage());\n        telemetry.addData(\"Error Count\", \"%d/%d\", errorCount, MAX_ERRORS);\n        \n        if (errorCount < MAX_ERRORS) {\n            // Attempt recovery\n            attemptPathRecovery();\n        } else {\n            telemetry.addData(\"Status\", \"Max errors reached - stopping\");\n        }\n        \n        telemetry.update();\n        sleep(1000);\n    }\n    \n    private void handleSensorError(SensorException e) {\n        errorCount++;\n        telemetry.addData(\"Error\", \"Sensor error: \" + e.getMessage());\n        telemetry.addData(\"Error Count\", \"%d/%d\", errorCount, MAX_ERRORS);\n        \n        if (errorCount < MAX_ERRORS) {\n            // Attempt sensor recovery\n            attemptSensorRecovery();\n        }\n        \n        telemetry.update();\n        sleep(1000);\n    }\n    \n    private void handleGeneralError(Exception e) {\n        errorCount++;\n        telemetry.addData(\"Error\", \"General error: \" + e.getMessage());\n        telemetry.addData(\"Error Count\", \"%d/%d\", errorCount, MAX_ERRORS);\n        \n        telemetry.update();\n        sleep(1000);\n    }\n    \n    private void attemptPathRecovery() {\n        telemetry.addData(\"Recovery\", \"Attempting path recovery...\");\n        \n        // Stop current movement\n        follower.interruptPath();\n        \n        // Get current position\n        double currentX = localization.getX();\n        double currentY = localization.getY();\n        \n        // Create recovery path back to original path\n        Path recoveryPath = pedro.getPathBuilder()\n            .startAt(currentX, currentY)\n            .lineTo(24, 0) // Return to original path\n            .build();\n        \n        // Follow recovery path\n        follower.followPath(recoveryPath);\n        \n        telemetry.addData(\"Recovery\", \"Path recovery completed\");\n    }\n    \n    private void attemptSensorRecovery() {\n        telemetry.addData(\"Recovery\", \"Attempting sensor recovery...\");\n        \n        // Reinitialize localization\n        localization.initialize(localization.getX(), localization.getY(), localization.getHeading());\n        \n        telemetry.addData(\"Recovery\", \"Sensor recovery completed\");\n    }\n    \n    private void updateErrorHandlingTelemetry() {\n        telemetry.addData(\"Error Count\", errorCount);\n        telemetry.addData(\"Recovery Mode\", recoveryMode);\n        telemetry.addData(\"Path Error\", \"%.2f inches\", follower.getPathError());\n        telemetry.update();\n    }\n    \n    private void reportFinalStatus(boolean pathComplete) {\n        if (pathComplete) {\n            telemetry.addData(\"Final Status\", \"Path completed successfully!\");\n        } else if (errorCount >= MAX_ERRORS) {\n            telemetry.addData(\"Final Status\", \"Path failed due to too many errors\");\n        } else {\n            telemetry.addData(\"Final Status\", \"Path was interrupted\");\n        }\n        \n        telemetry.addData(\"Total Errors\", errorCount);\n        telemetry.update();\n        sleep(3000);\n    }\n    \n    // Custom exception classes\n    private static class PathFollowingException extends Exception {\n        public PathFollowingException(String message) {\n            super(message);\n        }\n    }\n    \n    private static class SensorException extends Exception {\n        public SensorException(String message) {\n            super(message);\n        }\n    }\n}"
    },
    {
      "type": "text",
      "title": "Custom Pedro Extensions",
      "content": "<p>Pedro Pathing is designed to be extensible, allowing you to create custom components for team-specific requirements. This includes custom path builders, followers, and utilities.</p><p><strong>Extension Types:</strong></p><ul><li><strong>Custom Path Builders:</strong> Create specialized path building logic for your robot</li><li><strong>Custom Followers:</strong> Implement robot-specific following algorithms</li><li><strong>Custom Utilities:</strong> Add helper functions and utilities</li><li><strong>Custom Sensors:</strong> Integrate team-specific sensors with Pedro</li></ul><p>Creating custom extensions allows you to tailor Pedro Pathing to your specific robot design and competition requirements.</p>"
    },
    {
      "type": "code",
      "title": "Custom Pedro Extension Examples",
      "content": "// Examples of custom Pedro extensions\npublic class CustomPedroExtensions extends LinearOpMode {\n    \n    private PedroPathing pedro;\n    private CustomPathBuilder customPathBuilder;\n    private CustomPathFollower customFollower;\n    \n    @Override\n    public void runOpMode() {\n        // Initialize Pedro Pathing\n        pedro = new PedroPathing(hardwareMap);\n        // ... configuration code ...\n        \n        // Create custom extensions\n        customPathBuilder = new CustomPathBuilder(pedro);\n        customFollower = new CustomPathFollower(pedro);\n        \n        waitForStart();\n        \n        // Use custom extensions\n        Path customPath = customPathBuilder.createTeamSpecificPath();\n        customFollower.followPathWithCustomLogic(customPath);\n    }\n}\n\n// Custom path builder for team-specific requirements\nclass CustomPathBuilder {\n    private PedroPathing pedro;\n    private PathBuilder basePathBuilder;\n    \n    public CustomPathBuilder(PedroPathing pedro) {\n        this.pedro = pedro;\n        this.basePathBuilder = pedro.getPathBuilder();\n    }\n    \n    // Create a path optimized for your robot's specific capabilities\n    public Path createTeamSpecificPath() {\n        return basePathBuilder\n            .startAt(0, 0)\n            // Add team-specific waypoints\n            .lineTo(18, 0)\n            .customTurn(45, 0.5) // Custom turn with specific parameters\n            .lineTo(24, 6)\n            .build();\n    }\n    \n    // Create a path that accounts for your robot's turning radius\n    public Path createTurningRadiusOptimizedPath() {\n        double minTurningRadius = 8.0; // inches\n        \n        return basePathBuilder\n            .startAt(0, 0)\n            .lineTo(12, 0)\n            .arcTurn(90, minTurningRadius) // Use arc turn instead of point turn\n            .lineTo(12, 12)\n            .build();\n    }\n}\n\n// Custom path follower with team-specific logic\nclass CustomPathFollower {\n    private PedroPathing pedro;\n    private PathFollower baseFollower;\n    private Localization localization;\n    \n    public CustomPathFollower(PedroPathing pedro) {\n        this.pedro = pedro;\n        this.baseFollower = pedro.getPathFollower();\n        this.localization = pedro.getLocalization();\n    }\n    \n    // Follow path with custom logic for your robot\n    public boolean followPathWithCustomLogic(Path path) {\n        // Add custom pre-processing\n        Path processedPath = preprocessPath(path);\n        \n        // Follow path with custom monitoring\n        boolean success = baseFollower.followPath(processedPath, new PathFollower.Callback() {\n            @Override\n            public void onPathUpdate() {\n                // Add custom monitoring logic\n                monitorRobotHealth();\n                adjustForRobotCharacteristics();\n            }\n        });\n        \n        // Add custom post-processing\n        postProcessPathCompletion(success);\n        \n        return success;\n    }\n    \n    private Path preprocessPath(Path originalPath) {\n        // Add custom path preprocessing logic\n        // For example, adjust waypoints based on robot characteristics\n        return originalPath;\n    }\n    \n    private void monitorRobotHealth() {\n        // Monitor robot health during path following\n        double batteryVoltage = getBatteryVoltage();\n        if (batteryVoltage < 11.0) {\n            // Reduce speed if battery is low\n            adjustSpeedForBattery(batteryVoltage);\n        }\n    }\n    \n    private void adjustForRobotCharacteristics() {\n        // Adjust path following based on robot characteristics\n        // For example, adjust for wheel wear, motor performance, etc.\n    }\n    \n    private void postProcessPathCompletion(boolean success) {\n        // Add custom post-processing logic\n        if (success) {\n            // Log successful completion\n            logPathCompletion();\n        } else {\n            // Handle failed completion\n            handlePathFailure();\n        }\n    }\n    \n    // Helper methods\n    private double getBatteryVoltage() {\n        // Get battery voltage (implementation depends on your setup)\n        return 12.0; // Placeholder\n    }\n    \n    private void adjustSpeedForBattery(double voltage) {\n        // Adjust speed based on battery voltage\n        double speedMultiplier = Math.min(1.0, voltage / 12.0);\n        // Apply speed adjustment to motors\n    }\n    \n    private void logPathCompletion() {\n        // Log path completion for analysis\n        System.out.println(\"Path completed successfully at \" + System.currentTimeMillis());\n    }\n    \n    private void handlePathFailure() {\n        // Handle path failure\n        System.out.println(\"Path failed at \" + System.currentTimeMillis());\n    }\n}"
    },
    {
      "type": "exercise-box",
      "title": "Practice: Advanced Pedro Configuration",
      "description": "Implement advanced Pedro Pathing features in your autonomous routine",
      "tasks": [
        "Create a complex multi-segment path with conditional logic",
        "Implement custom path following with PID control",
        "Add vision integration to modify paths based on detected targets",
        "Implement comprehensive error handling and recovery",
        "Create a custom extension for your robot's specific needs",
        "Test and optimize the performance of your advanced configuration"
      ],
      "content": "// Template for advanced Pedro configuration practice\npublic class AdvancedPedroPractice extends LinearOpMode {\n    \n    private PedroPathing pedro;\n    private PathFollower follower;\n    private Localization localization;\n    \n    @Override\n    public void runOpMode() {\n        // TODO: Initialize Pedro Pathing with advanced configuration\n        \n        waitForStart();\n        \n        // TODO: Implement your advanced Pedro features here\n        \n        // TODO: Add vision integration\n        \n        // TODO: Implement error handling\n        \n        // TODO: Create custom extensions\n        \n        // TODO: Test and optimize performance\n    }\n}"
    },
    {
      "type": "text",
      "title": "Advanced Configuration Best Practices",
      "content": "<p>When implementing advanced Pedro Pathing features, follow these best practices to ensure reliable and maintainable code.</p><p><strong>Code Organization:</strong> Keep your advanced Pedro code well-organized with clear separation of concerns. Use separate classes for different functionality.</p><p><strong>Error Handling:</strong> Always implement comprehensive error handling. Pedro provides tools for detecting and recovering from errors.</p><p><strong>Performance Monitoring:</strong> Monitor the performance of your advanced configurations and optimize as needed.</p><p><strong>Testing:</strong> Thoroughly test all advanced features before using them in competition.</p><p><strong>Documentation:</strong> Document your custom extensions and configurations for future reference.</p>"
    },
    {
      "type": "link-grid",
      "title": "Related Topics",
      "content": "<a href=\"#\" onclick=\"loadContent('ftc/path-planning/pedro-pathing/intro-to-pedro-pathing.json')\">Introduction to Pedro Pathing</a><a href=\"#\" onclick=\"loadContent('ftc/path-planning/pedro-pathing/pedro-localization.json')\">Pedro Localization</a><a href=\"#\" onclick=\"loadContent('ftc/android-studio/advanced-movement-control/pid-control.json')\">PID Control</a><a href=\"#\" onclick=\"loadContent('ftc/android-studio/vision/vision-introduction.json')\">Vision Introduction</a>"
    }
  ]
} 