{
  "title": "Commands and Scheduler Implementation",
  "sections": [
    {
      "type": "text",
      "title": "Command Structure and Implementation",
      "content": "<p>Commands are the building blocks of command-based programming. Each command represents a discrete action that the robot can perform. Understanding how to properly implement commands is crucial for creating reliable, maintainable robot code.</p><p>Every command must implement the four lifecycle methods: <code>initialize()</code>, <code>execute()</code>, <code>isFinished()</code>, and <code>end(boolean interrupted)</code>. These methods define the complete behavior of the command.</p>"
    },
    {
      "type": "code",
      "title": "Complete Command Implementation",
      "content": "<p>Here's a complete example of a command that turns the robot to a specific angle using an IMU:</p>",
      "code": "package org.firstinspires.ftc.teamcode.commands;\n\nimport com.seattlesolvers.solverslib.command.CommandBase;\nimport com.seattlesolvers.solverslib.subsystems.DriveSubsystem;\nimport com.qualcomm.robotcore.hardware.IMU;\nimport org.firstinspires.ftc.robotcore.external.navigation.AngleUnit;\nimport org.firstinspires.ftc.robotcore.external.navigation.YawPitchRollAngles;\n\npublic class TurnToAngleCommand extends CommandBase {\n    private final DriveSubsystem driveSubsystem;\n    private final IMU imu;\n    private final double targetAngle;\n    private final double tolerance;\n    private final double power;\n    private double startAngle;\n    \n    public TurnToAngleCommand(DriveSubsystem driveSubsystem, IMU imu, \n                             double targetAngle, double tolerance, double power) {\n        this.driveSubsystem = driveSubsystem;\n        this.imu = imu;\n        this.targetAngle = targetAngle;\n        this.tolerance = tolerance;\n        this.power = power;\n        \n        // Declare subsystem requirements\n        addRequirements(driveSubsystem);\n    }\n    \n    @Override\n    public void initialize() {\n        // Get current angle when command starts\n        YawPitchRollAngles orientation = imu.getRobotYawPitchRollAngles();\n        startAngle = orientation.getYaw(AngleUnit.DEGREES);\n        \n        System.out.println(\"TurnToAngleCommand: Starting turn to \" + targetAngle + \" degrees\");\n    }\n    \n    @Override\n    public void execute() {\n        // Get current angle\n        YawPitchRollAngles orientation = imu.getRobotYawPitchRollAngles();\n        double currentAngle = orientation.getYaw(AngleUnit.DEGREES);\n        \n        // Calculate error (difference between target and current)\n        double error = targetAngle - currentAngle;\n        \n        // Normalize error to -180 to 180 degrees\n        while (error > 180) error -= 360;\n        while (error < -180) error += 360;\n        \n        // Determine turn direction and power\n        double turnPower = Math.signum(error) * power;\n        \n        // Apply turn\n        driveSubsystem.drive(turnPower, -turnPower);\n        \n        // Output telemetry\n        System.out.println(\"Current: \" + currentAngle + \", Target: \" + targetAngle + \", Error: \" + error);\n    }\n    \n    @Override\n    public boolean isFinished() {\n        // Check if we're close enough to target\n        YawPitchRollAngles orientation = imu.getRobotYawPitchRollAngles();\n        double currentAngle = orientation.getYaw(AngleUnit.DEGREES);\n        double error = Math.abs(targetAngle - currentAngle);\n        \n        // Normalize error\n        while (error > 180) error = 360 - error;\n        \n        return error <= tolerance;\n    }\n    \n    @Override\n    public void end(boolean interrupted) {\n        // Stop the robot\n        driveSubsystem.stop();\n        \n        if (interrupted) {\n            System.out.println(\"TurnToAngleCommand: Interrupted\");\n        } else {\n            System.out.println(\"TurnToAngleCommand: Completed successfully\");\n        }\n    }\n}"
    },
    {
      "type": "text",
      "title": "Command Requirements and Resource Management",
      "content": "<p>Commands must declare which subsystems they require using the <code>addRequirements()</code> method. This is crucial for preventing conflicts between commands that try to use the same hardware simultaneously.</p><p>The scheduler uses these requirements to ensure that only one command can control a subsystem at a time. If a new command requires a subsystem that's already in use, the scheduler will interrupt the current command and start the new one.</p>"
    },
    {
      "type": "code",
      "title": "Command Requirements Example",
      "content": "<p>Here are examples of how to properly declare command requirements:</p>",
      "code": "// Single subsystem requirement\npublic class DriveForwardCommand extends CommandBase {\n    private final DriveSubsystem driveSubsystem;\n    \n    public DriveForwardCommand(DriveSubsystem driveSubsystem) {\n        this.driveSubsystem = driveSubsystem;\n        addRequirements(driveSubsystem);\n    }\n}\n\n// Multiple subsystem requirements\npublic class ShootBallCommand extends CommandBase {\n    private final IntakeSubsystem intakeSubsystem;\n    private final ShooterSubsystem shooterSubsystem;\n    \n    public ShootBallCommand(IntakeSubsystem intakeSubsystem, ShooterSubsystem shooterSubsystem) {\n        this.intakeSubsystem = intakeSubsystem;\n        this.shooterSubsystem = shooterSubsystem;\n        \n        // This command requires both subsystems\n        addRequirements(intakeSubsystem, shooterSubsystem);\n    }\n}\n\n// No subsystem requirements (rare)\npublic class WaitCommand extends CommandBase {\n    private final double duration;\n    private Timer timer;\n    \n    public WaitCommand(double duration) {\n        this.duration = duration;\n        // No addRequirements() call - this command doesn't use any subsystems\n    }\n    \n    @Override\n    public void initialize() {\n        timer = new Timer();\n        timer.start();\n    }\n    \n    @Override\n    public boolean isFinished() {\n        return timer.get() >= duration;\n    }\n}"
    },
    {
      "type": "text",
      "title": "Scheduler Operation and Command Execution",
      "content": "<p>The command scheduler is responsible for managing the execution of all commands. It runs continuously during the OpMode and decides which commands should be running at any given time.</p><p>The scheduler follows these rules:</p><ul><li>Commands with requirements take priority over default commands</li><li>Only one command can require a subsystem at a time</li><li>When a new command requires a subsystem, the current command is interrupted</li><li>Default commands run when no other command requires their subsystem</li><li>The scheduler calls the appropriate lifecycle methods on each command</li></ul>"
    },
    {
      "type": "code",
      "title": "Scheduler Integration in OpMode",
      "content": "<p>Here's how to integrate the command scheduler into your OpMode:</p>",
      "code": "package org.firstinspires.ftc.teamcode;\n\nimport com.qualcomm.robotcore.eventloop.opmode.LinearOpMode;\nimport com.qualcomm.robotcore.eventloop.opmode.TeleOp;\nimport com.seattlesolvers.solverslib.command.CommandScheduler;\nimport org.firstinspires.ftc.teamcode.subsystems.DriveSubsystem;\nimport org.firstinspires.ftc.teamcode.commands.DriveForwardCommand;\nimport org.firstinspires.ftc.teamcode.commands.TurnToAngleCommand;\n\n@TeleOp(name=\"Command Based TeleOp\")\npublic class CommandBasedTeleOp extends LinearOpMode {\n    private DriveSubsystem driveSubsystem;\n    private CommandScheduler scheduler;\n    \n    @Override\n    public void runOpMode() {\n        // Initialize subsystems\n        driveSubsystem = new DriveSubsystem(hardwareMap);\n        \n        // Get the command scheduler\n        scheduler = CommandScheduler.getInstance();\n        \n        // Set up default commands\n        driveSubsystem.setDefaultCommand(new StopDriveCommand(driveSubsystem));\n        \n        waitForStart();\n        \n        while (opModeIsActive()) {\n            // Run the scheduler - this is crucial!\n            scheduler.run();\n            \n            // Handle gamepad input\n            if (gamepad1.a) {\n                // Schedule a command when button is pressed\n                scheduler.schedule(new DriveForwardCommand(driveSubsystem, 0.5, 2.0));\n            }\n            \n            if (gamepad1.b) {\n                // Schedule another command\n                scheduler.schedule(new TurnToAngleCommand(driveSubsystem, imu, 90, 5, 0.3));\n            }\n            \n            // Output telemetry\n            telemetry.addData(\"Active Commands\", scheduler.getActiveCommands().size());\n            telemetry.update();\n        }\n    }\n}\n\n// Simple default command\nclass StopDriveCommand extends CommandBase {\n    private final DriveSubsystem driveSubsystem;\n    \n    public StopDriveCommand(DriveSubsystem driveSubsystem) {\n        this.driveSubsystem = driveSubsystem;\n        addRequirements(driveSubsystem);\n    }\n    \n    @Override\n    public void execute() {\n        driveSubsystem.stop();\n    }\n    \n    @Override\n    public boolean isFinished() {\n        return false; // Run forever\n    }\n}"
    },
    {
      "type": "text",
      "title": "Command Interruption and Cancellation",
      "content": "<p>Commands can be interrupted in several ways:</p><ul><li><strong>Another command requires the same subsystem</strong>: The scheduler automatically interrupts the current command</li><li><strong>Manual cancellation</strong>: You can call <code>scheduler.cancel(command)</code></li><li><strong>OpMode ending</strong>: All commands are interrupted when the OpMode ends</li></ul><p>When a command is interrupted, the <code>end(boolean interrupted)</code> method is called with <code>interrupted = true</code>. This is your opportunity to clean up and ensure the robot is in a safe state.</p>"
    },
    {
      "type": "code",
      "title": "Handling Command Interruption",
      "content": "<p>Here's how to properly handle command interruption:</p>",
      "code": "public class ComplexMovementCommand extends CommandBase {\n    private final DriveSubsystem driveSubsystem;\n    private final ArmSubsystem armSubsystem;\n    private Timer timer;\n    private boolean isMoving;\n    \n    public ComplexMovementCommand(DriveSubsystem driveSubsystem, ArmSubsystem armSubsystem) {\n        this.driveSubsystem = driveSubsystem;\n        this.armSubsystem = armSubsystem;\n        addRequirements(driveSubsystem, armSubsystem);\n    }\n    \n    @Override\n    public void initialize() {\n        timer = new Timer();\n        timer.start();\n        isMoving = true;\n        \n        // Start the complex movement\n        driveSubsystem.drive(0.5, 0.5);\n        armSubsystem.extendArm();\n        \n        System.out.println(\"ComplexMovementCommand: Started\");\n    }\n    \n    @Override\n    public void execute() {\n        // Continue the movement\n        if (timer.get() > 2.0) {\n            // Change direction after 2 seconds\n            driveSubsystem.drive(-0.3, -0.3);\n        }\n    }\n    \n    @Override\n    public boolean isFinished() {\n        return timer.get() > 5.0; // Run for 5 seconds\n    }\n    \n    @Override\n    public void end(boolean interrupted) {\n        // Always clean up, regardless of how the command ended\n        driveSubsystem.stop();\n        armSubsystem.stop();\n        isMoving = false;\n        \n        if (interrupted) {\n            System.out.println(\"ComplexMovementCommand: Interrupted - robot stopped safely\");\n            \n            // Additional cleanup for interrupted commands\n            armSubsystem.retractArm();\n        } else {\n            System.out.println(\"ComplexMovementCommand: Completed successfully\");\n        }\n    }\n}\n\n// Example of manual command cancellation\npublic class TeleOpWithCancellation extends LinearOpMode {\n    private CommandScheduler scheduler;\n    private DriveSubsystem driveSubsystem;\n    private ComplexMovementCommand complexCommand;\n    \n    @Override\n    public void runOpMode() {\n        // ... initialization code ...\n        \n        while (opModeIsActive()) {\n            scheduler.run();\n            \n            if (gamepad1.a) {\n                // Start complex command\n                complexCommand = new ComplexMovementCommand(driveSubsystem, armSubsystem);\n                scheduler.schedule(complexCommand);\n            }\n            \n            if (gamepad1.b) {\n                // Cancel the complex command\n                if (complexCommand != null) {\n                    scheduler.cancel(complexCommand);\n                    System.out.println(\"Complex command cancelled by user\");\n                }\n            }\n        }\n    }\n}"
    },
    {
      "type": "exercise-box",
      "title": "Practice: Command Implementation",
      "description": "Create and test various types of commands",
      "tasks": [
        "Create a command that drives in a square pattern",
        "Implement a command that raises an arm while driving forward",
        "Write a command that can be safely interrupted at any time",
        "Create a command that requires multiple subsystems",
        "Test command scheduling and interruption scenarios"
      ],
      "content": "// Start with this command template\npublic class SquareDriveCommand extends CommandBase {\n    private final DriveSubsystem driveSubsystem;\n    private Timer timer;\n    private int currentSide;\n    \n    public SquareDriveCommand(DriveSubsystem driveSubsystem) {\n        this.driveSubsystem = driveSubsystem;\n        addRequirements(driveSubsystem);\n    }\n    \n    @Override\n    public void initialize() {\n        timer = new Timer();\n        timer.start();\n        currentSide = 0;\n    }\n    \n    @Override\n    public void execute() {\n        // Implement square driving logic:\n        // - Drive forward for 2 seconds\n        // - Turn 90 degrees\n        // - Repeat 4 times\n    }\n    \n    @Override\n    public boolean isFinished() {\n        // Return true when square is complete\n    }\n    \n    @Override\n    public void end(boolean interrupted) {\n        // Always stop the robot\n    }\n}"
    },
    {
      "type": "text",
      "title": "Command Design Best Practices",
      "content": "<p>Follow these guidelines when designing commands:</p><ul><li><strong>Single Purpose</strong>: Each command should do one thing well</li><li><strong>Proper Requirements</strong>: Always declare subsystem requirements</li><li><strong>Safe Interruption</strong>: Handle interruption gracefully in the end() method</li><li><strong>Clear State</strong>: Make command state easy to understand and debug</li><li><strong>Reasonable Duration</strong>: Commands should complete in a reasonable time</li><li><strong>Good Naming</strong>: Use descriptive names that indicate what the command does</li></ul>"
    },
    {
      "type": "emphasis-box",
      "title": "Key Takeaways",
      "content": "<ul><li>Commands must implement four lifecycle methods: initialize, execute, isFinished, and end</li><li>Always declare subsystem requirements using addRequirements()</li><li>The scheduler manages command execution and prevents conflicts</li><li>Commands can be interrupted - always handle this gracefully in end()</li><li>Run the scheduler continuously in your OpMode's main loop</li><li>Default commands provide safe, predictable behavior when no other commands are running</li></ul>"
    }
  ]
} 