{
  "title": "GoBILDA Pinpoint",
  "sections": [
    {
      "type": "text",
      "title": "Introduction to GoBILDA Pinpoint System",
      "content": "<p>GoBILDA Pinpoint is an integrated odometry solution designed specifically for FTC robots. It provides a complete, pre-calibrated odometry system that eliminates the need for custom hardware setup and complex mathematical implementations.</p><p><strong>What is Pinpoint:</strong></p><ul><li>Integrated odometry solution with three tracking wheels</li><li>Pre-calibrated sensors and mounting system</li><li>Software library for easy integration</li><li>High-accuracy position and orientation tracking</li></ul><p><strong>Hardware components and specifications:</strong></p><ul><li><strong>Sensor Pod:</strong> Contains three high-resolution encoders</li><li><strong>Tracking Wheels:</strong> Precision-machined wheels with consistent contact</li><li><strong>Mounting System:</strong> Adjustable brackets for various robot configurations</li><li><strong>Wiring Harness:</strong> Pre-wired connections to control hub</li></ul><p><strong>Advantages over custom-built odometry systems:</strong></p><ul><li>No custom hardware design required</li><li>Pre-calibrated and tested components</li><li>Comprehensive software library</li><li>Consistent performance across different robots</li><li>Professional support and documentation</li></ul><p>Reference: <a href=\"https://www.gobilda.com/pinpoint/\" target=\"_blank\">GoBILDA: Pinpoint System</a></p>"
    },
    {
      "type": "text",
      "title": "Pinpoint Hardware Setup",
      "content": "<p>Proper hardware setup is crucial for optimal Pinpoint performance:</p><p><strong>Sensor pod installation and configuration:</strong></p><ul><li>Mount sensor pod securely to robot frame</li><li>Ensure proper alignment with robot center</li><li>Check all connections and wiring</li><li>Verify encoder functionality</li></ul><p><strong>Wiring and power requirements:</strong></p><ul><li>Connect to appropriate ports on control hub</li><li>Ensure proper power supply</li><li>Check signal quality and noise</li><li>Verify communication with software</li></ul><p><strong>Mounting considerations and best practices:</strong></p><ul><li>Mount at consistent height from ground</li><li>Ensure wheels contact surface evenly</li><li>Check for interference with other components</li><li>Allow for easy access and maintenance</li></ul><p>Reference: <a href=\"https://www.gobilda.com/pinpoint/installation/\" target=\"_blank\">GoBILDA: Pinpoint Installation</a></p>"
    },
    {
      "type": "code",
      "title": "Pinpoint Software Integration",
      "content": "<p>GoBILDA provides a comprehensive software library for Pinpoint integration:</p><ul><li><strong>SDK installation and setup:</strong> Download Pinpoint SDK from GoBILDA website, add library to your Android Studio project, configure build.gradle dependencies, import necessary classes</li><li><strong>Basic Pinpoint class usage:</strong> Initialize Pinpoint object with hardware configuration, set up position tracking, configure update frequency, handle position updates</li><li><strong>Position and orientation reading methods:</strong> Get current X, Y position, get current heading angle, get velocity information, get acceleration data</li></ul>",
      "code": "// GoBILDA Pinpoint integration example\nimport com.gobilda.pinpoint.Pinpoint;\nimport com.gobilda.pinpoint.PinpointConfiguration;\nimport com.gobilda.pinpoint.Pose2d;\nimport com.gobilda.pinpoint.Velocity2d;\n\npublic class PinpointOdometry {\n    private Pinpoint pinpoint;\n    private Telemetry telemetry;\n    \n    // Robot dimensions for Pinpoint configuration\n    private static final double TRACK_WIDTH_MM = 300.0;\n    private static final double WHEEL_DIAMETER_MM = 35.0;\n    private static final double TICKS_PER_REVOLUTION = 8192.0;\n    \n    public PinpointOdometry(HardwareMap hardwareMap, Telemetry telemetry) {\n        this.telemetry = telemetry;\n        \n        // Configure Pinpoint\n        PinpointConfiguration config = new PinpointConfiguration.Builder()\n            .setTrackWidth(TRACK_WIDTH_MM)\n            .setWheelDiameter(WHEEL_DIAMETER_MM)\n            .setTicksPerRevolution(TICKS_PER_REVOLUTION)\n            .setLeftEncoder(hardwareMap.get(DcMotor.class, \"leftEncoder\"))\n            .setRightEncoder(hardwareMap.get(DcMotor.class, \"rightEncoder\"))\n            .setHorizontalEncoder(hardwareMap.get(DcMotor.class, \"horizontalEncoder\"))\n            .setImu(hardwareMap.get(IMU.class, \"imu\"))\n            .build();\n        \n        // Initialize Pinpoint\n        pinpoint = new Pinpoint(config);\n        \n        // Start position tracking\n        pinpoint.start();\n    }\n    \n    // Get current robot pose\n    public Pose2d getPose() {\n        return pinpoint.getPose();\n    }\n    \n    // Get current velocity\n    public Velocity2d getVelocity() {\n        return pinpoint.getVelocity();\n    }\n    \n    // Update position (call in loop)\n    public void update() {\n        pinpoint.update();\n        \n        // Display position information\n        Pose2d pose = getPose();\n        Velocity2d velocity = getVelocity();\n        \n        telemetry.addData(\"X Position (mm)\", String.format(\"%.2f\", pose.getX()));\n        telemetry.addData(\"Y Position (mm)\", String.format(\"%.2f\", pose.getY()));\n        telemetry.addData(\"Heading (deg)\", String.format(\"%.2f\", pose.getHeading()));\n        telemetry.addData(\"Velocity X\", String.format(\"%.2f\", velocity.getX()));\n        telemetry.addData(\"Velocity Y\", String.format(\"%.2f\", velocity.getY()));\n        telemetry.addData(\"Angular Velocity\", String.format(\"%.2f\", velocity.getAngularVelocity()));\n    }\n    \n    // Reset position to origin\n    public void resetPosition() {\n        pinpoint.resetPosition();\n    }\n    \n    // Set position to specific coordinates\n    public void setPosition(double x, double y, double heading) {\n        pinpoint.setPosition(new Pose2d(x, y, heading));\n    }\n    \n    // Stop Pinpoint\n    public void stop() {\n        pinpoint.stop();\n    }\n    \n    // Check if Pinpoint is running\n    public boolean isRunning() {\n        return pinpoint.isRunning();\n    }\n}"
    },
    {
      "type": "code",
      "title": "Pinpoint Calibration and Tuning",
      "content": "<p>Proper calibration and tuning are essential for accurate Pinpoint performance:</p><ul><li><strong>Initial calibration procedures:</strong> Measure and verify robot dimensions, calibrate encoder parameters, set up coordinate system origin, test basic movement tracking</li><li><strong>Tuning parameters for accuracy:</strong> Adjust track width measurements, fine-tune wheel diameter values, calibrate encoder resolution, optimize update frequency</li><li><strong>Calibration validation methods:</strong> Drive in known patterns (square, circle), compare with field measurements, test repeatability of movements, validate heading accuracy with IMU</li></ul><p>Reference: <a href=\"https://www.gobilda.com/pinpoint/calibration/\" target=\"_blank\">GoBILDA: Pinpoint Calibration</a></p>",
      "code": "// Pinpoint calibration and tuning utilities\npublic class PinpointCalibration {\n    private PinpointOdometry pinpoint;\n    private Telemetry telemetry;\n    \n    public PinpointCalibration(PinpointOdometry pinpoint, Telemetry telemetry) {\n        this.pinpoint = pinpoint;\n        this.telemetry = telemetry;\n    }\n    \n    // Calibrate track width by driving in a circle\n    public double calibrateTrackWidth() {\n        telemetry.addLine(\"Starting track width calibration...\");\n        telemetry.addLine(\"Drive robot in a circle and press A when complete\");\n        telemetry.update();\n        \n        // Record initial position\n        Pose2d initialPose = pinpoint.getPose();\n        \n        // Wait for user to complete circle\n        // (In real implementation, you'd wait for button press)\n        \n        // Record final position\n        Pose2d finalPose = pinpoint.getPose();\n        \n        // Calculate track width based on circle completion\n        double headingChange = finalPose.getHeading() - initialPose.getHeading();\n        double distanceTraveled = Math.sqrt(\n            Math.pow(finalPose.getX() - initialPose.getX(), 2) + \n            Math.pow(finalPose.getY() - initialPose.getY(), 2)\n        );\n        \n        // Simplified track width calculation\n        double estimatedTrackWidth = distanceTraveled / Math.abs(headingChange);\n        \n        telemetry.addData(\"Estimated Track Width (mm)\", String.format(\"%.2f\", estimatedTrackWidth));\n        telemetry.update();\n        \n        return estimatedTrackWidth;\n    }\n    \n    // Validate calibration accuracy\n    public boolean validateCalibration() {\n        telemetry.addLine(\"Validating calibration...\");\n        telemetry.addLine(\"Drive robot in a square pattern\");\n        telemetry.update();\n        \n        // Record starting position\n        Pose2d startPose = pinpoint.getPose();\n        \n        // Wait for square completion\n        // (In real implementation, you'd wait for button press)\n        \n        // Record ending position\n        Pose2d endPose = pinpoint.getPose();\n        \n        // Calculate error\n        double positionError = Math.sqrt(\n            Math.pow(endPose.getX() - startPose.getX(), 2) + \n            Math.pow(endPose.getY() - startPose.getY(), 2)\n        );\n        \n        double headingError = Math.abs(endPose.getHeading() - startPose.getHeading());\n        \n        telemetry.addData(\"Position Error (mm)\", String.format(\"%.2f\", positionError));\n        telemetry.addData(\"Heading Error (deg)\", String.format(\"%.2f\", headingError));\n        telemetry.update();\n        \n        // Return true if errors are within acceptable limits\n        return positionError < 50.0 && headingError < 5.0; // 50mm, 5 degrees\n    }\n}"
    },
    {
      "type": "code",
      "title": "Advanced Pinpoint Features",
      "content": "<p>GoBILDA Pinpoint offers several advanced features for sophisticated odometry applications:</p><ul><li><strong>Velocity tracking and acceleration:</strong> Real-time velocity measurements, acceleration calculations, velocity-based movement control, performance monitoring</li><li><strong>Integration with autonomous path planning:</strong> Position feedback for path following, velocity control for smooth movement, error correction and recovery, multi-point navigation</li><li><strong>Performance optimization techniques:</strong> Update frequency optimization, filtering and smoothing, memory management, CPU usage optimization</li></ul>",
      "code": "// Advanced Pinpoint features implementation\npublic class AdvancedPinpointOdometry extends PinpointOdometry {\n    \n    private List<Pose2d> pathHistory = new ArrayList<>();\n    private double maxVelocity = 0.0;\n    private double averageVelocity = 0.0;\n    private int velocitySamples = 0;\n    \n    public AdvancedPinpointOdometry(HardwareMap hardwareMap, Telemetry telemetry) {\n        super(hardwareMap, telemetry);\n    }\n    \n    @Override\n    public void update() {\n        super.update();\n        \n        // Track path history\n        Pose2d currentPose = getPose();\n        pathHistory.add(currentPose);\n        \n        // Keep only last 100 positions to prevent memory issues\n        if (pathHistory.size() > 100) {\n            pathHistory.remove(0);\n        }\n        \n        // Track velocity statistics\n        Velocity2d currentVelocity = getVelocity();\n        double currentSpeed = Math.sqrt(\n            Math.pow(currentVelocity.getX(), 2) + \n            Math.pow(currentVelocity.getY(), 2)\n        );\n        \n        if (currentSpeed > maxVelocity) {\n            maxVelocity = currentSpeed;\n        }\n        \n        averageVelocity = ((averageVelocity * velocitySamples) + currentSpeed) / (velocitySamples + 1);\n        velocitySamples++;\n        \n        // Display advanced information\n        telemetry.addData(\"Max Velocity (mm/s)\", String.format(\"%.2f\", maxVelocity));\n        telemetry.addData(\"Average Velocity (mm/s)\", String.format(\"%.2f\", averageVelocity));\n        telemetry.addData(\"Path Points\", pathHistory.size());\n    }\n    \n    // Get path history for analysis\n    public List<Pose2d> getPathHistory() {\n        return new ArrayList<>(pathHistory);\n    }\n    \n    // Calculate total distance traveled\n    public double getTotalDistance() {\n        if (pathHistory.size() < 2) return 0.0;\n        \n        double totalDistance = 0.0;\n        for (int i = 1; i < pathHistory.size(); i++) {\n            Pose2d prev = pathHistory.get(i - 1);\n            Pose2d curr = pathHistory.get(i);\n            \n            totalDistance += Math.sqrt(\n                Math.pow(curr.getX() - prev.getX(), 2) + \n                Math.pow(curr.getY() - prev.getY(), 2)\n            );\n        }\n        \n        return totalDistance;\n    }\n    \n    // Clear path history\n    public void clearPathHistory() {\n        pathHistory.clear();\n        maxVelocity = 0.0;\n        averageVelocity = 0.0;\n        velocitySamples = 0;\n    }\n}"
    },
    {
      "type": "emphasis-box",
      "title": "Troubleshooting and Maintenance",
      "content": "<p>Regular maintenance and troubleshooting ensure optimal Pinpoint performance:</p><ul><li><strong>Common Pinpoint issues and solutions:</strong> Inconsistent readings: Check wheel contact and encoder connections. Drift over time: Recalibrate and check for mechanical wear. Communication errors: Verify wiring and port connections. Performance degradation: Clean wheels and check for damage.</li><li><strong>Regular maintenance requirements:</strong> Clean tracking wheels regularly, check for wheel wear and replace as needed, verify encoder functionality, update software library</li><li><strong>Performance degradation detection:</strong> Monitor position accuracy over time, track velocity consistency, check for unusual error patterns, compare with known good performance</li></ul><p>Reference: <a href=\"https://gm0.org/en/latest/docs/software/tutorials/odometry.html#gobilda-pinpoint\" target=\"_blank\">gm0: Pinpoint Troubleshooting</a></p>"
    },
    {
      "type": "code",
      "title": "Pinpoint Diagnostics Example",
      "content": "<p>Example: Pinpoint troubleshooting and diagnostics.</p>",
      "code": "// Pinpoint troubleshooting and diagnostics\npublic class PinpointDiagnostics {\n    private PinpointOdometry pinpoint;\n    private Telemetry telemetry;\n    \n    public PinpointDiagnostics(PinpointOdometry pinpoint, Telemetry telemetry) {\n        this.pinpoint = pinpoint;\n        this.telemetry = telemetry;\n    }\n    \n    // Run comprehensive diagnostics\n    public void runDiagnostics() {\n        telemetry.addLine(\"=== Pinpoint Diagnostics ===\");\n        \n        // Check if Pinpoint is running\n        boolean isRunning = pinpoint.isRunning();\n        telemetry.addData(\"Pinpoint Running\", isRunning);\n        \n        if (!isRunning) {\n            telemetry.addLine(\"ERROR: Pinpoint is not running!\");\n            return;\n        }\n        \n        // Check position values\n        Pose2d pose = pinpoint.getPose();\n        telemetry.addData(\"Current X\", String.format(\"%.2f\", pose.getX()));\n        telemetry.addData(\"Current Y\", String.format(\"%.2f\", pose.getY()));\n        telemetry.addData(\"Current Heading\", String.format(\"%.2f\", pose.getHeading()));\n        \n        // Check velocity values\n        Velocity2d velocity = pinpoint.getVelocity();\n        telemetry.addData(\"Velocity X\", String.format(\"%.2f\", velocity.getX()));\n        telemetry.addData(\"Velocity Y\", String.format(\"%.2f\", velocity.getY()));\n        telemetry.addData(\"Angular Velocity\", String.format(\"%.2f\", velocity.getAngularVelocity()));\n        \n        // Check for unusual values\n        if (Double.isNaN(pose.getX()) || Double.isNaN(pose.getY())) {\n            telemetry.addLine(\"WARNING: Invalid position values detected!\");\n        }\n        \n        if (Double.isNaN(velocity.getX()) || Double.isNaN(velocity.getY())) {\n            telemetry.addLine(\"WARNING: Invalid velocity values detected!\");\n        }\n        \n        telemetry.update();\n    }\n    \n    // Test encoder functionality\n    public void testEncoders() {\n        telemetry.addLine(\"Testing encoders...\");\n        telemetry.addLine(\"Move robot and observe encoder changes\");\n        telemetry.update();\n        \n        // In a real implementation, you would:\n        // 1. Record initial encoder values\n        // 2. Ask user to move robot\n        // 3. Record final encoder values\n        // 4. Check if values changed appropriately\n        \n        telemetry.addLine(\"Encoder test complete\");\n        telemetry.update();\n    }\n}"
    },
    {
      "type": "exercise-box",
      "title": "Practice Exercise: GoBILDA Pinpoint Integration",
      "description": "Set up and configure a GoBILDA Pinpoint system.",
      "tasks": [
        "Install Pinpoint hardware on your robot",
        "Download and integrate the Pinpoint SDK",
        "Configure Pinpoint with your robot's dimensions",
        "Implement basic position tracking",
        "Calibrate the system using provided methods",
        "Test accuracy with known movement patterns",
        "Implement advanced features like path tracking",
        "Challenge: Create an autonomous routine that uses Pinpoint for precise navigation to multiple waypoints."
      ],
      "content": "// See code examples above for implementation guidance."
    },
    {
      "type": "list",
      "title": "Key Takeaways",
      "items": [
        "GoBILDA Pinpoint provides an integrated odometry solution",
        "Proper hardware setup and calibration are essential",
        "The Pinpoint SDK simplifies software integration",
        "Advanced features enable sophisticated applications",
        "Regular maintenance ensures optimal performance",
        "Comprehensive diagnostics help troubleshoot issues"
      ]
    },
    {
      "type": "link-grid",
      "title": "Next Steps: Related Topics",
      "content": "Explore these related topics for further learning.",
      "links": [
        {"id": "intro-to-pathplanning", "label": "Path Planning"},
        {"id": "vision-introduction", "label": "Vision Introduction"},
        {"id": "motion-profiling", "label": "Motion Profiling"}
      ]
    }
  ]
} 