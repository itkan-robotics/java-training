{
  "title": "Three Wheel Odometry",
  "sections": [
    {
      "type": "text",
      "title": "Three Wheel Odometry Theory",
      "content": "<p>Three wheel odometry is a mathematical approach that uses three tracking wheels to provide complete position and orientation tracking. This system is based on the principle that three points define a plane, allowing for precise localization.</p><p><strong>Why three wheels provide complete tracking:</strong></p><ul><li>Three points define a plane uniquely</li><li>Each wheel provides independent movement information</li><li>Can track forward/backward, lateral, and rotational movement</li><li>Provides redundancy for improved accuracy</li></ul><p><strong>Mathematical foundation:</strong></p><ul><li>Uses forward and inverse kinematics</li><li>Three-wheel configuration creates a stable tracking triangle</li><li>Each wheel's movement contributes to overall position calculation</li><li>Can handle complex robot movements including simultaneous translation and rotation</li></ul><p><strong>Advantages over single or dual encoder systems:</strong></p><ul><li>Complete 2D position and orientation tracking</li><li>Better accuracy due to redundant measurements</li><li>Can handle complex movement patterns</li><li>More robust to individual sensor failures</li></ul><p>Reference: <a href=\"https://gm0.org/en/latest/docs/software/tutorials/odometry.html#three-wheel-odometry\" target=\"_blank\">gm0: Three Wheel Odometry</a></p>"
    },
    {
      "type": "text",
      "title": "Hardware Configuration",
      "content": "<p>Proper hardware configuration is essential for accurate three wheel odometry:</p><p><strong>Optimal wheel placement (triangle formation):</strong></p><ul><li><strong>Equilateral triangle:</strong> Provides equal weight to all three wheels</li><li><strong>Right triangle:</strong> Common configuration with two wheels on one axis</li><li><strong>Custom triangle:</strong> Based on robot geometry and space constraints</li></ul><p><strong>Wheel size considerations for accuracy:</strong></p><ul><li>Larger wheels provide better resolution but require more space</li><li>Consistent wheel size across all three wheels</li><li>High-quality wheels with minimal runout</li><li>Proper wheel material for surface contact</li></ul><p><strong>Mounting height and alignment requirements:</strong></p><ul><li>All wheels must contact the ground at the same height</li><li>Wheels should be perpendicular to the mounting surface</li><li>Consistent spring tension across all wheels</li><li>Proper alignment to prevent binding or slipping</li></ul><p>Reference: <a href=\"https://www.gobilda.com/odometry/\" target=\"_blank\">GoBILDA: Three Wheel Setup</a></p>"
    },
    {
      "type": "code",
      "title": "Mathematical Implementation",
      "content": "<p>The mathematical implementation of three wheel odometry involves forward and inverse kinematics:</p><ul><li><strong>Forward Kinematics:</strong> Calculates robot movement from individual wheel movements</li><li><strong>Inverse Kinematics:</strong> Calculates required wheel movements for desired robot movement</li><li><strong>Key Equations:</strong> Robot velocity from wheel velocities, position update from velocity integration, heading calculation from wheel differentials</li></ul>",
      "code": "// Three wheel odometry mathematical implementation\npublic class ThreeWheelOdometry {\n    private DcMotor wheel1;\n    private DcMotor wheel2;\n    private DcMotor wheel3;\n    private IMU imu;\n    \n    // Robot pose variables\n    private double x = 0.0;\n    private double y = 0.0;\n    private double heading = 0.0;\n    \n    // Wheel positions relative to robot center (in mm)\n    private static final double WHEEL1_X = 150.0;\n    private static final double WHEEL1_Y = 100.0;\n    private static final double WHEEL2_X = -150.0;\n    private static final double WHEEL2_Y = 100.0;\n    private static final double WHEEL3_X = 0.0;\n    private static final double WHEEL3_Y = -200.0;\n    \n    // Encoder specifications\n    private static final double WHEEL_DIAMETER_MM = 35.0;\n    private static final double WHEEL_CIRCUMFERENCE_MM = WHEEL_DIAMETER_MM * Math.PI;\n    private static final double TICKS_PER_REVOLUTION = 8192.0;\n    private static final double MM_PER_TICK = WHEEL_CIRCUMFERENCE_MM / TICKS_PER_REVOLUTION;\n    \n    // Previous encoder values\n    private int prevWheel1Ticks = 0;\n    private int prevWheel2Ticks = 0;\n    private int prevWheel3Ticks = 0;\n    \n    public ThreeWheelOdometry(DcMotor wheel1, DcMotor wheel2, DcMotor wheel3, IMU imu) {\n        this.wheel1 = wheel1;\n        this.wheel2 = wheel2;\n        this.wheel3 = wheel3;\n        this.imu = imu;\n        \n        // Reset encoders\n        wheel1.setMode(DcMotor.RunMode.STOP_AND_RESET_ENCODER);\n        wheel2.setMode(DcMotor.RunMode.STOP_AND_RESET_ENCODER);\n        wheel3.setMode(DcMotor.RunMode.STOP_AND_RESET_ENCODER);\n    }\n    \n    // Convert encoder ticks to distance\n    public double ticksToDistance(int ticks) {\n        return ticks * MM_PER_TICK;\n    }\n    \n    // Forward kinematics: calculate robot movement from wheel movements\n    public void updatePosition() {\n        // Get current encoder values\n        int currentWheel1Ticks = wheel1.getCurrentPosition();\n        int currentWheel2Ticks = wheel2.getCurrentPosition();\n        int currentWheel3Ticks = wheel3.getCurrentPosition();\n        \n        // Calculate delta movements\n        double deltaWheel1 = ticksToDistance(currentWheel1Ticks - prevWheel1Ticks);\n        double deltaWheel2 = ticksToDistance(currentWheel2Ticks - prevWheel2Ticks);\n        double deltaWheel3 = ticksToDistance(currentWheel3Ticks - prevWheel3Ticks);\n        \n        // Calculate robot movement using forward kinematics\n        double deltaX = calculateDeltaX(deltaWheel1, deltaWheel2, deltaWheel3);\n        double deltaY = calculateDeltaY(deltaWheel1, deltaWheel2, deltaWheel3);\n        double deltaHeading = calculateDeltaHeading(deltaWheel1, deltaWheel2, deltaWheel3);\n        \n        // Update robot pose\n        heading += deltaHeading;\n        double headingRadians = Math.toRadians(heading);\n        \n        // Apply coordinate transformation\n        x += deltaX * Math.cos(headingRadians) - deltaY * Math.sin(headingRadians);\n        y += deltaX * Math.sin(headingRadians) + deltaY * Math.cos(headingRadians);\n        \n        // Store current values\n        prevWheel1Ticks = currentWheel1Ticks;\n        prevWheel2Ticks = currentWheel2Ticks;\n        prevWheel3Ticks = currentWheel3Ticks;\n    }\n    \n    // Calculate X movement from wheel movements\n    private double calculateDeltaX(double deltaWheel1, double deltaWheel2, double deltaWheel3) {\n        // Simplified calculation based on wheel geometry\n        return (deltaWheel1 + deltaWheel2) / 2.0;\n    }\n    \n    // Calculate Y movement from wheel movements\n    private double calculateDeltaY(double deltaWheel1, double deltaWheel2, double deltaWheel3) {\n        // Simplified calculation based on wheel geometry\n        return deltaWheel3 - ((deltaWheel1 + deltaWheel2) / 2.0);\n    }\n    \n    // Calculate heading change from wheel movements\n    private double calculateDeltaHeading(double deltaWheel1, double deltaWheel2, double deltaWheel3) {\n        // Calculate based on wheel differentials\n        double trackWidth = Math.abs(WHEEL1_X - WHEEL2_X);\n        return Math.toDegrees((deltaWheel2 - deltaWheel1) / trackWidth);\n    }\n    \n    // Get current robot pose\n    public double getX() { return x; }\n    public double getY() { return y; }\n    public double getHeadingDegrees() { return heading; }\n}"
    },
    {
      "type": "code",
      "title": "Coordinate Transformations",
      "content": "<p>Coordinate transformations are essential for converting between robot and field coordinate systems:</p><ul><li>Robot frame: Relative to robot's current position and orientation</li><li>Field frame: Fixed reference frame for the entire field</li><li>Transformation involves rotation and translation</li><li>Rotation matrices for coordinate system conversion</li><li>Translation vectors for position updates</li><li>Combined transformations for complex movements</li><li>Consistent coordinate system conventions</li><li>Proper handling of angle units (degrees vs radians)</li><li>Accumulation of transformation errors</li><li>Regular coordinate system validation</li></ul>",
      "code": "// Coordinate transformation utilities\npublic class CoordinateTransform {\n    \n    // Convert robot frame coordinates to field frame\n    public static double[] robotToField(double robotX, double robotY, \n                                       double fieldX, double fieldY, double fieldHeading) {\n        double headingRadians = Math.toRadians(fieldHeading);\n        \n        // Rotation matrix application\n        double fieldXResult = fieldX + robotX * Math.cos(headingRadians) - robotY * Math.sin(headingRadians);\n        double fieldYResult = fieldY + robotX * Math.sin(headingRadians) + robotY * Math.cos(headingRadians);\n        \n        return new double[]{fieldXResult, fieldYResult};\n    }\n    \n    // Convert field frame coordinates to robot frame\n    public static double[] fieldToRobot(double fieldX, double fieldY, \n                                       double robotFieldX, double robotFieldY, double robotFieldHeading) {\n        double headingRadians = Math.toRadians(robotFieldHeading);\n        \n        // Inverse rotation matrix application\n        double deltaX = fieldX - robotFieldX;\n        double deltaY = fieldY - robotFieldY;\n        \n        double robotX = deltaX * Math.cos(-headingRadians) - deltaY * Math.sin(-headingRadians);\n        double robotY = deltaX * Math.sin(-headingRadians) + deltaY * Math.cos(-headingRadians);\n        \n        return new double[]{robotX, robotY};\n    }\n    \n    // Normalize angle to -180 to 180 degrees\n    public static double normalizeAngle(double angle) {\n        while (angle > 180) angle -= 360;\n        while (angle < -180) angle += 360;\n        return angle;\n    }\n    \n    // Calculate distance between two points\n    public static double distance(double x1, double y1, double x2, double y2) {\n        return Math.sqrt(Math.pow(x2 - x1, 2) + Math.pow(y2 - y1, 2));\n    }\n    \n    // Calculate angle between two points\n    public static double angleToPoint(double fromX, double fromY, double toX, double toY) {\n        return Math.toDegrees(Math.atan2(toY - fromY, toX - fromX));\n    }\n}"
    },
    {
      "type": "emphasis-box",
      "title": "Advanced Three Wheel Concepts",
      "content": "<p>Advanced three wheel odometry concepts improve accuracy and reliability:</p><ul><li><strong>Handling Wheel Slippage Detection:</strong> Monitor wheel velocity consistency, detect sudden changes in wheel movement, implement slip detection algorithms, use IMU data to validate wheel readings.</li><li><strong>Weighted Averaging for Improved Accuracy:</strong> Weight measurements based on wheel reliability, dynamic weighting based on surface conditions, statistical filtering of measurements, Kalman filtering for optimal estimation.</li><li><strong>Integration with IMU for Heading Validation:</strong> Use IMU as primary heading source, validate wheel-based heading calculations, implement heading fusion algorithms, handle IMU drift and calibration.</li></ul><p>Reference: <a href=\"https://docs.revrobotics.com/duo-control/duo-control-programming/odometry/three-wheel-odometry\" target=\"_blank\">REV: Advanced Three Wheel Odometry</a></p>"
    },
    {
      "type": "code",
      "title": "Advanced Three Wheel Odometry Example",
      "content": "<p>Example: Advanced three wheel odometry with slip detection and IMU fusion.</p>",
      "code": "// Advanced three wheel odometry with slip detection and IMU fusion\npublic class AdvancedThreeWheelOdometry extends ThreeWheelOdometry {\n    \n    private static final double SLIP_THRESHOLD = 0.1; // 10% velocity difference\n    private static final double IMU_WEIGHT = 0.7; // Weight for IMU heading\n    private static final double WHEEL_WEIGHT = 0.3; // Weight for wheel-based heading\n    \n    // Velocity tracking for slip detection\n    private double prevWheel1Velocity = 0.0;\n    private double prevWheel2Velocity = 0.0;\n    private double prevWheel3Velocity = 0.0;\n    \n    @Override\n    public void updatePosition() {\n        // Get current velocities\n        double currentWheel1Velocity = getWheelVelocity(wheel1);\n        double currentWheel2Velocity = getWheelVelocity(wheel2);\n        double currentWheel3Velocity = getWheelVelocity(wheel3);\n        \n        // Check for wheel slippage\n        boolean wheel1Slipping = detectSlip(currentWheel1Velocity, prevWheel1Velocity);\n        boolean wheel2Slipping = detectSlip(currentWheel2Velocity, prevWheel2Velocity);\n        boolean wheel3Slipping = detectSlip(currentWheel3Velocity, prevWheel3Velocity);\n        \n        // Use weighted measurements based on slip detection\n        double wheel1Weight = wheel1Slipping ? 0.5 : 1.0;\n        double wheel2Weight = wheel2Slipping ? 0.5 : 1.0;\n        double wheel3Weight = wheel3Slipping ? 0.5 : 1.0;\n        \n        // Calculate weighted wheel movements\n        double deltaWheel1 = ticksToDistance(wheel1.getCurrentPosition() - prevWheel1Ticks) * wheel1Weight;\n        double deltaWheel2 = ticksToDistance(wheel2.getCurrentPosition() - prevWheel2Ticks) * wheel2Weight;\n        double deltaWheel3 = ticksToDistance(wheel3.getCurrentPosition() - prevWheel3Ticks) * wheel3Weight;\n        \n        // Fuse IMU and wheel-based heading\n        double imuHeading = imu.getRobotYawPitchRollAngles().getYaw(AngleUnit.DEGREES);\n        double wheelHeading = calculateDeltaHeading(deltaWheel1, deltaWheel2, deltaWheel3);\n        \n        double fusedHeading = (imuHeading * IMU_WEIGHT) + (wheelHeading * WHEEL_WEIGHT);\n        \n        // Update position with fused heading\n        heading = fusedHeading;\n        \n        // Store velocities for next iteration\n        prevWheel1Velocity = currentWheel1Velocity;\n        prevWheel2Velocity = currentWheel2Velocity;\n        prevWheel3Velocity = currentWheel3Velocity;\n    }\n    \n    // Detect wheel slippage based on velocity changes\n    private boolean detectSlip(double currentVelocity, double previousVelocity) {\n        if (previousVelocity == 0) return false;\n        \n        double velocityChange = Math.abs(currentVelocity - previousVelocity) / Math.abs(previousVelocity);\n        return velocityChange > SLIP_THRESHOLD;\n    }\n    \n    // Calculate wheel velocity (simplified)\n    private double getWheelVelocity(DcMotor motor) {\n        // This would typically use velocity measurements from the motor\n        // For this example, we'll use a simplified calculation\n        return motor.getCurrentPosition() - prevWheel1Ticks; // Simplified\n    }\n}"
    },
    {
      "type": "exercise-box",
      "title": "Practice Exercise: Three Wheel Odometry Implementation",
      "description": "Implement a complete three wheel odometry system.",
      "tasks": [
        "Set up three tracking wheels in a triangle configuration",
        "Measure and record wheel positions relative to robot center",
        "Implement the three wheel odometry class with forward kinematics",
        "Add coordinate transformation utilities",
        "Test with complex movement patterns (figure-8, spiral)",
        "Compare accuracy with simpler odometry methods",
        "Challenge: Implement slip detection and weighted averaging to improve accuracy during aggressive movements."
      ],
      "content": "// See code examples above for implementation guidance."
    },
    {
      "type": "list",
      "title": "Key Takeaways",
      "items": [
        "Three wheel odometry provides complete 2D position and orientation tracking",
        "Proper hardware configuration is crucial for accuracy",
        "Forward and inverse kinematics are essential mathematical concepts",
        "Coordinate transformations enable field-relative positioning",
        "Advanced features like slip detection improve reliability",
        "IMU integration provides heading validation and correction"
      ]
    },
    {
      "type": "link-grid",
      "title": "Next Steps: Related Topics",
      "content": "Explore these related topics for further learning.",
      "links": [
        {"id": "gobilda-pinpoint", "label": "GoBILDA Pinpoint"},
        {"id": "intro-to-pathplanning", "label": "Path Planning"},
        {"id": "vision-introduction", "label": "Vision Introduction"}
      ]
    }
  ]
} 