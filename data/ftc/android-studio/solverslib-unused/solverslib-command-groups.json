{
  "title": "Command Groups and Sequencing",
  "sections": [
    {
      "type": "text",
      "title": "Sequential Command Groups",
      "content": "<p>Sequential command groups allow you to chain commands together so they execute one after another. This is perfect for creating complex autonomous routines where each step must complete before the next begins.</p><p>Sequential groups are created using <code>SequentialCommandGroup</code> and are useful for actions like: drive forward, then turn, then extend arm, then retract arm.</p>"
    },
    {
      "type": "code",
      "title": "Basic Sequential Command Group",
      "content": "<p>Here's a simple example of a sequential command group:</p>",
      "code": "package org.firstinspires.ftc.teamcode.commands;\n\nimport com.seattlesolvers.solverslib.command.SequentialCommandGroup;\nimport com.seattlesolvers.solverslib.command.WaitCommand;\nimport org.firstinspires.ftc.teamcode.subsystems.DriveSubsystem;\nimport org.firstinspires.ftc.teamcode.subsystems.ArmSubsystem;\n\npublic class SimpleAutonomousRoutine extends SequentialCommandGroup {\n    public SimpleAutonomousRoutine(DriveSubsystem driveSubsystem, ArmSubsystem armSubsystem) {\n        // Add commands in the order they should execute\n        addCommands(\n            new DriveForwardCommand(driveSubsystem, 0.5, 2.0),  // Drive forward for 2 seconds\n            new WaitCommand(0.5),                               // Wait 0.5 seconds\n            new TurnToAngleCommand(driveSubsystem, imu, 90, 5, 0.3), // Turn 90 degrees\n            new ExtendArmCommand(armSubsystem),                 // Extend the arm\n            new WaitCommand(1.0),                               // Wait 1 second\n            new RetractArmCommand(armSubsystem)                 // Retract the arm\n        );\n    }\n}\n\n// Simple commands used in the example\nclass ExtendArmCommand extends CommandBase {\n    private final ArmSubsystem armSubsystem;\n    \n    public ExtendArmCommand(ArmSubsystem armSubsystem) {\n        this.armSubsystem = armSubsystem;\n        addRequirements(armSubsystem);\n    }\n    \n    @Override\n    public void initialize() {\n        armSubsystem.extendArm();\n    }\n    \n    @Override\n    public boolean isFinished() {\n        return true; // Complete immediately\n    }\n}\n\nclass RetractArmCommand extends CommandBase {\n    private final ArmSubsystem armSubsystem;\n    \n    public RetractArmCommand(ArmSubsystem armSubsystem) {\n        this.armSubsystem = armSubsystem;\n        addRequirements(armSubsystem);\n    }\n    \n    @Override\n    public void initialize() {\n        armSubsystem.retractArm();\n    }\n    \n    @Override\n    public boolean isFinished() {\n        return true; // Complete immediately\n    }\n}"
    },
    {
      "type": "text",
      "title": "Parallel Command Groups",
      "content": "<p>Parallel command groups execute multiple commands simultaneously. This is useful when you want to perform multiple actions at the same time, such as driving while raising an arm or spinning a shooter while moving.</p><p>Parallel groups are created using <code>ParallelCommandGroup</code>. All commands in a parallel group start at the same time, and the group finishes when all commands finish.</p>"
    },
    {
      "type": "code",
      "title": "Parallel Command Group Example",
      "content": "<p>Here's an example of a parallel command group:</p>",
      "code": "public class DriveAndShootCommand extends ParallelCommandGroup {\n    public DriveAndShootCommand(DriveSubsystem driveSubsystem, \n                               ShooterSubsystem shooterSubsystem,\n                               IntakeSubsystem intakeSubsystem) {\n        // All these commands will run simultaneously\n        addCommands(\n            new DriveForwardCommand(driveSubsystem, 0.3, 3.0),    // Drive slowly for 3 seconds\n            new SpinUpShooterCommand(shooterSubsystem),           // Start spinning up shooter\n            new RunIntakeCommand(intakeSubsystem, 0.8)           // Run intake at 80% power\n        );\n    }\n}\n\n// Commands used in parallel example\nclass SpinUpShooterCommand extends CommandBase {\n    private final ShooterSubsystem shooterSubsystem;\n    private Timer timer;\n    \n    public SpinUpShooterCommand(ShooterSubsystem shooterSubsystem) {\n        this.shooterSubsystem = shooterSubsystem;\n        addRequirements(shooterSubsystem);\n    }\n    \n    @Override\n    public void initialize() {\n        timer = new Timer();\n        timer.start();\n        shooterSubsystem.spinUp();\n    }\n    \n    @Override\n    public boolean isFinished() {\n        return timer.get() >= 2.5; // Spin up for 2.5 seconds\n    }\n    \n    @Override\n    public void end(boolean interrupted) {\n        if (!interrupted) {\n            shooterSubsystem.stop();\n        }\n    }\n}\n\nclass RunIntakeCommand extends CommandBase {\n    private final IntakeSubsystem intakeSubsystem;\n    private final double power;\n    private Timer timer;\n    \n    public RunIntakeCommand(IntakeSubsystem intakeSubsystem, double power) {\n        this.intakeSubsystem = intakeSubsystem;\n        this.power = power;\n        addRequirements(intakeSubsystem);\n    }\n    \n    @Override\n    public void initialize() {\n        timer = new Timer();\n        timer.start();\n        intakeSubsystem.setPower(power);\n    }\n    \n    @Override\n    public boolean isFinished() {\n        return timer.get() >= 3.0; // Run for 3 seconds\n    }\n    \n    @Override\n    public void end(boolean interrupted) {\n        intakeSubsystem.stop();\n    }\n}"
    },
    {
      "type": "text",
      "title": "Race Command Groups",
      "content": "<p>Race command groups execute multiple commands in parallel, but finish as soon as any one command completes. This is useful for conditional operations or timeout scenarios.</p><p>Race groups are created using <code>RaceCommandGroup</code>. Common use cases include: waiting for a sensor with a timeout, or executing a command until a condition is met.</p>"
    },
    {
      "type": "code",
      "title": "Race Command Group Example",
      "content": "<p>Here's an example using a race command group for timeout scenarios:</p>",
      "code": "public class DriveUntilLineCommand extends RaceCommandGroup {\n    public DriveUntilLineCommand(DriveSubsystem driveSubsystem, \n                                ColorSensor colorSensor) {\n        // Race between driving and finding the line\n        addCommands(\n            new DriveForwardCommand(driveSubsystem, 0.4, 10.0),  // Drive for max 10 seconds\n            new WaitForLineCommand(colorSensor)                  // Stop when line is found\n        );\n    }\n}\n\nclass WaitForLineCommand extends CommandBase {\n    private final ColorSensor colorSensor;\n    \n    public WaitForLineCommand(ColorSensor colorSensor) {\n        this.colorSensor = colorSensor;\n        // No requirements - this command doesn't use any subsystems\n    }\n    \n    @Override\n    public void execute() {\n        // Check if we're on a line (dark surface)\n        int red = colorSensor.red();\n        int green = colorSensor.green();\n        int blue = colorSensor.blue();\n        \n        // Calculate brightness\n        int brightness = (red + green + blue) / 3;\n        \n        // Output telemetry\n        System.out.println(\"Brightness: \" + brightness);\n    }\n    \n    @Override\n    public boolean isFinished() {\n        // Finish when we detect a dark line (brightness < 100)\n        int red = colorSensor.red();\n        int green = colorSensor.green();\n        int blue = colorSensor.blue();\n        int brightness = (red + green + blue) / 3;\n        \n        return brightness < 100;\n    }\n}\n\n// Another race example: wait for button press with timeout\npublic class WaitForButtonCommand extends RaceCommandGroup {\n    public WaitForButtonCommand(Gamepad gamepad) {\n        addCommands(\n            new WaitCommand(5.0),                    // Wait maximum 5 seconds\n            new WaitForGamepadButtonCommand(gamepad) // Or until button is pressed\n        );\n    }\n}\n\nclass WaitForGamepadButtonCommand extends CommandBase {\n    private final Gamepad gamepad;\n    \n    public WaitForGamepadButtonCommand(Gamepad gamepad) {\n        this.gamepad = gamepad;\n    }\n    \n    @Override\n    public boolean isFinished() {\n        return gamepad.a || gamepad.b || gamepad.x || gamepad.y;\n    }\n}"
    },
    {
      "type": "text",
      "title": "Deadline Command Groups",
      "content": "<p>Deadline command groups execute multiple commands in parallel, but have a time limit. The group finishes when either the time limit is reached or all commands complete.</p><p>Deadline groups are created using <code>DeadlineCommandGroup</code>. The first command added is the \"deadline\" command - when it finishes, the entire group ends.</p>"
    },
    {
      "type": "code",
      "title": "Deadline Command Group Example",
      "content": "<p>Here's an example of a deadline command group:</p>",
      "code": "public class TimedShootingSequence extends DeadlineCommandGroup {\n    public TimedShootingSequence(ShooterSubsystem shooterSubsystem,\n                                IntakeSubsystem intakeSubsystem) {\n        // The deadline command (first one) sets the time limit\n        addCommands(\n            new WaitCommand(3.0),  // Deadline: 3 seconds maximum\n            new SpinUpShooterCommand(shooterSubsystem),\n            new FeedBallsCommand(intakeSubsystem)\n        );\n    }\n}\n\nclass FeedBallsCommand extends CommandBase {\n    private final IntakeSubsystem intakeSubsystem;\n    \n    public FeedBallsCommand(IntakeSubsystem intakeSubsystem) {\n        this.intakeSubsystem = intakeSubsystem;\n        addRequirements(intakeSubsystem);\n    }\n    \n    @Override\n    public void initialize() {\n        intakeSubsystem.setPower(0.8);\n    }\n    \n    @Override\n    public void execute() {\n        // Continue feeding balls\n        // This command will run until the deadline (3 seconds) is reached\n    }\n    \n    @Override\n    public void end(boolean interrupted) {\n        intakeSubsystem.stop();\n    }\n    \n    @Override\n    public boolean isFinished() {\n        // This command runs until interrupted by the deadline\n        return false;\n    }\n}\n\n// Another deadline example: autonomous routine with time limit\npublic class TimedAutonomousRoutine extends DeadlineCommandGroup {\n    public TimedAutonomousRoutine(DriveSubsystem driveSubsystem,\n                                 ArmSubsystem armSubsystem) {\n        addCommands(\n            new WaitCommand(15.0),  // 15 second autonomous period\n            new ComplexMovementSequence(driveSubsystem, armSubsystem)\n        );\n    }\n}\n\nclass ComplexMovementSequence extends SequentialCommandGroup {\n    public ComplexMovementSequence(DriveSubsystem driveSubsystem,\n                                  ArmSubsystem armSubsystem) {\n        addCommands(\n            new DriveForwardCommand(driveSubsystem, 0.5, 2.0),\n            new TurnToAngleCommand(driveSubsystem, imu, 45, 5, 0.3),\n            new ExtendArmCommand(armSubsystem),\n            new DriveForwardCommand(driveSubsystem, 0.3, 1.5),\n            new RetractArmCommand(armSubsystem)\n        );\n    }\n}"
    },
    {
      "type": "text",
      "title": "Nested Command Groups",
      "content": "<p>Command groups can be nested within each other to create complex, hierarchical behaviors. This allows you to build sophisticated autonomous routines by combining different types of command groups.</p><p>For example, you might have a sequential group that contains parallel groups, or a race group that contains sequential groups. This modular approach makes complex behaviors manageable and reusable.</p>"
    },
    {
      "type": "code",
      "title": "Complex Nested Command Group",
      "content": "<p>Here's an example of a complex nested command group:</p>",
      "code": "public class ComplexAutonomousRoutine extends SequentialCommandGroup {\n    public ComplexAutonomousRoutine(DriveSubsystem driveSubsystem,\n                                   ShooterSubsystem shooterSubsystem,\n                                   IntakeSubsystem intakeSubsystem,\n                                   ArmSubsystem armSubsystem) {\n        addCommands(\n            // Phase 1: Approach and prepare\n            new SequentialCommandGroup(\n                new DriveForwardCommand(driveSubsystem, 0.5, 1.0),\n                new TurnToAngleCommand(driveSubsystem, imu, 90, 5, 0.3),\n                new ExtendArmCommand(armSubsystem)\n            ),\n            \n            // Phase 2: Shoot while moving (parallel)\n            new ParallelCommandGroup(\n                new DriveForwardCommand(driveSubsystem, 0.3, 2.0),\n                new SpinUpShooterCommand(shooterSubsystem),\n                new FeedBallsCommand(intakeSubsystem)\n            ),\n            \n            // Phase 3: Race between finding target and timeout\n            new RaceCommandGroup(\n                new WaitCommand(5.0),\n                new FindTargetCommand(driveSubsystem, visionSystem)\n            ),\n            \n            // Phase 4: Final approach with deadline\n            new DeadlineCommandGroup(\n                new WaitCommand(3.0),\n                new FinalApproachSequence(driveSubsystem, armSubsystem)\n            )\n        );\n    }\n}\n\nclass FindTargetCommand extends CommandBase {\n    private final DriveSubsystem driveSubsystem;\n    private final VisionSystem visionSystem;\n    \n    public FindTargetCommand(DriveSubsystem driveSubsystem, VisionSystem visionSystem) {\n        this.driveSubsystem = driveSubsystem;\n        this.visionSystem = visionSystem;\n        addRequirements(driveSubsystem);\n    }\n    \n    @Override\n    public void execute() {\n        // Search for target by rotating slowly\n        driveSubsystem.drive(0.1, -0.1);\n    }\n    \n    @Override\n    public boolean isFinished() {\n        return visionSystem.hasTarget();\n    }\n    \n    @Override\n    public void end(boolean interrupted) {\n        driveSubsystem.stop();\n    }\n}\n\nclass FinalApproachSequence extends SequentialCommandGroup {\n    public FinalApproachSequence(DriveSubsystem driveSubsystem, ArmSubsystem armSubsystem) {\n        addCommands(\n            new DriveForwardCommand(driveSubsystem, 0.2, 0.5),\n            new RetractArmCommand(armSubsystem),\n            new WaitCommand(0.5)\n        );\n    }\n}"
    },
    {
      "type": "exercise-box",
      "title": "Practice: Building Command Groups",
      "description": "Create various types of command groups for different scenarios",
      "tasks": [
        "Create a sequential group that drives in a triangle pattern",
        "Build a parallel group that drives and raises an arm simultaneously",
        "Design a race group that searches for a line with a timeout",
        "Make a deadline group for a timed shooting sequence",
        "Combine multiple group types in a complex autonomous routine"
      ],
      "content": "// Start with these command group templates\n\n// Sequential group template\npublic class TriangleDriveCommand extends SequentialCommandGroup {\n    public TriangleDriveCommand(DriveSubsystem driveSubsystem) {\n        addCommands(\n            // Drive forward, turn 120Â°, repeat 3 times\n        );\n    }\n}\n\n// Parallel group template\npublic class DriveAndArmCommand extends ParallelCommandGroup {\n    public DriveAndArmCommand(DriveSubsystem driveSubsystem, ArmSubsystem armSubsystem) {\n        addCommands(\n            // Drive forward while raising arm\n        );\n    }\n}\n\n// Race group template\npublic class SearchForLineCommand extends RaceCommandGroup {\n    public SearchForLineCommand(DriveSubsystem driveSubsystem, ColorSensor colorSensor) {\n        addCommands(\n            // Drive until line found or timeout\n        );\n    }\n}"
    },
    {
      "type": "text",
      "title": "Command Group Best Practices",
      "content": "<p>Follow these guidelines when creating command groups:</p><ul><li><strong>Keep Groups Focused</strong>: Each group should have a clear, single purpose</li><li><strong>Use Descriptive Names</strong>: Name groups to indicate what they accomplish</li><li><strong>Consider Dependencies</strong>: Be aware of which commands can run in parallel</li><li><strong>Plan for Interruption</strong>: Groups can be interrupted - ensure safe cleanup</li><li><strong>Test Incrementally</strong>: Test individual commands before combining them</li><li><strong>Document Complex Logic</strong>: Comment complex group structures</li></ul>"
    },
    {
      "type": "emphasis-box",
      "title": "Key Takeaways",
      "content": "<ul><li>Sequential groups execute commands one after another</li><li>Parallel groups run multiple commands simultaneously</li><li>Race groups finish when any command completes</li><li>Deadline groups have a time limit set by the first command</li><li>Command groups can be nested to create complex behaviors</li><li>Use the appropriate group type for your specific use case</li><li>Command groups make complex autonomous routines manageable and reusable</li></ul>"
    }
  ]
} 