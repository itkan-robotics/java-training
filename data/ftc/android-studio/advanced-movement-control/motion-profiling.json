{
  "title": "Motion Profiling",
  "type": "lesson",
  "sections": [
    {
      "type": "text",
      "title": "Introduction to Motion Profiling",
      "content": "Motion profiling generates smooth, optimal trajectories for robot movement by planning velocity and acceleration profiles. This enables precise positioning, efficient motion, and reduced wear on mechanical components."
    },
    {
      "type": "text",
      "title": "Motion Profile Fundamentals",
      "content": "Motion profiles define how a system should move from one position to another over time. They specify position, velocity, and acceleration at each point in the trajectory, ensuring smooth and efficient motion."
    },
    {
      "type": "code",
      "title": "Basic Motion Profile Class",
      "language": "java",
      "content": "public class MotionProfile {\n    private double startPosition;\n    private double endPosition;\n    private double maxVelocity;\n    private double maxAcceleration;\n    private double totalTime;\n    \n    // Profile segments\n    private double accelerationTime;\n    private double cruiseTime;\n    private double decelerationTime;\n    \n    public MotionProfile(double startPosition, double endPosition, \n                        double maxVelocity, double maxAcceleration) {\n        this.startPosition = startPosition;\n        this.endPosition = endPosition;\n        this.maxVelocity = maxVelocity;\n        this.maxAcceleration = maxAcceleration;\n        \n        calculateProfile();\n    }\n    \n    /**\n     * Calculate profile timing\n     */\n    private void calculateProfile() {\n        double distance = Math.abs(endPosition - startPosition);\n        \n        // Time to accelerate to max velocity\n        accelerationTime = maxVelocity / maxAcceleration;\n        \n        // Distance covered during acceleration\n        double accelerationDistance = 0.5 * maxAcceleration * accelerationTime * accelerationTime;\n        \n        // Check if we can reach max velocity\n        if (accelerationDistance * 2 > distance) {\n            // Triangular profile - can't reach max velocity\n            accelerationTime = Math.sqrt(distance / maxAcceleration);\n            cruiseTime = 0.0;\n            maxVelocity = maxAcceleration * accelerationTime;\n        } else {\n            // Trapezoidal profile - can reach max velocity\n            cruiseTime = (distance - 2 * accelerationDistance) / maxVelocity;\n        }\n        \n        decelerationTime = accelerationTime;\n        totalTime = accelerationTime + cruiseTime + decelerationTime;\n    }\n    \n    /**\n     * Get position at specific time\n     */\n    public double getPosition(double time) {\n        if (time <= 0) return startPosition;\n        if (time >= totalTime) return endPosition;\n        \n        double position;\n        \n        if (time <= accelerationTime) {\n            // Acceleration phase\n            position = startPosition + 0.5 * maxAcceleration * time * time;\n        } else if (time <= accelerationTime + cruiseTime) {\n            // Cruise phase\n            double cruiseTimeElapsed = time - accelerationTime;\n            double accelerationDistance = 0.5 * maxAcceleration * accelerationTime * accelerationTime;\n            position = startPosition + accelerationDistance + maxVelocity * cruiseTimeElapsed;\n        } else {\n            // Deceleration phase\n            double decelTime = time - accelerationTime - cruiseTime;\n            double accelerationDistance = 0.5 * maxAcceleration * accelerationTime * accelerationTime;\n            double cruiseDistance = maxVelocity * cruiseTime;\n            position = startPosition + accelerationDistance + cruiseDistance + \n                      maxVelocity * decelTime - 0.5 * maxAcceleration * decelTime * decelTime;\n        }\n        \n        return position;\n    }\n    \n    /**\n     * Get velocity at specific time\n     */\n    public double getVelocity(double time) {\n        if (time <= 0 || time >= totalTime) return 0.0;\n        \n        if (time <= accelerationTime) {\n            // Acceleration phase\n            return maxAcceleration * time;\n        } else if (time <= accelerationTime + cruiseTime) {\n            // Cruise phase\n            return maxVelocity;\n        } else {\n            // Deceleration phase\n            double decelTime = time - accelerationTime - cruiseTime;\n            return maxVelocity - maxAcceleration * decelTime;\n        }\n    }\n    \n    /**\n     * Get acceleration at specific time\n     */\n    public double getAcceleration(double time) {\n        if (time <= 0 || time >= totalTime) return 0.0;\n        \n        if (time <= accelerationTime) {\n            // Acceleration phase\n            return maxAcceleration;\n        } else if (time <= accelerationTime + cruiseTime) {\n            // Cruise phase\n            return 0.0;\n        } else {\n            // Deceleration phase\n            return -maxAcceleration;\n        }\n    }\n    \n    public double getTotalTime() { return totalTime; }\n    public double getStartPosition() { return startPosition; }\n    public double getEndPosition() { return endPosition; }\n}"
    },
    {
      "type": "text",
      "title": "Trapezoidal Motion Profiles",
      "content": "Trapezoidal profiles are the most common type of motion profile, consisting of acceleration, constant velocity, and deceleration phases. They provide smooth motion with efficient use of available power."
    },
    {
      "type": "code",
      "title": "Trapezoidal Profile Implementation",
      "language": "java",
      "content": "public class TrapezoidalProfile {\n    private double startPosition;\n    private double endPosition;\n    private double maxVelocity;\n    private double maxAcceleration;\n    private double maxDeceleration;\n    \n    // Profile timing\n    private double accelerationTime;\n    private double cruiseTime;\n    private double decelerationTime;\n    private double totalTime;\n    \n    // Profile distances\n    private double accelerationDistance;\n    private double cruiseDistance;\n    private double decelerationDistance;\n    \n    public TrapezoidalProfile(double startPosition, double endPosition, \n                             double maxVelocity, double maxAcceleration, double maxDeceleration) {\n        this.startPosition = startPosition;\n        this.endPosition = endPosition;\n        this.maxVelocity = maxVelocity;\n        this.maxAcceleration = maxAcceleration;\n        this.maxDeceleration = maxDeceleration;\n        \n        calculateProfile();\n    }\n    \n    /**\n     * Calculate complete profile\n     */\n    private void calculateProfile() {\n        double totalDistance = Math.abs(endPosition - startPosition);\n        \n        // Calculate acceleration and deceleration times\n        accelerationTime = maxVelocity / maxAcceleration;\n        decelerationTime = maxVelocity / maxDeceleration;\n        \n        // Calculate distances for each phase\n        accelerationDistance = 0.5 * maxAcceleration * accelerationTime * accelerationTime;\n        decelerationDistance = 0.5 * maxDeceleration * decelerationTime * decelerationTime;\n        \n        // Check if we can reach max velocity\n        if (accelerationDistance + decelerationDistance > totalDistance) {\n            // Can't reach max velocity - triangular profile\n            double ratio = maxDeceleration / (maxAcceleration + maxDeceleration);\n            accelerationTime = Math.sqrt(2 * totalDistance * ratio / maxAcceleration);\n            decelerationTime = Math.sqrt(2 * totalDistance * (1 - ratio) / maxDeceleration);\n            \n            maxVelocity = maxAcceleration * accelerationTime;\n            cruiseTime = 0.0;\n            cruiseDistance = 0.0;\n        } else {\n            // Can reach max velocity - trapezoidal profile\n            cruiseDistance = totalDistance - accelerationDistance - decelerationDistance;\n            cruiseTime = cruiseDistance / maxVelocity;\n        }\n        \n        totalTime = accelerationTime + cruiseTime + decelerationTime;\n    }\n    \n    /**\n     * Get profile state at specific time\n     */\n    public ProfileState getState(double time) {\n        if (time <= 0) {\n            return new ProfileState(startPosition, 0.0, 0.0);\n        }\n        if (time >= totalTime) {\n            return new ProfileState(endPosition, 0.0, 0.0);\n        }\n        \n        double position, velocity, acceleration;\n        \n        if (time <= accelerationTime) {\n            // Acceleration phase\n            acceleration = maxAcceleration;\n            velocity = maxAcceleration * time;\n            position = startPosition + 0.5 * maxAcceleration * time * time;\n        } else if (time <= accelerationTime + cruiseTime) {\n            // Cruise phase\n            acceleration = 0.0;\n            velocity = maxVelocity;\n            double cruiseTimeElapsed = time - accelerationTime;\n            position = startPosition + accelerationDistance + maxVelocity * cruiseTimeElapsed;\n        } else {\n            // Deceleration phase\n            double decelTime = time - accelerationTime - cruiseTime;\n            acceleration = -maxDeceleration;\n            velocity = maxVelocity - maxDeceleration * decelTime;\n            position = startPosition + accelerationDistance + cruiseDistance + \n                      maxVelocity * decelTime - 0.5 * maxDeceleration * decelTime * decelTime;\n        }\n        \n        return new ProfileState(position, velocity, acceleration);\n    }\n    \n    /**\n     * Check if profile is valid\n     */\n    public boolean isValid() {\n        return totalTime > 0 && !Double.isNaN(totalTime);\n    }\n    \n    public static class ProfileState {\n        public final double position;\n        public final double velocity;\n        public final double acceleration;\n        \n        public ProfileState(double position, double velocity, double acceleration) {\n            this.position = position;\n            this.velocity = velocity;\n            this.acceleration = acceleration;\n        }\n        \n        @Override\n        public String toString() {\n            return String.format(\"Position: %.3f, Velocity: %.3f, Acceleration: %.3f\", \n                                position, velocity, acceleration);\n        }\n    }\n    \n    public double getTotalTime() { return totalTime; }\n    public double getMaxVelocity() { return maxVelocity; }\n}"
    },
    {
      "type": "text",
      "title": "S-Curve Motion Profiles",
      "content": "S-curve profiles use smooth acceleration and deceleration curves instead of constant acceleration. This reduces jerk and provides even smoother motion, though with slightly longer travel times."
    },
    {
      "type": "code",
      "title": "S-Curve Profile Implementation",
      "language": "java",
      "content": "public class SCurveProfile {\n    private double startPosition;\n    private double endPosition;\n    private double maxVelocity;\n    private double maxAcceleration;\n    private double jerk;\n    \n    // Profile timing\n    private double jerkTime;\n    private double accelerationTime;\n    private double cruiseTime;\n    private double totalTime;\n    \n    public SCurveProfile(double startPosition, double endPosition, \n                        double maxVelocity, double maxAcceleration, double jerk) {\n        this.startPosition = startPosition;\n        this.endPosition = endPosition;\n        this.maxVelocity = maxVelocity;\n        this.maxAcceleration = maxAcceleration;\n        this.jerk = jerk;\n        \n        calculateProfile();\n    }\n    \n    /**\n     * Calculate S-curve profile timing\n     */\n    private void calculateProfile() {\n        // Time to reach max acceleration\n        jerkTime = maxAcceleration / jerk;\n        \n        // Time to reach max velocity (excluding jerk phases)\n        accelerationTime = maxVelocity / maxAcceleration;\n        \n        // Total acceleration time including jerk\n        double totalAccelTime = jerkTime + accelerationTime;\n        \n        // Distance covered during acceleration\n        double accelerationDistance = calculateAccelerationDistance(totalAccelTime);\n        \n        // Check if we can reach max velocity\n        if (accelerationDistance * 2 > Math.abs(endPosition - startPosition)) {\n            // Can't reach max velocity - adjust profile\n            double totalDistance = Math.abs(endPosition - startPosition) / 2.0;\n            totalAccelTime = solveForTime(totalDistance);\n            cruiseTime = 0.0;\n        } else {\n            // Can reach max velocity\n            double totalDistance = Math.abs(endPosition - startPosition);\n            cruiseTime = (totalDistance - 2 * accelerationDistance) / maxVelocity;\n        }\n        \n        totalTime = 2 * totalAccelTime + cruiseTime;\n    }\n    \n    /**\n     * Calculate distance covered during acceleration phase\n     */\n    private double calculateAccelerationDistance(double time) {\n        if (time <= jerkTime) {\n            // Only jerk phase\n            return jerk * time * time * time / 6.0;\n        } else {\n            // Jerk + constant acceleration phases\n            double jerkDistance = jerk * jerkTime * jerkTime * jerkTime / 6.0;\n            double constantAccelTime = time - jerkTime;\n            double constantAccelDistance = maxAcceleration * constantAccelTime * constantAccelTime / 2.0;\n            return jerkDistance + constantAccelDistance;\n        }\n    }\n    \n    /**\n     * Solve for time given distance (simplified)\n     */\n    private double solveForTime(double distance) {\n        // Simplified solution - in practice would use more sophisticated methods\n        return Math.sqrt(2 * distance / maxAcceleration);\n    }\n    \n    /**\n     * Get profile state at specific time\n     */\n    public ProfileState getState(double time) {\n        if (time <= 0) {\n            return new ProfileState(startPosition, 0.0, 0.0, 0.0);\n        }\n        if (time >= totalTime) {\n            return new ProfileState(endPosition, 0.0, 0.0, 0.0);\n        }\n        \n        double position, velocity, acceleration, jerkValue;\n        \n        if (time <= jerkTime) {\n            // Initial jerk phase\n            jerkValue = jerk;\n            acceleration = jerk * time;\n            velocity = jerk * time * time / 2.0;\n            position = startPosition + jerk * time * time * time / 6.0;\n        } else if (time <= jerkTime + accelerationTime) {\n            // Constant acceleration phase\n            double constantAccelTime = time - jerkTime;\n            jerkValue = 0.0;\n            acceleration = maxAcceleration;\n            velocity = maxAcceleration * constantAccelTime + jerk * jerkTime * jerkTime / 2.0;\n            position = startPosition + calculateAccelerationDistance(time);\n        } else if (time <= jerkTime + accelerationTime + cruiseTime) {\n            // Cruise phase\n            double cruiseTimeElapsed = time - jerkTime - accelerationTime;\n            jerkValue = 0.0;\n            acceleration = 0.0;\n            velocity = maxVelocity;\n            position = startPosition + 2 * calculateAccelerationDistance(jerkTime + accelerationTime) + \n                      maxVelocity * cruiseTimeElapsed;\n        } else {\n            // Deceleration phases (mirror of acceleration)\n            double decelTime = totalTime - time;\n            if (decelTime <= jerkTime) {\n                // Final jerk phase\n                jerkValue = -jerk;\n                acceleration = jerk * decelTime;\n                velocity = jerk * decelTime * decelTime / 2.0;\n                position = endPosition - jerk * decelTime * decelTime * decelTime / 6.0;\n            } else {\n                // Constant deceleration phase\n                double constantDecelTime = decelTime - jerkTime;\n                jerkValue = 0.0;\n                acceleration = -maxAcceleration;\n                velocity = maxAcceleration * constantDecelTime + jerk * jerkTime * jerkTime / 2.0;\n                position = endPosition - calculateAccelerationDistance(decelTime);\n            }\n        }\n        \n        return new ProfileState(position, velocity, acceleration, jerkValue);\n    }\n    \n    public static class ProfileState {\n        public final double position;\n        public final double velocity;\n        public final double acceleration;\n        public final double jerk;\n        \n        public ProfileState(double position, double velocity, double acceleration, double jerk) {\n            this.position = position;\n            this.velocity = velocity;\n            this.acceleration = acceleration;\n            this.jerk = jerk;\n        }\n    }\n    \n    public double getTotalTime() { return totalTime; }\n}"
    },
    {
      "type": "text",
      "title": "Motion Profile Execution",
      "content": "Executing motion profiles requires careful timing and feedback control to follow the planned trajectory accurately."
    },
    {
      "type": "code",
      "title": "Motion Profile Executor",
      "language": "java",
      "content": "public class MotionProfileExecutor extends LinearOpMode {\n    private DcMotor leftMotor;\n    private DcMotor rightMotor;\n    private IMU imu;\n    private PIDController positionController;\n    private PIDController velocityController;\n    \n    private TrapezoidalProfile profile;\n    private double startTime;\n    private boolean isExecuting = false;\n    \n    @Override\n    public void runOpMode() {\n        // Initialize hardware\n        leftMotor = hardwareMap.get(DcMotor.class, \"left_motor\");\n        rightMotor = hardwareMap.get(DcMotor.class, \"right_motor\");\n        imu = hardwareMap.get(IMU.class, \"imu\");\n        \n        // Initialize IMU\n        IMU.Parameters parameters = new IMU.Parameters(\n            new RevHubOrientationOnRobot(\n                RevHubOrientationOnRobot.LogoFacingDirection.UP,\n                RevHubOrientationOnRobot.UsbFacingDirection.FORWARD\n            )\n        );\n        imu.initialize(parameters);\n        \n        // Initialize controllers\n        positionController = new PIDController(0.1, 0.0, 0.01);\n        velocityController = new PIDController(0.8, 0.1, 0.05);\n        \n        waitForStart();\n        \n        // Example: Execute motion profile\n        executeProfile(0.0, 24.0, 12.0, 24.0); // 24 inches at 12 in/s\n    }\n    \n    /**\n     * Execute a motion profile\n     */\n    public void executeProfile(double startPosition, double endPosition, \n                              double maxVelocity, double maxAcceleration) {\n        // Create motion profile\n        profile = new TrapezoidalProfile(startPosition, endPosition, maxVelocity, maxAcceleration, maxAcceleration);\n        \n        if (!profile.isValid()) {\n            telemetry.addData(\"Error\", \"Invalid motion profile\");\n            telemetry.update();\n            return;\n        }\n        \n        startTime = getRuntime();\n        isExecuting = true;\n        \n        // Set initial setpoints\n        positionController.setSetpoint(startPosition);\n        velocityController.setSetpoint(0.0);\n        \n        while (opModeIsActive() && isExecuting) {\n            double currentTime = getRuntime() - startTime;\n            \n            if (currentTime >= profile.getTotalTime()) {\n                // Profile complete\n                stopMotors();\n                isExecuting = false;\n                break;\n            }\n            \n            // Get desired state from profile\n            TrapezoidalProfile.ProfileState desiredState = profile.getState(currentTime);\n            \n            // Get current robot state\n            double currentPosition = getCurrentPosition();\n            double currentVelocity = getCurrentVelocity();\n            \n            // Calculate control outputs\n            double positionError = desiredState.position - currentPosition;\n            double velocityError = desiredState.velocity - currentVelocity;\n            \n            double positionOutput = positionController.calculate(currentPosition, getRuntime());\n            double velocityOutput = velocityController.calculate(currentVelocity, getRuntime());\n            \n            // Combine outputs (feedforward + feedback)\n            double totalOutput = desiredState.velocity + positionOutput + velocityOutput;\n            \n            // Apply to motors\n            double leftPower = Math.max(-1.0, Math.min(1.0, totalOutput));\n            double rightPower = Math.max(-1.0, Math.min(1.0, totalOutput));\n            \n            leftMotor.setPower(leftPower);\n            rightMotor.setPower(rightPower);\n            \n            // Telemetry\n            telemetry.addData(\"Time\", String.format(\"%.2f/%.2f\", currentTime, profile.getTotalTime()));\n            telemetry.addData(\"Desired Position\", String.format(\"%.2f\", desiredState.position));\n            telemetry.addData(\"Current Position\", String.format(\"%.2f\", currentPosition));\n            telemetry.addData(\"Position Error\", String.format(\"%.2f\", positionError));\n            telemetry.addData(\"Desired Velocity\", String.format(\"%.2f\", desiredState.velocity));\n            telemetry.addData(\"Current Velocity\", String.format(\"%.2f\", currentVelocity));\n            telemetry.addData(\"Output\", String.format(\"%.2f\", totalOutput));\n            telemetry.update();\n            \n            sleep(50); // 20Hz control loop\n        }\n    }\n    \n    private double getCurrentPosition() {\n        // Simplified - would use odometry in practice\n        return (leftMotor.getCurrentPosition() + rightMotor.getCurrentPosition()) / 2.0;\n    }\n    \n    private double getCurrentVelocity() {\n        // Simplified - would use velocity estimation in practice\n        return (leftMotor.getPower() + rightMotor.getPower()) / 2.0;\n    }\n    \n    private void stopMotors() {\n        leftMotor.setPower(0);\n        rightMotor.setPower(0);\n    }\n    \n    public void stopProfile() {\n        isExecuting = false;\n        stopMotors();\n    }\n}"
    },
    {
      "type": "rules-box",
      "title": "Motion Profile Safety Guidelines",
      "content": "When implementing motion profiles:",
      "items": [
        "Always validate profile parameters before execution",
        "Implement emergency stop functionality",
        "Monitor actual vs desired trajectory",
        "Set reasonable velocity and acceleration limits",
        "Test profiles in simulation first",
        "Use proper error handling and recovery",
        "Validate performance under various conditions"
      ]
    },
    {
      "type": "text",
      "title": "Troubleshooting Motion Profile Issues",
      "content": "Common problems in motion profiling and their solutions:"
    },
    {
      "type": "list",
      "title": "Common Issues and Solutions",
      "items": [
        "Profile following errors: Increase PID gains or reduce profile speed",
        "Oscillations: Reduce PID gains or add filtering",
        "Incomplete profiles: Check for early termination conditions",
        "Timing issues: Ensure consistent control loop frequency",
        "Position drift: Improve position feedback accuracy",
        "Velocity tracking errors: Tune velocity controller gains",
        "Profile generation failures: Validate input parameters"
      ]
    },
    {
      "type": "exercise-box",
      "title": "Practice: Motion Profile Implementation",
      "description": "Implement and test different types of motion profiles.",
      "tasks": [
        "Create a basic trapezoidal motion profile",
        "Implement S-curve profile for smoother motion",
        "Add profile execution with PID control",
        "Test with different distance and speed parameters",
        "Compare performance of different profile types"
      ],
      "content": "// Example implementation\npublic class MyMotionProfile {\n    // Your implementation here\n}"
    },
    {
      "type": "link-grid",
      "title": "Related Topics",
      "content": "Explore these related topics to expand your knowledge:",
      "items": [
        "<a href=\"../advanced-movement-control/advanced-movement-control.json\">Advanced Movement Control</a> - Kinematics and dynamics",
        "<a href=\"../pid-control/pid-control.json\">PID Control</a> - Closed-loop control systems",
        "<a href=\"../robot-pid-control/robot-pid-control.json\">Robot PID Control</a> - Multi-axis coordination",
        "<a href=\"../advanced-control-theory/advanced-control-theory.json\">Advanced Control Theory</a> - Mathematical foundations",
        "<a href=\"../../sensors/imu.json\">IMU Integration</a> - Orientation and heading control"
      ]
    },
    {
      "type": "emphasis-box",
      "title": "External Resources",
      "content": "Additional resources for motion profiling:",
      "items": [
        "<a href=\"https://gm0.org/en/latest/docs/software/tutorials/advanced/motion-profiling.html\" target=\"_blank\">gm0: Motion Profiling</a>",
        "<a href=\"https://gm0.org/en/latest/docs/software/tutorials/advanced/trajectory-generation.html\" target=\"_blank\">gm0: Trajectory Generation</a>",
        "<a href=\"https://docs.revrobotics.com/duo-control/duo-control-programming/motion-profiling\" target=\"_blank\">REV: Motion Profiling Guide</a>",
        "<a href=\"https://www.chiefdelphi.com/t/paper-motion-profiling-for-robots/163087\" target=\"_blank\">Chief Delphi: Motion Profiling Paper</a>"
      ]
    }
  ]
} 