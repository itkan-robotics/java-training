{
  "title": "Configuration Variables",
  "sections": [
    {
      "type": "text",
      "title": "Runtime Configuration Overview",
      "content": "FTCDashboard's configuration system allows you to change robot parameters without recompiling your code. This is incredibly useful for tuning PID values, adjusting autonomous parameters, and testing different configurations during development and competition."
    },
    {
      "type": "rules-box",
      "title": "Configuration System Benefits",
      "items": [
        "Change parameters without code recompilation",
        "Real-time parameter adjustment during testing",
        "Save and load different configuration profiles",
        "Organize parameters into logical groups",
        "Validate parameter values and set constraints",
        "Share configurations across team members"
      ]
    },
    {
      "type": "text",
      "title": "Basic Configuration Setup",
      "content": "To use configuration variables, you need to annotate your OpMode class with @Config and declare your configurable variables. The dashboard automatically creates a configuration interface for these variables."
    },
    {
      "type": "code",
      "title": "Basic Configuration Example",
      "content": "This example shows how to set up basic configuration variables:",
      "code": "import com.acmerobotics.dashboard.config.Config;\nimport com.acmerobotics.dashboard.FtcDashboard;\n\n@Config\npublic class BasicConfigOpMode extends OpMode {\n    private FtcDashboard dashboard;\n    \n    // Configuration variables - these will appear in the dashboard\n    public static double DRIVE_SPEED = 0.5;\n    public static double TURN_SPEED = 0.3;\n    public static int TARGET_POSITION = 1000;\n    public static boolean USE_ENCODERS = true;\n    \n    private DcMotor leftMotor, rightMotor;\n    \n    @Override\n    public void init() {\n        dashboard = FtcDashboard.getInstance();\n        \n        leftMotor = hardwareMap.get(DcMotor.class, \"left_motor\");\n        rightMotor = hardwareMap.get(DcMotor.class, \"right_motor\");\n        \n        if (USE_ENCODERS) {\n            leftMotor.setMode(DcMotor.RunMode.STOP_AND_RESET_ENCODER);\n            rightMotor.setMode(DcMotor.RunMode.STOP_AND_RESET_ENCODER);\n        }\n    }\n    \n    @Override\n    public void loop() {\n        // Use configuration variables in your code\n        if (gamepad1.left_stick_y > 0.1) {\n            leftMotor.setPower(DRIVE_SPEED);\n            rightMotor.setPower(DRIVE_SPEED);\n        } else if (gamepad1.left_stick_y < -0.1) {\n            leftMotor.setPower(-DRIVE_SPEED);\n            rightMotor.setPower(-DRIVE_SPEED);\n        } else if (gamepad1.right_stick_x > 0.1) {\n            leftMotor.setPower(TURN_SPEED);\n            rightMotor.setPower(-TURN_SPEED);\n        } else if (gamepad1.right_stick_x < -0.1) {\n            leftMotor.setPower(-TURN_SPEED);\n            rightMotor.setPower(TURN_SPEED);\n        } else {\n            leftMotor.setPower(0);\n            rightMotor.setPower(0);\n        }\n        \n        // Display current configuration values\n        telemetry.addData(\"Drive Speed\", DRIVE_SPEED);\n        telemetry.addData(\"Turn Speed\", TURN_SPEED);\n        telemetry.addData(\"Use Encoders\", USE_ENCODERS);\n        telemetry.update();\n    }\n}"
    },
    {
      "type": "text",
      "title": "Variable Types and Constraints",
      "content": "FTCDashboard supports various data types for configuration variables, and you can set constraints to ensure values stay within acceptable ranges. This helps prevent invalid configurations that could damage your robot."
    },
    {
      "type": "code",
      "title": "Variable Types and Constraints Example",
      "content": "This example demonstrates different variable types and how to set constraints:",
      "code": "import com.acmerobotics.dashboard.config.Config;\nimport com.acmerobotics.dashboard.config.Value;\n\n@Config\npublic class AdvancedConfigOpMode extends OpMode {\n    private FtcDashboard dashboard;\n    \n    // Integer with range constraint\n    @Value(min = 0, max = 2000)\n    public static int ENCODER_TARGET = 1000;\n    \n    // Double with range constraint\n    @Value(min = 0.0, max = 1.0)\n    public static double MOTOR_POWER = 0.5;\n    \n    // Boolean configuration\n    public static boolean REVERSE_MOTORS = false;\n    \n    // String configuration\n    public static String ROBOT_NAME = \"MyRobot\";\n    \n    // Enum configuration\n    public static enum DriveMode {\n        TANK_DRIVE,\n        ARCADE_DRIVE,\n        MECANUM_DRIVE\n    }\n    public static DriveMode DRIVE_MODE = DriveMode.TANK_DRIVE;\n    \n    // Array configuration\n    public static double[] PID_VALUES = {0.1, 0.0, 0.0};\n    \n    private DcMotor leftMotor, rightMotor;\n    \n    @Override\n    public void init() {\n        dashboard = FtcDashboard.getInstance();\n        \n        leftMotor = hardwareMap.get(DcMotor.class, \"left_motor\");\n        rightMotor = hardwareMap.get(DcMotor.class, \"right_motor\");\n        \n        // Apply configuration\n        if (REVERSE_MOTORS) {\n            leftMotor.setDirection(DcMotor.Direction.REVERSE);\n            rightMotor.setDirection(DcMotor.Direction.REVERSE);\n        }\n    }\n    \n    @Override\n    public void loop() {\n        // Use different drive modes based on configuration\n        switch (DRIVE_MODE) {\n            case TANK_DRIVE:\n                tankDrive();\n                break;\n            case ARCADE_DRIVE:\n                arcadeDrive();\n                break;\n            case MECANUM_DRIVE:\n                mecanumDrive();\n                break;\n        }\n        \n        // Display configuration values\n        telemetry.addData(\"Robot Name\", ROBOT_NAME);\n        telemetry.addData(\"Drive Mode\", DRIVE_MODE);\n        telemetry.addData(\"Motor Power\", MOTOR_POWER);\n        telemetry.addData(\"PID Values\", \"[%.2f, %.2f, %.2f]\", \n                         PID_VALUES[0], PID_VALUES[1], PID_VALUES[2]);\n        telemetry.update();\n    }\n    \n    private void tankDrive() {\n        double leftPower = gamepad1.left_stick_y * MOTOR_POWER;\n        double rightPower = gamepad1.right_stick_y * MOTOR_POWER;\n        leftMotor.setPower(leftPower);\n        rightMotor.setPower(rightPower);\n    }\n    \n    private void arcadeDrive() {\n        double drive = gamepad1.left_stick_y * MOTOR_POWER;\n        double turn = gamepad1.right_stick_x * MOTOR_POWER;\n        double leftPower = drive + turn;\n        double rightPower = drive - turn;\n        leftMotor.setPower(leftPower);\n        rightMotor.setPower(rightPower);\n    }\n    \n    private void mecanumDrive() {\n        // Mecanum drive implementation\n        double forward = gamepad1.left_stick_y * MOTOR_POWER;\n        double strafe = gamepad1.left_stick_x * MOTOR_POWER;\n        double turn = gamepad1.right_stick_x * MOTOR_POWER;\n        \n        // This would need 4 motors for full mecanum implementation\n        leftMotor.setPower(forward + turn);\n        rightMotor.setPower(forward - turn);\n    }\n}"
    },
    {
      "type": "rules-box",
      "title": "Supported Variable Types",
      "items": [
        "int: Integer values with optional min/max constraints",
        "double: Decimal values with optional min/max constraints",
        "boolean: True/false values",
        "String: Text values",
        "Enum: Predefined option lists",
        "Arrays: Collections of values",
        "Custom objects: Complex data structures"
      ]
    },
    {
      "type": "text",
      "title": "Configuration Groups",
      "content": "For complex robots with many parameters, you can organize configuration variables into logical groups. This makes the dashboard interface more organized and easier to navigate."
    },
    {
      "type": "code",
      "title": "Configuration Groups Example",
      "content": "This example shows how to organize configuration variables into groups:",
      "code": "import com.acmerobotics.dashboard.config.Config;\nimport com.acmerobotics.dashboard.config.Value;\n\n@Config\npublic class GroupedConfigOpMode extends OpMode {\n    private FtcDashboard dashboard;\n    \n    // Drive configuration group\n    public static class DriveConfig {\n        @Value(min = 0.0, max = 1.0)\n        public static double MAX_SPEED = 0.8;\n        \n        @Value(min = 0.0, max = 1.0)\n        public static double TURN_SPEED = 0.6;\n        \n        public static boolean REVERSE_LEFT = false;\n        public static boolean REVERSE_RIGHT = false;\n    }\n    \n    // PID configuration group\n    public static class PIDConfig {\n        @Value(min = 0.0, max = 2.0)\n        public static double KP = 0.1;\n        \n        @Value(min = 0.0, max = 1.0)\n        public static double KI = 0.0;\n        \n        @Value(min = 0.0, max = 1.0)\n        public static double KD = 0.0;\n        \n        @Value(min = 0, max = 2000)\n        public static int TOLERANCE = 50;\n    }\n    \n    // Autonomous configuration group\n    public static class AutoConfig {\n        @Value(min = 0, max = 5000)\n        public static int FORWARD_DISTANCE = 1000;\n        \n        @Value(min = 0, max = 360)\n        public static int TURN_ANGLE = 90;\n        \n        public static boolean USE_VISION = true;\n        public static String STARTING_POSITION = \"LEFT\";\n    }\n    \n    // Sensor configuration group\n    public static class SensorConfig {\n        @Value(min = 0.0, max = 5.0)\n        public static double COLOR_THRESHOLD = 0.5;\n        \n        @Value(min = 0.0, max = 100.0)\n        public static double DISTANCE_THRESHOLD = 10.0;\n        \n        public static boolean USE_IMU = true;\n    }\n    \n    private DcMotor leftMotor, rightMotor;\n    private ColorSensor colorSensor;\n    private DistanceSensor distanceSensor;\n    \n    @Override\n    public void init() {\n        dashboard = FtcDashboard.getInstance();\n        \n        leftMotor = hardwareMap.get(DcMotor.class, \"left_motor\");\n        rightMotor = hardwareMap.get(DcMotor.class, \"right_motor\");\n        colorSensor = hardwareMap.get(ColorSensor.class, \"color_sensor\");\n        distanceSensor = hardwareMap.get(DistanceSensor.class, \"distance_sensor\");\n        \n        // Apply drive configuration\n        if (DriveConfig.REVERSE_LEFT) {\n            leftMotor.setDirection(DcMotor.Direction.REVERSE);\n        }\n        if (DriveConfig.REVERSE_RIGHT) {\n            rightMotor.setDirection(DcMotor.Direction.REVERSE);\n        }\n    }\n    \n    @Override\n    public void loop() {\n        // Use grouped configuration values\n        double leftPower = gamepad1.left_stick_y * DriveConfig.MAX_SPEED;\n        double rightPower = gamepad1.right_stick_y * DriveConfig.MAX_SPEED;\n        \n        if (gamepad1.right_stick_x > 0.1) {\n            leftPower = DriveConfig.TURN_SPEED;\n            rightPower = -DriveConfig.TURN_SPEED;\n        } else if (gamepad1.right_stick_x < -0.1) {\n            leftPower = -DriveConfig.TURN_SPEED;\n            rightPower = DriveConfig.TURN_SPEED;\n        }\n        \n        leftMotor.setPower(leftPower);\n        rightMotor.setPower(rightPower);\n        \n        // Display grouped configuration values\n        telemetry.addData(\"Drive Config\", \"Max Speed: %.2f, Turn Speed: %.2f\", \n                         DriveConfig.MAX_SPEED, DriveConfig.TURN_SPEED);\n        telemetry.addData(\"PID Config\", \"Kp: %.2f, Ki: %.2f, Kd: %.2f\", \n                         PIDConfig.KP, PIDConfig.KI, PIDConfig.KD);\n        telemetry.addData(\"Auto Config\", \"Distance: %d, Angle: %d\", \n                         AutoConfig.FORWARD_DISTANCE, AutoConfig.TURN_ANGLE);\n        telemetry.addData(\"Sensor Config\", \"Color Threshold: %.2f, Distance: %.1f\", \n                         SensorConfig.COLOR_THRESHOLD, SensorConfig.DISTANCE_THRESHOLD);\n        telemetry.update();\n    }\n}"
    },
    {
      "type": "text",
      "title": "Configuration Persistence",
      "content": "FTCDashboard can save and load configuration values, allowing you to maintain settings between robot restarts and share configurations across team members. This is especially useful for competition settings where you need consistent parameters."
    },
    {
      "type": "code",
      "title": "Configuration Persistence Example",
      "content": "This example demonstrates how to save and load configuration profiles:",
      "code": "import com.acmerobotics.dashboard.config.Config;\nimport com.acmerobotics.dashboard.config.Value;\nimport com.acmerobotics.dashboard.telemetry.TelemetryPacket;\n\n@Config\npublic class PersistentConfigOpMode extends OpMode {\n    private FtcDashboard dashboard;\n    private TelemetryPacket packet;\n    \n    // Configuration variables\n    @Value(min = 0.0, max = 1.0)\n    public static double DRIVE_SPEED = 0.5;\n    \n    @Value(min = 0.0, max = 1.0)\n    public static double TURN_SPEED = 0.3;\n    \n    public static String CONFIG_NAME = \"default\";\n    \n    private DcMotor leftMotor, rightMotor;\n    private boolean configLoaded = false;\n    \n    @Override\n    public void init() {\n        dashboard = FtcDashboard.getInstance();\n        packet = new TelemetryPacket();\n        \n        leftMotor = hardwareMap.get(DcMotor.class, \"left_motor\");\n        rightMotor = hardwareMap.get(DcMotor.class, \"right_motor\");\n        \n        // Load configuration if not already loaded\n        if (!configLoaded) {\n            loadConfiguration();\n            configLoaded = true;\n        }\n    }\n    \n    @Override\n    public void loop() {\n        // Handle configuration management\n        if (gamepad1.y) {\n            // Save current configuration\n            saveConfiguration();\n            telemetry.addData(\"Status\", \"Configuration saved\");\n        } else if (gamepad1.x) {\n            // Load configuration\n            loadConfiguration();\n            telemetry.addData(\"Status\", \"Configuration loaded\");\n        } else if (gamepad1.b) {\n            // Reset to defaults\n            resetConfiguration();\n            telemetry.addData(\"Status\", \"Configuration reset\");\n        }\n        \n        // Normal robot control using configuration values\n        double leftPower = gamepad1.left_stick_y * DRIVE_SPEED;\n        double rightPower = gamepad1.right_stick_y * DRIVE_SPEED;\n        \n        if (gamepad1.right_stick_x > 0.1) {\n            leftPower = TURN_SPEED;\n            rightPower = -TURN_SPEED;\n        } else if (gamepad1.right_stick_x < -0.1) {\n            leftPower = -TURN_SPEED;\n            rightPower = TURN_SPEED;\n        }\n        \n        leftMotor.setPower(leftPower);\n        rightMotor.setPower(rightPower);\n        \n        // Display configuration status\n        telemetry.addData(\"Drive Speed\", DRIVE_SPEED);\n        telemetry.addData(\"Turn Speed\", TURN_SPEED);\n        telemetry.addData(\"Config Name\", CONFIG_NAME);\n        telemetry.addData(\"Controls\", \"Y=Save, X=Load, B=Reset\");\n        telemetry.update();\n        \n        // Send configuration status to dashboard\n        packet.put(\"Drive Speed\", DRIVE_SPEED);\n        packet.put(\"Turn Speed\", TURN_SPEED);\n        packet.put(\"Config Name\", CONFIG_NAME);\n        dashboard.sendTelemetryPacket(packet);\n    }\n    \n    private void saveConfiguration() {\n        // Configuration is automatically saved by the dashboard\n        // You can add custom save logic here if needed\n        CONFIG_NAME = \"saved_config_\" + System.currentTimeMillis();\n    }\n    \n    private void loadConfiguration() {\n        // Configuration is automatically loaded by the dashboard\n        // You can add custom load logic here if needed\n        CONFIG_NAME = \"loaded_config\";\n    }\n    \n    private void resetConfiguration() {\n        DRIVE_SPEED = 0.5;\n        TURN_SPEED = 0.3;\n        CONFIG_NAME = \"default\";\n    }\n}"
    },
    {
      "type": "rules-box",
      "title": "Configuration Best Practices",
      "items": [
        "Use descriptive variable names that clearly indicate their purpose",
        "Set appropriate constraints to prevent invalid values",
        "Group related parameters together for better organization",
        "Use default values that are safe and functional",
        "Document what each configuration variable does",
        "Test configuration changes thoroughly before competition",
        "Save working configurations for different scenarios"
      ]
    },
    {
      "type": "text",
      "title": "Advanced Configuration Techniques",
      "content": "For more complex applications, you can create dynamic configurations, conditional parameters, and custom validation logic."
    },
    {
      "type": "code",
      "title": "Advanced Configuration Example",
      "content": "This example demonstrates advanced configuration techniques including dynamic parameters and validation:",
      "code": "import com.acmerobotics.dashboard.config.Config;\nimport com.acmerobotics.dashboard.config.Value;\nimport java.util.HashMap;\nimport java.util.Map;\n\n@Config\npublic class AdvancedConfigOpMode extends OpMode {\n    private FtcDashboard dashboard;\n    \n    // Dynamic configuration based on robot type\n    public static enum RobotType {\n        TANK_DRIVE,\n        MECANUM_DRIVE,\n        SWERVE_DRIVE\n    }\n    public static RobotType ROBOT_TYPE = RobotType.TANK_DRIVE;\n    \n    // Configuration that changes based on robot type\n    public static class TankDriveConfig {\n        @Value(min = 0.0, max = 1.0)\n        public static double LEFT_MOTOR_SCALE = 1.0;\n        \n        @Value(min = 0.0, max = 1.0)\n        public static double RIGHT_MOTOR_SCALE = 1.0;\n    }\n    \n    public static class MecanumDriveConfig {\n        @Value(min = 0.0, max = 1.0)\n        public static double FRONT_LEFT_SCALE = 1.0;\n        \n        @Value(min = 0.0, max = 1.0)\n        public static double FRONT_RIGHT_SCALE = 1.0;\n        \n        @Value(min = 0.0, max = 1.0)\n        public static double REAR_LEFT_SCALE = 1.0;\n        \n        @Value(min = 0.0, max = 1.0)\n        public static double REAR_RIGHT_SCALE = 1.0;\n    }\n    \n    // PID configuration for different subsystems\n    public static Map<String, double[]> PID_CONFIGS = new HashMap<>() {{\n        put(\"drive\", new double[]{0.1, 0.0, 0.0});\n        put(\"turn\", new double[]{0.05, 0.0, 0.0});\n        put(\"arm\", new double[]{0.2, 0.0, 0.0});\n    }};\n    \n    // Competition-specific configurations\n    public static class CompetitionConfig {\n        public static String ALLIANCE_COLOR = \"RED\";\n        public static String STARTING_POSITION = \"LEFT\";\n        public static boolean USE_AUTONOMOUS = true;\n        public static int AUTO_DURATION = 30; // seconds\n    }\n    \n    private DcMotor leftMotor, rightMotor;\n    private boolean configValid = true;\n    \n    @Override\n    public void init() {\n        dashboard = FtcDashboard.getInstance();\n        \n        leftMotor = hardwareMap.get(DcMotor.class, \"left_motor\");\n        rightMotor = hardwareMap.get(DcMotor.class, \"right_motor\");\n        \n        // Validate configuration\n        validateConfiguration();\n        \n        if (!configValid) {\n            telemetry.addData(\"ERROR\", \"Invalid configuration detected!\");\n            telemetry.update();\n            return;\n        }\n        \n        // Apply robot-specific configuration\n        applyRobotConfiguration();\n    }\n    \n    @Override\n    public void loop() {\n        if (!configValid) {\n            // Don't run if configuration is invalid\n            return;\n        }\n        \n        // Use robot-specific control based on configuration\n        switch (ROBOT_TYPE) {\n            case TANK_DRIVE:\n                tankDriveControl();\n                break;\n            case MECANUM_DRIVE:\n                mecanumDriveControl();\n                break;\n            case SWERVE_DRIVE:\n                swerveDriveControl();\n                break;\n        }\n        \n        // Display configuration information\n        telemetry.addData(\"Robot Type\", ROBOT_TYPE);\n        telemetry.addData(\"Alliance\", CompetitionConfig.ALLIANCE_COLOR);\n        telemetry.addData(\"Starting Position\", CompetitionConfig.STARTING_POSITION);\n        telemetry.addData(\"PID Configs\", PID_CONFIGS.size() + \" subsystems\");\n        telemetry.update();\n    }\n    \n    private void validateConfiguration() {\n        configValid = true;\n        \n        // Check PID configurations\n        for (Map.Entry<String, double[]> entry : PID_CONFIGS.entrySet()) {\n            double[] pid = entry.getValue();\n            if (pid.length != 3 || pid[0] < 0 || pid[1] < 0 || pid[2] < 0) {\n                configValid = false;\n                break;\n            }\n        }\n        \n        // Check competition configuration\n        if (!CompetitionConfig.ALLIANCE_COLOR.equals(\"RED\") && \n            !CompetitionConfig.ALLIANCE_COLOR.equals(\"BLUE\")) {\n            configValid = false;\n        }\n        \n        if (CompetitionConfig.AUTO_DURATION <= 0 || CompetitionConfig.AUTO_DURATION > 30) {\n            configValid = false;\n        }\n    }\n    \n    private void applyRobotConfiguration() {\n        switch (ROBOT_TYPE) {\n            case TANK_DRIVE:\n                // Apply tank drive specific settings\n                break;\n            case MECANUM_DRIVE:\n                // Apply mecanum drive specific settings\n                break;\n            case SWERVE_DRIVE:\n                // Apply swerve drive specific settings\n                break;\n        }\n    }\n    \n    private void tankDriveControl() {\n        double leftPower = gamepad1.left_stick_y * TankDriveConfig.LEFT_MOTOR_SCALE;\n        double rightPower = gamepad1.right_stick_y * TankDriveConfig.RIGHT_MOTOR_SCALE;\n        \n        leftMotor.setPower(leftPower);\n        rightMotor.setPower(rightPower);\n    }\n    \n    private void mecanumDriveControl() {\n        // Mecanum drive implementation using MecanumDriveConfig\n        double forward = gamepad1.left_stick_y;\n        double strafe = gamepad1.left_stick_x;\n        double turn = gamepad1.right_stick_x;\n        \n        // Apply scaling factors\n        double fl = (forward + strafe + turn) * MecanumDriveConfig.FRONT_LEFT_SCALE;\n        double fr = (forward - strafe - turn) * MecanumDriveConfig.FRONT_RIGHT_SCALE;\n        double rl = (forward - strafe + turn) * MecanumDriveConfig.REAR_LEFT_SCALE;\n        double rr = (forward + strafe - turn) * MecanumDriveConfig.REAR_RIGHT_SCALE;\n        \n        // This would need 4 motors for full implementation\n        leftMotor.setPower(fl);\n        rightMotor.setPower(fr);\n    }\n    \n    private void swerveDriveControl() {\n        // Swerve drive implementation\n        // This would require more complex motor control\n        telemetry.addData(\"Status\", \"Swerve drive not implemented\");\n    }\n}"
    },
    {
      "type": "exercise-box",
      "title": "Practice Exercise: PID Tuning Configuration",
      "description": "Create an OpMode with configurable PID parameters for motor control and use the dashboard to tune them in real-time.",
      "tasks": [
        "Set up configuration variables for PID gains (Kp, Ki, Kd)",
        "Create configuration groups for different subsystems",
        "Implement PID control using the configuration values",
        "Use the dashboard to tune parameters in real-time",
        "Save and load different PID configurations"
      ],
      "content": "// Your OpMode should include:\n// 1. PID configuration variables with constraints\n// 2. Configuration groups for different motors/subsystems\n// 3. Real-time PID control implementation\n// 4. Configuration persistence (save/load)\n// 5. Parameter validation and safety checks"
    },
    {
      "type": "rules-box",
      "title": "Configuration Safety Guidelines",
      "items": [
        "Always set appropriate min/max constraints for numeric values",
        "Use default values that are safe and functional",
        "Validate configuration values before applying them",
        "Test configuration changes in a safe environment first",
        "Document what each parameter does and its safe range",
        "Have a way to quickly reset to safe defaults",
        "Backup working configurations before making changes"
      ]
    },
    {
      "type": "rules-box",
      "title": "Troubleshooting Configuration Issues",
      "items": [
        "Configuration not appearing: Check @Config annotation and static variables",
        "Values not updating: Ensure variables are static and public",
        "Invalid values: Check constraints and validation logic",
        "Configuration not saving: Verify dashboard connection and permissions",
        "Performance issues: Limit the number of configuration variables",
        "Build errors: Check import statements and annotation usage"
      ]
    },
    {
      "type": "link-grid",
      "title": "Related Topics and Resources",
      "links": [
        "<a href=\"https://acmerobotics.github.io/ftc-dashboard/config\" target=\"_blank\">FTCDashboard Configuration Documentation</a>",
        "<a href=\"https://acmerobotics.github.io/ftc-dashboard/config#variable-types\" target=\"_blank\">Variable Types and Constraints</a>",
        "<a href=\"https://acmerobotics.github.io/ftc-dashboard/config#groups\" target=\"_blank\">Configuration Groups Guide</a>",
        "<a href=\"https://acmerobotics.github.io/ftc-dashboard/config#persistence\" target=\"_blank\">Configuration Persistence</a>",
        "<a href=\"../advanced-movement-control/pid-control.json\">PID Control</a>",
        "<a href=\"../motors/motor-encoders.json\">Motor Encoders</a>",
        "<a href=\"../autonomous-programming/basic-autonomous-programming.json\">Basic Autonomous Programming</a>"
      ]
    }
  ]
} 