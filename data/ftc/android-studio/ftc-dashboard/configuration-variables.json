{
  "title": "Configuration Variables",
  "sections": [
    {
      "type": "text",
      "title": "Runtime Configuration Overview",
      "content": "FTCDashboard's configuration system allows you to change robot parameters without recompiling your code. This is incredibly useful for tuning PID values, adjusting autonomous parameters, and testing different configurations during development and competition."
    },
    {
      "type": "rules-box",
      "title": "Configuration System Benefits",
      "items": [
        "Change parameters without code recompilation",
        "Real-time parameter adjustment during testing",
        "Save and load different configuration profiles",
        "Organize parameters into logical groups",
        "Validate parameter values and set constraints",
        "Share configurations across team members"
      ]
    },
    {
      "type": "text",
      "title": "Step 1: Basic Configuration Setup",
      "content": "To use configuration variables, you need to annotate your OpMode class with @Config and declare your configurable variables. The dashboard automatically creates a configuration interface for these variables."
    },
    {
      "type": "code",
      "title": "Required Imports and Class Setup",
      "content": "Start by adding these imports and class annotation:",
      "code": "// Essential imports for configuration\nimport com.acmerobotics.dashboard.config.Config;\nimport com.acmerobotics.dashboard.FtcDashboard;\n\n// Add @Config annotation to make variables configurable\n@Config\npublic class BasicConfigOpMode extends OpMode {\n    private FtcDashboard dashboard;\n    \n    // Configuration variables - these will appear in the dashboard\n    public static double DRIVE_SPEED = 0.5;\n    public static double TURN_SPEED = 0.3;\n    public static int TARGET_POSITION = 1000;\n    public static boolean USE_ENCODERS = true;\n    \n    // Hardware objects\n    private DcMotor leftMotor, rightMotor;"
    },
    {
      "type": "text",
      "title": "Step 2: Initialization with Configuration",
      "content": "In your init() method, you can use the configuration variables to set up your robot. The values can be changed in real-time through the dashboard."
    },
    {
      "type": "code",
      "title": "Using Configuration Variables in Init",
      "content": "Add this to your init() method:",
      "code": "@Override\npublic void init() {\n    dashboard = FtcDashboard.getInstance();\n    \n    leftMotor = hardwareMap.get(DcMotor.class, \"left_motor\");\n    rightMotor = hardwareMap.get(DcMotor.class, \"right_motor\");\n    \n    // Use configuration variable to decide whether to use encoders\n    if (USE_ENCODERS) {\n        leftMotor.setMode(DcMotor.RunMode.STOP_AND_RESET_ENCODER);\n        rightMotor.setMode(DcMotor.RunMode.STOP_AND_RESET_ENCODER);\n        telemetry.addData(\"Status\", \"Encoders enabled\");\n    } else {\n        telemetry.addData(\"Status\", \"Encoders disabled\");\n    }\n    \n    telemetry.update();\n}"
    },
    {
      "type": "text",
      "title": "Step 3: Using Configuration in Robot Control",
      "content": "Now you can use the configuration variables in your robot control code. This allows you to adjust robot behavior without stopping and recompiling."
    },
    {
      "type": "code",
      "title": "Robot Control with Configuration Variables",
      "content": "Add this to your loop() method:",
      "code": "@Override\npublic void loop() {\n    // Use configuration variables for robot control\n    if (gamepad1.left_stick_y > 0.1) {\n        // Forward movement using configurable speed\n        leftMotor.setPower(DRIVE_SPEED);\n        rightMotor.setPower(DRIVE_SPEED);\n    } else if (gamepad1.left_stick_y < -0.1) {\n        // Backward movement using configurable speed\n        leftMotor.setPower(-DRIVE_SPEED);\n        rightMotor.setPower(-DRIVE_SPEED);\n    } else if (gamepad1.right_stick_x > 0.1) {\n        // Right turn using configurable turn speed\n        leftMotor.setPower(TURN_SPEED);\n        rightMotor.setPower(-TURN_SPEED);\n    } else if (gamepad1.right_stick_x < -0.1) {\n        // Left turn using configurable turn speed\n        leftMotor.setPower(-TURN_SPEED);\n        rightMotor.setPower(TURN_SPEED);\n    } else {\n        // Stop motors\n        leftMotor.setPower(0);\n        rightMotor.setPower(0);\n    }\n    \n    // Display current configuration values\n    telemetry.addData(\"Drive Speed\", DRIVE_SPEED);\n    telemetry.addData(\"Turn Speed\", TURN_SPEED);\n    telemetry.addData(\"Use Encoders\", USE_ENCODERS);\n    telemetry.update();\n}"
    },
    {
      "type": "text",
      "title": "Variable Types and Constraints",
      "content": "FTCDashboard supports various data types for configuration variables, and you can set constraints to ensure values stay within acceptable ranges. This helps prevent invalid configurations that could damage your robot."
    },
    {
      "type": "code",
      "title": "Adding Constraints to Configuration Variables",
      "content": "You can add constraints using the @Value annotation:",
      "code": "import com.acmerobotics.dashboard.config.Config;\nimport com.acmerobotics.dashboard.config.Value;\n\n@Config\npublic class ConstrainedConfigOpMode extends OpMode {\n    private FtcDashboard dashboard;\n    \n    // Integer with range constraint (0 to 2000)\n    @Value(min = 0, max = 2000)\n    public static int ENCODER_TARGET = 1000;\n    \n    // Double with range constraint (0.0 to 1.0)\n    @Value(min = 0.0, max = 1.0)\n    public static double MOTOR_POWER = 0.5;\n    \n    // Boolean configuration (no constraints needed)\n    public static boolean REVERSE_MOTORS = false;\n    \n    // String configuration\n    public static String ROBOT_NAME = \"MyRobot\";\n    \n    // Hardware objects\n    private DcMotor leftMotor, rightMotor;"
    },
    {
      "type": "text",
      "title": "Step 4: Using Enum Configurations",
      "content": "You can use enums to create dropdown selections in the dashboard. This is useful for selecting between different modes or options."
    },
    {
      "type": "code",
      "title": "Enum Configuration Example",
      "content": "Add this to your class to create mode selection:",
      "code": "// Define available drive modes\npublic static enum DriveMode {\n    TANK_DRIVE,      // Tank drive (left/right sticks)\n    ARCADE_DRIVE,    // Arcade drive (left stick + right stick X)\n    MECANUM_DRIVE    // Mecanum drive (for mecanum robots)\n}\n\n// Configuration variable for drive mode\npublic static DriveMode DRIVE_MODE = DriveMode.TANK_DRIVE;\n\n// Method to handle different drive modes\nprivate void handleDriveMode() {\n    switch (DRIVE_MODE) {\n        case TANK_DRIVE:\n            tankDrive();\n            break;\n        case ARCADE_DRIVE:\n            arcadeDrive();\n            break;\n        case MECANUM_DRIVE:\n            mecanumDrive();\n            break;\n    }\n}\n\nprivate void tankDrive() {\n    double leftPower = gamepad1.left_stick_y * MOTOR_POWER;\n    double rightPower = gamepad1.right_stick_y * MOTOR_POWER;\n    leftMotor.setPower(leftPower);\n    rightMotor.setPower(rightPower);\n}\n\nprivate void arcadeDrive() {\n    double drive = gamepad1.left_stick_y * MOTOR_POWER;\n    double turn = gamepad1.right_stick_x * MOTOR_POWER;\n    double leftPower = drive + turn;\n    double rightPower = drive - turn;\n    leftMotor.setPower(leftPower);\n    rightMotor.setPower(rightPower);\n}\n\nprivate void mecanumDrive() {\n    // Mecanum drive implementation\n    double forward = gamepad1.left_stick_y * MOTOR_POWER;\n    double strafe = gamepad1.left_stick_x * MOTOR_POWER;\n    double turn = gamepad1.right_stick_x * MOTOR_POWER;\n    \n    // This would need 4 motors for full mecanum implementation\n    leftMotor.setPower(forward + turn);\n    rightMotor.setPower(forward - turn);\n}"
    },
    {
      "type": "rules-box",
      "title": "Supported Variable Types",
      "items": [
        "int: Integer values with optional min/max constraints",
        "double: Decimal values with optional min/max constraints",
        "boolean: True/false values",
        "String: Text values",
        "Enum: Predefined option lists",
        "Arrays: Collections of values",
        "Custom objects: Complex data structures"
      ]
    },
    {
      "type": "text",
      "title": "Step 5: Configuration Groups",
      "content": "For complex robots with many parameters, you can organize configuration variables into logical groups. This makes the dashboard interface more organized and easier to navigate."
    },
    {
      "type": "code",
      "title": "Creating Configuration Groups",
      "content": "Add these nested classes to organize your configurations:",
      "code": "// Drive configuration group\npublic static class DriveConfig {\n    @Value(min = 0.0, max = 1.0)\n    public static double MAX_SPEED = 0.8;\n    \n    @Value(min = 0.0, max = 1.0)\n    public static double TURN_SPEED = 0.6;\n    \n    public static boolean REVERSE_LEFT = false;\n    public static boolean REVERSE_RIGHT = false;\n}\n\n// PID configuration group\npublic static class PIDConfig {\n    @Value(min = 0.0, max = 2.0)\n    public static double KP = 0.1;\n    \n    @Value(min = 0.0, max = 1.0)\n    public static double KI = 0.0;\n    \n    @Value(min = 0.0, max = 1.0)\n    public static double KD = 0.0;\n    \n    @Value(min = 0, max = 2000)\n    public static int TOLERANCE = 50;\n}\n\n// Autonomous configuration group\npublic static class AutoConfig {\n    @Value(min = 0, max = 5000)\n    public static int FORWARD_DISTANCE = 1000;\n    \n    @Value(min = 0, max = 360)\n    public static int TURN_ANGLE = 90;\n    \n    public static boolean USE_VISION = true;\n    public static String STARTING_POSITION = \"LEFT\";\n}"
    },
    {
      "type": "text",
      "title": "Step 6: Using Configuration Groups",
      "content": "Now you can use the grouped configuration values in your robot control code. This makes your code more organized and easier to understand."
    },
    {
      "type": "code",
      "title": "Using Grouped Configuration Values",
      "content": "Add this to your loop() method to use grouped configurations:",
      "code": "@Override\npublic void loop() {\n    // Use grouped configuration values for robot control\n    double leftPower = gamepad1.left_stick_y * DriveConfig.MAX_SPEED;\n    double rightPower = gamepad1.right_stick_y * DriveConfig.MAX_SPEED;\n    \n    // Handle turning with configurable turn speed\n    if (gamepad1.right_stick_x > 0.1) {\n        leftPower = DriveConfig.TURN_SPEED;\n        rightPower = -DriveConfig.TURN_SPEED;\n    } else if (gamepad1.right_stick_x < -0.1) {\n        leftPower = -DriveConfig.TURN_SPEED;\n        rightPower = DriveConfig.TURN_SPEED;\n    }\n    \n    // Apply motor powers\n    leftMotor.setPower(leftPower);\n    rightMotor.setPower(rightPower);\n    \n    // Display grouped configuration values\n    telemetry.addData(\"Drive Config\", \"Max Speed: %.2f, Turn Speed: %.2f\", \n                     DriveConfig.MAX_SPEED, DriveConfig.TURN_SPEED);\n    telemetry.addData(\"PID Config\", \"Kp: %.2f, Ki: %.2f, Kd: %.2f\", \n                     PIDConfig.KP, PIDConfig.KI, PIDConfig.KD);\n    telemetry.addData(\"Auto Config\", \"Distance: %d, Angle: %d\", \n                     AutoConfig.FORWARD_DISTANCE, AutoConfig.TURN_ANGLE);\n    telemetry.update();\n}"
    },
    {
      "type": "text",
      "title": "Step 7: Configuration Persistence",
      "content": "FTCDashboard can save and load configuration values, allowing you to maintain settings between robot restarts and share configurations across team members. This is especially useful for competition settings where you need consistent parameters."
    },
    {
      "type": "code",
      "title": "Configuration Management Methods",
      "content": "Add these methods to handle configuration persistence:",
      "code": "// Configuration management variables\npublic static String CONFIG_NAME = \"default\";\nprivate boolean configLoaded = false;\n\n// Method to save current configuration\nprivate void saveConfiguration() {\n    // Configuration is automatically saved by the dashboard\n    // You can add custom save logic here if needed\n    CONFIG_NAME = \"saved_config_\" + System.currentTimeMillis();\n    telemetry.addData(\"Status\", \"Configuration saved as: \" + CONFIG_NAME);\n}\n\n// Method to load configuration\nprivate void loadConfiguration() {\n    // Configuration is automatically loaded by the dashboard\n    // You can add custom load logic here if needed\n    CONFIG_NAME = \"loaded_config\";\n    telemetry.addData(\"Status\", \"Configuration loaded: \" + CONFIG_NAME);\n}\n\n// Method to reset to default values\nprivate void resetConfiguration() {\n    DriveConfig.MAX_SPEED = 0.8;\n    DriveConfig.TURN_SPEED = 0.6;\n    PIDConfig.KP = 0.1;\n    PIDConfig.KI = 0.0;\n    PIDConfig.KD = 0.0;\n    AutoConfig.FORWARD_DISTANCE = 1000;\n    AutoConfig.TURN_ANGLE = 90;\n    CONFIG_NAME = \"default\";\n    telemetry.addData(\"Status\", \"Configuration reset to defaults\");\n}"
    },
    {
      "type": "text",
      "title": "Step 8: Configuration Control in Loop",
      "content": "You can add gamepad controls to save, load, and reset configurations during testing. This makes it easy to experiment with different settings."
    },
    {
      "type": "code",
      "title": "Configuration Control with Gamepad",
      "content": "Add this to your loop() method for configuration management:",
      "code": "@Override\npublic void loop() {\n    // Handle configuration management with gamepad\n    if (gamepad1.y) {\n        // Save current configuration\n        saveConfiguration();\n    } else if (gamepad1.x) {\n        // Load configuration\n        loadConfiguration();\n    } else if (gamepad1.b) {\n        // Reset to defaults\n        resetConfiguration();\n    }\n    \n    // Normal robot control code here...\n    handleDriveMode();\n    \n    // Display configuration status\n    telemetry.addData(\"Config Name\", CONFIG_NAME);\n    telemetry.addData(\"Controls\", \"Y=Save, X=Load, B=Reset\");\n    telemetry.update();\n}"
    },
    {
      "type": "text",
      "title": "Step 9: Advanced Configuration Techniques",
      "content": "For more complex applications, you can create dynamic configurations, conditional parameters, and custom validation logic."
    },
    {
      "type": "code",
      "title": "Advanced Configuration Example",
      "content": "Here's an example of advanced configuration with validation:",
      "code": "// Dynamic configuration based on robot type\npublic static enum RobotType {\n    TANK_DRIVE,\n    MECANUM_DRIVE,\n    SWERVE_DRIVE\n}\npublic static RobotType ROBOT_TYPE = RobotType.TANK_DRIVE;\n\n// Competition-specific configurations\npublic static class CompetitionConfig {\n    public static String ALLIANCE_COLOR = \"RED\";\n    public static String STARTING_POSITION = \"LEFT\";\n    public static boolean USE_AUTONOMOUS = true;\n    public static int AUTO_DURATION = 30; // seconds\n}\n\n// Validation method\nprivate boolean validateConfiguration() {\n    boolean valid = true;\n    \n    // Check competition configuration\n    if (!CompetitionConfig.ALLIANCE_COLOR.equals(\"RED\") && \n        !CompetitionConfig.ALLIANCE_COLOR.equals(\"BLUE\")) {\n        valid = false;\n        telemetry.addData(\"ERROR\", \"Invalid alliance color!\");\n    }\n    \n    if (CompetitionConfig.AUTO_DURATION <= 0 || CompetitionConfig.AUTO_DURATION > 30) {\n        valid = false;\n        telemetry.addData(\"ERROR\", \"Invalid auto duration!\");\n    }\n    \n    return valid;\n}\n\n// Apply robot-specific configuration\nprivate void applyRobotConfiguration() {\n    switch (ROBOT_TYPE) {\n        case TANK_DRIVE:\n            // Apply tank drive specific settings\n            DriveConfig.MAX_SPEED = 0.8;\n            break;\n        case MECANUM_DRIVE:\n            // Apply mecanum drive specific settings\n            DriveConfig.MAX_SPEED = 0.6;\n            break;\n        case SWERVE_DRIVE:\n            // Apply swerve drive specific settings\n            DriveConfig.MAX_SPEED = 0.7;\n            break;\n    }\n}"
    },
    {
      "type": "exercise-box",
      "title": "Practice Exercise: PID Tuning Configuration",
      "description": "Create an OpMode with configurable PID parameters for motor control and use the dashboard to tune them in real-time.",
      "tasks": [
        "Set up configuration variables for PID gains (Kp, Ki, Kd)",
        "Create configuration groups for different subsystems",
        "Implement PID control using the configuration values",
        "Use the dashboard to tune parameters in real-time",
        "Save and load different PID configurations"
      ],
      "content": "// Your OpMode should include:\n// 1. PID configuration variables with constraints\n// 2. Configuration groups for different motors/subsystems\n// 3. Real-time PID control implementation\n// 4. Configuration persistence (save/load)\n// 5. Parameter validation and safety checks"
    },
    {
      "type": "rules-box",
      "title": "Configuration Best Practices",
      "items": [
        "Use descriptive variable names that clearly indicate their purpose",
        "Set appropriate constraints to prevent invalid values",
        "Group related parameters together for better organization",
        "Use default values that are safe and functional",
        "Document what each configuration variable does",
        "Test configuration changes thoroughly before competition",
        "Save working configurations for different scenarios"
      ]
    },
    {
      "type": "rules-box",
      "title": "Configuration Safety Guidelines",
      "items": [
        "Always set appropriate min/max constraints for numeric values",
        "Use default values that are safe and functional",
        "Validate configuration values before applying them",
        "Test configuration changes in a safe environment first",
        "Document what each parameter does and its safe range",
        "Have a way to quickly reset to safe defaults",
        "Backup working configurations before making changes"
      ]
    },
    {
      "type": "rules-box",
      "title": "Troubleshooting Configuration Issues",
      "items": [
        "Configuration not appearing: Check @Config annotation and static variables",
        "Values not updating: Ensure variables are static and public",
        "Invalid values: Check constraints and validation logic",
        "Configuration not saving: Verify dashboard connection and permissions",
        "Performance issues: Limit the number of configuration variables",
        "Build errors: Check import statements and annotation usage"
      ]
    },
    {
      "type": "link-grid",
      "title": "Related Topics and Resources",
      "links": [
        "<a href=\"https://acmerobotics.github.io/ftc-dashboard/config\" target=\"_blank\">FTCDashboard Configuration Documentation</a>",
        "<a href=\"https://acmerobotics.github.io/ftc-dashboard/config#variable-types\" target=\"_blank\">Variable Types and Constraints</a>",
        "<a href=\"https://acmerobotics.github.io/ftc-dashboard/config#groups\" target=\"_blank\">Configuration Groups Guide</a>",
        "<a href=\"https://acmerobotics.github.io/ftc-dashboard/config#persistence\" target=\"_blank\">Configuration Persistence</a>",
        "<a href=\"../advanced-movement-control/pid-control.json\">PID Control</a>",
        "<a href=\"../motors/motor-encoders.json\">Motor Encoders</a>",
        "<a href=\"../autonomous-programming/basic-autonomous-programming.json\">Basic Autonomous Programming</a>"
      ]
    }
  ]
}
