{
  "title": "OpMode Controls",
  "sections": [
    {
      "type": "text",
      "title": "OpMode Controls Overview",
      "content": "FTCDashboard's OpMode controls provide an alternative way to start, stop, and control your robot programs beyond the traditional Driver Station interface. This feature is particularly useful for testing, debugging, and providing additional control options during development and competition."
    },
    {
      "type": "rules-box",
      "title": "OpMode Controls Benefits",
      "items": [
        "Remote OpMode management from any device",
        "Custom control buttons for specific robot actions",
        "Alternative control method beyond Driver Station",
        "Multi-device synchronization and coordination",
        "Enhanced debugging and testing capabilities",
        "Team collaboration and remote assistance"
      ]
    },
    {
      "type": "text",
      "title": "Remote OpMode Management",
      "content": "The dashboard provides a web-based interface for starting and stopping OpModes, similar to the Driver Station but accessible from any device on the network. This is especially useful when you need to control the robot from a different location or device."
    },
    {
      "type": "code",
      "title": "Basic OpMode Control Setup",
      "content": "To enable OpMode controls in the dashboard, you need to register your OpMode with the dashboard and optionally add custom control buttons:",
      "code": "import com.acmerobotics.dashboard.FtcDashboard;\nimport com.acmerobotics.dashboard.telemetry.TelemetryPacket;\nimport com.acmerobotics.dashboard.config.Config;\n\n@Config\npublic class ControllableOpMode extends OpMode {\n    private FtcDashboard dashboard;\n    private TelemetryPacket packet;\n    \n    // Configuration variables for control\n    public static double DRIVE_SPEED = 0.5;\n    public static boolean ENABLE_SAFETY = true;\n    public static String CONTROL_MODE = \"MANUAL\";\n    \n    private DcMotor leftMotor, rightMotor;\n    private boolean isRunning = false;\n    \n    @Override\n    public void init() {\n        dashboard = FtcDashboard.getInstance();\n        packet = new TelemetryPacket();\n        \n        leftMotor = hardwareMap.get(DcMotor.class, \"left_motor\");\n        rightMotor = hardwareMap.get(DcMotor.class, \"right_motor\");\n        \n        // Register this OpMode with the dashboard\n        dashboard.registerOpMode(this);\n        \n        // Send initial status\n        packet.put(\"Status\", \"Initialized\");\n        packet.put(\"Control Mode\", CONTROL_MODE);\n        dashboard.sendTelemetryPacket(packet);\n    }\n    \n    @Override\n    public void start() {\n        isRunning = true;\n        \n        // Send start status\n        packet.put(\"Status\", \"Running\");\n        packet.put(\"Start Time\", getRuntime());\n        dashboard.sendTelemetryPacket(packet);\n    }\n    \n    @Override\n    public void loop() {\n        // Check if OpMode is still running\n        if (!isRunning) {\n            return;\n        }\n        \n        // Handle different control modes\n        switch (CONTROL_MODE) {\n            case \"MANUAL\":\n                manualControl();\n                break;\n            case \"AUTO\":\n                autonomousControl();\n                break;\n            case \"TEST\":\n                testControl();\n                break;\n        }\n        \n        // Send status update\n        packet.put(\"Status\", \"Running\");\n        packet.put(\"Runtime\", getRuntime());\n        packet.put(\"Control Mode\", CONTROL_MODE);\n        packet.put(\"Drive Speed\", DRIVE_SPEED);\n        dashboard.sendTelemetryPacket(packet);\n    }\n    \n    @Override\n    public void stop() {\n        isRunning = false;\n        \n        // Stop all motors\n        leftMotor.setPower(0);\n        rightMotor.setPower(0);\n        \n        // Send stop status\n        packet.put(\"Status\", \"Stopped\");\n        packet.put(\"Total Runtime\", getRuntime());\n        dashboard.sendTelemetryPacket(packet);\n    }\n    \n    private void manualControl() {\n        // Manual control using gamepad\n        double leftPower = gamepad1.left_stick_y * DRIVE_SPEED;\n        double rightPower = gamepad1.right_stick_y * DRIVE_SPEED;\n        \n        if (ENABLE_SAFETY) {\n            leftPower = Math.max(-0.8, Math.min(0.8, leftPower));\n            rightPower = Math.max(-0.8, Math.min(0.8, rightPower));\n        }\n        \n        leftMotor.setPower(leftPower);\n        rightMotor.setPower(rightPower);\n    }\n    \n    private void autonomousControl() {\n        // Simple autonomous behavior\n        double time = getRuntime();\n        double power = Math.sin(time) * DRIVE_SPEED;\n        \n        leftMotor.setPower(power);\n        rightMotor.setPower(power);\n    }\n    \n    private void testControl() {\n        // Test mode - alternating motor power\n        double time = getRuntime();\n        \n        if ((int)(time * 2) % 2 == 0) {\n            leftMotor.setPower(DRIVE_SPEED);\n            rightMotor.setPower(0);\n        } else {\n            leftMotor.setPower(0);\n            rightMotor.setPower(DRIVE_SPEED);\n        }\n    }\n}"
    },
    {
      "type": "text",
      "title": "Custom Control Buttons",
      "content": "One of the most powerful features is the ability to create custom buttons in the dashboard interface. These buttons can trigger specific robot actions, making it easy to test individual functions or perform common operations."
    },
    {
      "type": "code",
      "title": "Custom Control Buttons Example",
      "content": "This example demonstrates how to create custom control buttons for specific robot actions:",
      "code": "import com.acmerobotics.dashboard.FtcDashboard;\nimport com.acmerobotics.dashboard.telemetry.TelemetryPacket;\nimport com.acmerobotics.dashboard.config.Config;\n\n@Config\npublic class CustomButtonsOpMode extends OpMode {\n    private FtcDashboard dashboard;\n    private TelemetryPacket packet;\n    \n    // Button state variables\n    public static boolean RESET_ENCODERS = false;\n    public static boolean CALIBRATE_SENSORS = false;\n    public static boolean RUN_TEST_SEQUENCE = false;\n    public static boolean EMERGENCY_STOP = false;\n    \n    // Configuration variables\n    public static double TEST_POWER = 0.3;\n    public static int TEST_DURATION = 2000; // milliseconds\n    \n    private DcMotor leftMotor, rightMotor;\n    private ColorSensor colorSensor;\n    private DistanceSensor distanceSensor;\n    private boolean testRunning = false;\n    private long testStartTime = 0;\n    \n    @Override\n    public void init() {\n        dashboard = FtcDashboard.getInstance();\n        packet = new TelemetryPacket();\n        \n        leftMotor = hardwareMap.get(DcMotor.class, \"left_motor\");\n        rightMotor = hardwareMap.get(DcMotor.class, \"right_motor\");\n        colorSensor = hardwareMap.get(ColorSensor.class, \"color_sensor\");\n        distanceSensor = hardwareMap.get(DistanceSensor.class, \"distance_sensor\");\n        \n        // Register OpMode\n        dashboard.registerOpMode(this);\n        \n        // Send initial status\n        packet.put(\"Status\", \"Ready for custom controls\");\n        dashboard.sendTelemetryPacket(packet);\n    }\n    \n    @Override\n    public void loop() {\n        // Check for button presses and handle them\n        handleCustomButtons();\n        \n        // Run test sequence if active\n        if (testRunning) {\n            runTestSequence();\n        } else {\n            // Normal robot control\n            normalControl();\n        }\n        \n        // Send status update\n        updateStatus();\n    }\n    \n    private void handleCustomButtons() {\n        // Reset encoders button\n        if (RESET_ENCODERS) {\n            resetEncoders();\n            RESET_ENCODERS = false; // Reset the button state\n        }\n        \n        // Calibrate sensors button\n        if (CALIBRATE_SENSORS) {\n            calibrateSensors();\n            CALIBRATE_SENSORS = false;\n        }\n        \n        // Run test sequence button\n        if (RUN_TEST_SEQUENCE && !testRunning) {\n            startTestSequence();\n            RUN_TEST_SEQUENCE = false;\n        }\n        \n        // Emergency stop button\n        if (EMERGENCY_STOP) {\n            emergencyStop();\n            EMERGENCY_STOP = false;\n        }\n    }\n    \n    private void resetEncoders() {\n        leftMotor.setMode(DcMotor.RunMode.STOP_AND_RESET_ENCODER);\n        rightMotor.setMode(DcMotor.RunMode.STOP_AND_RESET_ENCODER);\n        leftMotor.setMode(DcMotor.RunMode.RUN_USING_ENCODER);\n        rightMotor.setMode(DcMotor.RunMode.RUN_USING_ENCODER);\n        \n        packet.put(\"Action\", \"Encoders reset\");\n        dashboard.sendTelemetryPacket(packet);\n    }\n    \n    private void calibrateSensors() {\n        // Perform sensor calibration\n        // This is a simplified example - you would implement actual calibration\n        \n        // Read sensor values multiple times for averaging\n        double totalRed = 0, totalGreen = 0, totalBlue = 0;\n        double totalDistance = 0;\n        int samples = 10;\n        \n        for (int i = 0; i < samples; i++) {\n            totalRed += colorSensor.red();\n            totalGreen += colorSensor.green();\n            totalBlue += colorSensor.blue();\n            totalDistance += distanceSensor.getDistance(DistanceUnit.CM);\n            sleep(50);\n        }\n        \n        double avgRed = totalRed / samples;\n        double avgGreen = totalGreen / samples;\n        double avgBlue = totalBlue / samples;\n        double avgDistance = totalDistance / samples;\n        \n        packet.put(\"Action\", \"Sensors calibrated\");\n        packet.put(\"Avg Red\", avgRed);\n        packet.put(\"Avg Green\", avgGreen);\n        packet.put(\"Avg Blue\", avgBlue);\n        packet.put(\"Avg Distance\", avgDistance);\n        dashboard.sendTelemetryPacket(packet);\n    }\n    \n    private void startTestSequence() {\n        testRunning = true;\n        testStartTime = System.currentTimeMillis();\n        \n        packet.put(\"Action\", \"Test sequence started\");\n        packet.put(\"Test Duration\", TEST_DURATION + \"ms\");\n        dashboard.sendTelemetryPacket(packet);\n    }\n    \n    private void runTestSequence() {\n        long elapsed = System.currentTimeMillis() - testStartTime;\n        \n        if (elapsed >= TEST_DURATION) {\n            // Test complete\n            testRunning = false;\n            leftMotor.setPower(0);\n            rightMotor.setPower(0);\n            \n            packet.put(\"Action\", \"Test sequence completed\");\n            dashboard.sendTelemetryPacket(packet);\n            return;\n        }\n        \n        // Run test pattern based on elapsed time\n        double progress = (double) elapsed / TEST_DURATION;\n        \n        if (progress < 0.25) {\n            // Forward\n            leftMotor.setPower(TEST_POWER);\n            rightMotor.setPower(TEST_POWER);\n        } else if (progress < 0.5) {\n            // Turn right\n            leftMotor.setPower(TEST_POWER);\n            rightMotor.setPower(-TEST_POWER);\n        } else if (progress < 0.75) {\n            // Backward\n            leftMotor.setPower(-TEST_POWER);\n            rightMotor.setPower(-TEST_POWER);\n        } else {\n            // Turn left\n            leftMotor.setPower(-TEST_POWER);\n            rightMotor.setPower(TEST_POWER);\n        }\n        \n        packet.put(\"Test Progress\", \"%.1f%%\", progress * 100);\n        packet.put(\"Test Phase\", getTestPhase(progress));\n    }\n    \n    private String getTestPhase(double progress) {\n        if (progress < 0.25) return \"Forward\";\n        else if (progress < 0.5) return \"Turn Right\";\n        else if (progress < 0.75) return \"Backward\";\n        else return \"Turn Left\";\n    }\n    \n    private void emergencyStop() {\n        // Emergency stop - halt all motors immediately\n        leftMotor.setPower(0);\n        rightMotor.setPower(0);\n        testRunning = false;\n        \n        packet.put(\"Action\", \"EMERGENCY STOP ACTIVATED\");\n        packet.put(\"Status\", \"STOPPED\");\n        dashboard.sendTelemetryPacket(packet);\n    }\n    \n    private void normalControl() {\n        // Normal gamepad control when not in test mode\n        double leftPower = gamepad1.left_stick_y * 0.5;\n        double rightPower = gamepad1.right_stick_y * 0.5;\n        \n        leftMotor.setPower(leftPower);\n        rightMotor.setPower(rightPower);\n    }\n    \n    private void updateStatus() {\n        packet.put(\"Status\", testRunning ? \"Running Test\" : \"Normal Operation\");\n        packet.put(\"Left Encoder\", leftMotor.getCurrentPosition());\n        packet.put(\"Right Encoder\", rightMotor.getCurrentPosition());\n        packet.put(\"Color Sensor\", \"R:%d G:%d B:%d\", \n                   colorSensor.red(), colorSensor.green(), colorSensor.blue());\n        packet.put(\"Distance\", \"%.1f cm\", distanceSensor.getDistance(DistanceUnit.CM));\n        \n        dashboard.sendTelemetryPacket(packet);\n    }\n}"
    },
    {
      "type": "text",
      "title": "Control Validation",
      "content": "When implementing custom controls, it's important to include validation to ensure safe robot operation. This includes checking for dangerous conditions, validating inputs, and providing user feedback."
    },
    {
      "type": "code",
      "title": "Control Validation Example",
      "content": "This example demonstrates how to implement proper validation for custom controls:",
      "code": "import com.acmerobotics.dashboard.FtcDashboard;\nimport com.acmerobotics.dashboard.telemetry.TelemetryPacket;\nimport com.acmerobotics.dashboard.config.Config;\n\n@Config\npublic class ValidatedControlsOpMode extends OpMode {\n    private FtcDashboard dashboard;\n    private TelemetryPacket packet;\n    \n    // Control variables\n    public static boolean START_MOTOR_TEST = false;\n    public static boolean SET_MOTOR_POWER = false;\n    public static boolean MOVE_TO_POSITION = false;\n    \n    // Configuration with validation\n    @Value(min = 0.0, max = 1.0)\n    public static double MOTOR_POWER = 0.5;\n    \n    @Value(min = -5000, max = 5000)\n    public static int TARGET_POSITION = 1000;\n    \n    public static String MOTOR_SELECTION = \"LEFT\"; // LEFT, RIGHT, BOTH\n    \n    private DcMotor leftMotor, rightMotor;\n    private boolean motorTestRunning = false;\n    private long lastValidationTime = 0;\n    private String lastError = \"\";\n    \n    @Override\n    public void init() {\n        dashboard = FtcDashboard.getInstance();\n        packet = new TelemetryPacket();\n        \n        leftMotor = hardwareMap.get(DcMotor.class, \"left_motor\");\n        rightMotor = hardwareMap.get(DcMotor.class, \"right_motor\");\n        \n        // Set up motors with encoders\n        leftMotor.setMode(DcMotor.RunMode.STOP_AND_RESET_ENCODER);\n        rightMotor.setMode(DcMotor.RunMode.STOP_AND_RESET_ENCODER);\n        leftMotor.setMode(DcMotor.RunMode.RUN_USING_ENCODER);\n        rightMotor.setMode(DcMotor.RunMode.RUN_USING_ENCODER);\n        \n        dashboard.registerOpMode(this);\n        \n        packet.put(\"Status\", \"Ready with validation\");\n        dashboard.sendTelemetryPacket(packet);\n    }\n    \n    @Override\n    public void loop() {\n        // Handle control requests with validation\n        handleValidatedControls();\n        \n        // Run motor test if active\n        if (motorTestRunning) {\n            runMotorTest();\n        } else {\n            // Normal control\n            normalControl();\n        }\n        \n        // Update status with validation information\n        updateValidationStatus();\n    }\n    \n    private void handleValidatedControls() {\n        // Start motor test with validation\n        if (START_MOTOR_TEST && !motorTestRunning) {\n            if (validateMotorTest()) {\n                startMotorTest();\n            }\n            START_MOTOR_TEST = false;\n        }\n        \n        // Set motor power with validation\n        if (SET_MOTOR_POWER) {\n            if (validateMotorPower()) {\n                setMotorPower();\n            }\n            SET_MOTOR_POWER = false;\n        }\n        \n        // Move to position with validation\n        if (MOVE_TO_POSITION) {\n            if (validatePositionMove()) {\n                moveToPosition();\n            }\n            MOVE_TO_POSITION = false;\n        }\n    }\n    \n    private boolean validateMotorTest() {\n        // Check if motors are available and not already running\n        if (motorTestRunning) {\n            lastError = \"Motor test already running\";\n            return false;\n        }\n        \n        if (leftMotor == null || rightMotor == null) {\n            lastError = \"Motors not initialized\";\n            return false;\n        }\n        \n        // Check battery voltage for safety\n        double batteryVoltage = hardwareMap.voltageSensor.get(\"Expansion Hub 2\").getVoltage();\n        if (batteryVoltage < 10.0) {\n            lastError = \"Battery voltage too low: \" + batteryVoltage + \"V\";\n            return false;\n        }\n        \n        // Check if robot is in a safe state\n        if (Math.abs(leftMotor.getPower()) > 0.1 || Math.abs(rightMotor.getPower()) > 0.1) {\n            lastError = \"Motors already in use\";\n            return false;\n        }\n        \n        lastError = \"\";\n        return true;\n    }\n    \n    private boolean validateMotorPower() {\n        // Validate motor power setting\n        if (MOTOR_POWER < 0 || MOTOR_POWER > 1.0) {\n            lastError = \"Invalid motor power: \" + MOTOR_POWER;\n            return false;\n        }\n        \n        // Check for dangerous power levels\n        if (MOTOR_POWER > 0.8) {\n            lastError = \"Warning: High motor power (\" + MOTOR_POWER + \")\";\n            // Allow but warn\n        }\n        \n        // Validate motor selection\n        if (!MOTOR_SELECTION.equals(\"LEFT\") && \n            !MOTOR_SELECTION.equals(\"RIGHT\") && \n            !MOTOR_SELECTION.equals(\"BOTH\")) {\n            lastError = \"Invalid motor selection: \" + MOTOR_SELECTION;\n            return false;\n        }\n        \n        lastError = \"\";\n        return true;\n    }\n    \n    private boolean validatePositionMove() {\n        // Validate position move request\n        if (TARGET_POSITION < -5000 || TARGET_POSITION > 5000) {\n            lastError = \"Target position out of range: \" + TARGET_POSITION;\n            return false;\n        }\n        \n        // Check current position to avoid unnecessary moves\n        int currentLeft = leftMotor.getCurrentPosition();\n        int currentRight = rightMotor.getCurrentPosition();\n        \n        if (Math.abs(currentLeft - TARGET_POSITION) < 50 && \n            Math.abs(currentRight - TARGET_POSITION) < 50) {\n            lastError = \"Already at target position\";\n            return false;\n        }\n        \n        // Check if motors are in the right mode\n        if (leftMotor.getMode() != DcMotor.RunMode.RUN_TO_POSITION || \n            rightMotor.getMode() != DcMotor.RunMode.RUN_TO_POSITION) {\n            lastError = \"Motors not in position mode\";\n            return false;\n        }\n        \n        lastError = \"\";\n        return true;\n    }\n    \n    private void startMotorTest() {\n        motorTestRunning = true;\n        \n        packet.put(\"Action\", \"Motor test started\");\n        packet.put(\"Motor Power\", MOTOR_POWER);\n        packet.put(\"Motor Selection\", MOTOR_SELECTION);\n        dashboard.sendTelemetryPacket(packet);\n    }\n    \n    private void runMotorTest() {\n        // Run motor test for 3 seconds\n        if (getRuntime() > 3.0) {\n            motorTestRunning = false;\n            leftMotor.setPower(0);\n            rightMotor.setPower(0);\n            \n            packet.put(\"Action\", \"Motor test completed\");\n            dashboard.sendTelemetryPacket(packet);\n            return;\n        }\n        \n        // Apply power based on selection\n        switch (MOTOR_SELECTION) {\n            case \"LEFT\":\n                leftMotor.setPower(MOTOR_POWER);\n                rightMotor.setPower(0);\n                break;\n            case \"RIGHT\":\n                leftMotor.setPower(0);\n                rightMotor.setPower(MOTOR_POWER);\n                break;\n            case \"BOTH\":\n                leftMotor.setPower(MOTOR_POWER);\n                rightMotor.setPower(MOTOR_POWER);\n                break;\n        }\n        \n        packet.put(\"Test Progress\", \"%.1f seconds\", getRuntime());\n    }\n    \n    private void setMotorPower() {\n        // Apply validated motor power\n        switch (MOTOR_SELECTION) {\n            case \"LEFT\":\n                leftMotor.setPower(MOTOR_POWER);\n                break;\n            case \"RIGHT\":\n                rightMotor.setPower(MOTOR_POWER);\n                break;\n            case \"BOTH\":\n                leftMotor.setPower(MOTOR_POWER);\n                rightMotor.setPower(MOTOR_POWER);\n                break;\n        }\n        \n        packet.put(\"Action\", \"Motor power set\");\n        packet.put(\"Power\", MOTOR_POWER);\n        packet.put(\"Motor\", MOTOR_SELECTION);\n        dashboard.sendTelemetryPacket(packet);\n    }\n    \n    private void moveToPosition() {\n        // Move to validated position\n        leftMotor.setTargetPosition(TARGET_POSITION);\n        rightMotor.setTargetPosition(TARGET_POSITION);\n        \n        leftMotor.setMode(DcMotor.RunMode.RUN_TO_POSITION);\n        rightMotor.setMode(DcMotor.RunMode.RUN_TO_POSITION);\n        \n        leftMotor.setPower(0.5);\n        rightMotor.setPower(0.5);\n        \n        packet.put(\"Action\", \"Moving to position\");\n        packet.put(\"Target\", TARGET_POSITION);\n        dashboard.sendTelemetryPacket(packet);\n    }\n    \n    private void normalControl() {\n        // Normal gamepad control\n        double leftPower = gamepad1.left_stick_y * 0.5;\n        double rightPower = gamepad1.right_stick_y * 0.5;\n        \n        leftMotor.setPower(leftPower);\n        rightMotor.setPower(rightPower);\n    }\n    \n    private void updateValidationStatus() {\n        packet.put(\"Status\", motorTestRunning ? \"Running Test\" : \"Ready\");\n        packet.put(\"Last Error\", lastError.isEmpty() ? \"None\" : lastError);\n        packet.put(\"Validation Time\", System.currentTimeMillis() - lastValidationTime);\n        packet.put(\"Left Position\", leftMotor.getCurrentPosition());\n        packet.put(\"Right Position\", rightMotor.getCurrentPosition());\n        packet.put(\"Battery Voltage\", \n                   hardwareMap.voltageSensor.get(\"Expansion Hub 2\").getVoltage());\n        \n        dashboard.sendTelemetryPacket(packet);\n    }\n}"
    },
    {
      "type": "text",
      "title": "Multi-device Synchronization",
      "content": "FTCDashboard supports multiple devices connecting simultaneously, allowing team members to monitor and control the robot from different devices. This is useful for collaboration, remote assistance, and competition scenarios."
    },
    {
      "type": "code",
      "title": "Multi-device Support Example",
      "content": "This example demonstrates how to handle multiple device connections and coordinate controls:",
      "code": "import com.acmerobotics.dashboard.FtcDashboard;\nimport com.acmerobotics.dashboard.telemetry.TelemetryPacket;\nimport com.acmerobotics.dashboard.config.Config;\nimport java.util.HashSet;\nimport java.util.Set;\n\n@Config\npublic class MultiDeviceOpMode extends OpMode {\n    private FtcDashboard dashboard;\n    private TelemetryPacket packet;\n    \n    // Multi-device control variables\n    public static boolean ENABLE_MULTI_DEVICE = true;\n    public static String PRIMARY_CONTROLLER = \"DRIVER_STATION\";\n    public static boolean ALLOW_REMOTE_CONTROL = true;\n    \n    // Control variables\n    public static boolean REMOTE_START = false;\n    public static boolean REMOTE_STOP = false;\n    public static boolean REMOTE_EMERGENCY = false;\n    \n    private DcMotor leftMotor, rightMotor;\n    private Set<String> connectedDevices = new HashSet<>();\n    private String currentController = \"DRIVER_STATION\";\n    private boolean remoteControlActive = false;\n    private long lastDeviceUpdate = 0;\n    \n    @Override\n    public void init() {\n        dashboard = FtcDashboard.getInstance();\n        packet = new TelemetryPacket();\n        \n        leftMotor = hardwareMap.get(DcMotor.class, \"left_motor\");\n        rightMotor = hardwareMap.get(DcMotor.class, \"right_motor\");\n        \n        dashboard.registerOpMode(this);\n        \n        // Initialize device tracking\n        updateConnectedDevices();\n        \n        packet.put(\"Status\", \"Multi-device mode initialized\");\n        packet.put(\"Multi-device Enabled\", ENABLE_MULTI_DEVICE);\n        packet.put(\"Remote Control Allowed\", ALLOW_REMOTE_CONTROL);\n        dashboard.sendTelemetryPacket(packet);\n    }\n    \n    @Override\n    public void loop() {\n        // Update device connections periodically\n        if (System.currentTimeMillis() - lastDeviceUpdate > 1000) {\n            updateConnectedDevices();\n            lastDeviceUpdate = System.currentTimeMillis();\n        }\n        \n        // Handle multi-device controls\n        if (ENABLE_MULTI_DEVICE) {\n            handleMultiDeviceControls();\n        }\n        \n        // Normal robot control based on current controller\n        handleRobotControl();\n        \n        // Update status for all connected devices\n        updateMultiDeviceStatus();\n    }\n    \n    private void updateConnectedDevices() {\n        // In a real implementation, you would query the dashboard\n        // for connected devices. This is a simplified example.\n        connectedDevices.clear();\n        connectedDevices.add(\"Driver Station\");\n        \n        // Simulate additional connections based on dashboard activity\n        if (dashboard.getWebServer().isStarted()) {\n            connectedDevices.add(\"Dashboard Web Client\");\n        }\n        \n        // Add mobile devices if they're connected\n        if (ALLOW_REMOTE_CONTROL) {\n            connectedDevices.add(\"Mobile Device 1\");\n            connectedDevices.add(\"Mobile Device 2\");\n        }\n    }\n    \n    private void handleMultiDeviceControls() {\n        // Handle remote start request\n        if (REMOTE_START && ALLOW_REMOTE_CONTROL) {\n            if (!remoteControlActive) {\n                activateRemoteControl();\n            }\n            REMOTE_START = false;\n        }\n        \n        // Handle remote stop request\n        if (REMOTE_STOP) {\n            if (remoteControlActive) {\n                deactivateRemoteControl();\n            }\n            REMOTE_STOP = false;\n        }\n        \n        // Handle emergency stop from any device\n        if (REMOTE_EMERGENCY) {\n            emergencyStop();\n            REMOTE_EMERGENCY = false;\n        }\n    }\n    \n    private void activateRemoteControl() {\n        remoteControlActive = true;\n        currentController = \"REMOTE_DEVICE\";\n        \n        packet.put(\"Action\", \"Remote control activated\");\n        packet.put(\"Controller\", currentController);\n        dashboard.sendTelemetryPacket(packet);\n    }\n    \n    private void deactivateRemoteControl() {\n        remoteControlActive = false;\n        currentController = PRIMARY_CONTROLLER;\n        \n        // Stop all motors when switching control\n        leftMotor.setPower(0);\n        rightMotor.setPower(0);\n        \n        packet.put(\"Action\", \"Remote control deactivated\");\n        packet.put(\"Controller\", currentController);\n        dashboard.sendTelemetryPacket(packet);\n    }\n    \n    private void emergencyStop() {\n        // Emergency stop from any device\n        leftMotor.setPower(0);\n        rightMotor.setPower(0);\n        remoteControlActive = false;\n        currentController = \"EMERGENCY_STOP\";\n        \n        packet.put(\"Action\", \"EMERGENCY STOP - All devices\");\n        packet.put(\"Controller\", currentController);\n        dashboard.sendTelemetryPacket(packet);\n    }\n    \n    private void handleRobotControl() {\n        switch (currentController) {\n            case \"DRIVER_STATION\":\n                driverStationControl();\n                break;\n            case \"REMOTE_DEVICE\":\n                remoteDeviceControl();\n                break;\n            case \"EMERGENCY_STOP\":\n                // No control allowed in emergency stop\n                break;\n        }\n    }\n    \n    private void driverStationControl() {\n        // Normal gamepad control\n        double leftPower = gamepad1.left_stick_y * 0.5;\n        double rightPower = gamepad1.right_stick_y * 0.5;\n        \n        leftMotor.setPower(leftPower);\n        rightMotor.setPower(rightPower);\n    }\n    \n    private void remoteDeviceControl() {\n        // Remote control using dashboard buttons or other methods\n        // This would be implemented based on your specific remote control needs\n        \n        // For this example, we'll use a simple pattern\n        double time = getRuntime();\n        double power = Math.sin(time) * 0.3;\n        \n        leftMotor.setPower(power);\n        rightMotor.setPower(power);\n    }\n    \n    private void updateMultiDeviceStatus() {\n        packet.put(\"Status\", \"Multi-device operation\");\n        packet.put(\"Current Controller\", currentController);\n        packet.put(\"Remote Control Active\", remoteControlActive);\n        packet.put(\"Connected Devices\", connectedDevices.size());\n        packet.put(\"Device List\", String.join(\", \", connectedDevices));\n        packet.put(\"Left Motor Power\", leftMotor.getPower());\n        packet.put(\"Right Motor Power\", rightMotor.getPower());\n        packet.put(\"Battery Voltage\", \n                   hardwareMap.voltageSensor.get(\"Expansion Hub 2\").getVoltage());\n        \n        dashboard.sendTelemetryPacket(packet);\n    }\n}"
    },
    {
      "type": "rules-box",
      "title": "OpMode Controls Best Practices",
      "items": [
        "Always validate control inputs before executing actions",
        "Provide clear feedback for all control operations",
        "Include emergency stop functionality accessible from any device",
        "Use appropriate access controls for sensitive operations",
        "Monitor and log control actions for debugging",
        "Test multi-device scenarios thoroughly",
        "Have fallback control methods if dashboard is unavailable"
      ]
    },
    {
      "type": "exercise-box",
      "title": "Practice Exercise: Custom Control System",
      "description": "Create an OpMode with a comprehensive custom control system including validation, multi-device support, and safety features.",
      "tasks": [
        "Set up basic OpMode controls with dashboard registration",
        "Create custom control buttons for common robot actions",
        "Implement input validation and safety checks",
        "Add multi-device support and controller switching",
        "Include emergency stop functionality accessible from all devices"
      ],
      "content": "// Your OpMode should include:\n// 1. Dashboard registration and custom buttons\n// 2. Input validation and safety checks\n// 3. Multi-device coordination\n// 4. Emergency stop functionality\n// 5. Comprehensive status reporting"
    },
    {
      "type": "rules-box",
      "title": "Troubleshooting OpMode Controls",
      "items": [
        "Controls not appearing: Check dashboard registration and button variables",
        "Validation not working: Verify constraint annotations and validation logic",
        "Multi-device issues: Check network connectivity and device permissions",
        "Emergency stop not working: Ensure emergency stop is accessible from all devices",
        "Performance issues: Limit control update frequency and complexity",
        "Build errors: Check import statements and annotation usage"
      ]
    },
    {
      "type": "link-grid",
      "title": "Related Topics and Resources",
      "links": [
        "<a href=\"https://acmerobotics.github.io/ftc-dashboard/opmode-controls\" target=\"_blank\">FTCDashboard OpMode Controls Documentation</a>",
        "<a href=\"https://acmerobotics.github.io/ftc-dashboard/opmode-controls#buttons\" target=\"_blank\">Custom Buttons Guide</a>",
        "<a href=\"https://acmerobotics.github.io/ftc-dashboard/opmode-controls#validation\" target=\"_blank\">Control Validation</a>",
        "<a href=\"https://acmerobotics.github.io/ftc-dashboard/opmode-controls#multi-device\" target=\"_blank\">Multi-device Support</a>",
        "<a href=\"../teleop-programming/gamepad-controls.json\">Gamepad Controls</a>",
        "<a href=\"../autonomous-programming/basic-autonomous-programming.json\">Basic Autonomous Programming</a>",
        "<a href=\"../motors/basic-motor-control.json\">Basic Motor Control</a>"
      ]
    }
  ]
} 