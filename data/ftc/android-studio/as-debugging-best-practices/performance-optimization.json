{
  "title": "Performance Optimization",
  "sections": [
    {
      "type": "text",
      "title": "Introduction to Performance Optimization",
      "content": "Performance optimization is crucial for FTC robots. Your code must run efficiently to maintain consistent control loop timing and prevent crashes. This lesson covers techniques to optimize your robot's performance while maintaining reliability."
    },
    {
      "type": "rules-box",
      "title": "Why Performance Matters in FTC",
      "items": [
        "FTC robots require consistent 50Hz loop rates for reliable operation",
        "Android devices have limited memory and processing power",
        "Performance issues can cause robot crashes during competition",
        "Optimized code runs more smoothly and predictably"
      ]
    },
    {
      "type": "text",
      "title": "Loop Timing and Performance Monitoring",
      "content": "FTC robots operate on a tight timing schedule. The main control loop should run at approximately 50Hz (20ms per loop) to maintain smooth robot control. Monitoring loop timing helps identify performance bottlenecks."
    },
    {
      "type": "code",
      "title": "Loop Timing Monitor",
      "content": "Implement a loop timing monitor to track performance and identify bottlenecks. This class monitors how long each loop iteration takes and provides performance metrics:",
      "code": "public class PerformanceMonitorOpMode extends OpMode {\n    private static final String TAG = \"PerformanceMonitor\";\n    private static final double TARGET_LOOP_TIME = 0.020; // 20ms = 50Hz\n    \n    private long lastLoopTime;\n    private double averageLoopTime = 0.0;\n    private int loopCount = 0;\n    private double maxLoopTime = 0.0;\n    private double minLoopTime = Double.MAX_VALUE;\n    \n    // Performance tracking variables\n    private long initStartTime;\n    private long initEndTime;\n    private long loopStartTime;\n    \n    @Override\n    public void init() {\n        initStartTime = System.nanoTime();\n        \n        // Initialize hardware\n        initializeHardware();\n        \n        initEndTime = System.nanoTime();\n        double initTime = (initEndTime - initStartTime) / 1_000_000.0; // Convert to milliseconds\n        \n        Log.i(TAG, \"Initialization completed in \" + initTime + \"ms\");\n        telemetry.addData(\"Init Time (ms)\", String.format(\"%.2f\", initTime));\n        \n        lastLoopTime = System.nanoTime();\n    }"
    },
    {
      "type": "text",
      "title": "Understanding Loop Timing",
      "content": "Loop timing is critical for FTC robots. The main control loop should run at approximately 50Hz (20ms per loop) to maintain smooth robot control. Monitoring loop timing helps identify when your code is taking too long and potentially causing robot lag or missed commands."
    },
    {
      "type": "code",
      "title": "Loop Timing Monitor - Main Loop and Statistics",
      "content": "Add the main loop method and timing statistics calculation. This section handles the core performance monitoring logic:",
      "code": "    @Override\n    public void loop() {\n        loopStartTime = System.nanoTime();\n        \n        // Your main robot logic here\n        processGamepadInput();\n        updateRobotState();\n        controlMotors();\n        \n        // Calculate loop timing\n        long currentTime = System.nanoTime();\n        double loopTime = (currentTime - loopStartTime) / 1_000_000.0; // Convert to milliseconds\n        \n        // Update timing statistics\n        updateTimingStats(loopTime);\n        \n        // Display performance metrics every 50 loops\n        if (loopCount % 50 == 0) {\n            displayPerformanceMetrics();\n        }\n        \n        loopCount++;\n        lastLoopTime = currentTime;\n    }\n    \n    private void updateTimingStats(double loopTime) {\n        // Update running average\n        averageLoopTime = (averageLoopTime * (loopCount - 1) + loopTime) / loopCount;\n        \n        // Update min/max\n        if (loopTime > maxLoopTime) maxLoopTime = loopTime;\n        if (loopTime < minLoopTime) minLoopTime = loopTime;\n        \n        // Log performance warnings\n        if (loopTime > TARGET_LOOP_TIME * 1.5) { // 30ms\n            Log.w(TAG, \"Loop time exceeded target: \" + loopTime + \"ms\");\n        }\n    }"
    },
    {
      "type": "text",
      "title": "Performance Statistics and Monitoring",
      "content": "The performance monitor tracks key metrics including average, minimum, and maximum loop times. It also provides warnings when loop times exceed the target, helping you identify performance bottlenecks before they cause robot issues."
    },
    {
      "type": "code",
      "title": "Loop Timing Monitor - Display and Helper Methods",
      "content": "Add methods for displaying performance metrics and helper methods for robot logic. These methods complete the performance monitoring system:",
      "code": "    private void displayPerformanceMetrics() {\n        telemetry.addData(\"=== Performance Metrics ===\", \"\");\n        telemetry.addData(\"Current Loop Time (ms)\", String.format(\"%.2f\", (System.nanoTime() - loopStartTime) / 1_000_000.0));\n        telemetry.addData(\"Average Loop Time (ms)\", String.format(\"%.2f\", averageLoopTime));\n        telemetry.addData(\"Min Loop Time (ms)\", String.format(\"%.2f\", minLoopTime));\n        telemetry.addData(\"Max Loop Time (ms)\", String.format(\"%.2f\", maxLoopTime));\n        telemetry.addData(\"Loop Count\", loopCount);\n        telemetry.addData(\"Target Loop Time (ms)\", String.format(\"%.2f\", TARGET_LOOP_TIME * 1000));\n        \n        // Performance status\n        String status = averageLoopTime < TARGET_LOOP_TIME * 1000 ? \"GOOD\" : \"SLOW\";\n        telemetry.addData(\"Performance Status\", status);\n    }\n    \n    private void initializeHardware() {\n        // Initialize your hardware components here\n        // This is where you'd set up motors, servos, sensors, etc.\n    }\n    \n    private void processGamepadInput() {\n        // Process gamepad input efficiently\n        // Avoid complex calculations here\n    }\n    \n    private void updateRobotState() {\n        // Update robot state and calculations\n        // This is where most of your logic should go\n    }\n    \n    private void controlMotors() {\n        // Set motor powers and servo positions\n        // Keep this simple and fast\n    }\n}"
    },
    {
      "type": "text",
      "title": "Performance Display and Robot Logic",
      "content": "The display method shows performance metrics on the Driver Station, helping you monitor robot performance in real-time. The helper methods are placeholders for your actual robot logic, organized to maintain good performance."
    },
    {
      "type": "text",
      "title": "Memory Management in FTC Applications",
      "content": "Android devices have limited memory, and inefficient memory usage can cause your robot to crash. Understanding memory management is essential for creating stable FTC applications."
    },
    {
      "type": "code",
      "title": "Memory-Efficient Programming",
      "content": "Implement memory-efficient programming practices to avoid garbage collection issues:",
      "code": "public class MemoryEfficientOpMode extends OpMode {\n    private static final String TAG = \"MemoryEfficient\";\n    \n    // Reuse objects instead of creating new ones\n    private final StringBuilder telemetryBuilder = new StringBuilder();\n    private final double[] motorPowers = new double[4]; // Reuse array\n    private final int[] sensorReadings = new int[3]; // Reuse array\n    \n    // Object pooling for frequently used objects\n    private final Queue<RobotCommand> commandPool = new LinkedList<>();\n    private final int MAX_POOL_SIZE = 10;\n    \n    // Avoid creating objects in the main loop\n    private double lastTelemetryTime = 0.0;\n    private static final double TELEMETRY_INTERVAL = 0.1; // 100ms\n    \n    @Override\n    public void init() {\n        // Pre-allocate objects that will be used frequently\n        initializeObjectPool();\n        \n        // Initialize hardware with memory-efficient approach\n        initializeHardwareEfficiently();\n    }\n    \n    private void initializeObjectPool() {\n        // Pre-create objects for the pool\n        for (int i = 0; i < MAX_POOL_SIZE; i++) {\n            commandPool.offer(new RobotCommand());\n        }\n    }\n    \n    private void initializeHardwareEfficiently() {\n        // Initialize hardware without creating unnecessary objects\n        try {\n            // Use direct hardware map access\n            DcMotor leftMotor = hardwareMap.get(DcMotor.class, \"left_motor\");\n            DcMotor rightMotor = hardwareMap.get(DcMotor.class, \"right_motor\");\n            \n            // Configure motors efficiently\n            leftMotor.setDirection(DcMotor.Direction.FORWARD);\n            rightMotor.setDirection(DcMotor.Direction.REVERSE);\n            \n            Log.i(TAG, \"Hardware initialized efficiently\");\n        } catch (Exception e) {\n            Log.e(TAG, \"Hardware initialization failed\", e);\n        }\n    }\n    \n    @Override\n    public void loop() {\n        // Process input efficiently\n        processInputEfficiently();\n        \n        // Update robot state\n        updateRobotStateEfficiently();\n        \n        // Update telemetry periodically to reduce overhead\n        if (getRuntime() - lastTelemetryTime > TELEMETRY_INTERVAL) {\n            updateTelemetryEfficiently();\n            lastTelemetryTime = getRuntime();\n        }\n    }\n    \n    private void processInputEfficiently() {\n        // Reuse arrays instead of creating new ones\n        motorPowers[0] = gamepad1.left_stick_y;\n        motorPowers[1] = gamepad1.right_stick_y;\n        motorPowers[2] = gamepad1.left_trigger;\n        motorPowers[3] = gamepad1.right_trigger;\n        \n        // Apply deadzone efficiently\n        for (int i = 0; i < motorPowers.length; i++) {\n            if (Math.abs(motorPowers[i]) < 0.1) {\n                motorPowers[i] = 0.0;\n            }\n        }\n    }\n    \n    private void updateRobotStateEfficiently() {\n        // Get command from pool instead of creating new one\n        RobotCommand command = getCommandFromPool();\n        if (command != null) {\n            command.setMotorPowers(motorPowers);\n            executeCommand(command);\n            returnCommandToPool(command);\n        }\n    }\n    \n    private RobotCommand getCommandFromPool() {\n        return commandPool.poll();\n    }\n    \n    private void returnCommandToPool(RobotCommand command) {\n        if (commandPool.size() < MAX_POOL_SIZE) {\n            command.reset(); // Reset the command for reuse\n            commandPool.offer(command);\n        }\n    }\n    \n    private void executeCommand(RobotCommand command) {\n        // Execute the command efficiently\n        // Set motor powers directly without creating intermediate objects\n        DcMotor leftMotor = hardwareMap.get(DcMotor.class, \"left_motor\");\n        DcMotor rightMotor = hardwareMap.get(DcMotor.class, \"right_motor\");\n        \n        leftMotor.setPower(command.getLeftPower());\n        rightMotor.setPower(command.getRightPower());\n    }\n    \n    private void updateTelemetryEfficiently() {\n        // Use StringBuilder to build telemetry efficiently\n        telemetryBuilder.setLength(0); // Clear without creating new object\n        telemetryBuilder.append(\"Loop Time: \").append(getRuntime()).append(\"s\");\n        \n        telemetry.addData(\"Status\", telemetryBuilder.toString());\n        telemetry.addData(\"Left Power\", motorPowers[0]);\n        telemetry.addData(\"Right Power\", motorPowers[1]);\n    }\n    \n    // Efficient command class for object pooling\n    private static class RobotCommand {\n        private double leftPower = 0.0;\n        private double rightPower = 0.0;\n        \n        public void setMotorPowers(double[] powers) {\n            this.leftPower = powers[0];\n            this.rightPower = powers[1];\n        }\n        \n        public double getLeftPower() { return leftPower; }\n        public double getRightPower() { return rightPower; }\n        \n        public void reset() {\n            leftPower = 0.0;\n            rightPower = 0.0;\n        }\n    }\n}"
    },
    {
      "type": "text",
      "title": "Algorithm Optimization for Robot Control",
      "content": "Complex algorithms can slow down your main control loop. Breaking down complex calculations into smaller, more efficient pieces helps maintain performance."
    },
    {
      "type": "code",
      "title": "Optimized PID Control Implementation",
      "content": "Implement an optimized PID controller that minimizes computational overhead:",
      "code": "public class OptimizedPIDController {\n    private double kp, ki, kd;\n    private double setpoint;\n    private double previousError = 0.0;\n    private double integral = 0.0;\n    private double output = 0.0;\n    \n    // Pre-calculated constants to avoid repeated calculations\n    private double integralLimit;\n    private double outputLimit;\n    private boolean isEnabled = false;\n    \n    public OptimizedPIDController(double kp, double ki, double kd) {\n        this.kp = kp;\n        this.ki = ki;\n        this.kd = kd;\n        \n        // Pre-calculate limits for efficiency\n        this.integralLimit = 1.0 / ki; // Prevent integral windup\n        this.outputLimit = 1.0; // Limit output to motor range\n    }\n    \n    public void setSetpoint(double setpoint) {\n        this.setpoint = setpoint;\n        // Reset integral when setpoint changes to prevent windup\n        this.integral = 0.0;\n    }\n    \n    public double calculate(double measurement) {\n        if (!isEnabled) return 0.0;\n        \n        // Calculate error efficiently\n        double error = setpoint - measurement;\n        \n        // Proportional term\n        double pTerm = kp * error;\n        \n        // Integral term with anti-windup\n        integral += error;\n        if (Math.abs(integral) > integralLimit) {\n            integral = Math.signum(integral) * integralLimit;\n        }\n        double iTerm = ki * integral;\n        \n        // Derivative term (avoid division by zero)\n        double derivative = error - previousError;\n        double dTerm = kd * derivative;\n        \n        // Calculate output efficiently\n        output = pTerm + iTerm + dTerm;\n        \n        // Limit output\n        if (Math.abs(output) > outputLimit) {\n            output = Math.signum(output) * outputLimit;\n        }\n        \n        // Store error for next iteration\n        previousError = error;\n        \n        return output;\n    }\n    \n    public void enable() { isEnabled = true; }\n    public void disable() { isEnabled = false; }\n    public void reset() {\n        integral = 0.0;\n        previousError = 0.0;\n        output = 0.0;\n    }\n}\n\n// Optimized OpMode using the PID controller\npublic class OptimizedPIDOpMode extends OpMode {\n    private OptimizedPIDController drivePID;\n    private OptimizedPIDController turnPID;\n    private DcMotor leftMotor, rightMotor;\n    \n    // Pre-allocated variables to avoid object creation\n    private double targetDistance = 0.0;\n    private double targetAngle = 0.0;\n    private double currentDistance = 0.0;\n    private double currentAngle = 0.0;\n    \n    @Override\n    public void init() {\n        // Initialize PID controllers efficiently\n        drivePID = new OptimizedPIDController(0.5, 0.1, 0.05);\n        turnPID = new OptimizedPIDController(0.3, 0.05, 0.02);\n        \n        // Initialize hardware\n        leftMotor = hardwareMap.get(DcMotor.class, \"left_motor\");\n        rightMotor = hardwareMap.get(DcMotor.class, \"right_motor\");\n        \n        // Enable PID controllers\n        drivePID.enable();\n        turnPID.enable();\n    }\n    \n    @Override\n    public void loop() {\n        // Update sensor readings efficiently\n        updateSensorReadings();\n        \n        // Calculate PID outputs efficiently\n        double driveOutput = drivePID.calculate(currentDistance);\n        double turnOutput = turnPID.calculate(currentAngle);\n        \n        // Apply outputs to motors efficiently\n        double leftPower = driveOutput + turnOutput;\n        double rightPower = driveOutput - turnOutput;\n        \n        // Limit powers efficiently\n        leftPower = Math.max(-1.0, Math.min(1.0, leftPower));\n        rightPower = Math.max(-1.0, Math.min(1.0, rightPower));\n        \n        // Set motor powers\n        leftMotor.setPower(leftPower);\n        rightMotor.setPower(rightPower);\n        \n        // Update telemetry periodically\n        if (getRuntime() % 0.1 < 0.01) { // Every 100ms\n            telemetry.addData(\"Target Distance\", targetDistance);\n            telemetry.addData(\"Current Distance\", currentDistance);\n            telemetry.addData(\"Drive Output\", driveOutput);\n            telemetry.addData(\"Left Power\", leftPower);\n            telemetry.addData(\"Right Power\", rightPower);\n        }\n    }\n    \n    private void updateSensorReadings() {\n        // Update sensor readings efficiently\n        // This would typically read from encoders, IMU, etc.\n        // For this example, we'll simulate readings\n        currentDistance = getRuntime() * 0.1; // Simulate distance\n        currentAngle = Math.sin(getRuntime()) * 0.1; // Simulate angle\n    }\n}"
    },
    {
      "type": "text",
      "title": "Resource Management (Motors, Servos, Sensors)",
      "content": "Proper resource management prevents conflicts and improves performance. Efficient use of motors, servos, and sensors ensures smooth robot operation."
    },
    {
      "type": "code",
      "title": "Efficient Resource Management",
      "content": "Implement efficient resource management for robot hardware:",
      "code": "public class ResourceManagerOpMode extends OpMode {\n    private static final String TAG = \"ResourceManager\";\n    \n    // Hardware components\n    private DcMotor[] driveMotors = new DcMotor[4];\n    private Servo[] servos = new Servo[2];\n    private ColorSensor colorSensor;\n    private DistanceSensor distanceSensor;\n    \n    // Resource state tracking\n    private boolean[] motorBusy = new boolean[4];\n    private boolean[] servoBusy = new boolean[2];\n    private long lastSensorRead = 0;\n    private static final long SENSOR_READ_INTERVAL = 50; // 50ms between reads\n    \n    // Pre-allocated arrays for efficiency\n    private double[] motorPowers = new double[4];\n    private double[] servoPositions = new double[2];\n    private int[] sensorReadings = new int[3];\n    \n    @Override\n    public void init() {\n        initializeHardwareEfficiently();\n        resetResourceStates();\n    }\n    \n    private void initializeHardwareEfficiently() {\n        try {\n            // Initialize drive motors efficiently\n            String[] motorNames = {\"front_left\", \"front_right\", \"back_left\", \"back_right\"};\n            for (int i = 0; i < 4; i++) {\n                driveMotors[i] = hardwareMap.get(DcMotor.class, motorNames[i]);\n                driveMotors[i].setZeroPowerBehavior(DcMotor.ZeroPowerBehavior.BRAKE);\n            }\n            \n            // Initialize servos efficiently\n            String[] servoNames = {\"arm_servo\", \"claw_servo\"};\n            for (int i = 0; i < 2; i++) {\n                servos[i] = hardwareMap.get(Servo.class, servoNames[i]);\n            }\n            \n            // Initialize sensors efficiently\n            colorSensor = hardwareMap.get(ColorSensor.class, \"color_sensor\");\n            distanceSensor = hardwareMap.get(DistanceSensor.class, \"distance_sensor\");\n            \n            Log.i(TAG, \"Hardware initialized successfully\");\n        } catch (Exception e) {\n            Log.e(TAG, \"Hardware initialization failed\", e);\n        }\n    }\n    \n    private void resetResourceStates() {\n        // Reset all resource states\n        for (int i = 0; i < 4; i++) {\n            motorBusy[i] = false;\n            motorPowers[i] = 0.0;\n        }\n        for (int i = 0; i < 2; i++) {\n            servoBusy[i] = false;\n            servoPositions[i] = 0.5; // Default position\n        }\n        lastSensorRead = 0;\n    }\n    \n    @Override\n    public void loop() {\n        // Process input efficiently\n        processInputEfficiently();\n        \n        // Update sensors periodically\n        updateSensorsEfficiently();\n        \n        // Apply motor controls efficiently\n        applyMotorControls();\n        \n        // Apply servo controls efficiently\n        applyServoControls();\n        \n        // Update telemetry periodically\n        if (getRuntime() % 0.2 < 0.01) { // Every 200ms\n            updateTelemetryEfficiently();\n        }\n    }\n    \n    private void processInputEfficiently() {\n        // Process gamepad input and update motor powers efficiently\n        double forward = -gamepad1.left_stick_y;\n        double turn = gamepad1.right_stick_x;\n        \n        // Calculate motor powers efficiently\n        motorPowers[0] = forward + turn; // Front left\n        motorPowers[1] = forward - turn; // Front right\n        motorPowers[2] = forward + turn; // Back left\n        motorPowers[3] = forward - turn; // Back right\n        \n        // Apply deadzone efficiently\n        for (int i = 0; i < 4; i++) {\n            if (Math.abs(motorPowers[i]) < 0.1) {\n                motorPowers[i] = 0.0;\n            }\n        }\n        \n        // Process servo controls\n        if (gamepad1.a) {\n            servoPositions[0] = 1.0; // Arm up\n        } else if (gamepad1.b) {\n            servoPositions[0] = 0.0; // Arm down\n        }\n        \n        if (gamepad1.x) {\n            servoPositions[1] = 1.0; // Claw open\n        } else if (gamepad1.y) {\n            servoPositions[1] = 0.0; // Claw closed\n        }\n    }\n    \n    private void updateSensorsEfficiently() {\n        long currentTime = System.currentTimeMillis();\n        if (currentTime - lastSensorRead > SENSOR_READ_INTERVAL) {\n            // Read sensors efficiently\n            if (colorSensor != null) {\n                sensorReadings[0] = colorSensor.red();\n                sensorReadings[1] = colorSensor.green();\n                sensorReadings[2] = colorSensor.blue();\n            }\n            \n            lastSensorRead = currentTime;\n        }\n    }\n    \n    private void applyMotorControls() {\n        // Apply motor powers efficiently\n        for (int i = 0; i < 4; i++) {\n            if (driveMotors[i] != null && !motorBusy[i]) {\n                driveMotors[i].setPower(motorPowers[i]);\n            }\n        }\n    }\n    \n    private void applyServoControls() {\n        // Apply servo positions efficiently\n        for (int i = 0; i < 2; i++) {\n            if (servos[i] != null && !servoBusy[i]) {\n                servos[i].setPosition(servoPositions[i]);\n            }\n        }\n    }\n    \n    private void updateTelemetryEfficiently() {\n        telemetry.addData(\"=== Resource Status ===\", \"\");\n        telemetry.addData(\"Front Left Motor\", motorPowers[0]);\n        telemetry.addData(\"Front Right Motor\", motorPowers[1]);\n        telemetry.addData(\"Back Left Motor\", motorPowers[2]);\n        telemetry.addData(\"Back Right Motor\", motorPowers[3]);\n        telemetry.addData(\"Arm Position\", servoPositions[0]);\n        telemetry.addData(\"Claw Position\", servoPositions[1]);\n        \n        if (colorSensor != null) {\n            telemetry.addData(\"Color R\", sensorReadings[0]);\n            telemetry.addData(\"Color G\", sensorReadings[1]);\n            telemetry.addData(\"Color B\", sensorReadings[2]);\n        }\n    }\n    \n    // Method to mark resources as busy (for complex operations)\n    public void setMotorBusy(int motorIndex, boolean busy) {\n        if (motorIndex >= 0 && motorIndex < 4) {\n            motorBusy[motorIndex] = busy;\n        }\n    }\n    \n    public void setServoBusy(int servoIndex, boolean busy) {\n        if (servoIndex >= 0 && servoIndex < 2) {\n            servoBusy[servoIndex] = busy;\n        }\n    }\n}"
    },
    {
      "type": "exercise-box",
      "title": "Performance Optimization Exercise",
      "description": "Create an OpMode that demonstrates performance optimization techniques. Implement a robot that can drive, control an arm, and read sensors while maintaining optimal performance.",
      "tasks": [
        "Create an OpMode with performance monitoring",
        "Implement memory-efficient programming practices",
        "Use object pooling for frequently created objects",
        "Optimize sensor reading frequency",
        "Implement efficient PID control",
        "Monitor and display performance metrics"
      ],
      "content": "// Starter code for the performance optimization exercise:\npublic class PerformanceExerciseOpMode extends OpMode {\n    // TODO: Add performance monitoring variables\n    // TODO: Implement object pooling\n    // TODO: Add efficient resource management\n    // TODO: Implement optimized PID control\n    // TODO: Add performance metrics display\n    \n    @Override\n    public void init() {\n        // TODO: Initialize performance monitoring\n        // TODO: Set up object pools\n        // TODO: Initialize hardware efficiently\n    }\n    \n    @Override\n    public void loop() {\n        // TODO: Monitor loop timing\n        // TODO: Process input efficiently\n        // TODO: Update robot state with optimized algorithms\n        // TODO: Display performance metrics\n    }\n}"
    },
    {
      "type": "link-grid",
      "title": "Additional Resources",
      "links": [
        "<a href=\"https://gm0.org/en/latest/docs/software/tutorials/control-loops.html\" target=\"_blank\">gm0: Control Loops</a>",
        "<a href=\"https://developer.android.com/topic/performance/memory\" target=\"_blank\">Android Memory Management</a>",
        "<a href=\"https://gm0.org/en/latest/docs/software/tutorials/advanced-control.html\" target=\"_blank\">gm0: Advanced Control</a>",
        "<a href=\"https://ftc-docs.firstinspires.org/en/latest/programming_resources/hardware/hardware.html\" target=\"_blank\">FTC Hardware Documentation</a>"
      ]
    }
  ]
} 