{
  "title": "Unit Testing for FTC Development",
  "sections": [
    {
      "type": "text",
      "title": "Introduction to Unit Testing in FTC",
      "content": "Unit testing is a critical practice for ensuring your FTC robot code works correctly and reliably. By writing tests for individual components and methods, you can catch bugs early, verify functionality, and make your code more maintainable. This lesson covers how to implement unit testing in Android Studio for FTC projects."
    },
    {
      "type": "rules-box",
      "title": "Why Unit Testing Matters for FTC",
      "items": [
        "Catch bugs before they reach the robot hardware",
        "Verify complex algorithms work correctly",
        "Ensure code changes don't break existing functionality",
        "Document expected behavior of your code",
        "Speed up development by catching issues early"
      ]
    },
    {
      "type": "text",
      "title": "Setting Up Testing Framework",
      "content": "Android Studio uses JUnit for unit testing. You'll need to set up your project to include test dependencies and create test classes that can run independently of the robot hardware."
    },
    {
      "type": "code",
      "title": "Project Testing Configuration - Dependencies",
      "content": "First, ensure your project has the proper testing dependencies configured in your build.gradle file. These dependencies provide the testing framework and mocking capabilities:",
      "code": "// In your app/build.gradle file, ensure you have:\ndependencies {\n    // Existing FTC dependencies...\n    \n    // Testing dependencies\n    testImplementation 'junit:junit:4.13.2'\n    testImplementation 'org.mockito:mockito-core:4.5.1'\n    testImplementation 'org.mockito:mockito-inline:4.5.1'\n    \n    // For Android-specific testing\n    androidTestImplementation 'androidx.test.ext:junit:1.1.5'\n    androidTestImplementation 'androidx.test:runner:1.5.2'\n    androidTestImplementation 'androidx.test:rules:1.5.0'\n}"
    },
    {
      "type": "text",
      "title": "Understanding Testing Dependencies",
      "content": "The testing dependencies provide essential tools for unit testing. JUnit provides the testing framework, while Mockito allows you to create mock objects that simulate hardware components. This is crucial for testing robot code without requiring actual hardware."
    },
    {
      "type": "code",
      "title": "Project Testing Configuration - Test Options",
      "content": "Configure test options in your build.gradle file to ensure proper test execution. These options enable Android resources in tests and provide default values for Android framework calls:",
      "code": "// In your app/build.gradle file, add test options:\nandroid {\n    // Existing configuration...\n    \n    testOptions {\n        unitTests {\n            includeAndroidResources = true\n            returnDefaultValues = true\n        }\n    }\n}"
    },
    {
      "type": "text",
      "title": "Test Configuration Explanation",
      "content": "The test options configure how your tests run. 'includeAndroidResources' allows tests to access Android resources, while 'returnDefaultValues' provides default return values for Android framework methods that aren't available in unit tests."
    },
    {
      "type": "text",
      "title": "Creating Your First Test",
      "content": "Let's start with a simple test for a utility class that performs calculations. This demonstrates the basic structure of unit tests and shows how to test mathematical operations that are common in FTC programming."
    },
    {
      "type": "code",
      "title": "Basic Utility Class - Encoder Conversions",
      "content": "First, create a simple utility class to test. This class handles common FTC calculations like encoder conversions. These methods are essential for converting between encoder ticks and real-world distances:",
      "code": "// File: RobotUtils.java\npublic class RobotUtils {\n    /**\n     * Converts encoder ticks to distance in inches\n     * @param ticks Number of encoder ticks\n     * @param ticksPerRevolution Ticks per revolution of the motor\n     * @param wheelDiameter Wheel diameter in inches\n     * @return Distance in inches\n     */\n    public static double ticksToInches(int ticks, int ticksPerRevolution, double wheelDiameter) {\n        if (ticksPerRevolution <= 0 || wheelDiameter <= 0) {\n            throw new IllegalArgumentException(\"Ticks per revolution and wheel diameter must be positive\");\n        }\n        \n        double circumference = Math.PI * wheelDiameter;\n        return (ticks * circumference) / ticksPerRevolution;\n    }\n    \n    /**\n     * Converts distance in inches to encoder ticks\n     * @param inches Distance in inches\n     * @param ticksPerRevolution Ticks per revolution of the motor\n     * @param wheelDiameter Wheel diameter in inches\n     * @return Number of encoder ticks\n     */\n    public static int inchesToTicks(double inches, int ticksPerRevolution, double wheelDiameter) {\n        if (ticksPerRevolution <= 0 || wheelDiameter <= 0) {\n            throw new IllegalArgumentException(\"Ticks per revolution and wheel diameter must be positive\");\n        }\n        \n        double circumference = Math.PI * wheelDiameter;\n        return (int) Math.round((inches * ticksPerRevolution) / circumference);\n    }"
    },
    {
      "type": "code",
      "title": "Basic Utility Class - Power Calculations",
      "content": "Add power calculation methods to the utility class. These methods help determine appropriate motor power for different movements. Power calculations are crucial for smooth robot motion:",
      "code": "    /**\n     * Calculates the power needed for a given distance and time\n     * @param distance Distance to travel in inches\n     * @param time Time to travel in seconds\n     * @param maxPower Maximum power available (0.0 to 1.0)\n     * @return Calculated power (0.0 to maxPower)\n     */\n    public static double calculatePowerForDistance(double distance, double time, double maxPower) {\n        if (distance < 0 || time <= 0 || maxPower <= 0 || maxPower > 1.0) {\n            throw new IllegalArgumentException(\"Invalid parameters for power calculation\");\n        }\n        \n        // Simple linear calculation (in reality, you'd use more complex physics)\n        double requiredPower = distance / (time * 12.0); // Assuming 12 inches per second at full power\n        return Math.min(requiredPower, maxPower);\n    }\n}"
    },
    {
      "type": "text",
      "title": "Understanding Power Calculations",
      "content": "Power calculations determine how much motor power is needed to achieve a desired movement. This method uses a simplified linear model, but in practice, you might use more complex physics calculations that account for robot mass, friction, and acceleration."
    },
    {
      "type": "text",
      "title": "Writing Tests for Encoder Conversions",
      "content": "Now let's write tests for the encoder conversion methods. These tests verify that the mathematical calculations work correctly and handle edge cases properly."
    },
    {
      "type": "code",
      "title": "Test Class Setup and Ticks to Inches Tests",
      "content": "Create the test class for RobotUtils. Start with tests for the ticksToInches method:",
      "code": "// File: RobotUtilsTest.java (in test directory)\nimport org.junit.Test;\nimport static org.junit.Assert.*;\n\npublic class RobotUtilsTest {\n    \n    @Test\n    public void testTicksToInches() {\n        // Test case 1: Basic conversion\n        double result = RobotUtils.ticksToInches(1000, 1440, 4.0);\n        double expected = (1000 * Math.PI * 4.0) / 1440;\n        assertEquals(\"Basic ticks to inches conversion\", expected, result, 0.001);\n        \n        // Test case 2: Zero ticks\n        result = RobotUtils.ticksToInches(0, 1440, 4.0);\n        assertEquals(\"Zero ticks should return zero inches\", 0.0, result, 0.001);\n        \n        // Test case 3: Large number of ticks\n        result = RobotUtils.ticksToInches(10000, 1440, 4.0);\n        expected = (10000 * Math.PI * 4.0) / 1440;\n        assertEquals(\"Large number of ticks\", expected, result, 0.001);\n    }"
    },
    {
      "type": "text",
      "title": "Understanding Basic Conversion Tests",
      "content": "The basic conversion test verifies that the mathematical formula works correctly. It tests normal cases, edge cases (zero ticks), and large values to ensure the calculation remains accurate across different input ranges."
    },
    {
      "type": "code",
      "title": "Inches to Ticks Tests",
      "content": "Add tests for the inchesToTicks method. These tests verify the reverse conversion and rounding behavior:",
      "code": "    @Test\n    public void testInchesToTicks() {\n        // Test case 1: Basic conversion\n        int result = RobotUtils.inchesToTicks(10.0, 1440, 4.0);\n        int expected = (int) Math.round((10.0 * 1440) / (Math.PI * 4.0));\n        assertEquals(\"Basic inches to ticks conversion\", expected, result);\n        \n        // Test case 2: Zero inches\n        result = RobotUtils.inchesToTicks(0.0, 1440, 4.0);\n        assertEquals(\"Zero inches should return zero ticks\", 0, result);\n        \n        // Test case 3: Rounding behavior\n        result = RobotUtils.inchesToTicks(5.5, 1440, 4.0);\n        expected = (int) Math.round((5.5 * 1440) / (Math.PI * 4.0));\n        assertEquals(\"Rounding behavior test\", expected, result);\n    }"
    },
    {
      "type": "text",
      "title": "Understanding Reverse Conversion Tests",
      "content": "The inches to ticks tests verify the reverse conversion works correctly. They test the rounding behavior since the result must be an integer, and ensure that zero distance returns zero ticks."
    },
    {
      "type": "code",
      "title": "Power Calculation Tests",
      "content": "Add tests for the power calculation method. These tests verify power calculations and limits:",
      "code": "    @Test\n    public void testCalculatePowerForDistance() {\n        // Test case 1: Normal calculation\n        double result = RobotUtils.calculatePowerForDistance(24.0, 2.0, 1.0);\n        double expected = 24.0 / (2.0 * 12.0); // 1.0\n        assertEquals(\"Normal power calculation\", expected, result, 0.001);\n        \n        // Test case 2: Power limited by maxPower\n        result = RobotUtils.calculatePowerForDistance(48.0, 2.0, 0.5);\n        expected = 0.5; // Limited by maxPower\n        assertEquals(\"Power limited by maxPower\", expected, result, 0.001);\n        \n        // Test case 3: Zero distance\n        result = RobotUtils.calculatePowerForDistance(0.0, 2.0, 1.0);\n        assertEquals(\"Zero distance should return zero power\", 0.0, result, 0.001);\n    }"
    },
    {
      "type": "text",
      "title": "Understanding Power Calculation Tests",
      "content": "The power calculation tests verify that the method correctly calculates required power and respects the maximum power limit. They test normal cases, power limiting behavior, and edge cases like zero distance."
    },
    {
      "type": "code",
      "title": "Error Handling Tests",
      "content": "Add tests to verify that the methods properly handle invalid input parameters:",
      "code": "    @Test(expected = IllegalArgumentException.class)\n    public void testTicksToInchesInvalidParameters() {\n        RobotUtils.ticksToInches(1000, 0, 4.0); // Invalid ticks per revolution\n    }\n    \n    @Test(expected = IllegalArgumentException.class)\n    public void testInchesToTicksInvalidParameters() {\n        RobotUtils.inchesToTicks(10.0, 1440, -4.0); // Invalid wheel diameter\n    }\n    \n    @Test(expected = IllegalArgumentException.class)\n    public void testCalculatePowerInvalidParameters() {\n        RobotUtils.calculatePowerForDistance(10.0, 0.0, 1.0); // Invalid time\n    }\n}"
    },
    {
      "type": "text",
      "title": "Understanding Error Handling Tests",
      "content": "Error handling tests use the @Test(expected = ...) annotation to verify that methods throw appropriate exceptions when given invalid parameters. This ensures your code fails gracefully with meaningful error messages."
    },
    {
      "type": "text",
      "title": "Testing Robot Components with Mocking",
      "content": "Since you can't always test with real hardware, mocking allows you to simulate hardware components and test your control logic independently. Mocking is essential for testing robot controllers without requiring actual hardware."
    },
    {
      "type": "code",
      "title": "Robot Controller Class - Basic Structure",
      "content": "Create a testable robot controller class. This class will handle basic robot operations and can be tested with mocked hardware:",
      "code": "// File: RobotController.java\npublic class RobotController {\n    private DcMotor leftMotor;\n    private DcMotor rightMotor;\n    private ColorSensor colorSensor;\n    \n    public RobotController(DcMotor leftMotor, DcMotor rightMotor, ColorSensor colorSensor) {\n        this.leftMotor = leftMotor;\n        this.rightMotor = rightMotor;\n        this.colorSensor = colorSensor;\n    }\n    \n    public void driveForward(double power) {\n        if (power < -1.0 || power > 1.0) {\n            throw new IllegalArgumentException(\"Power must be between -1.0 and 1.0\");\n        }\n        \n        leftMotor.setPower(power);\n        rightMotor.setPower(power);\n    }"
    },
    {
      "type": "text",
      "title": "Understanding Robot Controller Design",
      "content": "The robot controller class encapsulates hardware interactions, making it easier to test. By accepting hardware components as constructor parameters, we can inject mock objects during testing instead of requiring real hardware."
    },
    {
      "type": "code",
      "title": "Robot Controller Class - Additional Methods",
      "content": "Add more methods to the robot controller for turning, stopping, and sensor operations:",
      "code": "    public void turn(double leftPower, double rightPower) {\n        if (Math.abs(leftPower) > 1.0 || Math.abs(rightPower) > 1.0) {\n            throw new IllegalArgumentException(\"Power values must be between -1.0 and 1.0\");\n        }\n        \n        leftMotor.setPower(leftPower);\n        rightMotor.setPower(rightPower);\n    }\n    \n    public boolean isRedBallDetected() {\n        int red = colorSensor.red();\n        int green = colorSensor.green();\n        int blue = colorSensor.blue();\n        \n        // Simple red detection logic\n        return red > green && red > blue && red > 100;\n    }\n    \n    public void stop() {\n        leftMotor.setPower(0.0);\n        rightMotor.setPower(0.0);\n    }\n    \n    public double getLeftMotorPower() {\n        return leftMotor.getPower();\n    }\n    \n    public double getRightMotorPower() {\n        return rightMotor.getPower();\n    }\n}"
    },
    {
      "type": "text",
      "title": "Understanding Robot Controller Methods",
      "content": "The additional methods provide a complete interface for robot control. The turn method allows differential drive, the color detection method processes sensor data, and the getter methods allow testing to verify motor states."
    },
    {
      "type": "text",
      "title": "Setting Up Mocked Hardware Tests",
      "content": "Now let's create tests for the RobotController using Mockito. These tests will verify that the controller properly interacts with the hardware components."
    },
    {
      "type": "code",
      "title": "Test Setup and Drive Forward Tests",
      "content": "Create tests for the RobotController using Mockito. Start with the test setup and drive forward tests:",
      "code": "// File: RobotControllerTest.java\nimport org.junit.Before;\nimport org.junit.Test;\nimport org.junit.runner.RunWith;\nimport org.mockito.Mock;\nimport org.mockito.junit.MockitoJUnitRunner;\nimport static org.mockito.Mockito.*;\nimport static org.junit.Assert.*;\n\n@RunWith(MockitoJUnitRunner.class)\npublic class RobotControllerTest {\n    \n    @Mock\n    private DcMotor leftMotor;\n    \n    @Mock\n    private DcMotor rightMotor;\n    \n    @Mock\n    private ColorSensor colorSensor;\n    \n    private RobotController robotController;\n    \n    @Before\n    public void setUp() {\n        robotController = new RobotController(leftMotor, rightMotor, colorSensor);\n    }\n    \n    @Test\n    public void testDriveForward() {\n        // Test driving forward with positive power\n        robotController.driveForward(0.5);\n        \n        verify(leftMotor).setPower(0.5);\n        verify(rightMotor).setPower(0.5);\n    }\n    \n    @Test\n    public void testDriveForwardNegativePower() {\n        // Test driving backward\n        robotController.driveForward(-0.3);\n        \n        verify(leftMotor).setPower(-0.3);\n        verify(rightMotor).setPower(-0.3);\n    }\n    \n    @Test(expected = IllegalArgumentException.class)\n    public void testDriveForwardInvalidPower() {\n        robotController.driveForward(1.5); // Power > 1.0\n    }"
    },
    {
      "type": "text",
      "title": "Understanding Mockito Test Setup",
      "content": "The @RunWith(MockitoJUnitRunner.class) annotation tells JUnit to use Mockito for test execution. The @Mock annotations create mock objects that simulate hardware components, and the @Before method sets up the test environment before each test."
    },
    {
      "type": "code",
      "title": "Turn and Stop Tests",
      "content": "Add tests for turning and stopping operations:",
      "code": "    @Test\n    public void testTurn() {\n        // Test turning left\n        robotController.turn(-0.4, 0.4);\n        \n        verify(leftMotor).setPower(-0.4);\n        verify(rightMotor).setPower(0.4);\n    }\n    \n    @Test(expected = IllegalArgumentException.class)\n    public void testTurnInvalidPower() {\n        robotController.turn(1.2, 0.5); // Left power > 1.0\n    }\n    \n    @Test\n    public void testStop() {\n        robotController.stop();\n        \n        verify(leftMotor).setPower(0.0);\n        verify(rightMotor).setPower(0.0);\n    }"
    },
    {
      "type": "text",
      "title": "Understanding Turn and Stop Tests",
      "content": "The turn test verifies that the robot controller correctly sets different powers for left and right motors to achieve turning. The stop test ensures both motors are set to zero power when stopping."
    },
    {
      "type": "code",
      "title": "Color Sensor Tests",
      "content": "Add tests for the color sensor detection logic:",
      "code": "    @Test\n    public void testIsRedBallDetected() {\n        // Test case 1: Red ball detected\n        when(colorSensor.red()).thenReturn(200);\n        when(colorSensor.green()).thenReturn(50);\n        when(colorSensor.blue()).thenReturn(30);\n        \n        assertTrue(\"Should detect red ball\", robotController.isRedBallDetected());\n        \n        // Test case 2: No red ball (blue dominant)\n        when(colorSensor.red()).thenReturn(50);\n        when(colorSensor.green()).thenReturn(60);\n        when(colorSensor.blue()).thenReturn(200);\n        \n        assertFalse(\"Should not detect red ball when blue is dominant\", robotController.isRedBallDetected());\n        \n        // Test case 3: Red too low\n        when(colorSensor.red()).thenReturn(80);\n        when(colorSensor.green()).thenReturn(30);\n        when(colorSensor.blue()).thenReturn(20);\n        \n        assertFalse(\"Should not detect red ball when red value is too low\", robotController.isRedBallDetected());\n    }"
    },
    {
      "type": "text",
      "title": "Understanding Color Sensor Tests",
      "content": "The color sensor tests use Mockito's when().thenReturn() to simulate different sensor readings. This allows testing the color detection logic with various scenarios without needing a real color sensor."
    },
    {
      "type": "code",
      "title": "Motor Power Retrieval Tests",
      "content": "Add tests for getting motor power values:",
      "code": "    @Test\n    public void testGetMotorPowers() {\n        when(leftMotor.getPower()).thenReturn(0.7);\n        when(rightMotor.getPower()).thenReturn(0.3);\n        \n        assertEquals(\"Left motor power should match\", 0.7, robotController.getLeftMotorPower(), 0.001);\n        assertEquals(\"Right motor power should match\", 0.3, robotController.getRightMotorPower(), 0.001);\n    }\n}"
    },
    {
      "type": "text",
      "title": "Understanding Motor Power Tests",
      "content": "The motor power retrieval tests verify that the controller correctly returns the current motor power values. These tests ensure that the getter methods properly delegate to the underlying motor objects."
    },
    {
      "type": "text",
      "title": "Testing Autonomous Sequences",
      "content": "Autonomous sequences are complex and critical for competition success. Testing them thoroughly ensures they work reliably under various conditions. We'll create a testable autonomous sequence class and verify its behavior."
    },
    {
      "type": "code",
      "title": "Autonomous Sequence Class",
      "content": "Create a testable autonomous sequence class. This class manages the state of an autonomous routine:",
      "code": "// File: AutonomousSequence.java\npublic class AutonomousSequence {\n    private RobotController robotController;\n    private double startTime;\n    private boolean isComplete = false;\n    \n    public AutonomousSequence(RobotController robotController) {\n        this.robotController = robotController;\n    }\n    \n    public void start(double currentTime) {\n        this.startTime = currentTime;\n        this.isComplete = false;\n    }\n    \n    public void update(double currentTime) {\n        if (isComplete) return;\n        \n        double elapsedTime = currentTime - startTime;\n        \n        // Simple autonomous sequence: drive forward for 2 seconds, then stop\n        if (elapsedTime < 2.0) {\n            robotController.driveForward(0.5);\n        } else {\n            robotController.stop();\n            isComplete = true;\n        }\n    }\n    \n    public boolean isComplete() {\n        return isComplete;\n    }\n    \n    public double getElapsedTime(double currentTime) {\n        return currentTime - startTime;\n    }\n}"
    },
    {
      "type": "text",
      "title": "Understanding Autonomous Sequence Design",
      "content": "The autonomous sequence class encapsulates the timing and state management of an autonomous routine. It uses dependency injection to accept a robot controller, making it testable with mocked components."
    },
    {
      "type": "text",
      "title": "Testing Autonomous Sequence Behavior",
      "content": "Now let's test the autonomous sequence to ensure it behaves correctly at different time points and properly manages its state."
    },
    {
      "type": "code",
      "title": "Autonomous Sequence Test Setup and Start Tests",
      "content": "Create tests for the autonomous sequence. Start with setup and sequence start tests:",
      "code": "// File: AutonomousSequenceTest.java\nimport org.junit.Before;\nimport org.junit.Test;\nimport org.junit.runner.RunWith;\nimport org.mockito.Mock;\nimport org.mockito.junit.MockitoJUnitRunner;\nimport static org.mockito.Mockito.*;\nimport static org.junit.Assert.*;\n\n@RunWith(MockitoJUnitRunner.class)\npublic class AutonomousSequenceTest {\n    \n    @Mock\n    private RobotController robotController;\n    \n    private AutonomousSequence autonomousSequence;\n    \n    @Before\n    public void setUp() {\n        autonomousSequence = new AutonomousSequence(robotController);\n    }\n    \n    @Test\n    public void testSequenceStart() {\n        autonomousSequence.start(0.0);\n        \n        assertFalse(\"Sequence should not be complete at start\", autonomousSequence.isComplete());\n        assertEquals(\"Elapsed time should be 0 at start\", 0.0, autonomousSequence.getElapsedTime(0.0), 0.001);\n    }"
    },
    {
      "type": "text",
      "title": "Understanding Sequence Start Tests",
      "content": "The sequence start test verifies that the autonomous sequence initializes correctly. It checks that the sequence is not complete at the start and that elapsed time calculation works properly."
    },
    {
      "type": "code",
      "title": "Driving Phase Tests",
      "content": "Add tests for the driving phase of the autonomous sequence:",
      "code": "    @Test\n    public void testSequenceDrivingPhase() {\n        autonomousSequence.start(0.0);\n        \n        // Test during driving phase (first 2 seconds)\n        autonomousSequence.update(1.0);\n        \n        verify(robotController).driveForward(0.5);\n        assertFalse(\"Sequence should not be complete during driving phase\", autonomousSequence.isComplete());\n        \n        // Test at 1.5 seconds\n        autonomousSequence.update(1.5);\n        \n        verify(robotController, times(2)).driveForward(0.5);\n        assertFalse(\"Sequence should not be complete at 1.5 seconds\", autonomousSequence.isComplete());\n    }"
    },
    {
      "type": "text",
      "title": "Understanding Driving Phase Tests",
      "content": "The driving phase tests verify that the sequence correctly drives forward during the first 2 seconds. The times(2) verification ensures that driveForward was called exactly twice during the test."
    },
    {
      "type": "code",
      "title": "Completion Tests",
      "content": "Add tests for sequence completion and post-completion behavior:",
      "code": "    @Test\n    public void testSequenceCompletion() {\n        autonomousSequence.start(0.0);\n        \n        // Test at exactly 2.0 seconds\n        autonomousSequence.update(2.0);\n        \n        verify(robotController).driveForward(0.5);\n        verify(robotController).stop();\n        assertTrue(\"Sequence should be complete at 2.0 seconds\", autonomousSequence.isComplete());\n        \n        // Test that further updates don't change behavior\n        autonomousSequence.update(3.0);\n        \n        // Should not call driveForward again since sequence is complete\n        verify(robotController, times(1)).driveForward(0.5);\n        verify(robotController, times(1)).stop();\n    }\n    \n    @Test\n    public void testSequenceAfterCompletion() {\n        autonomousSequence.start(0.0);\n        \n        // Complete the sequence\n        autonomousSequence.update(2.0);\n        assertTrue(\"Sequence should be complete\", autonomousSequence.isComplete());\n        \n        // Try to update again\n        autonomousSequence.update(5.0);\n        \n        // Should not call any robot controller methods\n        verify(robotController, times(1)).driveForward(0.5);\n        verify(robotController, times(1)).stop();\n        verifyNoMoreInteractions(robotController);\n    }\n    \n    @Test\n    public void testElapsedTimeCalculation() {\n        autonomousSequence.start(10.0);\n        \n        assertEquals(\"Elapsed time calculation\", 0.0, autonomousSequence.getElapsedTime(10.0), 0.001);\n        assertEquals(\"Elapsed time calculation\", 1.5, autonomousSequence.getElapsedTime(11.5), 0.001);\n        assertEquals(\"Elapsed time calculation\", 3.0, autonomousSequence.getElapsedTime(13.0), 0.001);\n    }\n}"
    },
    {
      "type": "text",
      "title": "Understanding Completion Tests",
      "content": "The completion tests verify that the sequence properly stops and marks itself as complete after 2 seconds. They also ensure that once complete, the sequence doesn't continue calling robot controller methods."
    },
    {
      "type": "text",
      "title": "Integration Testing",
      "content": "Integration tests verify that multiple components work together correctly. These tests are more complex but catch issues that unit tests might miss. They test the interaction between different parts of your robot system."
    },
    {
      "type": "code",
      "title": "Integration Test Setup and Complete Sequence Test",
      "content": "Create an integration test that tests multiple components working together:",
      "code": "// File: RobotIntegrationTest.java\nimport org.junit.Before;\nimport org.junit.Test;\nimport org.junit.runner.RunWith;\nimport org.mockito.Mock;\nimport org.mockito.junit.MockitoJUnitRunner;\nimport static org.mockito.Mockito.*;\nimport static org.junit.Assert.*;\n\n@RunWith(MockitoJUnitRunner.class)\npublic class RobotIntegrationTest {\n    \n    @Mock\n    private DcMotor leftMotor;\n    \n    @Mock\n    private DcMotor rightMotor;\n    \n    @Mock\n    private ColorSensor colorSensor;\n    \n    private RobotController robotController;\n    private AutonomousSequence autonomousSequence;\n    \n    @Before\n    public void setUp() {\n        robotController = new RobotController(leftMotor, rightMotor, colorSensor);\n        autonomousSequence = new AutonomousSequence(robotController);\n    }\n    \n    @Test\n    public void testCompleteAutonomousSequence() {\n        // Set up color sensor to detect red ball\n        when(colorSensor.red()).thenReturn(200);\n        when(colorSensor.green()).thenReturn(50);\n        when(colorSensor.blue()).thenReturn(30);\n        \n        // Start autonomous sequence\n        autonomousSequence.start(0.0);\n        \n        // Simulate sequence execution\n        for (double time = 0.1; time <= 2.5; time += 0.1) {\n            autonomousSequence.update(time);\n        }\n        \n        // Verify the complete sequence executed correctly\n        assertTrue(\"Autonomous sequence should be complete\", autonomousSequence.isComplete());\n        \n        // Verify motor interactions\n        verify(leftMotor, atLeastOnce()).setPower(0.5);\n        verify(rightMotor, atLeastOnce()).setPower(0.5);\n        verify(leftMotor, atLeastOnce()).setPower(0.0);\n        verify(rightMotor, atLeastOnce()).setPower(0.0);\n        \n        // Verify color sensor was used\n        verify(colorSensor, atLeastOnce()).red();\n        verify(colorSensor, atLeastOnce()).green();\n        verify(colorSensor, atLeastOnce()).blue();\n    }"
    },
    {
      "type": "text",
      "title": "Understanding Integration Test Setup",
      "content": "The integration test sets up a complete system with mocked hardware components. It tests the interaction between the autonomous sequence and the robot controller, ensuring they work together correctly."
    },
    {
      "type": "code",
      "title": "Integration Test with Real Calculations",
      "content": "Add an integration test that combines utility functions with robot controller operations:",
      "code": "    @Test\n    public void testRobotControllerWithRealCalculations() {\n        // Test that utility functions work with robot controller\n        double distance = 24.0; // 24 inches\n        int ticksPerRev = 1440;\n        double wheelDiameter = 4.0;\n        \n        // Calculate expected ticks\n        int expectedTicks = RobotUtils.inchesToTicks(distance, ticksPerRev, wheelDiameter);\n        \n        // Verify calculation is reasonable\n        assertTrue(\"Ticks should be positive\", expectedTicks > 0);\n        assertTrue(\"Ticks should be reasonable for 24 inches\", expectedTicks < 10000);\n        \n        // Test power calculation\n        double time = 3.0; // 3 seconds\n        double maxPower = 1.0;\n        double calculatedPower = RobotUtils.calculatePowerForDistance(distance, time, maxPower);\n        \n        assertTrue(\"Power should be positive\", calculatedPower > 0);\n        assertTrue(\"Power should not exceed maxPower\", calculatedPower <= maxPower);\n        \n        // Use calculated power with robot controller\n        robotController.driveForward(calculatedPower);\n        \n        verify(leftMotor).setPower(calculatedPower);\n        verify(rightMotor).setPower(calculatedPower);\n    }\n}"
    },
    {
      "type": "text",
      "title": "Understanding Integration with Real Calculations",
      "content": "This integration test combines utility functions with robot controller operations, testing that calculated values are reasonable and that the robot controller correctly uses them."
    },
    {
      "type": "code",
      "title": "Complete Unit Testing Example",
      "content": "Here's the complete unit testing example with all components combined:",
      "code": "import org.junit.Before;\nimport org.junit.Test;\nimport org.junit.runner.RunWith;\nimport org.mockito.Mock;\nimport org.mockito.junit.MockitoJUnitRunner;\nimport static org.mockito.Mockito.*;\nimport static org.junit.Assert.*;\nimport com.qualcomm.robotcore.hardware.DcMotor;\nimport com.qualcomm.robotcore.hardware.ColorSensor;\n\n// RobotUtils.java\npublic class RobotUtils {\n    public static double ticksToInches(int ticks, int ticksPerRevolution, double wheelDiameter) {\n        if (ticksPerRevolution <= 0 || wheelDiameter <= 0) {\n            throw new IllegalArgumentException(\"Ticks per revolution and wheel diameter must be positive\");\n        }\n        \n        double circumference = Math.PI * wheelDiameter;\n        return (ticks * circumference) / ticksPerRevolution;\n    }\n    \n    public static int inchesToTicks(double inches, int ticksPerRevolution, double wheelDiameter) {\n        if (ticksPerRevolution <= 0 || wheelDiameter <= 0) {\n            throw new IllegalArgumentException(\"Ticks per revolution and wheel diameter must be positive\");\n        }\n        \n        double circumference = Math.PI * wheelDiameter;\n        return (int) Math.round((inches * ticksPerRevolution) / circumference);\n    }\n    \n    public static double calculatePowerForDistance(double distance, double time, double maxPower) {\n        if (distance < 0 || time <= 0 || maxPower <= 0 || maxPower > 1.0) {\n            throw new IllegalArgumentException(\"Invalid parameters for power calculation\");\n        }\n        \n        double requiredPower = distance / (time * 12.0);\n        return Math.min(requiredPower, maxPower);\n    }\n}\n\n// RobotController.java\npublic class RobotController {\n    private DcMotor leftMotor;\n    private DcMotor rightMotor;\n    private ColorSensor colorSensor;\n    \n    public RobotController(DcMotor leftMotor, DcMotor rightMotor, ColorSensor colorSensor) {\n        this.leftMotor = leftMotor;\n        this.rightMotor = rightMotor;\n        this.colorSensor = colorSensor;\n    }\n    \n    public void driveForward(double power) {\n        if (power < -1.0 || power > 1.0) {\n            throw new IllegalArgumentException(\"Power must be between -1.0 and 1.0\");\n        }\n        \n        leftMotor.setPower(power);\n        rightMotor.setPower(power);\n    }\n    \n    public void turn(double leftPower, double rightPower) {\n        if (Math.abs(leftPower) > 1.0 || Math.abs(rightPower) > 1.0) {\n            throw new IllegalArgumentException(\"Power values must be between -1.0 and 1.0\");\n        }\n        \n        leftMotor.setPower(leftPower);\n        rightMotor.setPower(rightPower);\n    }\n    \n    public boolean isRedBallDetected() {\n        int red = colorSensor.red();\n        int green = colorSensor.green();\n        int blue = colorSensor.blue();\n        \n        return red > green && red > blue && red > 100;\n    }\n    \n    public void stop() {\n        leftMotor.setPower(0.0);\n        rightMotor.setPower(0.0);\n    }\n    \n    public double getLeftMotorPower() {\n        return leftMotor.getPower();\n    }\n    \n    public double getRightMotorPower() {\n        return rightMotor.getPower();\n    }\n}\n\n// AutonomousSequence.java\npublic class AutonomousSequence {\n    private RobotController robotController;\n    private double startTime;\n    private boolean isComplete = false;\n    \n    public AutonomousSequence(RobotController robotController) {\n        this.robotController = robotController;\n    }\n    \n    public void start(double currentTime) {\n        this.startTime = currentTime;\n        this.isComplete = false;\n    }\n    \n    public void update(double currentTime) {\n        if (isComplete) return;\n        \n        double elapsedTime = currentTime - startTime;\n        \n        if (elapsedTime < 2.0) {\n            robotController.driveForward(0.5);\n        } else {\n            robotController.stop();\n            isComplete = true;\n        }\n    }\n    \n    public boolean isComplete() {\n        return isComplete;\n    }\n    \n    public double getElapsedTime(double currentTime) {\n        return currentTime - startTime;\n    }\n}\n\n// ComprehensiveRobotTest.java\n@RunWith(MockitoJUnitRunner.class)\npublic class ComprehensiveRobotTest {\n    \n    @Mock\n    private DcMotor leftMotor, rightMotor;\n    \n    @Mock\n    private ColorSensor colorSensor;\n    \n    private RobotController robotController;\n    private AutonomousSequence autonomousSequence;\n    \n    @Before\n    public void setUp() {\n        robotController = new RobotController(leftMotor, rightMotor, colorSensor);\n        autonomousSequence = new AutonomousSequence(robotController);\n    }\n    \n    @Test\n    public void testTicksToInches() {\n        double result = RobotUtils.ticksToInches(1000, 1440, 4.0);\n        double expected = (1000 * Math.PI * 4.0) / 1440;\n        assertEquals(\"Basic ticks to inches conversion\", expected, result, 0.001);\n    }\n    \n    @Test\n    public void testInchesToTicks() {\n        int result = RobotUtils.inchesToTicks(10.0, 1440, 4.0);\n        int expected = (int) Math.round((10.0 * 1440) / (Math.PI * 4.0));\n        assertEquals(\"Basic inches to ticks conversion\", expected, result);\n    }\n    \n    @Test\n    public void testDriveForward() {\n        robotController.driveForward(0.5);\n        verify(leftMotor).setPower(0.5);\n        verify(rightMotor).setPower(0.5);\n    }\n    \n    @Test\n    public void testTurn() {\n        robotController.turn(-0.4, 0.4);\n        verify(leftMotor).setPower(-0.4);\n        verify(rightMotor).setPower(0.4);\n    }\n    \n    @Test\n    public void testIsRedBallDetected() {\n        when(colorSensor.red()).thenReturn(200);\n        when(colorSensor.green()).thenReturn(50);\n        when(colorSensor.blue()).thenReturn(30);\n        \n        assertTrue(\"Should detect red ball\", robotController.isRedBallDetected());\n    }\n    \n    @Test\n    public void testAutonomousSequence() {\n        autonomousSequence.start(0.0);\n        \n        autonomousSequence.update(1.0);\n        verify(robotController).driveForward(0.5);\n        assertFalse(\"Sequence should not be complete\", autonomousSequence.isComplete());\n        \n        autonomousSequence.update(2.0);\n        verify(robotController).stop();\n        assertTrue(\"Sequence should be complete\", autonomousSequence.isComplete());\n    }\n    \n    @Test\n    public void testIntegrationWithRealCalculations() {\n        double distance = 24.0;\n        int ticksPerRev = 1440;\n        double wheelDiameter = 4.0;\n        \n        int expectedTicks = RobotUtils.inchesToTicks(distance, ticksPerRev, wheelDiameter);\n        assertTrue(\"Ticks should be positive\", expectedTicks > 0);\n        \n        double time = 3.0;\n        double maxPower = 1.0;\n        double calculatedPower = RobotUtils.calculatePowerForDistance(distance, time, maxPower);\n        \n        assertTrue(\"Power should be positive\", calculatedPower > 0);\n        assertTrue(\"Power should not exceed maxPower\", calculatedPower <= maxPower);\n        \n        robotController.driveForward(calculatedPower);\n        verify(leftMotor).setPower(calculatedPower);\n        verify(rightMotor).setPower(calculatedPower);\n    }\n}"
    },
    {
      "type": "text",
      "title": "Test Organization and Best Practices",
      "content": "Organizing your tests properly and following best practices makes them more maintainable and effective. Good test organization helps you find and fix issues quickly."
    },
    {
      "type": "rules-box",
      "title": "Unit Testing Best Practices",
      "items": [
        "Test one thing at a time - each test should verify one specific behavior",
        "Use descriptive test names that explain what is being tested",
        "Follow the Arrange-Act-Assert pattern: set up, execute, verify",
        "Test both normal cases and edge cases (boundary conditions)",
        "Test error conditions and exception handling",
        "Keep tests independent - they should not depend on each other",
        "Use meaningful test data that represents real scenarios"
      ]
    },
    {
      "type": "text",
      "title": "Comprehensive Test Organization",
      "content": "Let's create a comprehensive test class that demonstrates proper test organization with clear naming conventions and thorough coverage."
    },
    {
      "type": "code",
      "title": "Comprehensive Test Class - Setup and Drive Tests",
      "content": "Organize your tests with clear structure and naming. This example shows how to group related tests together:",
      "code": "// File: ComprehensiveRobotTest.java\nimport org.junit.Before;\nimport org.junit.Test;\nimport org.junit.runner.RunWith;\nimport org.mockito.Mock;\nimport org.mockito.junit.MockitoJUnitRunner;\nimport static org.mockito.Mockito.*;\nimport static org.junit.Assert.*;\n\n@RunWith(MockitoJUnitRunner.class)\npublic class ComprehensiveRobotTest {\n    \n    @Mock\n    private DcMotor leftMotor, rightMotor;\n    \n    @Mock\n    private ColorSensor colorSensor;\n    \n    private RobotController robotController;\n    \n    @Before\n    public void setUp() {\n        robotController = new RobotController(leftMotor, rightMotor, colorSensor);\n    }\n    \n    // Group related tests together with descriptive names\n    \n    @Test\n    public void driveForward_WithPositivePower_ShouldSetBothMotorsToSamePower() {\n        // Arrange\n        double power = 0.7;\n        \n        // Act\n        robotController.driveForward(power);\n        \n        // Assert\n        verify(leftMotor).setPower(power);\n        verify(rightMotor).setPower(power);\n    }\n    \n    @Test\n    public void driveForward_WithNegativePower_ShouldDriveBackward() {\n        // Arrange\n        double power = -0.5;\n        \n        // Act\n        robotController.driveForward(power);\n        \n        // Assert\n        verify(leftMotor).setPower(power);\n        verify(rightMotor).setPower(power);\n    }"
    },
    {
      "type": "code",
      "title": "Comprehensive Test Class - Error Handling Tests",
      "content": "Add tests for error conditions and boundary cases:",
      "code": "    @Test(expected = IllegalArgumentException.class)\n    public void driveForward_WithPowerGreaterThanOne_ShouldThrowException() {\n        // Arrange\n        double invalidPower = 1.5;\n        \n        // Act & Assert\n        robotController.driveForward(invalidPower);\n    }\n    \n    @Test(expected = IllegalArgumentException.class)\n    public void driveForward_WithPowerLessThanNegativeOne_ShouldThrowException() {\n        // Arrange\n        double invalidPower = -1.2;\n        \n        // Act & Assert\n        robotController.driveForward(invalidPower);\n    }\n    \n    @Test\n    public void turn_WithDifferentLeftAndRightPowers_ShouldSetMotorsCorrectly() {\n        // Arrange\n        double leftPower = -0.3;\n        double rightPower = 0.3;\n        \n        // Act\n        robotController.turn(leftPower, rightPower);\n        \n        // Assert\n        verify(leftMotor).setPower(leftPower);\n        verify(rightMotor).setPower(rightPower);\n    }"
    },
    {
      "type": "code",
      "title": "Comprehensive Test Class - Sensor Tests",
      "content": "Add tests for sensor operations and color detection:",
      "code": "    @Test\n    public void isRedBallDetected_WithRedDominantColors_ShouldReturnTrue() {\n        // Arrange\n        when(colorSensor.red()).thenReturn(200);\n        when(colorSensor.green()).thenReturn(50);\n        when(colorSensor.blue()).thenReturn(30);\n        \n        // Act\n        boolean result = robotController.isRedBallDetected();\n        \n        // Assert\n        assertTrue(\"Should detect red ball when red is dominant\", result);\n    }\n    \n    @Test\n    public void isRedBallDetected_WithBlueDominantColors_ShouldReturnFalse() {\n        // Arrange\n        when(colorSensor.red()).thenReturn(50);\n        when(colorSensor.green()).thenReturn(60);\n        when(colorSensor.blue()).thenReturn(200);\n        \n        // Act\n        boolean result = robotController.isRedBallDetected();\n        \n        // Assert\n        assertFalse(\"Should not detect red ball when blue is dominant\", result);\n    }\n    \n    @Test\n    public void stop_ShouldSetBothMotorsToZero() {\n        // Arrange - no setup needed\n        \n        // Act\n        robotController.stop();\n        \n        // Assert\n        verify(leftMotor).setPower(0.0);\n        verify(rightMotor).setPower(0.0);\n    }\n}"
    },
    {
      "type": "exercise-box",
      "title": "Practice: Advanced Debugging",
      "description": "Try these debugging exercises to reinforce your understanding:",
      "tasks": [
        "Create an OpMode with a state machine that controls a robot drivetrain",
        "Intentionally introduce a bug (e.g., wrong state transition condition)",
        "Set up conditional breakpoints to catch the bug",
        "Use watch expressions to monitor state variables",
        "Implement structured logging to track the bug",
        "Use remote debugging to verify the fix works on hardware"
      ],
      "answers": [
        {
          "task": "Create an OpMode with a state machine that controls a robot drivetrain",
          "content": "import com.qualcomm.robotcore.eventloop.opmode.OpMode;\nimport com.qualcomm.robotcore.eventloop.opmode.TeleOp;\nimport com.qualcomm.robotcore.hardware.DcMotor;\nimport android.util.Log;\n\n@TeleOp(name = \"DebuggingExercise\")\npublic class DebuggingExerciseOpMode extends OpMode {\n    private static final String TAG = \"DebugExercise\";\n    \n    // State machine for robot control\n    private enum RobotState { IDLE, FORWARD, TURNING, COMPLETE }\n    private RobotState currentState = RobotState.IDLE;\n    \n    // Hardware components\n    private DcMotor leftMotor, rightMotor;\n    \n    // State tracking variables\n    private int loopCount = 0;\n    private double startTime = 0.0;\n    \n    @Override\n    public void init() {\n        // Initialize hardware\n        leftMotor = hardwareMap.get(DcMotor.class, \"left_motor\");\n        rightMotor = hardwareMap.get(DcMotor.class, \"right_motor\");\n        \n        // Add debug logging\n        Log.d(TAG, \"Hardware initialized\");\n        Log.d(TAG, \"Left motor: \" + leftMotor.getDeviceName());\n        Log.d(TAG, \"Right motor: \" + rightMotor.getDeviceName());\n    }\n    \n    @Override\n    public void loop() {\n        // State machine logic\n        switch (currentState) {\n            case IDLE:\n                handleIdleState();\n                break;\n            case FORWARD:\n                handleForwardState();\n                break;\n            case TURNING:\n                handleTurningState();\n                break;\n            case COMPLETE:\n                handleCompleteState();\n                break;\n        }\n        \n        // Update tracking variables\n        loopCount++;\n        \n        // Add telemetry\n        telemetry.addData(\"State\", currentState);\n        telemetry.addData(\"Loop Count\", loopCount);\n        telemetry.addData(\"Runtime\", \"%.2f\", getRuntime());\n    }\n    \n    private void handleIdleState() {\n        // TODO: Implement idle state logic\n    }\n    \n    private void handleForwardState() {\n        // TODO: Implement forward state logic\n    }\n    \n    private void handleTurningState() {\n        // TODO: Implement turning state logic\n    }\n    \n    private void handleCompleteState() {\n        // TODO: Implement complete state logic\n    }\n}"
        },
        {
          "task": "Intentionally introduce a bug (e.g., wrong state transition condition)",
          "content": "private void handleIdleState() {\n    // BUG: Wrong condition - should be loopCount > 50, not 5\n    if (loopCount > 5) {  // This bug makes the robot start too early\n        currentState = RobotState.FORWARD;\n        startTime = getRuntime();\n        Log.d(TAG, \"Transitioning to FORWARD state\");\n        \n        // Start driving forward\n        leftMotor.setPower(0.5);\n        rightMotor.setPower(0.5);\n    }\n}\n\nprivate void handleForwardState() {\n    // BUG: Wrong condition - should be getRuntime() - startTime > 3.0\n    if (getRuntime() - startTime > 1.0) {  // This bug makes the robot turn too early\n        currentState = RobotState.TURNING;\n        Log.d(TAG, \"Transitioning to TURNING state\");\n        \n        // Start turning\n        leftMotor.setPower(0.3);\n        rightMotor.setPower(-0.3);\n    }\n}\n\nprivate void handleTurningState() {\n    // BUG: Wrong condition - should be getRuntime() - startTime > 5.0\n    if (getRuntime() - startTime > 2.0) {  // This bug makes the robot stop too early\n        currentState = RobotState.COMPLETE;\n        Log.d(TAG, \"Transitioning to COMPLETE state\");\n        \n        // Stop motors\n        leftMotor.setPower(0);\n        rightMotor.setPower(0);\n    }\n}\n\nprivate void handleCompleteState() {\n    Log.d(TAG, \"Robot sequence complete\");\n    // Keep the robot stopped\n    leftMotor.setPower(0);\n    rightMotor.setPower(0);\n}"
        },
        {
          "task": "Set up conditional breakpoints to catch the bug",
          "content": "// Set these conditional breakpoints in your debugger:\n// 1. In handleIdleState() at line: if (loopCount > 5)\n//    Condition: loopCount > 5\n//    This will break when the buggy condition is met\n\n// 2. In handleForwardState() at line: if (getRuntime() - startTime > 1.0)\n//    Condition: getRuntime() - startTime > 1.0\n//    This will break when the robot transitions too early\n\n// 3. In handleTurningState() at line: if (getRuntime() - startTime > 2.0)\n//    Condition: getRuntime() - startTime > 2.0\n//    This will break when the robot completes too early\n\n// 4. In handleCompleteState() at the first line\n//    Condition: true\n//    This will always break when reaching the complete state\n\n// Watch these variables during debugging:\n// - currentState\n// - loopCount\n// - startTime\n// - getRuntime()\n// - leftMotor.getPower()\n// - rightMotor.getPower()"
        },
        {
          "task": "Use watch expressions to monitor state variables",
          "content": "// Add these watch expressions in your debugger:\n// 1. currentState - Monitor the current robot state\n// 2. loopCount - Track how many loops have executed\n// 3. startTime - See when the sequence started\n// 4. getRuntime() - Monitor the total runtime\n// 5. getRuntime() - startTime - Calculate elapsed time since sequence start\n// 6. leftMotor.getPower() - Monitor left motor power\n// 7. rightMotor.getPower() - Monitor right motor power\n\n// Expected behavior vs actual behavior:\n// Expected: Robot waits 50 loops before starting\n// Actual: Robot starts after only 5 loops (BUG)\n// \n// Expected: Robot drives forward for 3 seconds\n// Actual: Robot drives forward for only 1 second (BUG)\n// \n// Expected: Robot turns for 2 seconds\n// Actual: Robot turns for only 1 second (BUG)"
        },
        {
          "task": "Implement structured logging to track the bug",
          "content": "// Add this logging configuration at the top of your class:\nprivate static final boolean DEBUG_MODE = true;\nprivate static final boolean VERBOSE_LOGGING = true;\n\n// Add these logging methods:\nprivate void logInfo(String message) {\n    Log.i(TAG, message);\n    telemetry.addData(\"INFO\", message);\n}\n\nprivate void logDebug(String message) {\n    if (DEBUG_MODE) {\n        Log.d(TAG, message);\n        telemetry.addData(\"DEBUG\", message);\n    }\n}\n\nprivate void logVerbose(String message) {\n    if (VERBOSE_LOGGING) {\n        Log.v(TAG, message);\n    }\n}\n\n// Update your state handlers with logging:\nprivate void handleIdleState() {\n    logDebug(\"Idle state - Loop count: \" + loopCount);\n    \n    if (loopCount > 5) {  // BUG: Should be 50\n        logInfo(\"BUG: Transitioning to FORWARD too early!\");\n        logDebug(\"Expected: loopCount > 50, Actual: loopCount = \" + loopCount);\n        \n        currentState = RobotState.FORWARD;\n        startTime = getRuntime();\n        \n        leftMotor.setPower(0.5);\n        rightMotor.setPower(0.5);\n        \n        logInfo(\"Started driving forward\");\n    }\n}\n\nprivate void handleForwardState() {\n    double elapsedTime = getRuntime() - startTime;\n    logDebug(\"Forward state - Elapsed time: \" + elapsedTime);\n    \n    if (elapsedTime > 1.0) {  // BUG: Should be 3.0\n        logInfo(\"BUG: Transitioning to TURNING too early!\");\n        logDebug(\"Expected: elapsedTime > 3.0, Actual: elapsedTime = \" + elapsedTime);\n        \n        currentState = RobotState.TURNING;\n        \n        leftMotor.setPower(0.3);\n        rightMotor.setPower(-0.3);\n        \n        logInfo(\"Started turning\");\n    }\n}\n\nprivate void handleTurningState() {\n    double elapsedTime = getRuntime() - startTime;\n    logDebug(\"Turning state - Elapsed time: \" + elapsedTime);\n    \n    if (elapsedTime > 2.0) {  // BUG: Should be 5.0\n        logInfo(\"BUG: Completing sequence too early!\");\n        logDebug(\"Expected: elapsedTime > 5.0, Actual: elapsedTime = \" + elapsedTime);\n        \n        currentState = RobotState.COMPLETE;\n        \n        leftMotor.setPower(0);\n        rightMotor.setPower(0);\n        \n        logInfo(\"Sequence complete\");\n    }\n}\n\nprivate void handleCompleteState() {\n    logInfo(\"Robot stopped - Sequence finished\");\n    leftMotor.setPower(0);\n    rightMotor.setPower(0);\n}"
        },
        {
          "task": "Use remote debugging to verify the fix works on hardware",
          "content": "// First, fix the bugs in your code:\nprivate void handleIdleState() {\n    logDebug(\"Idle state - Loop count: \" + loopCount);\n    \n    if (loopCount > 50) {  // FIXED: Changed from 5 to 50\n        logInfo(\"Transitioning to FORWARD state\");\n        \n        currentState = RobotState.FORWARD;\n        startTime = getRuntime();\n        \n        leftMotor.setPower(0.5);\n        rightMotor.setPower(0.5);\n        \n        logInfo(\"Started driving forward\");\n    }\n}\n\nprivate void handleForwardState() {\n    double elapsedTime = getRuntime() - startTime;\n    logDebug(\"Forward state - Elapsed time: \" + elapsedTime);\n    \n    if (elapsedTime > 3.0) {  // FIXED: Changed from 1.0 to 3.0\n        logInfo(\"Transitioning to TURNING state\");\n        \n        currentState = RobotState.TURNING;\n        \n        leftMotor.setPower(0.3);\n        rightMotor.setPower(-0.3);\n        \n        logInfo(\"Started turning\");\n    }\n}\n\nprivate void handleTurningState() {\n    double elapsedTime = getRuntime() - startTime;\n    logDebug(\"Turning state - Elapsed time: \" + elapsedTime);\n    \n    if (elapsedTime > 5.0) {  // FIXED: Changed from 2.0 to 5.0\n        logInfo(\"Transitioning to COMPLETE state\");\n        \n        currentState = RobotState.COMPLETE;\n        \n        leftMotor.setPower(0);\n        rightMotor.setPower(0);\n        \n        logInfo(\"Sequence complete\");\n    }\n}\n\n// Remote debugging setup:\n// 1. Connect to Control Hub via ADB:\n//    adb connect 192.168.43.1:5555\n// \n// 2. Verify connection:\n//    adb devices\n// \n// 3. Set breakpoints on the fixed conditions\n// \n// 4. Run the OpMode and verify:\n//    - Robot waits 50 loops before starting\n//    - Robot drives forward for 3 seconds\n//    - Robot turns for 2 seconds\n//    - Robot stops and completes sequence\n// \n// 5. Check logs to confirm no more bug messages\n// \n// 6. Verify motor behavior matches expected timing"
        },
        {
          "task": "Combine all tasks into one complete debugging exercise",
          "content": "import com.qualcomm.robotcore.eventloop.opmode.OpMode;\nimport com.qualcomm.robotcore.eventloop.opmode.TeleOp;\nimport com.qualcomm.robotcore.hardware.DcMotor;\nimport android.util.Log;\n\n@TeleOp(name = \"CompleteDebuggingExercise\")\npublic class CompleteDebuggingExercise extends OpMode {\n    private static final String TAG = \"CompleteDebug\";\n    private static final boolean DEBUG_MODE = true;\n    private static final boolean VERBOSE_LOGGING = true;\n    \n    // State machine\n    private enum RobotState { IDLE, FORWARD, TURNING, COMPLETE }\n    private RobotState currentState = RobotState.IDLE;\n    \n    // Hardware\n    private DcMotor leftMotor, rightMotor;\n    \n    // State tracking\n    private int loopCount = 0;\n    private double startTime = 0.0;\n    \n    // Logging methods\n    private void logInfo(String message) {\n        Log.i(TAG, message);\n        telemetry.addData(\"INFO\", message);\n    }\n    \n    private void logDebug(String message) {\n        if (DEBUG_MODE) {\n            Log.d(TAG, message);\n            telemetry.addData(\"DEBUG\", message);\n        }\n    }\n    \n    private void logVerbose(String message) {\n        if (VERBOSE_LOGGING) {\n            Log.v(TAG, message);\n        }\n    }\n    \n    @Override\n    public void init() {\n        // Initialize hardware\n        leftMotor = hardwareMap.get(DcMotor.class, \"left_motor\");\n        rightMotor = hardwareMap.get(DcMotor.class, \"right_motor\");\n        \n        logInfo(\"Hardware initialized successfully\");\n        logDebug(\"Left motor: \" + leftMotor.getDeviceName());\n        logDebug(\"Right motor: \" + rightMotor.getDeviceName());\n    }\n    \n    @Override\n    public void loop() {\n        // State machine with debugging\n        switch (currentState) {\n            case IDLE:\n                handleIdleState();\n                break;\n            case FORWARD:\n                handleForwardState();\n                break;\n            case TURNING:\n                handleTurningState();\n                break;\n            case COMPLETE:\n                handleCompleteState();\n                break;\n        }\n        \n        loopCount++;\n        \n        // Telemetry for debugging\n        telemetry.addData(\"State\", currentState);\n        telemetry.addData(\"Loop Count\", loopCount);\n        telemetry.addData(\"Runtime\", \"%.2f\", getRuntime());\n        telemetry.addData(\"Left Power\", leftMotor.getPower());\n        telemetry.addData(\"Right Power\", rightMotor.getPower());\n    }\n    \n    private void handleIdleState() {\n        logDebug(\"Idle state - Loop count: \" + loopCount);\n        \n        if (loopCount > 50) {  // FIXED: Correct condition\n            logInfo(\"Transitioning to FORWARD state\");\n            \n            currentState = RobotState.FORWARD;\n            startTime = getRuntime();\n            \n            leftMotor.setPower(0.5);\n            rightMotor.setPower(0.5);\n            \n            logInfo(\"Started driving forward\");\n        }\n    }\n    \n    private void handleForwardState() {\n        double elapsedTime = getRuntime() - startTime;\n        logDebug(\"Forward state - Elapsed time: \" + elapsedTime);\n        \n        if (elapsedTime > 3.0) {  // FIXED: Correct condition\n            logInfo(\"Transitioning to TURNING state\");\n            \n            currentState = RobotState.TURNING;\n            \n            leftMotor.setPower(0.3);\n            rightMotor.setPower(-0.3);\n            \n            logInfo(\"Started turning\");\n        }\n    }\n    \n    private void handleTurningState() {\n        double elapsedTime = getRuntime() - startTime;\n        logDebug(\"Turning state - Elapsed time: \" + elapsedTime);\n        \n        if (elapsedTime > 5.0) {  // FIXED: Correct condition\n            logInfo(\"Transitioning to COMPLETE state\");\n            \n            currentState = RobotState.COMPLETE;\n            \n            leftMotor.setPower(0);\n            rightMotor.setPower(0);\n            \n            logInfo(\"Sequence complete\");\n        }\n    }\n    \n    private void handleCompleteState() {\n        logInfo(\"Robot stopped - Sequence finished\");\n        leftMotor.setPower(0);\n        rightMotor.setPower(0);\n    }\n}"
        }
      ]
    },
    {
      "type": "link-grid",
      "title": "Additional Resources",
      "links": [
        "<a href=\"https://developer.android.com/studio/test\" target=\"_blank\">Android Studio Testing Guide</a>",
        "<a href=\"https://junit.org/junit4/\" target=\"_blank\">JUnit 4 Documentation</a>",
        "<a href=\"https://site.mockito.org/\" target=\"_blank\">Mockito Documentation</a>",
        "<a href=\"https://developer.android.com/training/testing/junit-rules\" target=\"_blank\">Android Testing Rules</a>"
      ]
    }
  ]
} 