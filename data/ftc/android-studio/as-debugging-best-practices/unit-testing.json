{
  "title": "Unit Testing for FTC Development",
  "sections": [
    {
      "type": "text",
      "title": "Introduction to Unit Testing in FTC",
      "content": "Unit testing is a critical practice for ensuring your FTC robot code works correctly and reliably. By writing tests for individual components and methods, you can catch bugs early, verify functionality, and make your code more maintainable. This lesson covers how to implement unit testing in Android Studio for FTC projects."
    },
    {
      "type": "rules-box",
      "title": "Why Unit Testing Matters for FTC",
      "items": [
        "Catch bugs before they reach the robot hardware",
        "Verify complex algorithms work correctly",
        "Ensure code changes don't break existing functionality",
        "Document expected behavior of your code",
        "Speed up development by catching issues early"
      ]
    },
    {
      "type": "text",
      "title": "Setting Up Testing Framework",
      "content": "Android Studio uses JUnit for unit testing. You'll need to set up your project to include test dependencies and create test classes that can run independently of the robot hardware."
    },
    {
      "type": "code",
      "title": "Project Testing Configuration",
      "content": "First, ensure your project has the proper testing dependencies configured in your build.gradle file:",
      "code": "// In your app/build.gradle file, ensure you have:\ndependencies {\n    // Existing FTC dependencies...\n    \n    // Testing dependencies\n    testImplementation 'junit:junit:4.13.2'\n    testImplementation 'org.mockito:mockito-core:4.5.1'\n    testImplementation 'org.mockito:mockito-inline:4.5.1'\n    \n    // For Android-specific testing\n    androidTestImplementation 'androidx.test.ext:junit:1.1.5'\n    androidTestImplementation 'androidx.test:runner:1.5.2'\n    androidTestImplementation 'androidx.test:rules:1.5.0'\n}\n\n// In your app/build.gradle file, add test options:\nandroid {\n    // Existing configuration...\n    \n    testOptions {\n        unitTests {\n            includeAndroidResources = true\n            returnDefaultValues = true\n        }\n    }\n}"
    },
    {
      "type": "text",
      "title": "Creating Your First Test",
      "content": "Let's start with a simple test for a utility class that performs calculations. This demonstrates the basic structure of unit tests."
    },
    {
      "type": "code",
      "title": "Basic Utility Class and Test",
      "content": "First, create a simple utility class to test:",
      "code": "// File: RobotUtils.java\npublic class RobotUtils {\n    /**\n     * Converts encoder ticks to distance in inches\n     * @param ticks Number of encoder ticks\n     * @param ticksPerRevolution Ticks per revolution of the motor\n     * @param wheelDiameter Wheel diameter in inches\n     * @return Distance in inches\n     */\n    public static double ticksToInches(int ticks, int ticksPerRevolution, double wheelDiameter) {\n        if (ticksPerRevolution <= 0 || wheelDiameter <= 0) {\n            throw new IllegalArgumentException(\"Ticks per revolution and wheel diameter must be positive\");\n        }\n        \n        double circumference = Math.PI * wheelDiameter;\n        return (ticks * circumference) / ticksPerRevolution;\n    }\n    \n    /**\n     * Converts distance in inches to encoder ticks\n     * @param inches Distance in inches\n     * @param ticksPerRevolution Ticks per revolution of the motor\n     * @param wheelDiameter Wheel diameter in inches\n     * @return Number of encoder ticks\n     */\n    public static int inchesToTicks(double inches, int ticksPerRevolution, double wheelDiameter) {\n        if (ticksPerRevolution <= 0 || wheelDiameter <= 0) {\n            throw new IllegalArgumentException(\"Ticks per revolution and wheel diameter must be positive\");\n        }\n        \n        double circumference = Math.PI * wheelDiameter;\n        return (int) Math.round((inches * ticksPerRevolution) / circumference);\n    }\n    \n    /**\n     * Calculates the power needed for a given distance and time\n     * @param distance Distance to travel in inches\n     * @param time Time to travel in seconds\n     * @param maxPower Maximum power available (0.0 to 1.0)\n     * @return Calculated power (0.0 to maxPower)\n     */\n    public static double calculatePowerForDistance(double distance, double time, double maxPower) {\n        if (distance < 0 || time <= 0 || maxPower <= 0 || maxPower > 1.0) {\n            throw new IllegalArgumentException(\"Invalid parameters for power calculation\");\n        }\n        \n        // Simple linear calculation (in reality, you'd use more complex physics)\n        double requiredPower = distance / (time * 12.0); // Assuming 12 inches per second at full power\n        return Math.min(requiredPower, maxPower);\n    }\n}"
    },
    {
      "type": "code",
      "title": "Corresponding Test Class",
      "content": "Now create the test class for RobotUtils:",
      "code": "// File: RobotUtilsTest.java (in test directory)\nimport org.junit.Test;\nimport static org.junit.Assert.*;\n\npublic class RobotUtilsTest {\n    \n    @Test\n    public void testTicksToInches() {\n        // Test case 1: Basic conversion\n        double result = RobotUtils.ticksToInches(1000, 1440, 4.0);\n        double expected = (1000 * Math.PI * 4.0) / 1440;\n        assertEquals(\"Basic ticks to inches conversion\", expected, result, 0.001);\n        \n        // Test case 2: Zero ticks\n        result = RobotUtils.ticksToInches(0, 1440, 4.0);\n        assertEquals(\"Zero ticks should return zero inches\", 0.0, result, 0.001);\n        \n        // Test case 3: Large number of ticks\n        result = RobotUtils.ticksToInches(10000, 1440, 4.0);\n        expected = (10000 * Math.PI * 4.0) / 1440;\n        assertEquals(\"Large number of ticks\", expected, result, 0.001);\n    }\n    \n    @Test\n    public void testInchesToTicks() {\n        // Test case 1: Basic conversion\n        int result = RobotUtils.inchesToTicks(10.0, 1440, 4.0);\n        int expected = (int) Math.round((10.0 * 1440) / (Math.PI * 4.0));\n        assertEquals(\"Basic inches to ticks conversion\", expected, result);\n        \n        // Test case 2: Zero inches\n        result = RobotUtils.inchesToTicks(0.0, 1440, 4.0);\n        assertEquals(\"Zero inches should return zero ticks\", 0, result);\n        \n        // Test case 3: Rounding behavior\n        result = RobotUtils.inchesToTicks(5.5, 1440, 4.0);\n        expected = (int) Math.round((5.5 * 1440) / (Math.PI * 4.0));\n        assertEquals(\"Rounding behavior test\", expected, result);\n    }\n    \n    @Test\n    public void testCalculatePowerForDistance() {\n        // Test case 1: Normal calculation\n        double result = RobotUtils.calculatePowerForDistance(24.0, 2.0, 1.0);\n        double expected = 24.0 / (2.0 * 12.0); // 1.0\n        assertEquals(\"Normal power calculation\", expected, result, 0.001);\n        \n        // Test case 2: Power limited by maxPower\n        result = RobotUtils.calculatePowerForDistance(48.0, 2.0, 0.5);\n        expected = 0.5; // Limited by maxPower\n        assertEquals(\"Power limited by maxPower\", expected, result, 0.001);\n        \n        // Test case 3: Zero distance\n        result = RobotUtils.calculatePowerForDistance(0.0, 2.0, 1.0);\n        assertEquals(\"Zero distance should return zero power\", 0.0, result, 0.001);\n    }\n    \n    @Test(expected = IllegalArgumentException.class)\n    public void testTicksToInchesInvalidParameters() {\n        RobotUtils.ticksToInches(1000, 0, 4.0); // Invalid ticks per revolution\n    }\n    \n    @Test(expected = IllegalArgumentException.class)\n    public void testInchesToTicksInvalidParameters() {\n        RobotUtils.inchesToTicks(10.0, 1440, -4.0); // Invalid wheel diameter\n    }\n    \n    @Test(expected = IllegalArgumentException.class)\n    public void testCalculatePowerInvalidParameters() {\n        RobotUtils.calculatePowerForDistance(10.0, 0.0, 1.0); // Invalid time\n    }\n}"
    },
    {
      "type": "text",
      "title": "Testing Robot Components with Mocking",
      "content": "Since you can't always test with real hardware, mocking allows you to simulate hardware components and test your control logic independently."
    },
    {
      "type": "code",
      "title": "Mocking Hardware Components",
      "content": "Create a testable robot controller class and test it with mocked hardware:",
      "code": "// File: RobotController.java\npublic class RobotController {\n    private DcMotor leftMotor;\n    private DcMotor rightMotor;\n    private ColorSensor colorSensor;\n    \n    public RobotController(DcMotor leftMotor, DcMotor rightMotor, ColorSensor colorSensor) {\n        this.leftMotor = leftMotor;\n        this.rightMotor = rightMotor;\n        this.colorSensor = colorSensor;\n    }\n    \n    public void driveForward(double power) {\n        if (power < -1.0 || power > 1.0) {\n            throw new IllegalArgumentException(\"Power must be between -1.0 and 1.0\");\n        }\n        \n        leftMotor.setPower(power);\n        rightMotor.setPower(power);\n    }\n    \n    public void turn(double leftPower, double rightPower) {\n        if (Math.abs(leftPower) > 1.0 || Math.abs(rightPower) > 1.0) {\n            throw new IllegalArgumentException(\"Power values must be between -1.0 and 1.0\");\n        }\n        \n        leftMotor.setPower(leftPower);\n        rightMotor.setPower(rightPower);\n    }\n    \n    public boolean isRedBallDetected() {\n        int red = colorSensor.red();\n        int green = colorSensor.green();\n        int blue = colorSensor.blue();\n        \n        // Simple red detection logic\n        return red > green && red > blue && red > 100;\n    }\n    \n    public void stop() {\n        leftMotor.setPower(0.0);\n        rightMotor.setPower(0.0);\n    }\n    \n    public double getLeftMotorPower() {\n        return leftMotor.getPower();\n    }\n    \n    public double getRightMotorPower() {\n        return rightMotor.getPower();\n    }\n}"
    },
    {
      "type": "code",
      "title": "Testing with Mocked Hardware",
      "content": "Create tests for the RobotController using Mockito:",
      "code": "// File: RobotControllerTest.java\nimport org.junit.Before;\nimport org.junit.Test;\nimport org.junit.runner.RunWith;\nimport org.mockito.Mock;\nimport org.mockito.junit.MockitoJUnitRunner;\nimport static org.mockito.Mockito.*;\nimport static org.junit.Assert.*;\n\n@RunWith(MockitoJUnitRunner.class)\npublic class RobotControllerTest {\n    \n    @Mock\n    private DcMotor leftMotor;\n    \n    @Mock\n    private DcMotor rightMotor;\n    \n    @Mock\n    private ColorSensor colorSensor;\n    \n    private RobotController robotController;\n    \n    @Before\n    public void setUp() {\n        robotController = new RobotController(leftMotor, rightMotor, colorSensor);\n    }\n    \n    @Test\n    public void testDriveForward() {\n        // Test driving forward with positive power\n        robotController.driveForward(0.5);\n        \n        verify(leftMotor).setPower(0.5);\n        verify(rightMotor).setPower(0.5);\n    }\n    \n    @Test\n    public void testDriveForwardNegativePower() {\n        // Test driving backward\n        robotController.driveForward(-0.3);\n        \n        verify(leftMotor).setPower(-0.3);\n        verify(rightMotor).setPower(-0.3);\n    }\n    \n    @Test(expected = IllegalArgumentException.class)\n    public void testDriveForwardInvalidPower() {\n        robotController.driveForward(1.5); // Power > 1.0\n    }\n    \n    @Test\n    public void testTurn() {\n        // Test turning left\n        robotController.turn(-0.4, 0.4);\n        \n        verify(leftMotor).setPower(-0.4);\n        verify(rightMotor).setPower(0.4);\n    }\n    \n    @Test(expected = IllegalArgumentException.class)\n    public void testTurnInvalidPower() {\n        robotController.turn(1.2, 0.5); // Left power > 1.0\n    }\n    \n    @Test\n    public void testStop() {\n        robotController.stop();\n        \n        verify(leftMotor).setPower(0.0);\n        verify(rightMotor).setPower(0.0);\n    }\n    \n    @Test\n    public void testIsRedBallDetected() {\n        // Test case 1: Red ball detected\n        when(colorSensor.red()).thenReturn(200);\n        when(colorSensor.green()).thenReturn(50);\n        when(colorSensor.blue()).thenReturn(30);\n        \n        assertTrue(\"Should detect red ball\", robotController.isRedBallDetected());\n        \n        // Test case 2: No red ball (blue dominant)\n        when(colorSensor.red()).thenReturn(50);\n        when(colorSensor.green()).thenReturn(60);\n        when(colorSensor.blue()).thenReturn(200);\n        \n        assertFalse(\"Should not detect red ball when blue is dominant\", robotController.isRedBallDetected());\n        \n        // Test case 3: Red too low\n        when(colorSensor.red()).thenReturn(80);\n        when(colorSensor.green()).thenReturn(30);\n        when(colorSensor.blue()).thenReturn(20);\n        \n        assertFalse(\"Should not detect red ball when red value is too low\", robotController.isRedBallDetected());\n    }\n    \n    @Test\n    public void testGetMotorPowers() {\n        when(leftMotor.getPower()).thenReturn(0.7);\n        when(rightMotor.getPower()).thenReturn(0.3);\n        \n        assertEquals(\"Left motor power should match\", 0.7, robotController.getLeftMotorPower(), 0.001);\n        assertEquals(\"Right motor power should match\", 0.3, robotController.getRightMotorPower(), 0.001);\n    }\n}"
    },
    {
      "type": "text",
      "title": "Testing Autonomous Sequences",
      "content": "Autonomous sequences are complex and critical for competition success. Testing them thoroughly ensures they work reliably under various conditions."
    },
    {
      "type": "code",
      "title": "Autonomous Sequence Class",
      "content": "Create a testable autonomous sequence class:",
      "code": "// File: AutonomousSequence.java\npublic class AutonomousSequence {\n    private RobotController robotController;\n    private double startTime;\n    private boolean isComplete = false;\n    \n    public AutonomousSequence(RobotController robotController) {\n        this.robotController = robotController;\n    }\n    \n    public void start(double currentTime) {\n        this.startTime = currentTime;\n        this.isComplete = false;\n    }\n    \n    public void update(double currentTime) {\n        if (isComplete) return;\n        \n        double elapsedTime = currentTime - startTime;\n        \n        // Simple autonomous sequence: drive forward for 2 seconds, then stop\n        if (elapsedTime < 2.0) {\n            robotController.driveForward(0.5);\n        } else {\n            robotController.stop();\n            isComplete = true;\n        }\n    }\n    \n    public boolean isComplete() {\n        return isComplete;\n    }\n    \n    public double getElapsedTime(double currentTime) {\n        return currentTime - startTime;\n    }\n}"
    },
    {
      "type": "code",
      "title": "Testing Autonomous Sequence",
      "content": "Test the autonomous sequence with mocked robot controller:",
      "code": "// File: AutonomousSequenceTest.java\nimport org.junit.Before;\nimport org.junit.Test;\nimport org.junit.runner.RunWith;\nimport org.mockito.Mock;\nimport org.mockito.junit.MockitoJUnitRunner;\nimport static org.mockito.Mockito.*;\nimport static org.junit.Assert.*;\n\n@RunWith(MockitoJUnitRunner.class)\npublic class AutonomousSequenceTest {\n    \n    @Mock\n    private RobotController robotController;\n    \n    private AutonomousSequence autonomousSequence;\n    \n    @Before\n    public void setUp() {\n        autonomousSequence = new AutonomousSequence(robotController);\n    }\n    \n    @Test\n    public void testSequenceStart() {\n        autonomousSequence.start(0.0);\n        \n        assertFalse(\"Sequence should not be complete at start\", autonomousSequence.isComplete());\n        assertEquals(\"Elapsed time should be 0 at start\", 0.0, autonomousSequence.getElapsedTime(0.0), 0.001);\n    }\n    \n    @Test\n    public void testSequenceDrivingPhase() {\n        autonomousSequence.start(0.0);\n        \n        // Test during driving phase (first 2 seconds)\n        autonomousSequence.update(1.0);\n        \n        verify(robotController).driveForward(0.5);\n        assertFalse(\"Sequence should not be complete during driving phase\", autonomousSequence.isComplete());\n        \n        // Test at 1.5 seconds\n        autonomousSequence.update(1.5);\n        \n        verify(robotController, times(2)).driveForward(0.5);\n        assertFalse(\"Sequence should not be complete at 1.5 seconds\", autonomousSequence.isComplete());\n    }\n    \n    @Test\n    public void testSequenceCompletion() {\n        autonomousSequence.start(0.0);\n        \n        // Test at exactly 2.0 seconds\n        autonomousSequence.update(2.0);\n        \n        verify(robotController).driveForward(0.5);\n        verify(robotController).stop();\n        assertTrue(\"Sequence should be complete at 2.0 seconds\", autonomousSequence.isComplete());\n        \n        // Test that further updates don't change behavior\n        autonomousSequence.update(3.0);\n        \n        // Should not call driveForward again since sequence is complete\n        verify(robotController, times(1)).driveForward(0.5);\n        verify(robotController, times(1)).stop();\n    }\n    \n    @Test\n    public void testSequenceAfterCompletion() {\n        autonomousSequence.start(0.0);\n        \n        // Complete the sequence\n        autonomousSequence.update(2.0);\n        assertTrue(\"Sequence should be complete\", autonomousSequence.isComplete());\n        \n        // Try to update again\n        autonomousSequence.update(5.0);\n        \n        // Should not call any robot controller methods\n        verify(robotController, times(1)).driveForward(0.5);\n        verify(robotController, times(1)).stop();\n        verifyNoMoreInteractions(robotController);\n    }\n    \n    @Test\n    public void testElapsedTimeCalculation() {\n        autonomousSequence.start(10.0);\n        \n        assertEquals(\"Elapsed time calculation\", 0.0, autonomousSequence.getElapsedTime(10.0), 0.001);\n        assertEquals(\"Elapsed time calculation\", 1.5, autonomousSequence.getElapsedTime(11.5), 0.001);\n        assertEquals(\"Elapsed time calculation\", 3.0, autonomousSequence.getElapsedTime(13.0), 0.001);\n    }\n}"
    },
    {
      "type": "text",
      "title": "Integration Testing",
      "content": "Integration tests verify that multiple components work together correctly. These tests are more complex but catch issues that unit tests might miss."
    },
    {
      "type": "code",
      "title": "Integration Test Example",
      "content": "Create an integration test that tests multiple components working together:",
      "code": "// File: RobotIntegrationTest.java\nimport org.junit.Before;\nimport org.junit.Test;\nimport org.junit.runner.RunWith;\nimport org.mockito.Mock;\nimport org.mockito.junit.MockitoJUnitRunner;\nimport static org.mockito.Mockito.*;\nimport static org.junit.Assert.*;\n\n@RunWith(MockitoJUnitRunner.class)\npublic class RobotIntegrationTest {\n    \n    @Mock\n    private DcMotor leftMotor;\n    \n    @Mock\n    private DcMotor rightMotor;\n    \n    @Mock\n    private ColorSensor colorSensor;\n    \n    private RobotController robotController;\n    private AutonomousSequence autonomousSequence;\n    \n    @Before\n    public void setUp() {\n        robotController = new RobotController(leftMotor, rightMotor, colorSensor);\n        autonomousSequence = new AutonomousSequence(robotController);\n    }\n    \n    @Test\n    public void testCompleteAutonomousSequence() {\n        // Set up color sensor to detect red ball\n        when(colorSensor.red()).thenReturn(200);\n        when(colorSensor.green()).thenReturn(50);\n        when(colorSensor.blue()).thenReturn(30);\n        \n        // Start autonomous sequence\n        autonomousSequence.start(0.0);\n        \n        // Simulate sequence execution\n        for (double time = 0.1; time <= 2.5; time += 0.1) {\n            autonomousSequence.update(time);\n        }\n        \n        // Verify the complete sequence executed correctly\n        assertTrue(\"Autonomous sequence should be complete\", autonomousSequence.isComplete());\n        \n        // Verify motor interactions\n        verify(leftMotor, atLeastOnce()).setPower(0.5);\n        verify(rightMotor, atLeastOnce()).setPower(0.5);\n        verify(leftMotor, atLeastOnce()).setPower(0.0);\n        verify(rightMotor, atLeastOnce()).setPower(0.0);\n        \n        // Verify color sensor was used\n        verify(colorSensor, atLeastOnce()).red();\n        verify(colorSensor, atLeastOnce()).green();\n        verify(colorSensor, atLeastOnce()).blue();\n    }\n    \n    @Test\n    public void testRobotControllerWithRealCalculations() {\n        // Test that utility functions work with robot controller\n        double distance = 24.0; // 24 inches\n        int ticksPerRev = 1440;\n        double wheelDiameter = 4.0;\n        \n        // Calculate expected ticks\n        int expectedTicks = RobotUtils.inchesToTicks(distance, ticksPerRev, wheelDiameter);\n        \n        // Verify calculation is reasonable\n        assertTrue(\"Ticks should be positive\", expectedTicks > 0);\n        assertTrue(\"Ticks should be reasonable for 24 inches\", expectedTicks < 10000);\n        \n        // Test power calculation\n        double time = 3.0; // 3 seconds\n        double maxPower = 1.0;\n        double calculatedPower = RobotUtils.calculatePowerForDistance(distance, time, maxPower);\n        \n        assertTrue(\"Power should be positive\", calculatedPower > 0);\n        assertTrue(\"Power should not exceed maxPower\", calculatedPower <= maxPower);\n        \n        // Use calculated power with robot controller\n        robotController.driveForward(calculatedPower);\n        \n        verify(leftMotor).setPower(calculatedPower);\n        verify(rightMotor).setPower(calculatedPower);\n    }\n}"
    },
    {
      "type": "text",
      "title": "Test Organization and Best Practices",
      "content": "Organizing your tests properly and following best practices makes them more maintainable and effective."
    },
    {
      "type": "rules-box",
      "title": "Unit Testing Best Practices",
      "items": [
        "Test one thing at a time - each test should verify one specific behavior",
        "Use descriptive test names that explain what is being tested",
        "Follow the Arrange-Act-Assert pattern: set up, execute, verify",
        "Test both normal cases and edge cases (boundary conditions)",
        "Test error conditions and exception handling",
        "Keep tests independent - they should not depend on each other",
        "Use meaningful test data that represents real scenarios"
      ]
    },
    {
      "type": "code",
      "title": "Test Organization Example",
      "content": "Organize your tests with clear structure and naming:",
      "code": "// File: ComprehensiveRobotTest.java\nimport org.junit.Before;\nimport org.junit.Test;\nimport org.junit.runner.RunWith;\nimport org.mockito.Mock;\nimport org.mockito.junit.MockitoJUnitRunner;\nimport static org.mockito.Mockito.*;\nimport static org.junit.Assert.*;\n\n@RunWith(MockitoJUnitRunner.class)\npublic class ComprehensiveRobotTest {\n    \n    @Mock\n    private DcMotor leftMotor, rightMotor;\n    \n    @Mock\n    private ColorSensor colorSensor;\n    \n    private RobotController robotController;\n    \n    @Before\n    public void setUp() {\n        robotController = new RobotController(leftMotor, rightMotor, colorSensor);\n    }\n    \n    // Group related tests together with descriptive names\n    \n    @Test\n    public void driveForward_WithPositivePower_ShouldSetBothMotorsToSamePower() {\n        // Arrange\n        double power = 0.7;\n        \n        // Act\n        robotController.driveForward(power);\n        \n        // Assert\n        verify(leftMotor).setPower(power);\n        verify(rightMotor).setPower(power);\n    }\n    \n    @Test\n    public void driveForward_WithNegativePower_ShouldDriveBackward() {\n        // Arrange\n        double power = -0.5;\n        \n        // Act\n        robotController.driveForward(power);\n        \n        // Assert\n        verify(leftMotor).setPower(power);\n        verify(rightMotor).setPower(power);\n    }\n    \n    @Test(expected = IllegalArgumentException.class)\n    public void driveForward_WithPowerGreaterThanOne_ShouldThrowException() {\n        // Arrange\n        double invalidPower = 1.5;\n        \n        // Act & Assert\n        robotController.driveForward(invalidPower);\n    }\n    \n    @Test(expected = IllegalArgumentException.class)\n    public void driveForward_WithPowerLessThanNegativeOne_ShouldThrowException() {\n        // Arrange\n        double invalidPower = -1.2;\n        \n        // Act & Assert\n        robotController.driveForward(invalidPower);\n    }\n    \n    @Test\n    public void turn_WithDifferentLeftAndRightPowers_ShouldSetMotorsCorrectly() {\n        // Arrange\n        double leftPower = -0.3;\n        double rightPower = 0.3;\n        \n        // Act\n        robotController.turn(leftPower, rightPower);\n        \n        // Assert\n        verify(leftMotor).setPower(leftPower);\n        verify(rightMotor).setPower(rightPower);\n    }\n    \n    @Test\n    public void isRedBallDetected_WithRedDominantColors_ShouldReturnTrue() {\n        // Arrange\n        when(colorSensor.red()).thenReturn(200);\n        when(colorSensor.green()).thenReturn(50);\n        when(colorSensor.blue()).thenReturn(30);\n        \n        // Act\n        boolean result = robotController.isRedBallDetected();\n        \n        // Assert\n        assertTrue(\"Should detect red ball when red is dominant\", result);\n    }\n    \n    @Test\n    public void isRedBallDetected_WithBlueDominantColors_ShouldReturnFalse() {\n        // Arrange\n        when(colorSensor.red()).thenReturn(50);\n        when(colorSensor.green()).thenReturn(60);\n        when(colorSensor.blue()).thenReturn(200);\n        \n        // Act\n        boolean result = robotController.isRedBallDetected();\n        \n        // Assert\n        assertFalse(\"Should not detect red ball when blue is dominant\", result);\n    }\n    \n    @Test\n    public void stop_ShouldSetBothMotorsToZero() {\n        // Arrange - no setup needed\n        \n        // Act\n        robotController.stop();\n        \n        // Assert\n        verify(leftMotor).setPower(0.0);\n        verify(rightMotor).setPower(0.0);\n    }\n}"
    },
    {
      "type": "exercise-box",
      "title": "Unit Testing Practice Exercise",
      "description": "Create comprehensive unit tests for a PID controller class that you might use in your FTC robot.",
      "tasks": [
        "Create a PIDController class with setpoint, kP, kI, kD parameters",
        "Implement calculate() method that returns the control output",
        "Add methods to update setpoint and tune parameters",
        "Write unit tests for normal operation with various inputs",
        "Test edge cases like zero setpoint, negative gains, and reset functionality",
        "Create integration tests with mocked motor and encoder",
        "Test error conditions and parameter validation"
      ],
      "code": "// Starter code for the exercise:\npublic class PIDController {\n    private double setpoint;\n    private double kP, kI, kD;\n    private double integral = 0.0;\n    private double previousError = 0.0;\n    private boolean firstRun = true;\n    \n    public PIDController(double kP, double kI, double kD) {\n        this.kP = kP;\n        this.kI = kI;\n        this.kD = kD;\n    }\n    \n    public double calculate(double currentValue) {\n        // TODO: Implement PID calculation\n        return 0.0;\n    }\n    \n    public void setSetpoint(double setpoint) {\n        this.setpoint = setpoint;\n    }\n    \n    public void reset() {\n        integral = 0.0;\n        previousError = 0.0;\n        firstRun = true;\n    }\n    \n    // TODO: Add getter methods for testing\n}"
    },
    {
      "type": "link-grid",
      "title": "Additional Resources",
      "links": [
        "<a href=\"https://developer.android.com/studio/test\" target=\"_blank\">Android Studio Testing Guide</a>",
        "<a href=\"https://junit.org/junit4/\" target=\"_blank\">JUnit 4 Documentation</a>",
        "<a href=\"https://site.mockito.org/\" target=\"_blank\">Mockito Documentation</a>",
        "<a href=\"https://developer.android.com/training/testing/junit-rules\" target=\"_blank\">Android Testing Rules</a>",
        "<a href=\"https://gm0.org/en/latest/docs/software/tutorials/android-studio.html\" target=\"_blank\">gm0: Android Studio Setup</a>"
      ]
    }
  ]
} 