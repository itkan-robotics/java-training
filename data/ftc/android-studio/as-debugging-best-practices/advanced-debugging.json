{
  "title": "Advanced Debugging Techniques",
  "sections": [
    {
      "type": "text",
      "title": "Introduction to Advanced Debugging",
      "content": "Advanced debugging in Android Studio is essential for FTC development. When your robot doesn't behave as expected, you need powerful tools to identify and fix issues quickly. This lesson covers professional debugging techniques that will help you troubleshoot complex robot behaviors efficiently."
    },
    {
      "type": "rules-box",
      "title": "Why Advanced Debugging Matters",
      "items": [
        "FTC robots operate in real-time environments where issues must be resolved quickly",
        "Complex autonomous programs require systematic debugging approaches",
        "Hardware-software interactions can create difficult-to-reproduce bugs",
        "Competition environments demand reliable debugging skills"
      ]
    },
    {
      "type": "text",
      "title": "Android Studio Debugger Setup for FTC",
      "content": "Setting up the Android Studio debugger for FTC projects requires a specific configuration to work with the Control Hub and Expansion Hub. The debugger allows you to pause execution, inspect variables, and step through code line by line."
    },
    {
      "type": "code",
      "title": "Basic Debug Logging Setup",
      "content": "Start with basic debug logging to track program execution. The TAG constant helps organize log messages:",
      "code": "// Add this at the top of your OpMode class\nprivate static final String TAG = \"MyDebugOpMode\";\n\n// This TAG will be used in all log statements to identify your OpMode's logs"
    },
    {
      "type": "text",
      "title": "Understanding the TAG Constant",
      "content": "<p>The <code>TAG</code> constant is a string identifier that appears in all log messages from this OpMode. It helps you filter and organize logs when debugging. Choose a descriptive name that clearly identifies your OpMode.</p>"
    },
    {
      "type": "code",
      "title": "Adding Debug Logging to Init Method",
      "content": "Add debug logging to track the initialization process:",
      "code": "@Override\npublic void init() {\n    // Log the start of initialization\n    Log.d(TAG, \"Initializing OpMode\");\n    \n    // Your initialization code goes here\n    \n    // Log successful completion\n    Log.d(TAG, \"Initialization complete\");\n}"
    },
    {
      "type": "text",
      "title": "Understanding Log Levels",
      "content": "<p>Android provides different log levels for different types of messages:</p><ul><li><code>Log.d()</code> - Debug messages for development</li><li><code>Log.i()</code> - Information messages for general status</li><li><code>Log.w()</code> - Warning messages for potential issues</li><li><code>Log.e()</code> - Error messages for actual problems</li></ul>"
    },
    {
      "type": "code",
      "title": "Error Handling with Logging",
      "content": "Add error handling to catch and log initialization problems:",
      "code": "@Override\npublic void init() {\n    Log.d(TAG, \"Initializing OpMode\");\n    \n    try {\n        // Your initialization code here\n        initializeHardware();\n        Log.d(TAG, \"Hardware initialized successfully\");\n    } catch (Exception e) {\n        // Log the error with full details\n        Log.e(TAG, \"Hardware initialization failed\", e);\n        \n        // Also show error on telemetry for driver station\n        telemetry.addData(\"Error\", \"Hardware init failed: \" + e.getMessage());\n    }\n}"
    },
    {
      "type": "text",
      "title": "Understanding Try-Catch for Debugging",
      "content": "<p>The <code>try-catch</code> block allows you to catch exceptions and handle them gracefully. The <code>Log.e()</code> call includes the exception object, which provides the full stack trace for debugging.</p>"
    },
    {
      "type": "code",
      "title": "Complete Debug OpMode Example",
      "content": "Here's the complete OpMode with all debugging elements combined:",
      "code": "import com.qualcomm.robotcore.eventloop.opmode.OpMode;\nimport com.qualcomm.robotcore.eventloop.opmode.TeleOp;\nimport com.qualcomm.robotcore.hardware.DcMotor;\nimport com.qualcomm.robotcore.hardware.Servo;\nimport android.util.Log;\n\n@TeleOp(name = \"Debug Example\")\npublic class MyDebugOpMode extends OpMode {\n    private static final String TAG = \"MyDebugOpMode\";\n    \n    private DcMotor leftMotor, rightMotor;\n    private Servo armServo;\n    \n    @Override\n    public void init() {\n        // Enable debug logging\n        Log.d(TAG, \"Initializing OpMode\");\n        \n        // Initialize hardware with debug info\n        try {\n            initializeHardware();\n            Log.d(TAG, \"Hardware initialized successfully\");\n        } catch (Exception e) {\n            Log.e(TAG, \"Hardware initialization failed\", e);\n            telemetry.addData(\"Error\", \"Hardware init failed: \" + e.getMessage());\n        }\n    }\n    \n    private void initializeHardware() {\n        // Initialize motors\n        leftMotor = hardwareMap.get(DcMotor.class, \"left_motor\");\n        rightMotor = hardwareMap.get(DcMotor.class, \"right_motor\");\n        \n        // Initialize servo\n        armServo = hardwareMap.get(Servo.class, \"arm_servo\");\n        \n        // Log hardware details\n        Log.d(TAG, \"Motors initialized: \" + leftMotor.getDeviceName() + \", \" + rightMotor.getDeviceName());\n        Log.d(TAG, \"Servo initialized: \" + armServo.getDeviceName());\n    }\n    \n    @Override\n    public void loop() {\n        // Your robot control code here\n        // Add breakpoints in this method to debug robot behavior\n    }\n}"
    },
    {
      "type": "text",
      "title": "Setting Up Debug Logging",
      "content": "Debug logging is the foundation of advanced debugging. By adding strategic log statements throughout your code, you can track program execution and identify where issues occur. The TAG constant helps organize log messages, and different log levels (d for debug, e for error) provide appropriate detail."
    },
    {
      "type": "text",
      "title": "Setting Breakpoints",
      "content": "Breakpoints are the foundation of debugging. They allow you to pause execution at specific points in your code to inspect the program state. In Android Studio, you can set breakpoints by clicking in the gutter next to line numbers."
    },
    {
      "type": "rules-box",
      "title": "Breakpoint Best Practices",
      "items": [
        "Set breakpoints at the beginning of methods you suspect have issues",
        "Use breakpoints to inspect variable values before and after critical operations",
        "Place breakpoints before conditional statements to verify logic flow",
        "Remove or disable breakpoints when not actively debugging to improve performance"
      ]
    },
    {
      "type": "text",
      "title": "Conditional Breakpoints and Watch Expressions",
      "content": "Conditional breakpoints are powerful tools for debugging complex robot behaviors. They only pause execution when specific conditions are met, making it easier to debug rare or specific scenarios."
    },
    {
      "type": "code",
      "title": "State Machine Setup",
      "content": "First, set up the basic state machine structure with an enum to define possible states:",
      "code": "public class StateMachineOpMode extends OpMode {\n    // Define possible robot states\n    enum RobotState {\n        IDLE,      // Robot is waiting\n        MOVING,    // Robot is in motion\n        COMPLETE   // Robot has finished its task\n    }\n    \n    // Track current state and loop count\n    private RobotState currentState = RobotState.IDLE;\n    private int loopCount = 0;\n}"
    },
    {
      "type": "text",
      "title": "Understanding State Machines",
      "content": "<p>A state machine is a programming pattern where your robot can be in one of several defined states at any time. Each state represents a different behavior or phase of operation. The robot transitions between states based on conditions or events.</p>"
    },
    {
      "type": "code",
      "title": "Adding the Main Loop with State Logic",
      "content": "Add the main loop method that handles state transitions:",
      "code": "@Override\npublic void loop() {\n    // This is where you'll set conditional breakpoints\n    switch (currentState) {\n        case IDLE:\n            handleIdleState();\n            break;\n            \n        case MOVING:\n            handleMovingState();\n            break;\n            \n        case COMPLETE:\n            handleCompleteState();\n            break;\n    }\n    \n    // Update loop counter and telemetry\n    loopCount++;\n    telemetry.addData(\"State\", currentState);\n    telemetry.addData(\"Loop Count\", loopCount);\n}"
    },
    {
      "type": "text",
      "title": "Understanding the Switch Statement",
      "content": "<p>The <code>switch</code> statement checks the current state and calls the appropriate handler method. This makes the code more organized and easier to debug. Each case represents a different state of the robot.</p>"
    },
    {
      "type": "code",
      "title": "Implementing State Handler Methods",
      "content": "Create separate methods to handle each state's logic:",
      "code": "private void handleIdleState() {\n    // Set conditional breakpoint here with condition: loopCount > 100\n    if (loopCount > 100) {\n        currentState = RobotState.MOVING;\n        Log.d(\"StateMachine\", \"Transitioning to MOVING state\");\n    }\n}\n\nprivate void handleMovingState() {\n    // Set conditional breakpoint here with condition: getRuntime() > 5.0\n    if (getRuntime() > 5.0) {\n        currentState = RobotState.COMPLETE;\n        Log.d(\"StateMachine\", \"Movement complete\");\n    }\n}\n\nprivate void handleCompleteState() {\n    // Set breakpoint with condition: true (always break)\n    Log.d(\"StateMachine\", \"OpMode complete\");\n    requestOpModeStop();\n}"
    },
    {
      "type": "text",
      "title": "Understanding Conditional Breakpoints",
      "content": "<p>Conditional breakpoints only pause execution when a specific condition is true. This is useful for debugging rare events or specific scenarios without stopping on every loop iteration.</p><ul><li><code>loopCount > 100</code> - Only breaks when the robot has been idle for 100 loops</li><li><code>getRuntime() > 5.0</code> - Only breaks when the robot has been moving for 5 seconds</li><li><code>true</code> - Always breaks (useful for debugging the complete state)</li></ul>"
    },
    {
      "type": "code",
      "title": "Complete State Machine Example",
      "content": "Here's the complete state machine OpMode with all debugging elements:",
      "code": "import com.qualcomm.robotcore.eventloop.opmode.OpMode;\nimport com.qualcomm.robotcore.eventloop.opmode.TeleOp;\nimport com.qualcomm.robotcore.hardware.DcMotor;\nimport android.util.Log;\n\n@TeleOp(name = \"State Machine Debug\")\npublic class StateMachineOpMode extends OpMode {\n    // Define possible robot states\n    enum RobotState {\n        IDLE,      // Robot is waiting\n        MOVING,    // Robot is in motion\n        COMPLETE   // Robot has finished its task\n    }\n    \n    // Track current state and loop count\n    private RobotState currentState = RobotState.IDLE;\n    private int loopCount = 0;\n    private DcMotor driveMotor;\n    \n    @Override\n    public void init() {\n        driveMotor = hardwareMap.get(DcMotor.class, \"drive_motor\");\n        Log.d(\"StateMachine\", \"Initialized in IDLE state\");\n    }\n    \n    @Override\n    public void loop() {\n        // Set conditional breakpoints in each case\n        switch (currentState) {\n            case IDLE:\n                handleIdleState();\n                break;\n                \n            case MOVING:\n                handleMovingState();\n                break;\n                \n            case COMPLETE:\n                handleCompleteState();\n                break;\n        }\n        \n        // Update loop counter and telemetry\n        loopCount++;\n        telemetry.addData(\"State\", currentState);\n        telemetry.addData(\"Loop Count\", loopCount);\n        telemetry.addData(\"Runtime\", \"%.2f\", getRuntime());\n    }\n    \n    private void handleIdleState() {\n        // Set conditional breakpoint here with condition: loopCount > 100\n        if (loopCount > 100) {\n            currentState = RobotState.MOVING;\n            Log.d(\"StateMachine\", \"Transitioning to MOVING state\");\n            driveMotor.setPower(0.5); // Start moving\n        }\n    }\n    \n    private void handleMovingState() {\n        // Set conditional breakpoint here with condition: getRuntime() > 5.0\n        if (getRuntime() > 5.0) {\n            currentState = RobotState.COMPLETE;\n            Log.d(\"StateMachine\", \"Movement complete\");\n            driveMotor.setPower(0); // Stop moving\n        }\n    }\n    \n    private void handleCompleteState() {\n        // Set breakpoint with condition: true (always break)\n        Log.d(\"StateMachine\", \"OpMode complete\");\n        requestOpModeStop();\n    }\n}"
    },
    {
      "type": "text",
      "title": "Watch Expressions",
      "content": "Watch expressions allow you to monitor specific variables or expressions without setting breakpoints. They're displayed in the debug window and update in real-time as your program runs."
    },
    {
      "type": "code",
      "title": "Setting Up Variables for Watching",
      "content": "First, declare the variables you want to monitor during debugging:",
      "code": "public class WatchExpressionsExample extends OpMode {\n    // Hardware components\n    private DcMotor leftMotor, rightMotor;\n    \n    // Variables to watch during debugging\n    private double targetPower = 0.5;    // Maximum power limit\n    private double currentPower = 0.0;   // Current motor power\n    private boolean isMoving = false;    // Movement state\n    \n    // These variables will be monitored in the debugger"
    },
    {
      "type": "text",
      "title": "Understanding Watch Expressions",
      "content": "<p>Watch expressions allow you to monitor specific variables or expressions in real-time during debugging. They appear in the debug window and update as your program runs, making it easy to track how values change over time.</p>"
    },
    {
      "type": "code",
      "title": "Initializing Hardware Components",
      "content": "Set up the hardware components that you'll want to monitor:",
      "code": "@Override\npublic void init() {\n    // Initialize motors\n    leftMotor = hardwareMap.get(DcMotor.class, \"left_motor\");\n    rightMotor = hardwareMap.get(DcMotor.class, \"right_motor\");\n    \n    // Set up watch expressions for these variables:\n    // - targetPower (double)\n    // - currentPower (double)\n    // - isMoving (boolean)\n    // - leftMotor.getPower() (method call)\n    // - rightMotor.getPower() (method call)\n    // - getRuntime() (method call)\n}"
    },
    {
      "type": "text",
      "title": "Understanding Method Calls in Watch Expressions",
      "content": "<p>You can watch method calls like <code>leftMotor.getPower()</code> to see the actual power being sent to the motor. This is useful for verifying that your commands are being executed correctly.</p>"
    },
    {
      "type": "code",
      "title": "Implementing Gamepad Control Logic",
      "content": "Add the control logic that changes the variables you're watching:",
      "code": "@Override\npublic void loop() {\n    // Check if the left stick is being used\n    if (gamepad1.left_stick_y > 0.1) {\n        // Calculate power based on stick position\n        currentPower = gamepad1.left_stick_y * targetPower;\n        isMoving = true;\n    } else {\n        // Stop the robot\n        currentPower = 0.0;\n        isMoving = false;\n    }\n    \n    // Apply power to motors\n    leftMotor.setPower(currentPower);\n    rightMotor.setPower(currentPower);\n}"
    },
    {
      "type": "text",
      "title": "Understanding the Control Logic",
      "content": "<p>The control logic checks if the left stick Y-axis is pressed beyond a small threshold (0.1) to avoid accidental movement. When pressed, it calculates the power as a percentage of the target power. When released, it stops the robot.</p>"
    },
    {
      "type": "code",
      "title": "Adding Telemetry for Debugging",
      "content": "Add telemetry to display the watched variables on the driver station:",
      "code": "// Add this to the end of the loop() method\n// Add telemetry for debugging\ntelemetry.addData(\"Target Power\", targetPower);\ntelemetry.addData(\"Current Power\", currentPower);\ntelemetry.addData(\"Is Moving\", isMoving);\ntelemetry.addData(\"Left Motor Power\", leftMotor.getPower());\ntelemetry.addData(\"Right Motor Power\", rightMotor.getPower());\ntelemetry.addData(\"Runtime\", \"%.2f\", getRuntime());"
    },
    {
      "type": "text",
      "title": "Understanding Telemetry vs Watch Expressions",
      "content": "<p>Telemetry displays information on the driver station screen, while watch expressions are only visible in the debugger. Use telemetry for information the driver needs, and watch expressions for detailed debugging information.</p>"
    },
    {
      "type": "code",
      "title": "Complete Watch Expressions Example",
      "content": "Here's the complete OpMode with all watch expression variables:",
      "code": "import com.qualcomm.robotcore.eventloop.opmode.OpMode;\nimport com.qualcomm.robotcore.eventloop.opmode.TeleOp;\nimport com.qualcomm.robotcore.hardware.DcMotor;\n\n@TeleOp(name = \"Watch Expressions Example\")\npublic class WatchExpressionsExample extends OpMode {\n    // Hardware components\n    private DcMotor leftMotor, rightMotor;\n    \n    // Variables to watch during debugging\n    private double targetPower = 0.5;    // Maximum power limit\n    private double currentPower = 0.0;   // Current motor power\n    private boolean isMoving = false;    // Movement state\n    \n    @Override\n    public void init() {\n        // Initialize motors\n        leftMotor = hardwareMap.get(DcMotor.class, \"left_motor\");\n        rightMotor = hardwareMap.get(DcMotor.class, \"right_motor\");\n        \n        // Set up watch expressions for these variables:\n        // - targetPower\n        // - currentPower\n        // - isMoving\n        // - leftMotor.getPower()\n        // - rightMotor.getPower()\n        // - getRuntime()\n    }\n    \n    @Override\n    public void loop() {\n        // Watch how these values change during execution\n        if (gamepad1.left_stick_y > 0.1) {\n            currentPower = gamepad1.left_stick_y * targetPower;\n            isMoving = true;\n        } else {\n            currentPower = 0.0;\n            isMoving = false;\n        }\n        \n        // Apply power to motors\n        leftMotor.setPower(currentPower);\n        rightMotor.setPower(currentPower);\n        \n        // Add telemetry for debugging\n        telemetry.addData(\"Target Power\", targetPower);\n        telemetry.addData(\"Current Power\", currentPower);\n        telemetry.addData(\"Is Moving\", isMoving);\n        telemetry.addData(\"Left Motor Power\", leftMotor.getPower());\n        telemetry.addData(\"Right Motor Power\", rightMotor.getPower());\n        telemetry.addData(\"Runtime\", \"%.2f\", getRuntime());\n    }\n}"
    },
    {
      "type": "text",
      "title": "Logging Strategies for Robot State",
      "content": "Effective logging is crucial for debugging robot behavior. You need to log enough information to understand what's happening without overwhelming the system or making logs unreadable."
    },
    {
      "type": "code",
      "title": "Setting Up Logging Configuration",
      "content": "First, define the logging configuration constants that control what gets logged:",
      "code": "public class StructuredLoggingOpMode extends OpMode {\n    private static final String TAG = \"RobotDebug\";\n    private static final boolean DEBUG_MODE = true;      // Enable debug logging\n    private static final boolean VERBOSE_LOGGING = false; // Enable verbose logging\n    \n    // Hardware components\n    private DcMotor driveMotor;\n    private Servo armServo;\n    private ColorSensor colorSensor;\n}"
    },
    {
      "type": "text",
      "title": "Understanding Logging Configuration",
      "content": "<p>The boolean constants control which logging levels are active. You can change these values to enable or disable different levels of logging without modifying the code. This is useful for performance tuning and debugging different scenarios.</p>"
    },
    {
      "type": "code",
      "title": "Creating Custom Logging Methods",
      "content": "Create helper methods for different logging levels:",
      "code": "// Logging methods with different levels\nprivate void logInfo(String message) {\n    Log.i(TAG, message);\n    telemetry.addData(\"INFO\", message);\n}\n\nprivate void logDebug(String message) {\n    if (DEBUG_MODE) {\n        Log.d(TAG, message);\n        telemetry.addData(\"DEBUG\", message);\n    }\n}\n\nprivate void logVerbose(String message) {\n    if (VERBOSE_LOGGING) {\n        Log.v(TAG, message);\n    }\n}\n\nprivate void logError(String message, Exception e) {\n    Log.e(TAG, message, e);\n    telemetry.addData(\"ERROR\", message + \": \" + e.getMessage());\n}"
    },
    {
      "type": "text",
      "title": "Understanding Logging Levels",
      "content": "<p>Each logging method serves a different purpose:</p><ul><li><code>logInfo()</code> - Always logs important information to both logcat and telemetry</li><li><code>logDebug()</code> - Only logs when DEBUG_MODE is true, useful for development</li><li><code>logVerbose()</code> - Only logs when VERBOSE_LOGGING is true, for detailed debugging</li><li><code>logError()</code> - Always logs errors with full exception details</li></ul>"
    },
    {
      "type": "code",
      "title": "Initializing Hardware with Logging",
      "content": "Add logging to the initialization process:",
      "code": "@Override\npublic void init() {\n    // Initialize hardware\n    driveMotor = hardwareMap.get(DcMotor.class, \"drive_motor\");\n    armServo = hardwareMap.get(Servo.class, \"arm_servo\");\n    colorSensor = hardwareMap.get(ColorSensor.class, \"color_sensor\");\n    \n    // Log successful initialization\n    logInfo(\"Hardware initialized successfully\");\n    \n    // Log detailed hardware information (debug level)\n    logDebug(\"Drive motor: \" + driveMotor.getDeviceName());\n    logDebug(\"Arm servo: \" + armServo.getDeviceName());\n    logDebug(\"Color sensor: \" + colorSensor.getDeviceName());\n}"
    },
    {
      "type": "text",
      "title": "Understanding Hardware Logging",
      "content": "<p>The initialization logs help you verify that all hardware components are properly connected and accessible. The debug-level logs provide detailed information about each device, which is useful for troubleshooting hardware issues.</p>"
    },
    {
      "type": "code",
      "title": "Adding Event-Based Logging",
      "content": "Add logging for important events in the main loop:",
      "code": "@Override\npublic void loop() {\n    // Log state changes (important events)\n    if (gamepad1.a) {\n        logInfo(\"Button A pressed - starting autonomous sequence\");\n        startAutonomousSequence();\n    }\n    \n    // Log sensor readings periodically (debug information)\n    if (getRuntime() % 2.0 < 0.1) { // Every 2 seconds\n        logDebug(\"Color sensor reading: R=\" + colorSensor.red() + \", G=\" + colorSensor.green() + \", B=\" + colorSensor.blue());\n    }\n    \n    // Log motor behavior (verbose information)\n    double motorPower = gamepad1.left_stick_y;\n    if (Math.abs(motorPower) > 0.1) {\n        logVerbose(\"Setting motor power to: \" + motorPower);\n        driveMotor.setPower(motorPower);\n    }\n}"
    },
    {
      "type": "text",
      "title": "Understanding Event-Based Logging",
      "content": "<p>Different types of events are logged at different levels:</p><ul><li><strong>Info level</strong> - Important user actions (button presses, mode changes)</li><li><strong>Debug level</strong> - Periodic sensor readings and system status</li><li><strong>Verbose level</strong> - Frequent motor commands and detailed behavior</li></ul>"
    },
    {
      "type": "code",
      "title": "Creating Sequence Logging",
      "content": "Add logging to track multi-step sequences:",
      "code": "private void startAutonomousSequence() {\n    logInfo(\"Starting autonomous sequence\");\n    \n    // Log each step of the sequence\n    logDebug(\"Step 1: Moving arm to position\");\n    armServo.setPosition(0.5);\n    \n    logDebug(\"Step 2: Driving forward\");\n    driveMotor.setPower(0.5);\n    \n    logInfo(\"Autonomous sequence started\");\n}"
    },
    {
      "type": "text",
      "title": "Understanding Sequence Logging",
      "content": "<p>Sequence logging helps you track the progress of complex operations. Each step is logged at the debug level, while the start and completion are logged at the info level. This makes it easy to see where a sequence might be failing or taking too long.</p>"
    },
    {
      "type": "code",
      "title": "Complete Structured Logging Example",
      "content": "Here's the complete OpMode with all structured logging elements:",
      "code": "import com.qualcomm.robotcore.eventloop.opmode.OpMode;\nimport com.qualcomm.robotcore.eventloop.opmode.TeleOp;\nimport com.qualcomm.robotcore.hardware.DcMotor;\nimport com.qualcomm.robotcore.hardware.Servo;\nimport com.qualcomm.robotcore.hardware.ColorSensor;\nimport android.util.Log;\n\n@TeleOp(name = \"Structured Logging Example\")\npublic class StructuredLoggingOpMode extends OpMode {\n    private static final String TAG = \"RobotDebug\";\n    private static final boolean DEBUG_MODE = true;      // Enable debug logging\n    private static final boolean VERBOSE_LOGGING = false; // Enable verbose logging\n    \n    // Hardware components\n    private DcMotor driveMotor;\n    private Servo armServo;\n    private ColorSensor colorSensor;\n    \n    @Override\n    public void init() {\n        // Initialize hardware\n        driveMotor = hardwareMap.get(DcMotor.class, \"drive_motor\");\n        armServo = hardwareMap.get(Servo.class, \"arm_servo\");\n        colorSensor = hardwareMap.get(ColorSensor.class, \"color_sensor\");\n        \n        // Log successful initialization\n        logInfo(\"Hardware initialized successfully\");\n        \n        // Log detailed hardware information (debug level)\n        logDebug(\"Drive motor: \" + driveMotor.getDeviceName());\n        logDebug(\"Arm servo: \" + armServo.getDeviceName());\n        logDebug(\"Color sensor: \" + colorSensor.getDeviceName());\n    }\n    \n    @Override\n    public void loop() {\n        // Log state changes (important events)\n        if (gamepad1.a) {\n            logInfo(\"Button A pressed - starting autonomous sequence\");\n            startAutonomousSequence();\n        }\n        \n        // Log sensor readings periodically (debug information)\n        if (getRuntime() % 2.0 < 0.1) { // Every 2 seconds\n            logDebug(\"Color sensor reading: R=\" + colorSensor.red() + \", G=\" + colorSensor.green() + \", B=\" + colorSensor.blue());\n        }\n        \n        // Log motor behavior (verbose information)\n        double motorPower = gamepad1.left_stick_y;\n        if (Math.abs(motorPower) > 0.1) {\n            logVerbose(\"Setting motor power to: \" + motorPower);\n            driveMotor.setPower(motorPower);\n        }\n    }\n    \n    private void startAutonomousSequence() {\n        logInfo(\"Starting autonomous sequence\");\n        \n        // Log each step of the sequence\n        logDebug(\"Step 1: Moving arm to position\");\n        armServo.setPosition(0.5);\n        \n        logDebug(\"Step 2: Driving forward\");\n        driveMotor.setPower(0.5);\n        \n        logInfo(\"Autonomous sequence started\");\n    }\n    \n    // Logging methods with different levels\n    private void logInfo(String message) {\n        Log.i(TAG, message);\n        telemetry.addData(\"INFO\", message);\n    }\n    \n    private void logDebug(String message) {\n        if (DEBUG_MODE) {\n            Log.d(TAG, message);\n            telemetry.addData(\"DEBUG\", message);\n        }\n    }\n    \n    private void logVerbose(String message) {\n        if (VERBOSE_LOGGING) {\n            Log.v(TAG, message);\n        }\n    }\n    \n    private void logError(String message, Exception e) {\n        Log.e(TAG, message, e);\n        telemetry.addData(\"ERROR\", message + \": \" + e.getMessage());\n    }\n}"
    },
    {
      "type": "text",
      "title": "Remote Debugging on Control Hub",
      "content": "Remote debugging allows you to debug code running on the actual Control Hub hardware. This is essential for debugging issues that only occur on the real robot."
    },
    {
      "type": "code",
      "title": "ADB Connection Setup",
      "content": "To set up remote debugging, you need to establish an ADB (Android Debug Bridge) connection to the Control Hub. Here's the process:",
      "code": "// First, ensure your Control Hub is connected to the same network\n// Then use ADB to connect to the Control Hub\n\n// In terminal/command prompt:\n// adb connect 192.168.43.1:5555\n// (Replace with your Control Hub's IP address)\n\n// Verify connection:\n// adb devices\n\n// In your OpMode, add remote debugging support:\npublic class RemoteDebugOpMode extends OpMode {\n    private static final String TAG = \"RemoteDebug\";\n    private boolean remoteDebugEnabled = false;\n    \n    @Override\n    public void init() {\n        // Check if remote debugging is available\n        try {\n            // This will only work if ADB is connected\n            Log.d(TAG, \"Remote debugging available\");\n            remoteDebugEnabled = true;\n        } catch (Exception e) {\n            Log.w(TAG, \"Remote debugging not available: \" + e.getMessage());\n            remoteDebugEnabled = false;\n        }\n        \n        // Initialize hardware with remote debugging support\n        initializeHardwareWithDebugging();\n    }\n    \n    private void initializeHardwareWithDebugging() {\n        try {\n            // Initialize motors\n            DcMotor leftMotor = hardwareMap.get(DcMotor.class, \"left_motor\");\n            DcMotor rightMotor = hardwareMap.get(DcMotor.class, \"right_motor\");\n            \n            if (remoteDebugEnabled) {\n                Log.d(TAG, \"Motors initialized: \" + leftMotor.getDeviceName() + \", \" + rightMotor.getDeviceName());\n            }\n            \n            // Initialize sensors\n            ColorSensor colorSensor = hardwareMap.get(ColorSensor.class, \"color_sensor\");\n            \n            if (remoteDebugEnabled) {\n                Log.d(TAG, \"Color sensor initialized: \" + colorSensor.getDeviceName());\n            }\n            \n        } catch (Exception e) {\n            Log.e(TAG, \"Hardware initialization failed\", e);\n            if (remoteDebugEnabled) {\n                // Additional debugging information for remote sessions\n                Log.e(TAG, \"Hardware map contents: \" + hardwareMap.getAll(DcMotor.class).size() + \" motors, \" + \n                      hardwareMap.getAll(ColorSensor.class).size() + \" color sensors\");\n            }\n        }\n    }\n    \n    @Override\n    public void loop() {\n        if (remoteDebugEnabled) {\n            // Enhanced logging for remote debugging\n            Log.d(TAG, \"Loop iteration: \" + getRuntime() + \"s\");\n            \n            // Log gamepad state\n            if (gamepad1.a) {\n                Log.d(TAG, \"Button A pressed\");\n            }\n            if (Math.abs(gamepad1.left_stick_y) > 0.1) {\n                Log.d(TAG, \"Left stick Y: \" + gamepad1.left_stick_y);\n            }\n        }\n        \n        // Your normal OpMode logic here\n    }\n}"
    },
    {
      "type": "exercise-box",
      "title": "Practice: Advanced Debugging",
      "description": "Try these debugging exercises to reinforce your understanding:",
      "tasks": [
        "Create an OpMode with a state machine that controls a robot drivetrain",
        "Intentionally introduce a bug (e.g., wrong state transition condition)",
        "Set up conditional breakpoints to catch the bug",
        "Use watch expressions to monitor state variables",
        "Implement structured logging to track the bug",
        "Use remote debugging to verify the fix works on hardware"
      ],
      "answers": [
        {
          "task": "Create an OpMode with a state machine that controls a robot drivetrain",
          "content": "import com.qualcomm.robotcore.eventloop.opmode.OpMode;\nimport com.qualcomm.robotcore.eventloop.opmode.TeleOp;\nimport com.qualcomm.robotcore.hardware.DcMotor;\nimport android.util.Log;\n\n@TeleOp(name = \"DebuggingExercise\")\npublic class DebuggingExerciseOpMode extends OpMode {\n    private static final String TAG = \"DebugExercise\";\n    \n    // State machine for robot control\n    private enum RobotState { IDLE, FORWARD, TURNING, COMPLETE }\n    private RobotState currentState = RobotState.IDLE;\n    \n    // Hardware components\n    private DcMotor leftMotor, rightMotor;\n    \n    // State tracking variables\n    private int loopCount = 0;\n    private double startTime = 0.0;\n    \n    @Override\n    public void init() {\n        // Initialize hardware\n        leftMotor = hardwareMap.get(DcMotor.class, \"left_motor\");\n        rightMotor = hardwareMap.get(DcMotor.class, \"right_motor\");\n        \n        // Add debug logging\n        Log.d(TAG, \"Hardware initialized\");\n        Log.d(TAG, \"Left motor: \" + leftMotor.getDeviceName());\n        Log.d(TAG, \"Right motor: \" + rightMotor.getDeviceName());\n    }\n    \n    @Override\n    public void loop() {\n        // State machine logic\n        switch (currentState) {\n            case IDLE:\n                handleIdleState();\n                break;\n            case FORWARD:\n                handleForwardState();\n                break;\n            case TURNING:\n                handleTurningState();\n                break;\n            case COMPLETE:\n                handleCompleteState();\n                break;\n        }\n        \n        // Update tracking variables\n        loopCount++;\n        \n        // Add telemetry\n        telemetry.addData(\"State\", currentState);\n        telemetry.addData(\"Loop Count\", loopCount);\n        telemetry.addData(\"Runtime\", \"%.2f\", getRuntime());\n    }\n    \n    private void handleIdleState() {\n        // TODO: Implement idle state logic\n    }\n    \n    private void handleForwardState() {\n        // TODO: Implement forward state logic\n    }\n    \n    private void handleTurningState() {\n        // TODO: Implement turning state logic\n    }\n    \n    private void handleCompleteState() {\n        // TODO: Implement complete state logic\n    }\n}"
        },
        {
          "task": "Intentionally introduce a bug (e.g., wrong state transition condition)",
          "content": "private void handleIdleState() {\n    // BUG: Wrong condition - should be loopCount > 50, not 5\n    if (loopCount > 5) {  // This bug makes the robot start too early\n        currentState = RobotState.FORWARD;\n        startTime = getRuntime();\n        Log.d(TAG, \"Transitioning to FORWARD state\");\n        \n        // Start driving forward\n        leftMotor.setPower(0.5);\n        rightMotor.setPower(0.5);\n    }\n}\n\nprivate void handleForwardState() {\n    // BUG: Wrong condition - should be getRuntime() - startTime > 3.0\n    if (getRuntime() - startTime > 1.0) {  // This bug makes the robot turn too early\n        currentState = RobotState.TURNING;\n        Log.d(TAG, \"Transitioning to TURNING state\");\n        \n        // Start turning\n        leftMotor.setPower(0.3);\n        rightMotor.setPower(-0.3);\n    }\n}\n\nprivate void handleTurningState() {\n    // BUG: Wrong condition - should be getRuntime() - startTime > 5.0\n    if (getRuntime() - startTime > 2.0) {  // This bug makes the robot stop too early\n        currentState = RobotState.COMPLETE;\n        Log.d(TAG, \"Transitioning to COMPLETE state\");\n        \n        // Stop motors\n        leftMotor.setPower(0);\n        rightMotor.setPower(0);\n    }\n}\n\nprivate void handleCompleteState() {\n    Log.d(TAG, \"Robot sequence complete\");\n    // Keep the robot stopped\n    leftMotor.setPower(0);\n    rightMotor.setPower(0);\n}"
        },
        {
          "task": "Set up conditional breakpoints to catch the bug",
          "content": "// Set these conditional breakpoints in your debugger:\n// 1. In handleIdleState() at line: if (loopCount > 5)\n//    Condition: loopCount > 5\n//    This will break when the buggy condition is met\n\n// 2. In handleForwardState() at line: if (getRuntime() - startTime > 1.0)\n//    Condition: getRuntime() - startTime > 1.0\n//    This will break when the robot transitions too early\n\n// 3. In handleTurningState() at line: if (getRuntime() - startTime > 2.0)\n//    Condition: getRuntime() - startTime > 2.0\n//    This will break when the robot completes too early\n\n// 4. In handleCompleteState() at the first line\n//    Condition: true\n//    This will always break when reaching the complete state\n\n// Watch these variables during debugging:\n// - currentState\n// - loopCount\n// - startTime\n// - getRuntime()\n// - leftMotor.getPower()\n// - rightMotor.getPower()"
        },
        {
          "task": "Use watch expressions to monitor state variables",
          "content": "// Add these watch expressions in your debugger:\n// 1. currentState - Monitor the current robot state\n// 2. loopCount - Track how many loops have executed\n// 3. startTime - See when the sequence started\n// 4. getRuntime() - Monitor the total runtime\n// 5. getRuntime() - startTime - Calculate elapsed time since sequence start\n// 6. leftMotor.getPower() - Monitor left motor power\n// 7. rightMotor.getPower() - Monitor right motor power\n\n// Expected behavior vs actual behavior:\n// Expected: Robot waits 50 loops before starting\n// Actual: Robot starts after only 5 loops (BUG)\n// \n// Expected: Robot drives forward for 3 seconds\n// Actual: Robot drives forward for only 1 second (BUG)\n// \n// Expected: Robot turns for 2 seconds\n// Actual: Robot turns for only 1 second (BUG)"
        },
        {
          "task": "Implement structured logging to track the bug",
          "content": "// Add this logging configuration at the top of your class:\nprivate static final boolean DEBUG_MODE = true;\nprivate static final boolean VERBOSE_LOGGING = true;\n\n// Add these logging methods:\nprivate void logInfo(String message) {\n    Log.i(TAG, message);\n    telemetry.addData(\"INFO\", message);\n}\n\nprivate void logDebug(String message) {\n    if (DEBUG_MODE) {\n        Log.d(TAG, message);\n        telemetry.addData(\"DEBUG\", message);\n    }\n}\n\nprivate void logVerbose(String message) {\n    if (VERBOSE_LOGGING) {\n        Log.v(TAG, message);\n    }\n}\n\n// Update your state handlers with logging:\nprivate void handleIdleState() {\n    logDebug(\"Idle state - Loop count: \" + loopCount);\n    \n    if (loopCount > 5) {  // BUG: Should be 50\n        logInfo(\"BUG: Transitioning to FORWARD too early!\");\n        logDebug(\"Expected: loopCount > 50, Actual: loopCount = \" + loopCount);\n        \n        currentState = RobotState.FORWARD;\n        startTime = getRuntime();\n        \n        leftMotor.setPower(0.5);\n        rightMotor.setPower(0.5);\n        \n        logInfo(\"Started driving forward\");\n    }\n}\n\nprivate void handleForwardState() {\n    double elapsedTime = getRuntime() - startTime;\n    logDebug(\"Forward state - Elapsed time: \" + elapsedTime);\n    \n    if (elapsedTime > 1.0) {  // BUG: Should be 3.0\n        logInfo(\"BUG: Transitioning to TURNING too early!\");\n        logDebug(\"Expected: elapsedTime > 3.0, Actual: elapsedTime = \" + elapsedTime);\n        \n        currentState = RobotState.TURNING;\n        \n        leftMotor.setPower(0.3);\n        rightMotor.setPower(-0.3);\n        \n        logInfo(\"Started turning\");\n    }\n}\n\nprivate void handleTurningState() {\n    double elapsedTime = getRuntime() - startTime;\n    logDebug(\"Turning state - Elapsed time: \" + elapsedTime);\n    \n    if (elapsedTime > 2.0) {  // BUG: Should be 5.0\n        logInfo(\"BUG: Completing sequence too early!\");\n        logDebug(\"Expected: elapsedTime > 5.0, Actual: elapsedTime = \" + elapsedTime);\n        \n        currentState = RobotState.COMPLETE;\n        \n        leftMotor.setPower(0);\n        rightMotor.setPower(0);\n        \n        logInfo(\"Sequence complete\");\n    }\n}\n\nprivate void handleCompleteState() {\n    logInfo(\"Robot stopped - Sequence finished\");\n    leftMotor.setPower(0);\n    rightMotor.setPower(0);\n}"
        },
        {
          "task": "Use remote debugging to verify the fix works on hardware",
          "content": "// First, fix the bugs in your code:\nprivate void handleIdleState() {\n    logDebug(\"Idle state - Loop count: \" + loopCount);\n    \n    if (loopCount > 50) {  // FIXED: Changed from 5 to 50\n        logInfo(\"Transitioning to FORWARD state\");\n        \n        currentState = RobotState.FORWARD;\n        startTime = getRuntime();\n        \n        leftMotor.setPower(0.5);\n        rightMotor.setPower(0.5);\n        \n        logInfo(\"Started driving forward\");\n    }\n}\n\nprivate void handleForwardState() {\n    double elapsedTime = getRuntime() - startTime;\n    logDebug(\"Forward state - Elapsed time: \" + elapsedTime);\n    \n    if (elapsedTime > 3.0) {  // FIXED: Changed from 1.0 to 3.0\n        logInfo(\"Transitioning to TURNING state\");\n        \n        currentState = RobotState.TURNING;\n        \n        leftMotor.setPower(0.3);\n        rightMotor.setPower(-0.3);\n        \n        logInfo(\"Started turning\");\n    }\n}\n\nprivate void handleTurningState() {\n    double elapsedTime = getRuntime() - startTime;\n    logDebug(\"Turning state - Elapsed time: \" + elapsedTime);\n    \n    if (elapsedTime > 5.0) {  // FIXED: Changed from 2.0 to 5.0\n        logInfo(\"Transitioning to COMPLETE state\");\n        \n        currentState = RobotState.COMPLETE;\n        \n        leftMotor.setPower(0);\n        rightMotor.setPower(0);\n        \n        logInfo(\"Sequence complete\");\n    }\n}\n\n// Remote debugging setup:\n// 1. Connect to Control Hub via ADB:\n//    adb connect 192.168.43.1:5555\n// \n// 2. Verify connection:\n//    adb devices\n// \n// 3. Set breakpoints on the fixed conditions\n// \n// 4. Run the OpMode and verify:\n//    - Robot waits 50 loops before starting\n//    - Robot drives forward for 3 seconds\n//    - Robot turns for 2 seconds\n//    - Robot stops and completes sequence\n// \n// 5. Check logs to confirm no more bug messages\n// \n// 6. Verify motor behavior matches expected timing"
        },
        {
          "task": "Combine all tasks into one complete debugging exercise",
          "content": "import com.qualcomm.robotcore.eventloop.opmode.OpMode;\nimport com.qualcomm.robotcore.eventloop.opmode.TeleOp;\nimport com.qualcomm.robotcore.hardware.DcMotor;\nimport android.util.Log;\n\n@TeleOp(name = \"CompleteDebuggingExercise\")\npublic class CompleteDebuggingExercise extends OpMode {\n    private static final String TAG = \"CompleteDebug\";\n    private static final boolean DEBUG_MODE = true;\n    private static final boolean VERBOSE_LOGGING = true;\n    \n    // State machine\n    private enum RobotState { IDLE, FORWARD, TURNING, COMPLETE }\n    private RobotState currentState = RobotState.IDLE;\n    \n    // Hardware\n    private DcMotor leftMotor, rightMotor;\n    \n    // State tracking\n    private int loopCount = 0;\n    private double startTime = 0.0;\n    \n    // Logging methods\n    private void logInfo(String message) {\n        Log.i(TAG, message);\n        telemetry.addData(\"INFO\", message);\n    }\n    \n    private void logDebug(String message) {\n        if (DEBUG_MODE) {\n            Log.d(TAG, message);\n            telemetry.addData(\"DEBUG\", message);\n        }\n    }\n    \n    private void logVerbose(String message) {\n        if (VERBOSE_LOGGING) {\n            Log.v(TAG, message);\n        }\n    }\n    \n    @Override\n    public void init() {\n        // Initialize hardware\n        leftMotor = hardwareMap.get(DcMotor.class, \"left_motor\");\n        rightMotor = hardwareMap.get(DcMotor.class, \"right_motor\");\n        \n        logInfo(\"Hardware initialized successfully\");\n        logDebug(\"Left motor: \" + leftMotor.getDeviceName());\n        logDebug(\"Right motor: \" + rightMotor.getDeviceName());\n    }\n    \n    @Override\n    public void loop() {\n        // State machine with debugging\n        switch (currentState) {\n            case IDLE:\n                handleIdleState();\n                break;\n            case FORWARD:\n                handleForwardState();\n                break;\n            case TURNING:\n                handleTurningState();\n                break;\n            case COMPLETE:\n                handleCompleteState();\n                break;\n        }\n        \n        loopCount++;\n        \n        // Telemetry for debugging\n        telemetry.addData(\"State\", currentState);\n        telemetry.addData(\"Loop Count\", loopCount);\n        telemetry.addData(\"Runtime\", \"%.2f\", getRuntime());\n        telemetry.addData(\"Left Power\", leftMotor.getPower());\n        telemetry.addData(\"Right Power\", rightMotor.getPower());\n    }\n    \n    private void handleIdleState() {\n        logDebug(\"Idle state - Loop count: \" + loopCount);\n        \n        if (loopCount > 50) {  // FIXED: Correct condition\n            logInfo(\"Transitioning to FORWARD state\");\n            \n            currentState = RobotState.FORWARD;\n            startTime = getRuntime();\n            \n            leftMotor.setPower(0.5);\n            rightMotor.setPower(0.5);\n            \n            logInfo(\"Started driving forward\");\n        }\n    }\n    \n    private void handleForwardState() {\n        double elapsedTime = getRuntime() - startTime;\n        logDebug(\"Forward state - Elapsed time: \" + elapsedTime);\n        \n        if (elapsedTime > 3.0) {  // FIXED: Correct condition\n            logInfo(\"Transitioning to TURNING state\");\n            \n            currentState = RobotState.TURNING;\n            \n            leftMotor.setPower(0.3);\n            rightMotor.setPower(-0.3);\n            \n            logInfo(\"Started turning\");\n        }\n    }\n    \n    private void handleTurningState() {\n        double elapsedTime = getRuntime() - startTime;\n        logDebug(\"Turning state - Elapsed time: \" + elapsedTime);\n        \n        if (elapsedTime > 5.0) {  // FIXED: Correct condition\n            logInfo(\"Transitioning to COMPLETE state\");\n            \n            currentState = RobotState.COMPLETE;\n            \n            leftMotor.setPower(0);\n            rightMotor.setPower(0);\n            \n            logInfo(\"Sequence complete\");\n        }\n    }\n    \n    private void handleCompleteState() {\n        logInfo(\"Robot stopped - Sequence finished\");\n        leftMotor.setPower(0);\n        rightMotor.setPower(0);\n    }\n}"
        }
      ]
    },
    {
      "type": "link-grid",
      "title": "Additional Resources",
      "links": [
        {"url":"https://developer.android.com/studio/debug","label":"Android Studio Debugging Guide"},
        {"url":"https://developer.android.com/studio/debug#breakPoints","label":"Android Studio Conditional Breakpoints"},
        {"url":"https://developer.android.com/studio/debug#variablesAndWatches","label":"Variables and Watch Expressions"},
        {"id":"state-machines","label":"State Machines"}
      ]
    }
  ]
}
