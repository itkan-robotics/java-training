{
  "title": "Debugging Strategies for FTC Development",
  "sections": [
    {
      "type": "text",
      "title": "Introduction to Systematic Debugging",
      "content": "Effective debugging is not just about finding bugsâ€”it's about developing a systematic approach to problem-solving. In FTC development, you need strategies that work both in the lab and under competition pressure. This lesson teaches you how to approach debugging methodically and efficiently."
    },
    {
      "type": "rules-box",
      "title": "Why Systematic Debugging Matters",
      "items": [
        "FTC competitions have limited time for debugging and testing",
        "Hardware-software interactions create complex failure modes",
        "Systematic approaches prevent you from making the same mistakes",
        "Good debugging skills transfer to other programming domains",
        "Competition environments require quick problem resolution"
      ]
    },
    {
      "type": "text",
      "title": "The Scientific Method of Debugging",
      "content": "Apply the scientific method to debugging: observe the problem, form a hypothesis, test it, and refine your understanding. This systematic approach helps you avoid random trial-and-error debugging."
    },
    {
      "type": "code",
      "title": "Debugging Framework - Core Structure",
      "content": "Implement a structured debugging process in your code. This framework provides a systematic approach to debugging by following the scientific method. The framework tracks observations, hypotheses, tests, and conclusions:",
      "code": "public class DebuggingFramework {\n    private static final String TAG = \"DebugFramework\";\n    private boolean debugMode = true;\n    private List<String> debugLog = new ArrayList<>();\n    \n    /**\n     * Step 1: Observe and Document the Problem\n     */\n    public void observeProblem(String problemDescription, Object... data) {\n        String observation = String.format(\"OBSERVATION: %s | Data: %s\", \n                                          problemDescription, \n                                          Arrays.toString(data));\n        logDebug(observation);\n        debugLog.add(observation);\n    }\n    \n    /**\n     * Step 2: Form a Hypothesis\n     */\n    public void formHypothesis(String hypothesis, String expectedOutcome) {\n        String hypothesisEntry = String.format(\"HYPOTHESIS: %s | Expected: %s\", \n                                              hypothesis, \n                                              expectedOutcome);\n        logDebug(hypothesisEntry);\n        debugLog.add(hypothesisEntry);\n    }"
    },
    {
      "type": "text",
      "title": "Understanding the Scientific Method in Debugging",
      "content": "The scientific method provides a systematic approach to debugging. First, you observe and document the problem with specific data. Then you form a hypothesis about what might be causing the issue. This structured approach prevents random trial-and-error debugging."
    },
    {
      "type": "code",
      "title": "Debugging Framework - Testing and Conclusion Methods",
      "content": "Add methods for testing hypotheses and documenting conclusions. These methods complete the scientific method cycle by testing your hypothesis and recording the results:",
      "code": "    /**\n     * Step 3: Test the Hypothesis\n     */\n    public void testHypothesis(String testDescription, boolean result, Object actualOutcome) {\n        String testResult = String.format(\"TEST: %s | Result: %s | Actual: %s\", \n                                         testDescription, \n                                         result ? \"PASS\" : \"FAIL\", \n                                         actualOutcome);\n        logDebug(testResult);\n        debugLog.add(testResult);\n    }\n    \n    /**\n     * Step 4: Document the Conclusion\n     */\n    public void documentConclusion(String conclusion, String nextSteps) {\n        String conclusionEntry = String.format(\"CONCLUSION: %s | Next: %s\", \n                                              conclusion, \n                                              nextSteps);\n        logDebug(conclusionEntry);\n        debugLog.add(conclusionEntry);\n    }\n    \n    private void logDebug(String message) {\n        if (debugMode) {\n            Log.d(TAG, message);\n        }\n    }\n    \n    public List<String> getDebugLog() {\n        return new ArrayList<>(debugLog);\n    }\n    \n    public void clearDebugLog() {\n        debugLog.clear();\n    }\n}"
    },
    {
      "type": "text",
      "title": "Completing the Debugging Cycle",
      "content": "The testing and conclusion methods complete the debugging cycle. Testing verifies whether your hypothesis was correct, and conclusions document what you learned and what steps to take next. This creates a record that helps with future debugging and team communication."
    },
    {
      "type": "text",
      "title": "Common FTC Debugging Scenarios",
      "content": "FTC development has specific challenges that require targeted debugging strategies. Understanding these common scenarios helps you develop effective debugging approaches."
    },
    {
      "type": "code",
      "title": "Hardware Debugger - Basic Structure",
      "content": "Hardware connection issues are common in FTC. Here's a systematic approach to debugging them. This class provides methods to test hardware connections systematically:",
      "code": "public class HardwareDebugger {\n    private HardwareMap hardwareMap;\n    private Telemetry telemetry;\n    private DebuggingFramework debugger;\n    \n    public HardwareDebugger(HardwareMap hardwareMap, Telemetry telemetry) {\n        this.hardwareMap = hardwareMap;\n        this.telemetry = telemetry;\n        this.debugger = new DebuggingFramework();\n    }\n    \n    public boolean debugMotorConnection(String motorName) {\n        debugger.observeProblem(\"Motor \" + motorName + \" not responding\");\n        \n        // Step 1: Check if motor exists in hardware map\n        debugger.formHypothesis(\"Motor not found in hardware map\", \"HardwareMap.get() throws exception\");\n        \n        try {\n            DcMotor motor = hardwareMap.get(DcMotor.class, motorName);\n            debugger.testHypothesis(\"Motor exists in hardware map\", true, motor.getDeviceName());\n            \n            // Step 2: Check if motor responds to basic commands\n            debugger.formHypothesis(\"Motor hardware connection issue\", \"setPower() should work without exception\");\n            \n            try {\n                motor.setPower(0.1);\n                Thread.sleep(100); // Brief test\n                motor.setPower(0.0);\n                debugger.testHypothesis(\"Motor responds to commands\", true, \"Power set successfully\");\n                \n                debugger.documentConclusion(\"Motor connection is working\", \"Check software logic\");\n                return true;\n                \n            } catch (Exception e) {\n                debugger.testHypothesis(\"Motor responds to commands\", false, e.getMessage());\n                debugger.documentConclusion(\"Motor hardware connection issue\", \"Check wiring and power\");\n                return false;\n            }\n            \n        } catch (Exception e) {\n            debugger.testHypothesis(\"Motor exists in hardware map\", false, e.getMessage());\n            debugger.documentConclusion(\"Motor not configured in hardware map\", \"Check configuration file\");\n            return false;\n        }\n    }"
    },
    {
      "type": "text",
      "title": "Understanding Hardware Debugging",
      "content": "The hardware debugger systematically tests each component of the motor connection. First, it checks if the motor exists in the hardware map. Then it tests if the motor responds to basic commands. This helps identify whether the issue is configuration, wiring, or software-related."
    },
    {
      "type": "code",
      "title": "Hardware Debugger - Sensor Connection Methods",
      "content": "Add methods for debugging sensor connections. These methods handle different types of sensors:",
      "code": "    public boolean debugSensorConnection(String sensorName, Class<?> sensorType) {\n        debugger.observeProblem(\"Sensor \" + sensorName + \" not providing data\");\n        \n        try {\n            Object sensor = hardwareMap.get(sensorType, sensorName);\n            debugger.testHypothesis(\"Sensor exists in hardware map\", true, sensor.getClass().getSimpleName());\n            \n            // Test sensor functionality based on type\n            if (sensor instanceof ColorSensor) {\n                return debugColorSensor((ColorSensor) sensor, sensorName);\n            } else if (sensor instanceof TouchSensor) {\n                return debugTouchSensor((TouchSensor) sensor, sensorName);\n            } else if (sensor instanceof DistanceSensor) {\n                return debugDistanceSensor((DistanceSensor) sensor, sensorName);\n            }\n            \n            return true;\n            \n        } catch (Exception e) {\n            debugger.testHypothesis(\"Sensor exists in hardware map\", false, e.getMessage());\n            debugger.documentConclusion(\"Sensor not configured\", \"Check configuration file\");\n            return false;\n        }\n    }"
    },
    {
      "type": "text",
      "title": "Understanding Sensor Debugging",
      "content": "The sensor debugging method first checks if the sensor exists in the hardware map, then calls specific debugging methods based on the sensor type. This allows for customized testing for each type of sensor."
    },
    {
      "type": "code",
      "title": "Hardware Debugger - Specific Sensor Debug Methods",
      "content": "Add specific debugging methods for different sensor types. Each method tests the sensor's basic functionality:",
      "code": "    private boolean debugColorSensor(ColorSensor sensor, String sensorName) {\n        debugger.formHypothesis(\"Color sensor not reading values\", \"getRed(), getGreen(), getBlue() should return values\");\n        \n        try {\n            int red = sensor.red();\n            int green = sensor.green();\n            int blue = sensor.blue();\n            \n            String reading = String.format(\"R:%d G:%d B:%d\", red, green, blue);\n            debugger.testHypothesis(\"Color sensor reading values\", true, reading);\n            \n            debugger.documentConclusion(\"Color sensor working\", \"Check sensor positioning and lighting\");\n            return true;\n            \n        } catch (Exception e) {\n            debugger.testHypothesis(\"Color sensor reading values\", false, e.getMessage());\n            debugger.documentConclusion(\"Color sensor hardware issue\", \"Check wiring and power\");\n            return false;\n        }\n    }\n    \n    private boolean debugTouchSensor(TouchSensor sensor, String sensorName) {\n        debugger.formHypothesis(\"Touch sensor not responding\", \"isPressed() should return boolean\");\n        \n        try {\n            boolean isPressed = sensor.isPressed();\n            debugger.testHypothesis(\"Touch sensor responding\", true, \"Pressed: \" + isPressed);\n            \n            debugger.documentConclusion(\"Touch sensor working\", \"Test with physical touch\");\n            return true;\n            \n        } catch (Exception e) {\n            debugger.testHypothesis(\"Touch sensor responding\", false, e.getMessage());\n            debugger.documentConclusion(\"Touch sensor hardware issue\", \"Check wiring and mounting\");\n            return false;\n        }\n    }\n    \n    private boolean debugDistanceSensor(DistanceSensor sensor, String sensorName) {\n        debugger.formHypothesis(\"Distance sensor not reading\", \"getDistance() should return distance value\");\n        \n        try {\n            double distance = sensor.getDistance(DistanceUnit.INCH);\n            debugger.testHypothesis(\"Distance sensor reading\", true, \"Distance: \" + distance + \" inches\");\n            \n            debugger.documentConclusion(\"Distance sensor working\", \"Check sensor positioning and calibration\");\n            return true;\n            \n        } catch (Exception e) {\n            debugger.testHypothesis(\"Distance sensor reading\", false, e.getMessage());\n            debugger.documentConclusion(\"Distance sensor hardware issue\", \"Check wiring and power\");\n            return false;\n        }\n    }\n    \n    public void printDebugLog() {\n        List<String> log = debugger.getDebugLog();\n        telemetry.addLine(\"=== HARDWARE DEBUG LOG ===\");\n        for (String entry : log) {\n            telemetry.addLine(entry);\n        }\n        telemetry.update();\n    }\n}"
    },
    {
      "type": "text",
      "title": "Understanding Sensor-Specific Debugging",
      "content": "Each sensor type has different testing requirements. Color sensors need to read RGB values, touch sensors need to respond to physical contact, and distance sensors need to return distance measurements. These specific methods ensure each sensor type is tested appropriately."
    },
    {
      "type": "text",
      "title": "State Machine Debugging",
      "content": "State machines are common in FTC autonomous programs but can be difficult to debug. Use systematic approaches to track state transitions and identify issues."
    },
    {
      "type": "code",
      "title": "Debuggable State Machine - Core Structure",
      "content": "Create a debuggable state machine that tracks transitions and conditions. This class provides comprehensive debugging information for state machines:",
      "code": "public class DebuggableStateMachine<T extends Enum<T>> {\n    private T currentState;\n    private T previousState;\n    private double stateStartTime;\n    private double currentTime;\n    private List<StateTransition> transitionHistory = new ArrayList<>();\n    private DebuggingFramework debugger;\n    \n    public DebuggableStateMachine(T initialState, DebuggingFramework debugger) {\n        this.currentState = initialState;\n        this.previousState = initialState;\n        this.debugger = debugger;\n        this.stateStartTime = 0.0;\n        this.currentTime = 0.0;\n    }\n    \n    public void update(double time) {\n        this.currentTime = time;\n        \n        // Log state duration if it's been too long\n        double stateDuration = time - stateStartTime;\n        if (stateDuration > 10.0) { // 10 second timeout\n            debugger.observeProblem(\"State \" + currentState + \" has been active for \" + stateDuration + \" seconds\");\n            debugger.formHypothesis(\"State transition condition not met\", \"Check transition logic\");\n        }\n    }"
    },
    {
      "type": "text",
      "title": "Understanding State Machine Debugging",
      "content": "The debuggable state machine tracks the current state, previous state, and how long each state has been active. It automatically detects when a state has been active too long, which often indicates a bug in the transition logic."
    },
    {
      "type": "code",
      "title": "Debuggable State Machine - Transition and History Methods",
      "content": "Add methods for managing state transitions and tracking history:",
      "code": "    public void transitionTo(T newState, String reason) {\n        if (newState != currentState) {\n            previousState = currentState;\n            double stateDuration = currentTime - stateStartTime;\n            \n            // Record the transition\n            StateTransition transition = new StateTransition(\n                previousState, newState, reason, stateDuration, currentTime\n            );\n            transitionHistory.add(transition);\n            \n            // Log the transition\n            debugger.observeProblem(\"State transition: \" + previousState + \" -> \" + newState + \" (\" + reason + \")\");\n            \n            currentState = newState;\n            stateStartTime = currentTime;\n        }\n    }\n    \n    public T getCurrentState() {\n        return currentState;\n    }\n    \n    public T getPreviousState() {\n        return previousState;\n    }\n    \n    public double getStateDuration() {\n        return currentTime - stateStartTime;\n    }\n    \n    public List<StateTransition> getTransitionHistory() {\n        return new ArrayList<>(transitionHistory);\n    }"
    },
    {
      "type": "text",
      "title": "Understanding State Transitions",
      "content": "The transitionTo method records every state change with the reason for the transition and how long the previous state was active. This creates a complete history that helps identify patterns in state machine behavior."
    },
    {
      "type": "code",
      "title": "Debuggable State Machine - Debug Display and Helper Class",
      "content": "Add debug display methods and the StateTransition helper class:",
      "code": "    public void debugStateMachine(Telemetry telemetry) {\n        telemetry.addLine(\"=== STATE MACHINE DEBUG ===\");\n        telemetry.addData(\"Current State\", currentState);\n        telemetry.addData(\"Previous State\", previousState);\n        telemetry.addData(\"State Duration\", String.format(\"%.2fs\", getStateDuration()));\n        telemetry.addData(\"Total Time\", String.format(\"%.2fs\", currentTime));\n        \n        telemetry.addLine(\"\\nRecent Transitions:\");\n        int startIndex = Math.max(0, transitionHistory.size() - 5);\n        for (int i = startIndex; i < transitionHistory.size(); i++) {\n            StateTransition t = transitionHistory.get(i);\n            telemetry.addLine(String.format(\"%.1fs: %s -> %s (%s)\", \n                t.timestamp, t.fromState, t.toState, t.reason));\n        }\n        \n        telemetry.update();\n    }\n    \n    private static class StateTransition {\n        T fromState, toState;\n        String reason;\n        double duration, timestamp;\n        \n        StateTransition(T from, T to, String reason, double duration, double timestamp) {\n            this.fromState = from;\n            this.toState = to;\n            this.reason = reason;\n            this.duration = duration;\n            this.timestamp = timestamp;\n        }\n    }\n}"
    },
    {
      "type": "text",
      "title": "Understanding State Machine Display",
      "content": "The debugStateMachine method displays comprehensive information about the state machine's current status and recent history. The StateTransition helper class stores all the details about each state change for analysis."
    },
    {
      "type": "text",
      "title": "Using the Debuggable State Machine",
      "content": "Now let's see how to use the debuggable state machine in an actual autonomous OpMode. This example shows how to integrate the debugging framework with real robot behavior."
    },
    {
      "type": "code",
      "title": "Debuggable Autonomous OpMode - Setup and Initialization",
      "content": "Use the debuggable state machine in an autonomous OpMode. This example shows how to set up debugging for a complete autonomous sequence:",
      "code": "public class DebuggableAutonomousOpMode extends OpMode {\n    private enum AutonomousState {\n        INIT, DRIVE_FORWARD, TURN_LEFT, DETECT_COLOR, COMPLETE\n    }\n    \n    private DebuggableStateMachine<AutonomousState> stateMachine;\n    private DebuggingFramework debugger;\n    private HardwareDebugger hardwareDebugger;\n    \n    private DcMotor leftMotor, rightMotor;\n    private ColorSensor colorSensor;\n    private double startTime;\n    \n    @Override\n    public void init() {\n        debugger = new DebuggingFramework();\n        stateMachine = new DebuggableStateMachine<>(AutonomousState.INIT, debugger);\n        hardwareDebugger = new HardwareDebugger(hardwareMap, telemetry);\n        \n        // Debug hardware connections\n        debugger.observeProblem(\"Initializing autonomous sequence\");\n        \n        boolean motorsOK = hardwareDebugger.debugMotorConnection(\"left_motor\") &&\n                           hardwareDebugger.debugMotorConnection(\"right_motor\");\n        \n        boolean sensorOK = hardwareDebugger.debugSensorConnection(\"color_sensor\", ColorSensor.class);\n        \n        if (!motorsOK || !sensorOK) {\n            debugger.documentConclusion(\"Hardware issues detected\", \"Fix hardware before proceeding\");\n            return;\n        }\n        \n        // Initialize hardware\n        leftMotor = hardwareMap.get(DcMotor.class, \"left_motor\");\n        rightMotor = hardwareMap.get(DcMotor.class, \"right_motor\");\n        colorSensor = hardwareMap.get(ColorSensor.class, \"color_sensor\");\n        \n        debugger.documentConclusion(\"Hardware initialized successfully\", \"Ready to start autonomous\");\n    }"
    },
    {
      "type": "text",
      "title": "Understanding Autonomous Setup",
      "content": "The initialization method sets up all the debugging components and tests hardware connections before starting the autonomous sequence. This ensures that any hardware issues are identified early."
    },
    {
      "type": "code",
      "title": "Debuggable Autonomous OpMode - Main Loop and State Handling",
      "content": "Add the main loop and state handling logic with comprehensive debugging:",
      "code": "    @Override\n    public void start() {\n        startTime = getRuntime();\n        stateMachine.transitionTo(AutonomousState.DRIVE_FORWARD, \"Starting autonomous sequence\");\n        debugger.observeProblem(\"Autonomous sequence started\");\n    }\n    \n    @Override\n    public void loop() {\n        double currentTime = getRuntime();\n        stateMachine.update(currentTime);\n        \n        AutonomousState currentState = stateMachine.getCurrentState();\n        \n        switch (currentState) {\n            case INIT:\n                // Should not reach here\n                debugger.observeProblem(\"Unexpected INIT state in loop\");\n                break;\n                \n            case DRIVE_FORWARD:\n                // Drive forward for 2 seconds\n                if (currentTime - startTime < 2.0) {\n                    leftMotor.setPower(0.5);\n                    rightMotor.setPower(0.5);\n                } else {\n                    leftMotor.setPower(0.0);\n                    rightMotor.setPower(0.0);\n                    stateMachine.transitionTo(AutonomousState.TURN_LEFT, \"Drive forward complete\");\n                }\n                break;\n                \n            case TURN_LEFT:\n                // Turn left for 1 second\n                if (stateMachine.getStateDuration() < 1.0) {\n                    leftMotor.setPower(-0.3);\n                    rightMotor.setPower(0.3);\n                } else {\n                    leftMotor.setPower(0.0);\n                    rightMotor.setPower(0.0);\n                    stateMachine.transitionTo(AutonomousState.DETECT_COLOR, \"Turn complete\");\n                }\n                break;\n                \n            case DETECT_COLOR:\n                // Check for red color\n                int red = colorSensor.red();\n                int green = colorSensor.green();\n                int blue = colorSensor.blue();\n                \n                if (red > green && red > blue && red > 100) {\n                    debugger.observeProblem(\"Red color detected: R=\" + red + \" G=\" + green + \" B=\" + blue);\n                    stateMachine.transitionTo(AutonomousState.COMPLETE, \"Red color detected\");\n                } else if (stateMachine.getStateDuration() > 5.0) {\n                    debugger.observeProblem(\"Color detection timeout after 5 seconds\");\n                    stateMachine.transitionTo(AutonomousState.COMPLETE, \"Color detection timeout\");\n                }\n                break;\n                \n            case COMPLETE:\n                // Stop all motors\n                leftMotor.setPower(0.0);\n                rightMotor.setPower(0.0);\n                \n                if (stateMachine.getStateDuration() > 1.0) {\n                    requestOpModeStop();\n                }\n                break;\n        }\n        \n        // Display debug information\n        stateMachine.debugStateMachine(telemetry);\n        telemetry.addLine(\"\");\n        hardwareDebugger.printDebugLog();\n    }\n}"
    },
    {
      "type": "text",
      "title": "Understanding State Machine Logic",
      "content": "Each state in the autonomous sequence has specific logic and transition conditions. The debugging framework tracks all state changes and provides detailed information about what's happening at each step."
    },
    {
      "type": "code",
      "title": "Complete Debugging Framework Example",
      "content": "Here's the complete debugging framework with all components combined:",
      "code": "import com.qualcomm.robotcore.eventloop.opmode.OpMode;\nimport com.qualcomm.robotcore.eventloop.opmode.Autonomous;\nimport com.qualcomm.robotcore.hardware.DcMotor;\nimport com.qualcomm.robotcore.hardware.ColorSensor;\nimport com.qualcomm.robotcore.hardware.TouchSensor;\nimport com.qualcomm.robotcore.hardware.DistanceSensor;\nimport com.qualcomm.robotcore.util.DistanceUnit;\nimport android.util.Log;\nimport java.util.*;\n\n@Autonomous(name = \"Debugging Framework Example\")\npublic class DebuggingFrameworkExample extends OpMode {\n    private enum AutonomousState {\n        INIT, DRIVE_FORWARD, TURN_LEFT, DETECT_COLOR, COMPLETE\n    }\n    \n    private DebuggableStateMachine<AutonomousState> stateMachine;\n    private DebuggingFramework debugger;\n    private HardwareDebugger hardwareDebugger;\n    \n    private DcMotor leftMotor, rightMotor;\n    private ColorSensor colorSensor;\n    private double startTime;\n    \n    @Override\n    public void init() {\n        debugger = new DebuggingFramework();\n        stateMachine = new DebuggableStateMachine<>(AutonomousState.INIT, debugger);\n        hardwareDebugger = new HardwareDebugger(hardwareMap, telemetry);\n        \n        // Debug hardware connections\n        debugger.observeProblem(\"Initializing autonomous sequence\");\n        \n        boolean motorsOK = hardwareDebugger.debugMotorConnection(\"left_motor\") &&\n                           hardwareDebugger.debugMotorConnection(\"right_motor\");\n        \n        boolean sensorOK = hardwareDebugger.debugSensorConnection(\"color_sensor\", ColorSensor.class);\n        \n        if (!motorsOK || !sensorOK) {\n            debugger.documentConclusion(\"Hardware issues detected\", \"Fix hardware before proceeding\");\n            return;\n        }\n        \n        // Initialize hardware\n        leftMotor = hardwareMap.get(DcMotor.class, \"left_motor\");\n        rightMotor = hardwareMap.get(DcMotor.class, \"right_motor\");\n        colorSensor = hardwareMap.get(ColorSensor.class, \"color_sensor\");\n        \n        debugger.documentConclusion(\"Hardware initialized successfully\", \"Ready to start autonomous\");\n    }\n    \n    @Override\n    public void start() {\n        startTime = getRuntime();\n        stateMachine.transitionTo(AutonomousState.DRIVE_FORWARD, \"Starting autonomous sequence\");\n        debugger.observeProblem(\"Autonomous sequence started\");\n    }\n    \n    @Override\n    public void loop() {\n        double currentTime = getRuntime();\n        stateMachine.update(currentTime);\n        \n        AutonomousState currentState = stateMachine.getCurrentState();\n        \n        switch (currentState) {\n            case INIT:\n                debugger.observeProblem(\"Unexpected INIT state in loop\");\n                break;\n                \n            case DRIVE_FORWARD:\n                if (currentTime - startTime < 2.0) {\n                    leftMotor.setPower(0.5);\n                    rightMotor.setPower(0.5);\n                } else {\n                    leftMotor.setPower(0.0);\n                    rightMotor.setPower(0.0);\n                    stateMachine.transitionTo(AutonomousState.TURN_LEFT, \"Drive forward complete\");\n                }\n                break;\n                \n            case TURN_LEFT:\n                if (stateMachine.getStateDuration() < 1.0) {\n                    leftMotor.setPower(-0.3);\n                    rightMotor.setPower(0.3);\n                } else {\n                    leftMotor.setPower(0.0);\n                    rightMotor.setPower(0.0);\n                    stateMachine.transitionTo(AutonomousState.DETECT_COLOR, \"Turn complete\");\n                }\n                break;\n                \n            case DETECT_COLOR:\n                int red = colorSensor.red();\n                int green = colorSensor.green();\n                int blue = colorSensor.blue();\n                \n                if (red > green && red > blue && red > 100) {\n                    debugger.observeProblem(\"Red color detected: R=\" + red + \" G=\" + green + \" B=\" + blue);\n                    stateMachine.transitionTo(AutonomousState.COMPLETE, \"Red color detected\");\n                } else if (stateMachine.getStateDuration() > 5.0) {\n                    debugger.observeProblem(\"Color detection timeout after 5 seconds\");\n                    stateMachine.transitionTo(AutonomousState.COMPLETE, \"Color detection timeout\");\n                }\n                break;\n                \n            case COMPLETE:\n                leftMotor.setPower(0.0);\n                rightMotor.setPower(0.0);\n                \n                if (stateMachine.getStateDuration() > 1.0) {\n                    requestOpModeStop();\n                }\n                break;\n        }\n        \n        // Display debug information\n        stateMachine.debugStateMachine(telemetry);\n        telemetry.addLine(\"\");\n        hardwareDebugger.printDebugLog();\n    }\n    \n    // Debugging Framework Classes\n    public static class DebuggingFramework {\n        private static final String TAG = \"DebugFramework\";\n        private boolean debugMode = true;\n        private List<String> debugLog = new ArrayList<>();\n        \n        public void observeProblem(String problemDescription, Object... data) {\n            String observation = String.format(\"OBSERVATION: %s | Data: %s\", \n                                              problemDescription, \n                                              Arrays.toString(data));\n            logDebug(observation);\n            debugLog.add(observation);\n        }\n        \n        public void formHypothesis(String hypothesis, String expectedOutcome) {\n            String hypothesisEntry = String.format(\"HYPOTHESIS: %s | Expected: %s\", \n                                                  hypothesis, \n                                                  expectedOutcome);\n            logDebug(hypothesisEntry);\n            debugLog.add(hypothesisEntry);\n        }\n        \n        public void testHypothesis(String testDescription, boolean result, Object actualOutcome) {\n            String testResult = String.format(\"TEST: %s | Result: %s | Actual: %s\", \n                                             testDescription, \n                                             result ? \"PASS\" : \"FAIL\", \n                                             actualOutcome);\n            logDebug(testResult);\n            debugLog.add(testResult);\n        }\n        \n        public void documentConclusion(String conclusion, String nextSteps) {\n            String conclusionEntry = String.format(\"CONCLUSION: %s | Next: %s\", \n                                                  conclusion, \n                                                  nextSteps);\n            logDebug(conclusionEntry);\n            debugLog.add(conclusionEntry);\n        }\n        \n        private void logDebug(String message) {\n            if (debugMode) {\n                Log.d(TAG, message);\n            }\n        }\n        \n        public List<String> getDebugLog() {\n            return new ArrayList<>(debugLog);\n        }\n        \n        public void clearDebugLog() {\n            debugLog.clear();\n        }\n    }\n    \n    public static class HardwareDebugger {\n        private HardwareMap hardwareMap;\n        private Telemetry telemetry;\n        private DebuggingFramework debugger;\n        \n        public HardwareDebugger(HardwareMap hardwareMap, Telemetry telemetry) {\n            this.hardwareMap = hardwareMap;\n            this.telemetry = telemetry;\n            this.debugger = new DebuggingFramework();\n        }\n        \n        public boolean debugMotorConnection(String motorName) {\n            debugger.observeProblem(\"Motor \" + motorName + \" not responding\");\n            \n            try {\n                DcMotor motor = hardwareMap.get(DcMotor.class, motorName);\n                debugger.testHypothesis(\"Motor exists in hardware map\", true, motor.getDeviceName());\n                \n                try {\n                    motor.setPower(0.1);\n                    Thread.sleep(100);\n                    motor.setPower(0.0);\n                    debugger.testHypothesis(\"Motor responds to commands\", true, \"Power set successfully\");\n                    debugger.documentConclusion(\"Motor connection is working\", \"Check software logic\");\n                    return true;\n                    \n                } catch (Exception e) {\n                    debugger.testHypothesis(\"Motor responds to commands\", false, e.getMessage());\n                    debugger.documentConclusion(\"Motor hardware connection issue\", \"Check wiring and power\");\n                    return false;\n                }\n                \n            } catch (Exception e) {\n                debugger.testHypothesis(\"Motor exists in hardware map\", false, e.getMessage());\n                debugger.documentConclusion(\"Motor not configured in hardware map\", \"Check configuration file\");\n                return false;\n            }\n        }\n        \n        public boolean debugSensorConnection(String sensorName, Class<?> sensorType) {\n            debugger.observeProblem(\"Sensor \" + sensorName + \" not providing data\");\n            \n            try {\n                Object sensor = hardwareMap.get(sensorType, sensorName);\n                debugger.testHypothesis(\"Sensor exists in hardware map\", true, sensor.getClass().getSimpleName());\n                \n                if (sensor instanceof ColorSensor) {\n                    return debugColorSensor((ColorSensor) sensor, sensorName);\n                }\n                \n                return true;\n                \n            } catch (Exception e) {\n                debugger.testHypothesis(\"Sensor exists in hardware map\", false, e.getMessage());\n                debugger.documentConclusion(\"Sensor not configured\", \"Check configuration file\");\n                return false;\n            }\n        }\n        \n        private boolean debugColorSensor(ColorSensor sensor, String sensorName) {\n            debugger.formHypothesis(\"Color sensor not reading values\", \"getRed(), getGreen(), getBlue() should return values\");\n            \n            try {\n                int red = sensor.red();\n                int green = sensor.green();\n                int blue = sensor.blue();\n                \n                String reading = String.format(\"R:%d G:%d B:%d\", red, green, blue);\n                debugger.testHypothesis(\"Color sensor reading values\", true, reading);\n                \n                debugger.documentConclusion(\"Color sensor working\", \"Check sensor positioning and lighting\");\n                return true;\n                \n            } catch (Exception e) {\n                debugger.testHypothesis(\"Color sensor reading values\", false, e.getMessage());\n                debugger.documentConclusion(\"Color sensor hardware issue\", \"Check wiring and power\");\n                return false;\n            }\n        }\n        \n        public void printDebugLog() {\n            List<String> log = debugger.getDebugLog();\n            telemetry.addLine(\"=== HARDWARE DEBUG LOG ===\");\n            for (String entry : log) {\n                telemetry.addLine(entry);\n            }\n            telemetry.update();\n        }\n    }\n    \n    public static class DebuggableStateMachine<T extends Enum<T>> {\n        private T currentState;\n        private T previousState;\n        private double stateStartTime;\n        private double currentTime;\n        private List<StateTransition> transitionHistory = new ArrayList<>();\n        private DebuggingFramework debugger;\n        \n        public DebuggableStateMachine(T initialState, DebuggingFramework debugger) {\n            this.currentState = initialState;\n            this.previousState = initialState;\n            this.debugger = debugger;\n            this.stateStartTime = 0.0;\n            this.currentTime = 0.0;\n        }\n        \n        public void update(double time) {\n            this.currentTime = time;\n            \n            double stateDuration = time - stateStartTime;\n            if (stateDuration > 10.0) {\n                debugger.observeProblem(\"State \" + currentState + \" has been active for \" + stateDuration + \" seconds\");\n                debugger.formHypothesis(\"State transition condition not met\", \"Check transition logic\");\n            }\n        }\n        \n        public void transitionTo(T newState, String reason) {\n            if (newState != currentState) {\n                previousState = currentState;\n                double stateDuration = currentTime - stateStartTime;\n                \n                StateTransition transition = new StateTransition(\n                    previousState, newState, reason, stateDuration, currentTime\n                );\n                transitionHistory.add(transition);\n                \n                debugger.observeProblem(\"State transition: \" + previousState + \" -> \" + newState + \" (\" + reason + \")\");\n                \n                currentState = newState;\n                stateStartTime = currentTime;\n            }\n        }\n        \n        public T getCurrentState() {\n            return currentState;\n        }\n        \n        public double getStateDuration() {\n            return currentTime - stateStartTime;\n        }\n        \n        public void debugStateMachine(Telemetry telemetry) {\n            telemetry.addLine(\"=== STATE MACHINE DEBUG ===\");\n            telemetry.addData(\"Current State\", currentState);\n            telemetry.addData(\"Previous State\", previousState);\n            telemetry.addData(\"State Duration\", String.format(\"%.2fs\", getStateDuration()));\n            telemetry.addData(\"Total Time\", String.format(\"%.2fs\", currentTime));\n            \n            telemetry.addLine(\"\\nRecent Transitions:\");\n            int startIndex = Math.max(0, transitionHistory.size() - 5);\n            for (int i = startIndex; i < transitionHistory.size(); i++) {\n                StateTransition t = transitionHistory.get(i);\n                telemetry.addLine(String.format(\"%.1fs: %s -> %s (%s)\", \n                    t.timestamp, t.fromState, t.toState, t.reason));\n            }\n            \n            telemetry.update();\n        }\n        \n        private static class StateTransition {\n            T fromState, toState;\n            String reason;\n            double duration, timestamp;\n            \n            StateTransition(T from, T to, String reason, double duration, double timestamp) {\n                this.fromState = from;\n                this.toState = to;\n                this.reason = reason;\n                this.duration = duration;\n                this.timestamp = timestamp;\n            }\n        }\n    }\n}"
    },
    {
      "type": "text",
      "title": "Performance Debugging",
      "content": "Performance issues in FTC can cause missed commands, laggy telemetry, or unreliable autonomous behavior. Learn to identify and fix performance bottlenecks."
    },
    {
      "type": "code",
      "title": "Performance Monitor - Core Structure",
      "content": "Create a framework to monitor and debug performance issues. This class tracks loop timing and operation performance:",
      "code": "public class PerformanceMonitor {\n    private Map<String, Long> operationStartTimes = new HashMap<>();\n    private Map<String, List<Long>> operationDurations = new HashMap<>();\n    private long loopStartTime;\n    private int loopCount = 0;\n    private double averageLoopTime = 0.0;\n    private double maxLoopTime = 0.0;\n    private DebuggingFramework debugger;\n    \n    public PerformanceMonitor(DebuggingFramework debugger) {\n        this.debugger = debugger;\n    }\n    \n    public void startLoop() {\n        loopStartTime = System.nanoTime();\n        loopCount++;\n    }\n    \n    public void endLoop() {\n        long loopDuration = System.nanoTime() - loopStartTime;\n        double loopTimeMs = loopDuration / 1_000_000.0;\n        \n        // Update average loop time\n        averageLoopTime = (averageLoopTime * (loopCount - 1) + loopTimeMs) / loopCount;\n        maxLoopTime = Math.max(maxLoopTime, loopTimeMs);\n        \n        // Check for performance issues\n        if (loopTimeMs > 50.0) { // More than 50ms per loop\n            debugger.observeProblem(\"Slow loop detected: \" + String.format(\"%.2f\", loopTimeMs) + \"ms\");\n            debugger.formHypothesis(\"Loop taking too long\", \"Check for expensive operations in loop\");\n        }\n    }"
    },
    {
      "type": "text",
      "title": "Understanding Performance Monitoring",
      "content": "The performance monitor tracks how long each loop takes to execute. It calculates the average and maximum loop times, and alerts you when loops take too long. This helps identify performance bottlenecks in your code."
    },
    {
      "type": "code",
      "title": "Performance Monitor - Operation Tracking Methods",
      "content": "Add methods for tracking individual operation performance:",
      "code": "    public void startOperation(String operationName) {\n        operationStartTimes.put(operationName, System.nanoTime());\n    }\n    \n    public void endOperation(String operationName) {\n        Long startTime = operationStartTimes.remove(operationName);\n        if (startTime != null) {\n            long duration = System.nanoTime() - startTime;\n            double durationMs = duration / 1_000_000.0;\n            \n            // Store duration for analysis\n            operationDurations.computeIfAbsent(operationName, k -> new ArrayList<>()).add(duration);\n            \n            // Check for slow operations\n            if (durationMs > 10.0) { // More than 10ms\n                debugger.observeProblem(\"Slow operation: \" + operationName + \" took \" + String.format(\"%.2f\", durationMs) + \"ms\");\n            }\n        }\n    }"
    },
    {
      "type": "text",
      "title": "Understanding Operation Tracking",
      "content": "The operation tracking methods allow you to measure how long specific operations take. You can wrap any code section with startOperation() and endOperation() calls to identify which parts of your code are causing performance issues."
    },
    {
      "type": "code",
      "title": "Performance Monitor - Analysis and Reporting",
      "content": "Add methods for analyzing and reporting performance data:",
      "code": "    public void analyzePerformance(Telemetry telemetry) {\n        telemetry.addLine(\"=== PERFORMANCE ANALYSIS ===\");\n        telemetry.addData(\"Loop Count\", loopCount);\n        telemetry.addData(\"Average Loop Time\", String.format(\"%.2fms\", averageLoopTime));\n        telemetry.addData(\"Max Loop Time\", String.format(\"%.2fms\", maxLoopTime));\n        \n        if (averageLoopTime > 20.0) {\n            telemetry.addLine(\"WARNING: Average loop time is high!\");\n        }\n        \n        telemetry.addLine(\"\\nOperation Analysis:\");\n        for (Map.Entry<String, List<Long>> entry : operationDurations.entrySet()) {\n            String operation = entry.getKey();\n            List<Long> durations = entry.getValue();\n            \n            if (durations.size() > 0) {\n                double avgDuration = durations.stream().mapToLong(Long::longValue).average().orElse(0) / 1_000_000.0;\n                double maxDuration = durations.stream().mapToLong(Long::longValue).max().orElse(0) / 1_000_000.0;\n                \n                telemetry.addData(operation, String.format(\"Avg: %.2fms, Max: %.2fms, Count: %d\", \n                    avgDuration, maxDuration, durations.size()));\n            }\n        }\n        \n        telemetry.update();\n    }\n    \n    public void reset() {\n        operationStartTimes.clear();\n        operationDurations.clear();\n        loopCount = 0;\n        averageLoopTime = 0.0;\n        maxLoopTime = 0.0;\n    }\n}"
    },
    {
      "type": "text",
      "title": "Understanding Performance Analysis",
      "content": "The analyzePerformance method provides detailed statistics about your code's performance. It shows average and maximum loop times, and breaks down the performance of individual operations. This helps you identify which parts of your code need optimization."
    },
    {
      "type": "text",
      "title": "Competition Debugging Strategies",
      "content": "Competition environments require different debugging strategies. You have limited time and need to work quickly and efficiently."
    },
    {
      "type": "rules-box",
      "title": "Competition Debugging Checklist",
      "items": [
        "Have a pre-competition debugging checklist ready",
        "Use quick diagnostic tools that provide immediate feedback",
        "Keep debugging logs concise but informative",
        "Have backup strategies for common failure modes",
        "Practice debugging under time pressure before competition",
        "Document successful debugging approaches for future reference"
      ]
    },
    {
      "type": "code",
      "title": "Competition Debugger - Basic Structure",
      "content": "Create lightweight debugging tools for competition use. This class provides quick diagnostics for competition environments:",
      "code": "public class CompetitionDebugger {\n    private Telemetry telemetry;\n    private boolean quickMode = true; // Competition mode\n    private Map<String, Object> lastValues = new HashMap<>();\n    \n    public CompetitionDebugger(Telemetry telemetry) {\n        this.telemetry = telemetry;\n    }\n    \n    /**\n     * Quick hardware check for competition\n     */\n    public boolean quickHardwareCheck(HardwareMap hardwareMap) {\n        telemetry.addLine(\"=== QUICK HARDWARE CHECK ===\");\n        \n        boolean allOK = true;\n        \n        // Check motors\n        try {\n            DcMotor leftMotor = hardwareMap.get(DcMotor.class, \"left_motor\");\n            DcMotor rightMotor = hardwareMap.get(DcMotor.class, \"right_motor\");\n            leftMotor.setPower(0.0);\n            rightMotor.setPower(0.0);\n            telemetry.addData(\"Motors\", \"OK\");\n        } catch (Exception e) {\n            telemetry.addData(\"Motors\", \"FAIL: \" + e.getMessage());\n            allOK = false;\n        }\n        \n        // Check sensors\n        try {\n            ColorSensor colorSensor = hardwareMap.get(ColorSensor.class, \"color_sensor\");\n            int red = colorSensor.red();\n            telemetry.addData(\"Color Sensor\", \"OK (R=\" + red + \")\");\n        } catch (Exception e) {\n            telemetry.addData(\"Color Sensor\", \"FAIL: \" + e.getMessage());\n            allOK = false;\n        }\n        \n        telemetry.addData(\"Overall Status\", allOK ? \"READY\" : \"ISSUES DETECTED\");\n        telemetry.update();\n        \n        return allOK;\n    }"
    },
    {
      "type": "text",
      "title": "Understanding Competition Debugging",
      "content": "The competition debugger provides quick, essential diagnostics that can be run rapidly during competition. It focuses on the most critical hardware components and provides immediate feedback about their status."
    },
    {
      "type": "code",
      "title": "Competition Debugger - Monitoring and Display Methods",
      "content": "Add methods for monitoring values and displaying competition status:",
      "code": "    /**\n     * Monitor critical values for changes\n     */\n    public void monitorValue(String name, Object value) {\n        Object lastValue = lastValues.get(name);\n        if (!Objects.equals(lastValue, value)) {\n            telemetry.addData(name + \" (CHANGED)\", value);\n            lastValues.put(name, value);\n        } else {\n            telemetry.addData(name, value);\n        }\n    }\n    \n    /**\n     * Quick state display for competition\n     */\n    public void displayState(String state, double time, String... additionalInfo) {\n        telemetry.clear();\n        telemetry.addLine(\"=== COMPETITION STATUS ===\");\n        telemetry.addData(\"State\", state);\n        telemetry.addData(\"Time\", String.format(\"%.1fs\", time));\n        \n        for (String info : additionalInfo) {\n            telemetry.addLine(info);\n        }\n        \n        telemetry.update();\n    }\n    \n    /**\n     * Emergency stop with debugging info\n     */\n    public void emergencyStop(String reason, DcMotor... motors) {\n        telemetry.addLine(\"!!! EMERGENCY STOP !!!\");\n        telemetry.addData(\"Reason\", reason);\n        \n        for (DcMotor motor : motors) {\n            motor.setPower(0.0);\n        }\n        \n        telemetry.update();\n    }\n}"
    },
    {
      "type": "text",
      "title": "Understanding Competition Monitoring",
      "content": "The monitoring methods help track critical values during competition. The monitorValue method highlights when values change, making it easy to spot unexpected behavior. The displayState method provides a clean competition status display, and emergencyStop provides a safe way to stop the robot with debugging information."
    },
    {
      "type": "code",
      "title": "Complete Performance and Competition Debugging Example",
      "content": "Here's the complete performance monitoring and competition debugging example:",
      "code": "import com.qualcomm.robotcore.eventloop.opmode.OpMode;\nimport com.qualcomm.robotcore.eventloop.opmode.TeleOp;\nimport com.qualcomm.robotcore.hardware.DcMotor;\nimport com.qualcomm.robotcore.hardware.ColorSensor;\nimport android.util.Log;\nimport java.util.*;\n\n@TeleOp(name = \"Performance and Competition Debugging Example\")\npublic class PerformanceAndCompetitionDebuggingExample extends OpMode {\n    private PerformanceMonitor performanceMonitor;\n    private CompetitionDebugger competitionDebugger;\n    private DebuggingFramework debugger;\n    \n    private DcMotor leftMotor, rightMotor;\n    private ColorSensor colorSensor;\n    private int loopCount = 0;\n    \n    @Override\n    public void init() {\n        debugger = new DebuggingFramework();\n        performanceMonitor = new PerformanceMonitor(debugger);\n        competitionDebugger = new CompetitionDebugger(telemetry);\n        \n        // Quick hardware check for competition\n        boolean hardwareOK = competitionDebugger.quickHardwareCheck(hardwareMap);\n        \n        if (!hardwareOK) {\n            debugger.observeProblem(\"Hardware check failed\", \"Hardware issues detected\");\n            return;\n        }\n        \n        // Initialize hardware\n        leftMotor = hardwareMap.get(DcMotor.class, \"left_motor\");\n        rightMotor = hardwareMap.get(DcMotor.class, \"right_motor\");\n        colorSensor = hardwareMap.get(ColorSensor.class, \"color_sensor\");\n        \n        debugger.documentConclusion(\"Hardware initialized successfully\", \"Ready for operation\");\n    }\n    \n    @Override\n    public void loop() {\n        performanceMonitor.startLoop();\n        \n        // Monitor gamepad input\n        performanceMonitor.startOperation(\"gamepad_processing\");\n        double leftStickY = gamepad1.left_stick_y;\n        double rightStickY = gamepad1.right_stick_y;\n        performanceMonitor.endOperation(\"gamepad_processing\");\n        \n        // Monitor motor control\n        performanceMonitor.startOperation(\"motor_control\");\n        leftMotor.setPower(leftStickY);\n        rightMotor.setPower(rightStickY);\n        performanceMonitor.endOperation(\"motor_control\");\n        \n        // Monitor sensor reading\n        performanceMonitor.startOperation(\"sensor_reading\");\n        int red = colorSensor.red();\n        int green = colorSensor.green();\n        int blue = colorSensor.blue();\n        performanceMonitor.endOperation(\"sensor_reading\");\n        \n        // Competition monitoring\n        competitionDebugger.monitorValue(\"Left Stick Y\", leftStickY);\n        competitionDebugger.monitorValue(\"Right Stick Y\", rightStickY);\n        competitionDebugger.monitorValue(\"Color Red\", red);\n        \n        // Emergency stop check\n        if (gamepad1.back) {\n            competitionDebugger.emergencyStop(\"Back button pressed\", leftMotor, rightMotor);\n            return;\n        }\n        \n        // Display performance analysis every 100 loops\n        if (loopCount % 100 == 0) {\n            performanceMonitor.analyzePerformance(telemetry);\n        }\n        \n        // Display competition status\n        competitionDebugger.displayState(\"TeleOp Running\", getRuntime(), \n            \"Loop: \" + loopCount,\n            \"Motors: \" + leftMotor.getPower() + \", \" + rightMotor.getPower()\n        );\n        \n        performanceMonitor.endLoop();\n        loopCount++;\n    }\n    \n    // Performance Monitor Class\n    public static class PerformanceMonitor {\n        private Map<String, Long> operationStartTimes = new HashMap<>();\n        private Map<String, List<Long>> operationDurations = new HashMap<>();\n        private long loopStartTime;\n        private int loopCount = 0;\n        private double averageLoopTime = 0.0;\n        private double maxLoopTime = 0.0;\n        private DebuggingFramework debugger;\n        \n        public PerformanceMonitor(DebuggingFramework debugger) {\n            this.debugger = debugger;\n        }\n        \n        public void startLoop() {\n            loopStartTime = System.nanoTime();\n            loopCount++;\n        }\n        \n        public void endLoop() {\n            long loopDuration = System.nanoTime() - loopStartTime;\n            double loopTimeMs = loopDuration / 1_000_000.0;\n            \n            averageLoopTime = (averageLoopTime * (loopCount - 1) + loopTimeMs) / loopCount;\n            maxLoopTime = Math.max(maxLoopTime, loopTimeMs);\n            \n            if (loopTimeMs > 50.0) {\n                debugger.observeProblem(\"Slow loop detected: \" + String.format(\"%.2f\", loopTimeMs) + \"ms\");\n                debugger.formHypothesis(\"Loop taking too long\", \"Check for expensive operations in loop\");\n            }\n        }\n        \n        public void startOperation(String operationName) {\n            operationStartTimes.put(operationName, System.nanoTime());\n        }\n        \n        public void endOperation(String operationName) {\n            Long startTime = operationStartTimes.remove(operationName);\n            if (startTime != null) {\n                long duration = System.nanoTime() - startTime;\n                double durationMs = duration / 1_000_000.0;\n                \n                operationDurations.computeIfAbsent(operationName, k -> new ArrayList<>()).add(duration);\n                \n                if (durationMs > 10.0) {\n                    debugger.observeProblem(\"Slow operation: \" + operationName + \" took \" + String.format(\"%.2f\", durationMs) + \"ms\");\n                }\n            }\n        }\n        \n        public void analyzePerformance(Telemetry telemetry) {\n            telemetry.addLine(\"=== PERFORMANCE ANALYSIS ===\");\n            telemetry.addData(\"Loop Count\", loopCount);\n            telemetry.addData(\"Average Loop Time\", String.format(\"%.2fms\", averageLoopTime));\n            telemetry.addData(\"Max Loop Time\", String.format(\"%.2fms\", maxLoopTime));\n            \n            if (averageLoopTime > 20.0) {\n                telemetry.addLine(\"WARNING: Average loop time is high!\");\n            }\n            \n            telemetry.addLine(\"\\nOperation Analysis:\");\n            for (Map.Entry<String, List<Long>> entry : operationDurations.entrySet()) {\n                String operation = entry.getKey();\n                List<Long> durations = entry.getValue();\n                \n                if (durations.size() > 0) {\n                    double avgDuration = durations.stream().mapToLong(Long::longValue).average().orElse(0) / 1_000_000.0;\n                    double maxDuration = durations.stream().mapToLong(Long::longValue).max().orElse(0) / 1_000_000.0;\n                    \n                    telemetry.addData(operation, String.format(\"Avg: %.2fms, Max: %.2fms, Count: %d\", \n                        avgDuration, maxDuration, durations.size()));\n                }\n            }\n            \n            telemetry.update();\n        }\n        \n        public void reset() {\n            operationStartTimes.clear();\n            operationDurations.clear();\n            loopCount = 0;\n            averageLoopTime = 0.0;\n            maxLoopTime = 0.0;\n        }\n    }\n    \n    // Competition Debugger Class\n    public static class CompetitionDebugger {\n        private Telemetry telemetry;\n        private boolean quickMode = true;\n        private Map<String, Object> lastValues = new HashMap<>();\n        \n        public CompetitionDebugger(Telemetry telemetry) {\n            this.telemetry = telemetry;\n        }\n        \n        public boolean quickHardwareCheck(HardwareMap hardwareMap) {\n            telemetry.addLine(\"=== QUICK HARDWARE CHECK ===\");\n            \n            boolean allOK = true;\n            \n            try {\n                DcMotor leftMotor = hardwareMap.get(DcMotor.class, \"left_motor\");\n                DcMotor rightMotor = hardwareMap.get(DcMotor.class, \"right_motor\");\n                leftMotor.setPower(0.0);\n                rightMotor.setPower(0.0);\n                telemetry.addData(\"Motors\", \"OK\");\n            } catch (Exception e) {\n                telemetry.addData(\"Motors\", \"FAIL: \" + e.getMessage());\n                allOK = false;\n            }\n            \n            try {\n                ColorSensor colorSensor = hardwareMap.get(ColorSensor.class, \"color_sensor\");\n                int red = colorSensor.red();\n                telemetry.addData(\"Color Sensor\", \"OK (R=\" + red + \")\");\n            } catch (Exception e) {\n                telemetry.addData(\"Color Sensor\", \"FAIL: \" + e.getMessage());\n                allOK = false;\n            }\n            \n            telemetry.addData(\"Overall Status\", allOK ? \"READY\" : \"ISSUES DETECTED\");\n            telemetry.update();\n            \n            return allOK;\n        }\n        \n        public void monitorValue(String name, Object value) {\n            Object lastValue = lastValues.get(name);\n            if (!Objects.equals(lastValue, value)) {\n                telemetry.addData(name + \" (CHANGED)\", value);\n                lastValues.put(name, value);\n            } else {\n                telemetry.addData(name, value);\n            }\n        }\n        \n        public void displayState(String state, double time, String... additionalInfo) {\n            telemetry.clear();\n            telemetry.addLine(\"=== COMPETITION STATUS ===\");\n            telemetry.addData(\"State\", state);\n            telemetry.addData(\"Time\", String.format(\"%.1fs\", time));\n            \n            for (String info : additionalInfo) {\n                telemetry.addLine(info);\n            }\n            \n            telemetry.update();\n        }\n        \n        public void emergencyStop(String reason, DcMotor... motors) {\n            telemetry.addLine(\"!!! EMERGENCY STOP !!!\");\n            telemetry.addData(\"Reason\", reason);\n            \n            for (DcMotor motor : motors) {\n                motor.setPower(0.0);\n            }\n            \n            telemetry.update();\n        }\n    }\n    \n    // Debugging Framework Class (from previous example)\n    public static class DebuggingFramework {\n        private static final String TAG = \"DebugFramework\";\n        private boolean debugMode = true;\n        private List<String> debugLog = new ArrayList<>();\n        \n        public void observeProblem(String problemDescription, Object... data) {\n            String observation = String.format(\"OBSERVATION: %s | Data: %s\", \n                                              problemDescription, \n                                              Arrays.toString(data));\n            logDebug(observation);\n            debugLog.add(observation);\n        }\n        \n        public void formHypothesis(String hypothesis, String expectedOutcome) {\n            String hypothesisEntry = String.format(\"HYPOTHESIS: %s | Expected: %s\", \n                                                  hypothesis, \n                                                  expectedOutcome);\n            logDebug(hypothesisEntry);\n            debugLog.add(hypothesisEntry);\n        }\n        \n        public void testHypothesis(String testDescription, boolean result, Object actualOutcome) {\n            String testResult = String.format(\"TEST: %s | Result: %s | Actual: %s\", \n                                             testDescription, \n                                             result ? \"PASS\" : \"FAIL\", \n                                             actualOutcome);\n            logDebug(testResult);\n            debugLog.add(testResult);\n        }\n        \n        public void documentConclusion(String conclusion, String nextSteps) {\n            String conclusionEntry = String.format(\"CONCLUSION: %s | Next: %s\", \n                                                  conclusion, \n                                                  nextSteps);\n            logDebug(conclusionEntry);\n            debugLog.add(conclusionEntry);\n        }\n        \n        private void logDebug(String message) {\n            if (debugMode) {\n                Log.d(TAG, message);\n            }\n        }\n        \n        public List<String> getDebugLog() {\n            return new ArrayList<>(debugLog);\n        }\n        \n        public void clearDebugLog() {\n            debugLog.clear();\n        }\n    }\n}"
    },
    {
      "type": "exercise-box",
      "title": "Debugging Strategy Practice Exercise",
      "description": "Create a comprehensive debugging system for a complex robot behavior and practice systematic debugging approaches.",
      "tasks": [
        "Create a robot behavior that combines multiple sensors and actuators",
        "Implement the scientific method debugging framework",
        "Add performance monitoring to identify bottlenecks",
        "Create competition-ready debugging tools",
        "Write a debugging checklist for common failure modes",
        "Practice debugging the system with intentional bugs",
        "Document your debugging process and findings"
      ],
      "content": "// Example: Robot searches for an object using a color sensor, approaches it, grabs it with a servo, and returns\nimport com.qualcomm.robotcore.eventloop.opmode.OpMode;\nimport com.qualcomm.robotcore.eventloop.opmode.TeleOp;\nimport com.qualcomm.robotcore.hardware.DcMotor;\nimport com.qualcomm.robotcore.hardware.Servo;\nimport com.qualcomm.robotcore.hardware.ColorSensor;\n\n@TeleOp(name = \"DebuggingExercise\")\npublic class DebuggingExerciseOpMode extends OpMode {\n    private DcMotor leftMotor, rightMotor;\n    private Servo grabberServo;\n    private ColorSensor colorSensor;\n    private enum RobotState { INIT, SEARCH, APPROACH, GRAB, RETURN, COMPLETE }\n    private RobotState currentState = RobotState.INIT;\n    private double startTime = 0.0;\n    \n    @Override\n    public void init() {\n        leftMotor = hardwareMap.get(DcMotor.class, \"left_motor\");\n        rightMotor = hardwareMap.get(DcMotor.class, \"right_motor\");\n        grabberServo = hardwareMap.get(Servo.class, \"grabber_servo\");\n        colorSensor = hardwareMap.get(ColorSensor.class, \"color_sensor\");\n        currentState = RobotState.SEARCH;\n    }\n    \n    @Override\n    public void loop() {\n        switch (currentState) {\n            case SEARCH:\n                // Search for red object\n                if (colorSensor.red() > 100) {\n                    currentState = RobotState.APPROACH;\n                    startTime = getRuntime();\n                } else {\n                    leftMotor.setPower(0.2);\n                    rightMotor.setPower(0.2);\n                }\n                break;\n            case APPROACH:\n                // Approach for 2 seconds\n                if (getRuntime() - startTime > 2.0) {\n                    currentState = RobotState.GRAB;\n                } else {\n                    leftMotor.setPower(0.3);\n                    rightMotor.setPower(0.3);\n                }\n                break;\n            case GRAB:\n                grabberServo.setPosition(1.0); // Close grabber\n                currentState = RobotState.RETURN;\n                startTime = getRuntime();\n                break;\n            case RETURN:\n                // Return for 2 seconds\n                if (getRuntime() - startTime > 2.0) {\n                    currentState = RobotState.COMPLETE;\n                } else {\n                    leftMotor.setPower(-0.3);\n                    rightMotor.setPower(-0.3);\n                }\n                break;\n            case COMPLETE:\n                leftMotor.setPower(0);\n                rightMotor.setPower(0);\n                break;\n        }\n    }\n}\n\n// This code combines multiple actuators (motors, servo) and a sensor (color sensor) in a state machine.",
      "answers": [
        {
          "task": "Implement the scientific method debugging framework",
          "content": "// Integrate the DebuggingFramework to document observations, hypotheses, tests, and conclusions\nprivate DebuggingFramework debugger = new DebuggingFramework();\n\nprivate void observeAndDebug() {\n    debugger.observeProblem(\"Robot started searching for object\");\n    debugger.formHypothesis(\"Object will be detected when red > 100\", \"Color sensor red value exceeds 100\");\n    // ... after detection\n    debugger.testHypothesis(\"Color sensor detects red\", colorSensor.red() > 100, colorSensor.red());\n    debugger.documentConclusion(\"Object found\", \"Proceed to approach\");\n}\n\n// Call these methods at each state transition to document the debugging process."
        },
        {
          "task": "Add performance monitoring to identify bottlenecks",
          "content": "// Use PerformanceMonitor to track loop and operation timing\nprivate PerformanceMonitor performanceMonitor = new PerformanceMonitor(debugger);\n\n@Override\npublic void loop() {\n    performanceMonitor.startLoop();\n    // ... robot logic ...\n    performanceMonitor.endLoop();\n    if (loopCount % 100 == 0) {\n        performanceMonitor.analyzePerformance(telemetry);\n    }\n}\n\n// Wrap expensive operations:\nperformanceMonitor.startOperation(\"sensor_reading\");\nint red = colorSensor.red();\nperformanceMonitor.endOperation(\"sensor_reading\");\n// This helps identify slow operations."
        },
        {
          "task": "Create competition-ready debugging tools",
          "content": "// Use CompetitionDebugger for quick checks and emergency stops\nprivate CompetitionDebugger competitionDebugger = new CompetitionDebugger(telemetry);\n\n@Override\npublic void init() {\n    boolean hardwareOK = competitionDebugger.quickHardwareCheck(hardwareMap);\n    if (!hardwareOK) {\n        telemetry.addData(\"Error\", \"Hardware check failed\");\n    }\n}\n\n@Override\npublic void loop() {\n    competitionDebugger.monitorValue(\"Left Motor Power\", leftMotor.getPower());\n    competitionDebugger.monitorValue(\"Color Red\", colorSensor.red());\n    if (gamepad1.back) {\n        competitionDebugger.emergencyStop(\"Back button pressed\", leftMotor, rightMotor);\n        return;\n    }\n}\n// These tools provide fast diagnostics and safe emergency handling during competition."
        },
        {
          "task": "Write a debugging checklist for common failure modes",
          "content": "// Example checklist:\n1. Verify all hardware is configured correctly in the configuration file.\n2. Run quick hardware check before each match.\n3. Check sensor readings in telemetry before starting.\n4. Use debug logs to confirm state transitions.\n5. Monitor loop timing for performance issues.\n6. Have a backup plan for hardware failures (e.g., swap motors, sensors).\n7. Document any issues and solutions for future reference."
        },
        {
          "task": "Practice debugging the system with intentional bugs",
          "content": "// Example: Introduce a bug in the approach state\ncase APPROACH:\n    // BUG: Wrong time threshold (should be 2.0)\n    if (getRuntime() - startTime > 0.5) { // Too short, robot doesn't approach long enough\n        currentState = RobotState.GRAB;\n    } else {\n        leftMotor.setPower(0.3);\n        rightMotor.setPower(0.3);\n    }\n    break;\n// Use conditional breakpoints and watch expressions to catch the bug:\n// - Set a breakpoint on the if condition with: getRuntime() - startTime > 0.5\n// - Watch variables: currentState, startTime, getRuntime(), leftMotor.getPower()\n// - Use logs to confirm the bug triggers too early."
        },
        {
          "task": "Document your debugging process and findings",
          "content": "// Example documentation:\n- Observed that the robot did not approach the object long enough.\n- Hypothesized that the time threshold was too short.\n- Set a conditional breakpoint on the approach state.\n- Confirmed that the transition occurred at 0.5s instead of 2.0s.\n- Fixed the bug by changing the threshold to 2.0.\n- Verified correct behavior with logs and telemetry.\n- Added this scenario to the debugging checklist for future reference."
        }
      ]
    },
    {
      "type": "link-grid",
      "title": "Additional Resources",
      "links": [
        "<a href=\"https://developer.android.com/studio/debug\" target=\"_blank\">Android Studio Debugging Guide</a>",
        "<a href=\"https://developer.android.com/studio/profile\" target=\"_blank\">Android Studio Profiler</a>"
      ]
    }
  ]
}