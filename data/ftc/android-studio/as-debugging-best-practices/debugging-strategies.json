{
  "title": "Debugging Strategies for FTC Development",
  "sections": [
    {
      "type": "text",
      "title": "Introduction to Systematic Debugging",
      "content": "Effective debugging is not just about finding bugsâ€”it's about developing a systematic approach to problem-solving. In FTC development, you need strategies that work both in the lab and under competition pressure. This lesson teaches you how to approach debugging methodically and efficiently."
    },
    {
      "type": "rules-box",
      "title": "Why Systematic Debugging Matters",
      "items": [
        "FTC competitions have limited time for debugging and testing",
        "Hardware-software interactions create complex failure modes",
        "Systematic approaches prevent you from making the same mistakes",
        "Good debugging skills transfer to other programming domains",
        "Competition environments require quick problem resolution"
      ]
    },
    {
      "type": "text",
      "title": "The Scientific Method of Debugging",
      "content": "Apply the scientific method to debugging: observe the problem, form a hypothesis, test it, and refine your understanding. This systematic approach helps you avoid random trial-and-error debugging."
    },
    {
      "type": "code",
      "title": "Debugging Framework - Core Structure",
      "content": "Implement a structured debugging process in your code. This framework provides a systematic approach to debugging by following the scientific method. The framework tracks observations, hypotheses, tests, and conclusions:",
      "code": "public class DebuggingFramework {\n    private static final String TAG = \"DebugFramework\";\n    private boolean debugMode = true;\n    private List<String> debugLog = new ArrayList<>();\n    \n    /**\n     * Step 1: Observe and Document the Problem\n     */\n    public void observeProblem(String problemDescription, Object... data) {\n        String observation = String.format(\"OBSERVATION: %s | Data: %s\", \n                                          problemDescription, \n                                          Arrays.toString(data));\n        logDebug(observation);\n        debugLog.add(observation);\n    }\n    \n    /**\n     * Step 2: Form a Hypothesis\n     */\n    public void formHypothesis(String hypothesis, String expectedOutcome) {\n        String hypothesisEntry = String.format(\"HYPOTHESIS: %s | Expected: %s\", \n                                              hypothesis, \n                                              expectedOutcome);\n        logDebug(hypothesisEntry);\n        debugLog.add(hypothesisEntry);\n    }"
    },
    {
      "type": "text",
      "title": "Understanding the Scientific Method in Debugging",
      "content": "The scientific method provides a systematic approach to debugging. First, you observe and document the problem with specific data. Then you form a hypothesis about what might be causing the issue. This structured approach prevents random trial-and-error debugging."
    },
    {
      "type": "code",
      "title": "Debugging Framework - Testing and Conclusion Methods",
      "content": "Add methods for testing hypotheses and documenting conclusions. These methods complete the scientific method cycle by testing your hypothesis and recording the results:",
      "code": "    /**\n     * Step 3: Test the Hypothesis\n     */\n    public void testHypothesis(String testDescription, boolean result, Object actualOutcome) {\n        String testResult = String.format(\"TEST: %s | Result: %s | Actual: %s\", \n                                         testDescription, \n                                         result ? \"PASS\" : \"FAIL\", \n                                         actualOutcome);\n        logDebug(testResult);\n        debugLog.add(testResult);\n    }\n    \n    /**\n     * Step 4: Document the Conclusion\n     */\n    public void documentConclusion(String conclusion, String nextSteps) {\n        String conclusionEntry = String.format(\"CONCLUSION: %s | Next: %s\", \n                                              conclusion, \n                                              nextSteps);\n        logDebug(conclusionEntry);\n        debugLog.add(conclusionEntry);\n    }\n    \n    private void logDebug(String message) {\n        if (debugMode) {\n            Log.d(TAG, message);\n        }\n    }\n    \n    public List<String> getDebugLog() {\n        return new ArrayList<>(debugLog);\n    }\n    \n    public void clearDebugLog() {\n        debugLog.clear();\n    }\n}"
    },
    {
      "type": "text",
      "title": "Completing the Debugging Cycle",
      "content": "The testing and conclusion methods complete the debugging cycle. Testing verifies whether your hypothesis was correct, and conclusions document what you learned and what steps to take next. This creates a record that helps with future debugging and team communication."
    },
    {
      "type": "text",
      "title": "Common FTC Debugging Scenarios",
      "content": "FTC development has specific challenges that require targeted debugging strategies. Understanding these common scenarios helps you develop effective debugging approaches."
    },
    {
      "type": "code",
      "title": "Hardware Debugger - Basic Structure",
      "content": "Hardware connection issues are common in FTC. Here's a systematic approach to debugging them. This class provides methods to test hardware connections systematically:",
      "code": "public class HardwareDebugger {\n    private HardwareMap hardwareMap;\n    private Telemetry telemetry;\n    private DebuggingFramework debugger;\n    \n    public HardwareDebugger(HardwareMap hardwareMap, Telemetry telemetry) {\n        this.hardwareMap = hardwareMap;\n        this.telemetry = telemetry;\n        this.debugger = new DebuggingFramework();\n    }\n    \n    public boolean debugMotorConnection(String motorName) {\n        debugger.observeProblem(\"Motor \" + motorName + \" not responding\");\n        \n        // Step 1: Check if motor exists in hardware map\n        debugger.formHypothesis(\"Motor not found in hardware map\", \"HardwareMap.get() throws exception\");\n        \n        try {\n            DcMotor motor = hardwareMap.get(DcMotor.class, motorName);\n            debugger.testHypothesis(\"Motor exists in hardware map\", true, motor.getDeviceName());\n            \n            // Step 2: Check if motor responds to basic commands\n            debugger.formHypothesis(\"Motor hardware connection issue\", \"setPower() should work without exception\");\n            \n            try {\n                motor.setPower(0.1);\n                Thread.sleep(100); // Brief test\n                motor.setPower(0.0);\n                debugger.testHypothesis(\"Motor responds to commands\", true, \"Power set successfully\");\n                \n                debugger.documentConclusion(\"Motor connection is working\", \"Check software logic\");\n                return true;\n                \n            } catch (Exception e) {\n                debugger.testHypothesis(\"Motor responds to commands\", false, e.getMessage());\n                debugger.documentConclusion(\"Motor hardware connection issue\", \"Check wiring and power\");\n                return false;\n            }\n            \n        } catch (Exception e) {\n            debugger.testHypothesis(\"Motor exists in hardware map\", false, e.getMessage());\n            debugger.documentConclusion(\"Motor not configured in hardware map\", \"Check configuration file\");\n            return false;\n        }\n    }"
    },
    {
      "type": "code",
      "title": "Hardware Debugger - Sensor Connection Methods",
      "content": "Add methods for debugging sensor connections. These methods handle different types of sensors:",
      "code": "    public boolean debugSensorConnection(String sensorName, Class<?> sensorType) {\n        debugger.observeProblem(\"Sensor \" + sensorName + \" not providing data\");\n        \n        try {\n            Object sensor = hardwareMap.get(sensorType, sensorName);\n            debugger.testHypothesis(\"Sensor exists in hardware map\", true, sensor.getClass().getSimpleName());\n            \n            // Test sensor functionality based on type\n            if (sensor instanceof ColorSensor) {\n                return debugColorSensor((ColorSensor) sensor, sensorName);\n            } else if (sensor instanceof TouchSensor) {\n                return debugTouchSensor((TouchSensor) sensor, sensorName);\n            } else if (sensor instanceof DistanceSensor) {\n                return debugDistanceSensor((DistanceSensor) sensor, sensorName);\n            }\n            \n            return true;\n            \n        } catch (Exception e) {\n            debugger.testHypothesis(\"Sensor exists in hardware map\", false, e.getMessage());\n            debugger.documentConclusion(\"Sensor not configured\", \"Check configuration file\");\n            return false;\n        }\n    }"
    },
    {
      "type": "code",
      "title": "Hardware Debugger - Specific Sensor Debug Methods",
      "content": "Add specific debugging methods for different sensor types. Each method tests the sensor's basic functionality:",
      "code": "    private boolean debugColorSensor(ColorSensor sensor, String sensorName) {\n        debugger.formHypothesis(\"Color sensor not reading values\", \"getRed(), getGreen(), getBlue() should return values\");\n        \n        try {\n            int red = sensor.red();\n            int green = sensor.green();\n            int blue = sensor.blue();\n            \n            String reading = String.format(\"R:%d G:%d B:%d\", red, green, blue);\n            debugger.testHypothesis(\"Color sensor reading values\", true, reading);\n            \n            debugger.documentConclusion(\"Color sensor working\", \"Check sensor positioning and lighting\");\n            return true;\n            \n        } catch (Exception e) {\n            debugger.testHypothesis(\"Color sensor reading values\", false, e.getMessage());\n            debugger.documentConclusion(\"Color sensor hardware issue\", \"Check wiring and power\");\n            return false;\n        }\n    }\n    \n    private boolean debugTouchSensor(TouchSensor sensor, String sensorName) {\n        debugger.formHypothesis(\"Touch sensor not responding\", \"isPressed() should return boolean\");\n        \n        try {\n            boolean isPressed = sensor.isPressed();\n            debugger.testHypothesis(\"Touch sensor responding\", true, \"Pressed: \" + isPressed);\n            \n            debugger.documentConclusion(\"Touch sensor working\", \"Test with physical touch\");\n            return true;\n            \n        } catch (Exception e) {\n            debugger.testHypothesis(\"Touch sensor responding\", false, e.getMessage());\n            debugger.documentConclusion(\"Touch sensor hardware issue\", \"Check wiring and mounting\");\n            return false;\n        }\n    }\n    \n    private boolean debugDistanceSensor(DistanceSensor sensor, String sensorName) {\n        debugger.formHypothesis(\"Distance sensor not reading\", \"getDistance() should return distance value\");\n        \n        try {\n            double distance = sensor.getDistance(DistanceUnit.INCH);\n            debugger.testHypothesis(\"Distance sensor reading\", true, \"Distance: \" + distance + \" inches\");\n            \n            debugger.documentConclusion(\"Distance sensor working\", \"Check sensor positioning and calibration\");\n            return true;\n            \n        } catch (Exception e) {\n            debugger.testHypothesis(\"Distance sensor reading\", false, e.getMessage());\n            debugger.documentConclusion(\"Distance sensor hardware issue\", \"Check wiring and power\");\n            return false;\n        }\n    }\n    \n    public void printDebugLog() {\n        List<String> log = debugger.getDebugLog();\n        telemetry.addLine(\"=== HARDWARE DEBUG LOG ===\");\n        for (String entry : log) {\n            telemetry.addLine(entry);\n        }\n        telemetry.update();\n    }\n}"
    },
    {
      "type": "text",
      "title": "State Machine Debugging",
      "content": "State machines are common in FTC autonomous programs but can be difficult to debug. Use systematic approaches to track state transitions and identify issues."
    },
    {
      "type": "code",
      "title": "Debuggable State Machine - Core Structure",
      "content": "Create a debuggable state machine that tracks transitions and conditions. This class provides comprehensive debugging information for state machines:",
      "code": "public class DebuggableStateMachine<T extends Enum<T>> {\n    private T currentState;\n    private T previousState;\n    private double stateStartTime;\n    private double currentTime;\n    private List<StateTransition> transitionHistory = new ArrayList<>();\n    private DebuggingFramework debugger;\n    \n    public DebuggableStateMachine(T initialState, DebuggingFramework debugger) {\n        this.currentState = initialState;\n        this.previousState = initialState;\n        this.debugger = debugger;\n        this.stateStartTime = 0.0;\n        this.currentTime = 0.0;\n    }\n    \n    public void update(double time) {\n        this.currentTime = time;\n        \n        // Log state duration if it's been too long\n        double stateDuration = time - stateStartTime;\n        if (stateDuration > 10.0) { // 10 second timeout\n            debugger.observeProblem(\"State \" + currentState + \" has been active for \" + stateDuration + \" seconds\");\n            debugger.formHypothesis(\"State transition condition not met\", \"Check transition logic\");\n        }\n    }"
    },
    {
      "type": "code",
      "title": "Debuggable State Machine - Transition and History Methods",
      "content": "Add methods for managing state transitions and tracking history:",
      "code": "    public void transitionTo(T newState, String reason) {\n        if (newState != currentState) {\n            previousState = currentState;\n            double stateDuration = currentTime - stateStartTime;\n            \n            // Record the transition\n            StateTransition transition = new StateTransition(\n                previousState, newState, reason, stateDuration, currentTime\n            );\n            transitionHistory.add(transition);\n            \n            // Log the transition\n            debugger.observeProblem(\"State transition: \" + previousState + \" -> \" + newState + \" (\" + reason + \")\");\n            \n            currentState = newState;\n            stateStartTime = currentTime;\n        }\n    }\n    \n    public T getCurrentState() {\n        return currentState;\n    }\n    \n    public T getPreviousState() {\n        return previousState;\n    }\n    \n    public double getStateDuration() {\n        return currentTime - stateStartTime;\n    }\n    \n    public List<StateTransition> getTransitionHistory() {\n        return new ArrayList<>(transitionHistory);\n    }"
    },
    {
      "type": "code",
      "title": "Debuggable State Machine - Debug Display and Helper Class",
      "content": "Add debug display methods and the StateTransition helper class:",
      "code": "    public void debugStateMachine(Telemetry telemetry) {\n        telemetry.addLine(\"=== STATE MACHINE DEBUG ===\");\n        telemetry.addData(\"Current State\", currentState);\n        telemetry.addData(\"Previous State\", previousState);\n        telemetry.addData(\"State Duration\", String.format(\"%.2fs\", getStateDuration()));\n        telemetry.addData(\"Total Time\", String.format(\"%.2fs\", currentTime));\n        \n        telemetry.addLine(\"\\nRecent Transitions:\");\n        int startIndex = Math.max(0, transitionHistory.size() - 5);\n        for (int i = startIndex; i < transitionHistory.size(); i++) {\n            StateTransition t = transitionHistory.get(i);\n            telemetry.addLine(String.format(\"%.1fs: %s -> %s (%s)\", \n                t.timestamp, t.fromState, t.toState, t.reason));\n        }\n        \n        telemetry.update();\n    }\n    \n    private static class StateTransition {\n        T fromState, toState;\n        String reason;\n        double duration, timestamp;\n        \n        StateTransition(T from, T to, String reason, double duration, double timestamp) {\n            this.fromState = from;\n            this.toState = to;\n            this.reason = reason;\n            this.duration = duration;\n            this.timestamp = timestamp;\n        }\n    }\n}"
    },
    {
      "type": "text",
      "title": "Using the Debuggable State Machine",
      "content": "Now let's see how to use the debuggable state machine in an actual autonomous OpMode. This example shows how to integrate the debugging framework with real robot behavior."
    },
    {
      "type": "code",
      "title": "Debuggable Autonomous OpMode - Setup and Initialization",
      "content": "Use the debuggable state machine in an autonomous OpMode. This example shows how to set up debugging for a complete autonomous sequence:",
      "code": "public class DebuggableAutonomousOpMode extends OpMode {\n    private enum AutonomousState {\n        INIT, DRIVE_FORWARD, TURN_LEFT, DETECT_COLOR, COMPLETE\n    }\n    \n    private DebuggableStateMachine<AutonomousState> stateMachine;\n    private DebuggingFramework debugger;\n    private HardwareDebugger hardwareDebugger;\n    \n    private DcMotor leftMotor, rightMotor;\n    private ColorSensor colorSensor;\n    private double startTime;\n    \n    @Override\n    public void init() {\n        debugger = new DebuggingFramework();\n        stateMachine = new DebuggableStateMachine<>(AutonomousState.INIT, debugger);\n        hardwareDebugger = new HardwareDebugger(hardwareMap, telemetry);\n        \n        // Debug hardware connections\n        debugger.observeProblem(\"Initializing autonomous sequence\");\n        \n        boolean motorsOK = hardwareDebugger.debugMotorConnection(\"left_motor\") &&\n                           hardwareDebugger.debugMotorConnection(\"right_motor\");\n        \n        boolean sensorOK = hardwareDebugger.debugSensorConnection(\"color_sensor\", ColorSensor.class);\n        \n        if (!motorsOK || !sensorOK) {\n            debugger.documentConclusion(\"Hardware issues detected\", \"Fix hardware before proceeding\");\n            return;\n        }\n        \n        // Initialize hardware\n        leftMotor = hardwareMap.get(DcMotor.class, \"left_motor\");\n        rightMotor = hardwareMap.get(DcMotor.class, \"right_motor\");\n        colorSensor = hardwareMap.get(ColorSensor.class, \"color_sensor\");\n        \n        debugger.documentConclusion(\"Hardware initialized successfully\", \"Ready to start autonomous\");\n    }"
    },
    {
      "type": "code",
      "title": "Debuggable Autonomous OpMode - Main Loop and State Handling",
      "content": "Add the main loop and state handling logic with comprehensive debugging:",
      "code": "    @Override\n    public void start() {\n        startTime = getRuntime();\n        stateMachine.transitionTo(AutonomousState.DRIVE_FORWARD, \"Starting autonomous sequence\");\n        debugger.observeProblem(\"Autonomous sequence started\");\n    }\n    \n    @Override\n    public void loop() {\n        double currentTime = getRuntime();\n        stateMachine.update(currentTime);\n        \n        AutonomousState currentState = stateMachine.getCurrentState();\n        \n        switch (currentState) {\n            case INIT:\n                // Should not reach here\n                debugger.observeProblem(\"Unexpected INIT state in loop\");\n                break;\n                \n            case DRIVE_FORWARD:\n                // Drive forward for 2 seconds\n                if (currentTime - startTime < 2.0) {\n                    leftMotor.setPower(0.5);\n                    rightMotor.setPower(0.5);\n                } else {\n                    leftMotor.setPower(0.0);\n                    rightMotor.setPower(0.0);\n                    stateMachine.transitionTo(AutonomousState.TURN_LEFT, \"Drive forward complete\");\n                }\n                break;\n                \n            case TURN_LEFT:\n                // Turn left for 1 second\n                if (stateMachine.getStateDuration() < 1.0) {\n                    leftMotor.setPower(-0.3);\n                    rightMotor.setPower(0.3);\n                } else {\n                    leftMotor.setPower(0.0);\n                    rightMotor.setPower(0.0);\n                    stateMachine.transitionTo(AutonomousState.DETECT_COLOR, \"Turn complete\");\n                }\n                break;\n                \n            case DETECT_COLOR:\n                // Check for red color\n                int red = colorSensor.red();\n                int green = colorSensor.green();\n                int blue = colorSensor.blue();\n                \n                if (red > green && red > blue && red > 100) {\n                    debugger.observeProblem(\"Red color detected: R=\" + red + \" G=\" + green + \" B=\" + blue);\n                    stateMachine.transitionTo(AutonomousState.COMPLETE, \"Red color detected\");\n                } else if (stateMachine.getStateDuration() > 5.0) {\n                    debugger.observeProblem(\"Color detection timeout after 5 seconds\");\n                    stateMachine.transitionTo(AutonomousState.COMPLETE, \"Color detection timeout\");\n                }\n                break;\n                \n            case COMPLETE:\n                // Stop all motors\n                leftMotor.setPower(0.0);\n                rightMotor.setPower(0.0);\n                \n                if (stateMachine.getStateDuration() > 1.0) {\n                    requestOpModeStop();\n                }\n                break;\n        }\n        \n        // Display debug information\n        stateMachine.debugStateMachine(telemetry);\n        telemetry.addLine(\"\");\n        hardwareDebugger.printDebugLog();\n    }\n}"
    },
    {
      "type": "text",
      "title": "Performance Debugging",
      "content": "Performance issues in FTC can cause missed commands, laggy telemetry, or unreliable autonomous behavior. Learn to identify and fix performance bottlenecks."
    },
    {
      "type": "code",
      "title": "Performance Monitor - Core Structure",
      "content": "Create a framework to monitor and debug performance issues. This class tracks loop timing and operation performance:",
      "code": "public class PerformanceMonitor {\n    private Map<String, Long> operationStartTimes = new HashMap<>();\n    private Map<String, List<Long>> operationDurations = new HashMap<>();\n    private long loopStartTime;\n    private int loopCount = 0;\n    private double averageLoopTime = 0.0;\n    private double maxLoopTime = 0.0;\n    private DebuggingFramework debugger;\n    \n    public PerformanceMonitor(DebuggingFramework debugger) {\n        this.debugger = debugger;\n    }\n    \n    public void startLoop() {\n        loopStartTime = System.nanoTime();\n        loopCount++;\n    }\n    \n    public void endLoop() {\n        long loopDuration = System.nanoTime() - loopStartTime;\n        double loopTimeMs = loopDuration / 1_000_000.0;\n        \n        // Update average loop time\n        averageLoopTime = (averageLoopTime * (loopCount - 1) + loopTimeMs) / loopCount;\n        maxLoopTime = Math.max(maxLoopTime, loopTimeMs);\n        \n        // Check for performance issues\n        if (loopTimeMs > 50.0) { // More than 50ms per loop\n            debugger.observeProblem(\"Slow loop detected: \" + String.format(\"%.2f\", loopTimeMs) + \"ms\");\n            debugger.formHypothesis(\"Loop taking too long\", \"Check for expensive operations in loop\");\n        }\n    }"
    },
    {
      "type": "code",
      "title": "Performance Monitor - Operation Tracking Methods",
      "content": "Add methods for tracking individual operation performance:",
      "code": "    public void startOperation(String operationName) {\n        operationStartTimes.put(operationName, System.nanoTime());\n    }\n    \n    public void endOperation(String operationName) {\n        Long startTime = operationStartTimes.remove(operationName);\n        if (startTime != null) {\n            long duration = System.nanoTime() - startTime;\n            double durationMs = duration / 1_000_000.0;\n            \n            // Store duration for analysis\n            operationDurations.computeIfAbsent(operationName, k -> new ArrayList<>()).add(duration);\n            \n            // Check for slow operations\n            if (durationMs > 10.0) { // More than 10ms\n                debugger.observeProblem(\"Slow operation: \" + operationName + \" took \" + String.format(\"%.2f\", durationMs) + \"ms\");\n            }\n        }\n    }"
    },
    {
      "type": "code",
      "title": "Performance Monitor - Analysis and Reporting",
      "content": "Add methods for analyzing and reporting performance data:",
      "code": "    public void analyzePerformance(Telemetry telemetry) {\n        telemetry.addLine(\"=== PERFORMANCE ANALYSIS ===\");\n        telemetry.addData(\"Loop Count\", loopCount);\n        telemetry.addData(\"Average Loop Time\", String.format(\"%.2fms\", averageLoopTime));\n        telemetry.addData(\"Max Loop Time\", String.format(\"%.2fms\", maxLoopTime));\n        \n        if (averageLoopTime > 20.0) {\n            telemetry.addLine(\"WARNING: Average loop time is high!\");\n        }\n        \n        telemetry.addLine(\"\\nOperation Analysis:\");\n        for (Map.Entry<String, List<Long>> entry : operationDurations.entrySet()) {\n            String operation = entry.getKey();\n            List<Long> durations = entry.getValue();\n            \n            if (durations.size() > 0) {\n                double avgDuration = durations.stream().mapToLong(Long::longValue).average().orElse(0) / 1_000_000.0;\n                double maxDuration = durations.stream().mapToLong(Long::longValue).max().orElse(0) / 1_000_000.0;\n                \n                telemetry.addData(operation, String.format(\"Avg: %.2fms, Max: %.2fms, Count: %d\", \n                    avgDuration, maxDuration, durations.size()));\n            }\n        }\n        \n        telemetry.update();\n    }\n    \n    public void reset() {\n        operationStartTimes.clear();\n        operationDurations.clear();\n        loopCount = 0;\n        averageLoopTime = 0.0;\n        maxLoopTime = 0.0;\n    }\n}"
    },
    {
      "type": "text",
      "title": "Competition Debugging Strategies",
      "content": "Competition environments require different debugging strategies. You have limited time and need to work quickly and efficiently."
    },
    {
      "type": "rules-box",
      "title": "Competition Debugging Checklist",
      "items": [
        "Have a pre-competition debugging checklist ready",
        "Use quick diagnostic tools that provide immediate feedback",
        "Keep debugging logs concise but informative",
        "Have backup strategies for common failure modes",
        "Practice debugging under time pressure before competition",
        "Document successful debugging approaches for future reference"
      ]
    },
    {
      "type": "code",
      "title": "Competition Debugger - Basic Structure",
      "content": "Create lightweight debugging tools for competition use. This class provides quick diagnostics for competition environments:",
      "code": "public class CompetitionDebugger {\n    private Telemetry telemetry;\n    private boolean quickMode = true; // Competition mode\n    private Map<String, Object> lastValues = new HashMap<>();\n    \n    public CompetitionDebugger(Telemetry telemetry) {\n        this.telemetry = telemetry;\n    }\n    \n    /**\n     * Quick hardware check for competition\n     */\n    public boolean quickHardwareCheck(HardwareMap hardwareMap) {\n        telemetry.addLine(\"=== QUICK HARDWARE CHECK ===\");\n        \n        boolean allOK = true;\n        \n        // Check motors\n        try {\n            DcMotor leftMotor = hardwareMap.get(DcMotor.class, \"left_motor\");\n            DcMotor rightMotor = hardwareMap.get(DcMotor.class, \"right_motor\");\n            leftMotor.setPower(0.0);\n            rightMotor.setPower(0.0);\n            telemetry.addData(\"Motors\", \"OK\");\n        } catch (Exception e) {\n            telemetry.addData(\"Motors\", \"FAIL: \" + e.getMessage());\n            allOK = false;\n        }\n        \n        // Check sensors\n        try {\n            ColorSensor colorSensor = hardwareMap.get(ColorSensor.class, \"color_sensor\");\n            int red = colorSensor.red();\n            telemetry.addData(\"Color Sensor\", \"OK (R=\" + red + \")\");\n        } catch (Exception e) {\n            telemetry.addData(\"Color Sensor\", \"FAIL: \" + e.getMessage());\n            allOK = false;\n        }\n        \n        telemetry.addData(\"Overall Status\", allOK ? \"READY\" : \"ISSUES DETECTED\");\n        telemetry.update();\n        \n        return allOK;\n    }"
    },
    {
      "type": "code",
      "title": "Competition Debugger - Monitoring and Display Methods",
      "content": "Add methods for monitoring values and displaying competition status:",
      "code": "    /**\n     * Monitor critical values for changes\n     */\n    public void monitorValue(String name, Object value) {\n        Object lastValue = lastValues.get(name);\n        if (!Objects.equals(lastValue, value)) {\n            telemetry.addData(name + \" (CHANGED)\", value);\n            lastValues.put(name, value);\n        } else {\n            telemetry.addData(name, value);\n        }\n    }\n    \n    /**\n     * Quick state display for competition\n     */\n    public void displayState(String state, double time, String... additionalInfo) {\n        telemetry.clear();\n        telemetry.addLine(\"=== COMPETITION STATUS ===\");\n        telemetry.addData(\"State\", state);\n        telemetry.addData(\"Time\", String.format(\"%.1fs\", time));\n        \n        for (String info : additionalInfo) {\n            telemetry.addLine(info);\n        }\n        \n        telemetry.update();\n    }\n    \n    /**\n     * Emergency stop with debugging info\n     */\n    public void emergencyStop(String reason, DcMotor... motors) {\n        telemetry.addLine(\"!!! EMERGENCY STOP !!!\");\n        telemetry.addData(\"Reason\", reason);\n        \n        for (DcMotor motor : motors) {\n            motor.setPower(0.0);\n        }\n        \n        telemetry.update();\n    }\n}"
    },
    {
      "type": "exercise-box",
      "title": "Debugging Strategy Practice Exercise",
      "description": "Create a comprehensive debugging system for a complex robot behavior and practice systematic debugging approaches.",
      "tasks": [
        "Create a robot behavior that combines multiple sensors and actuators",
        "Implement the scientific method debugging framework",
        "Add performance monitoring to identify bottlenecks",
        "Create competition-ready debugging tools",
        "Write a debugging checklist for common failure modes",
        "Practice debugging the system with intentional bugs",
        "Document your debugging process and findings"
      ],
      "content": "// Starter code for the exercise:\npublic class DebuggingExerciseOpMode extends OpMode {\n    private DebuggingFramework debugger;\n    private PerformanceMonitor performanceMonitor;\n    private CompetitionDebugger competitionDebugger;\n    private DebuggableStateMachine<RobotState> stateMachine;\n    \n    private enum RobotState { INIT, SEARCH, APPROACH, GRAB, RETURN, COMPLETE }\n    \n    @Override\n    public void init() {\n        debugger = new DebuggingFramework();\n        performanceMonitor = new PerformanceMonitor(debugger);\n        competitionDebugger = new CompetitionDebugger(telemetry);\n        stateMachine = new DebuggableStateMachine<>(RobotState.INIT, debugger);\n        \n        // TODO: Initialize hardware and add debugging\n    }\n    \n    @Override\n    public void loop() {\n        performanceMonitor.startLoop();\n        \n        // TODO: Implement robot behavior with comprehensive debugging\n        \n        performanceMonitor.endLoop();\n        \n        // TODO: Display debugging information\n    }\n}"
    },
    {
      "type": "link-grid",
      "title": "Additional Resources",
      "links": [
        "<a href=\"https://developer.android.com/studio/debug\" target=\"_blank\">Android Studio Debugging Guide</a>",
        "<a href=\"https://gm0.org/en/latest/docs/software/tutorials/telemetry.html\" target=\"_blank\">gm0: Telemetry Tutorial</a>",
        "<a href=\"https://ftc-docs.firstinspires.org/en/latest/programming_resources/control_hub/control_hub_setup.html\" target=\"_blank\">FTC Control Hub Documentation</a>",
        "<a href=\"https://developer.android.com/studio/profile\" target=\"_blank\">Android Studio Profiler</a>",
        "<a href=\"https://gm0.org/en/latest/docs/software/tutorials/android-studio.html\" target=\"_blank\">gm0: Android Studio Setup</a>"
      ]
    }
  ]
} 