{
  "title": "Code Review",
  "sections": [
    {
      "type": "text",
      "title": "Introduction to Code Review",
      "content": "Code review is a systematic process of examining code to find bugs, improve quality, and ensure consistency. For FTC teams, code reviews help catch issues early and improve team collaboration. This lesson covers how to conduct effective code reviews for robot programming."
    },
    {
      "type": "rules-box",
      "title": "Why Code Review Matters for FTC",
      "items": [
        "Catches bugs before they reach the robot during competition",
        "Improves code quality and maintainability",
        "Helps team members learn from each other",
        "Ensures safety and performance standards are met",
        "Maintains consistent coding standards across the team"
      ]
    },
    {
      "type": "text",
      "title": "Code Review Process for FTC Teams",
      "content": "Establishing a systematic code review process helps ensure all code changes are properly examined. A good review process includes checklists, feedback guidelines, and clear communication."
    },
    {
      "type": "rules-box",
      "title": "Code Review Checklist - Review Categories",
      "subtitle": "Main review categories for FTC code",
      "goodPractices": [
        "Functionality - Ensure code works correctly and handles edge cases",
        "Safety - Prevent robot damage and ensure safe operation",
        "Performance - Maintain smooth robot operation and efficiency",
        "Style - Improve code readability and maintainability",
        "Documentation - Ensure code is understandable and well-documented"
      ],
      "avoid": [
        "Reviewing only one category at a time",
        "Skipping safety checks in favor of functionality",
        "Ignoring performance issues for cleaner code",
        "Focusing only on style without checking functionality",
        "Documenting without verifying code correctness"
      ]
    },
    {
      "type": "text",
      "title": "Understanding Review Categories",
      "content": "The review categories help organize the code review process. Functionality checks ensure the code works correctly, safety checks prevent robot damage, performance checks maintain smooth operation, style checks improve readability, and documentation checks ensure maintainability."
    },
    {
      "type": "rules-box",
      "title": "Code Review Checklist - Functionality and Safety Checks",
      "subtitle": "Critical categories for FTC code reviews",
      "goodPractices": [
        "Does the code do what it's supposed to do?",
        "Are all edge cases handled?",
        "Does the code handle hardware failures gracefully?",
        "Are there any infinite loops or deadlocks?",
        "Does the autonomous sequence complete successfully?",
        "Are gamepad controls intuitive and responsive?",
        "Does the robot stop when it should?",
        "Are there safety timeouts for all operations?",
        "Does the robot stop if sensors detect obstacles?",
        "Are motor powers limited to safe values?",
        "Is there emergency stop functionality?",
        "Does the code prevent the robot from damaging itself?",
        "Are there checks for hardware initialization failures?",
        "Does the robot have a safe default state?"
      ],
      "avoid": [
        "Assuming hardware will always work correctly",
        "Ignoring edge cases for simpler code",
        "Using unlimited motor powers",
        "Missing emergency stop functionality",
        "Not testing autonomous sequences thoroughly",
        "Overlooking sensor failure scenarios",
        "Forgetting to handle initialization errors"
      ]
    },
    {
      "type": "text",
      "title": "Understanding Functionality and Safety Checks",
      "content": "Functionality checks ensure your robot code works as intended and handles real-world scenarios. Safety checks are critical for preventing robot damage and ensuring safe operation during competition. These categories should be reviewed first as they directly impact robot performance and safety."
    },
    {
      "type": "rules-box",
      "title": "Code Review Checklist - Performance and Style Checks",
      "subtitle": "Focus on code efficiency and maintainability",
      "goodPractices": [
        "Does the main loop run at acceptable speed (50Hz)?",
        "Are there any memory leaks or excessive object creation?",
        "Are sensor readings optimized (not read too frequently)?",
        "Are complex calculations broken into smaller pieces?",
        "Is telemetry updated at reasonable intervals?",
        "Are there any blocking operations in the main loop?",
        "Is the code efficient for the target hardware?",
        "Are variable and method names descriptive?",
        "Is the code properly indented and formatted?",
        "Are there consistent naming conventions?",
        "Is the code organized into logical methods?",
        "Are magic numbers replaced with named constants?",
        "Is the code readable and well-structured?",
        "Are there appropriate comments for complex logic?"
      ],
      "avoid": [
        "Creating objects in tight loops",
        "Reading sensors every loop iteration",
        "Updating telemetry too frequently",
        "Using blocking operations in main loop",
        "Using unclear variable names",
        "Leaving magic numbers in code",
        "Writing overly complex methods",
        "Forgetting to comment complex logic"
      ]
    },
    {
      "type": "text",
      "title": "Performance and Style Considerations",
      "content": "Performance checks ensure your robot operates smoothly and efficiently. Style checks improve code readability and maintainability, making it easier for team members to understand and modify the code. Documentation checks ensure that complex logic is properly explained for future reference."
    },
    {
      "type": "rules-box",
      "title": "Code Review Checklist - Documentation Checks",
      "subtitle": "Ensure code is maintainable and understandable",
      "goodPractices": [
        "Is there JavaDoc for public methods?",
        "Are complex algorithms explained with comments?",
        "Is there a README file for the project?",
        "Are hardware configurations documented?",
        "Are there comments explaining robot behavior?",
        "Is the code self-documenting where possible?",
        "Are there inline comments for non-obvious code?"
      ],
      "avoid": [
        "Writing code without any comments",
        "Using unclear method names",
        "Not documenting hardware requirements",
        "Leaving complex logic unexplained",
        "Forgetting to update documentation",
        "Using outdated comments",
        "Not explaining robot behavior decisions"
      ]
    },
    {
      "type": "text",
      "title": "Understanding Documentation Checks",
      "content": "Documentation checks ensure that your code is maintainable and understandable by other team members. Good documentation includes JavaDoc comments, inline explanations for complex logic, and project-level documentation that explains the overall robot design and configuration."
    },
    {
      "type": "text",
      "title": "Example of Well-Reviewed OpMode",
      "content": "Let's look at an example of a well-reviewed OpMode that follows the checklist. This example demonstrates proper code organization, safety measures, and documentation."
    },
    {
      "type": "code",
      "title": "Reviewed OpMode - Constants and Hardware Components",
      "content": "Example of a well-reviewed OpMode that follows the checklist. This class demonstrates proper organization and safety practices:",
      "code": "    /**\n     * Example of a well-reviewed OpMode that follows the checklist\n     */\n    public static class ReviewedOpMode extends OpMode {\n        \n        // Constants - no magic numbers\n        private static final double MAX_DRIVE_SPEED = 0.8;\n        private static final double MAX_TURN_SPEED = 0.6;\n        private static final double DEADBAND_THRESHOLD = 0.1;\n        private static final double SAFETY_DISTANCE_CM = 10.0;\n        private static final long TELEMETRY_UPDATE_INTERVAL_MS = 100;\n        \n        // Hardware components - clearly named\n        private DcMotor leftDriveMotor, rightDriveMotor;\n        private Servo armServo, clawServo;\n        private ColorSensor gameElementDetector;\n        private DistanceSensor proximitySensor;\n        \n        // State variables - descriptive names\n        private boolean isEmergencyStopActive = false;\n        private long lastTelemetryUpdate = 0;\n        private double currentArmPosition = 0.5;\n        private boolean isClawOpen = false;"
    },
    {
      "type": "text",
      "title": "Understanding Well-Reviewed OpMode Structure",
      "content": "The well-reviewed OpMode uses named constants instead of magic numbers, has clearly named hardware components, and includes descriptive state variables. This makes the code more readable and maintainable."
    },
    {
      "type": "code",
      "title": "Reviewed OpMode - Initialization Methods",
      "content": "Add initialization methods with proper error handling and documentation:",
      "code": "        /**\n         * Initializes the OpMode and all hardware components.\n         * Includes safety checks and error handling.\n         */\n        @Override\n        public void init() {\n            try {\n                initializeHardware();\n                configureHardware();\n                resetRobotState();\n                displayInitializationStatus();\n            } catch (Exception e) {\n                handleInitializationError(e);\n            }\n        }\n        \n        /**\n         * Main control loop with safety and performance considerations.\n         * Runs at approximately 50Hz for smooth robot control.\n         */\n        @Override\n        public void loop() {\n            // Check for emergency stop first\n            if (isEmergencyStopActive) {\n                stopAllMotors();\n                return;\n            }\n            \n            // Process input with safety checks\n            processDriverInput();\n            \n            // Update robot state\n            updateRobotState();\n            \n            // Apply safety checks\n            applySafetyChecks();\n            \n            // Update telemetry periodically for performance\n            updateTelemetryIfNeeded();\n        }"
    },
    {
      "type": "text",
      "title": "Understanding Initialization and Main Loop",
      "content": "The initialization method includes proper error handling with try-catch blocks. The main loop is organized into clear sections with safety checks first, followed by input processing, state updates, and periodic telemetry updates for performance."
    },
    {
      "type": "code",
      "title": "Reviewed OpMode - Hardware Initialization and Configuration",
      "content": "Add hardware initialization and configuration methods with proper error handling:",
      "code": "        /**\n         * Initializes all hardware components with error handling.\n         * Throws exception if critical hardware is missing.\n         */\n        private void initializeHardware() throws Exception {\n            // Initialize drive motors\n            leftDriveMotor = hardwareMap.get(DcMotor.class, \"left_drive\");\n            rightDriveMotor = hardwareMap.get(DcMotor.class, \"right_drive\");\n            \n            // Initialize servos\n            armServo = hardwareMap.get(Servo.class, \"arm_servo\");\n            clawServo = hardwareMap.get(Servo.class, \"claw_servo\");\n            \n            // Initialize sensors\n            gameElementDetector = hardwareMap.get(ColorSensor.class, \"color_sensor\");\n            proximitySensor = hardwareMap.get(DistanceSensor.class, \"distance_sensor\");\n            \n            // Verify critical hardware is available\n            if (leftDriveMotor == null || rightDriveMotor == null) {\n                throw new Exception(\"Critical drive motors not found\");\n            }\n        }\n        \n        /**\n         * Configures hardware settings for safe operation.\n         */\n        private void configureHardware() {\n            // Configure drive motors for safety\n            leftDriveMotor.setDirection(DcMotor.Direction.FORWARD);\n            rightDriveMotor.setDirection(DcMotor.Direction.REVERSE);\n            leftDriveMotor.setZeroPowerBehavior(DcMotor.ZeroPowerBehavior.BRAKE);\n            rightDriveMotor.setZeroPowerBehavior(DcMotor.ZeroPowerBehavior.BRAKE);\n            \n            // Set initial servo positions\n            if (armServo != null) armServo.setPosition(currentArmPosition);\n            if (clawServo != null) clawServo.setPosition(isClawOpen ? 1.0 : 0.0);\n        }"
    },
    {
      "type": "text",
      "title": "Understanding Hardware Initialization and Configuration",
      "content": "The hardware initialization method includes null checks for critical components and throws exceptions if essential hardware is missing. The configuration method sets up safe default behaviors like brake mode for motors and initial servo positions."
    },
    {
      "type": "text",
      "title": "Common FTC-Specific Code Issues",
      "content": "FTC code has specific patterns and common issues that reviewers should look for. Understanding these patterns helps identify potential problems before they cause issues during competition."
    },
    {
      "type": "code",
      "title": "Common Issues - Deadband and Timeout Examples",
      "content": "Examples of common FTC code issues and how to fix them. This section covers deadband and timeout problems:",
      "code": "// Common FTC Code Issues and Solutions\n\npublic class CommonIssuesExamples {\n    \n    /**\n     * ISSUE 1: No deadband on gamepad input\n     * PROBLEM: Controller drift causes unwanted movement\n     * SOLUTION: Apply deadband to prevent drift\n     */\n    public static class DeadbandExample {\n        // BAD - No deadband\n        public void badGamepadProcessing() {\n            double forward = gamepad1.left_stick_y;\n            double turn = gamepad1.right_stick_x;\n            // This can cause unwanted movement from controller drift\n        }\n        \n        // GOOD - With deadband\n        public void goodGamepadProcessing() {\n            double forward = applyDeadband(gamepad1.left_stick_y);\n            double turn = applyDeadband(gamepad1.right_stick_x);\n            // Prevents unwanted movement from controller drift\n        }\n        \n        private double applyDeadband(double input) {\n            return Math.abs(input) < 0.1 ? 0.0 : input;\n        }\n    }"
    },
    {
      "type": "text",
      "title": "Understanding Deadband Issues",
      "content": "Controller drift is a common problem in FTC. Without a deadband, small controller movements can cause unwanted robot movement. The applyDeadband method filters out small inputs below the threshold, preventing drift-related issues."
    },
    {
      "type": "code",
      "title": "Common Issues - Timeout Examples",
      "content": "Add timeout examples to prevent robot operations from getting stuck:",
      "code": "    /**\n     * ISSUE 2: No safety timeouts\n     * PROBLEM: Robot can get stuck in operations\n     * SOLUTION: Add timeouts for all operations\n     */\n    public static class TimeoutExample {\n        private double operationStartTime;\n        private static final double OPERATION_TIMEOUT = 5.0; // 5 seconds\n        \n        // BAD - No timeout\n        public void badOperation() {\n            while (!isOperationComplete()) {\n                // Robot can get stuck here forever\n                performOperation();\n            }\n        }\n        \n        // GOOD - With timeout\n        public void goodOperation() {\n            operationStartTime = getRuntime();\n            while (!isOperationComplete() && !isTimeoutReached()) {\n                performOperation();\n            }\n            \n            if (isTimeoutReached()) {\n                handleTimeout();\n            }\n        }\n        \n        private boolean isTimeoutReached() {\n            return getRuntime() - operationStartTime > OPERATION_TIMEOUT;\n        }\n        \n        private void handleTimeout() {\n            // Stop operation and notify driver\n            stopOperation();\n            telemetry.addData(\"Warning\", \"Operation timed out\");\n        }\n    }"
    },
    {
      "type": "text",
      "title": "Understanding Timeout Issues",
      "content": "Timeouts prevent robots from getting stuck in operations indefinitely. The good example tracks operation start time and checks for timeout conditions, ensuring the robot can recover from stuck operations and notify the driver of issues."
    },
    {
      "type": "code",
      "title": "Common Issues - Hardware Failure and Telemetry Examples",
      "content": "Add examples for hardware failure handling and telemetry optimization:",
      "code": "    /**\n     * ISSUE 3: No hardware failure handling\n     * PROBLEM: Code crashes if hardware is missing or fails\n     * SOLUTION: Check for null and handle exceptions\n     */\n    public static class HardwareFailureExample {\n        private DcMotor driveMotor;\n        \n        // BAD - No null check\n        public void badHardwareAccess() {\n            driveMotor = hardwareMap.get(DcMotor.class, \"drive_motor\");\n            driveMotor.setPower(0.5); // Crashes if motor is null\n        }\n        \n        // GOOD - With null check\n        public void goodHardwareAccess() {\n            driveMotor = hardwareMap.get(DcMotor.class, \"drive_motor\");\n            if (driveMotor != null) {\n                driveMotor.setPower(0.5);\n            } else {\n                telemetry.addData(\"ERROR\", \"Drive motor not found\");\n            }\n        }\n    }"
    },
    {
      "type": "text",
      "title": "Understanding Hardware Failure Handling",
      "content": "Hardware failures are common in FTC due to loose connections or missing components. The good example includes null checks to prevent crashes and provides feedback to the driver when hardware is missing."
    },
    {
      "type": "code",
      "title": "Common Issues - Telemetry Optimization",
      "content": "Add telemetry optimization examples to improve performance:",
      "code": "    /**\n     * ISSUE 4: Inefficient telemetry updates\n     * PROBLEM: Too much telemetry slows down the main loop\n     * SOLUTION: Update telemetry periodically\n     */\n    public static class TelemetryExample {\n        private long lastTelemetryUpdate = 0;\n        private static final long TELEMETRY_INTERVAL = 100; // 100ms\n        \n        // BAD - Updates every loop\n        public void badTelemetryUpdate() {\n            telemetry.addData(\"Runtime\", getRuntime());\n            telemetry.addData(\"Motor Power\", motor.getPower());\n            telemetry.addData(\"Sensor Value\", sensor.getValue());\n            // This runs every 20ms, which is excessive\n        }\n        \n        // GOOD - Updates periodically\n        public void goodTelemetryUpdate() {\n            long currentTime = System.currentTimeMillis();\n            if (currentTime - lastTelemetryUpdate > TELEMETRY_INTERVAL) {\n                telemetry.addData(\"Runtime\", getRuntime());\n                telemetry.addData(\"Motor Power\", motor.getPower());\n                telemetry.addData(\"Sensor Value\", sensor.getValue());\n                lastTelemetryUpdate = currentTime;\n            }\n        }\n    }\n}"
    },
    {
      "type": "text",
      "title": "Understanding Telemetry Optimization",
      "content": "Excessive telemetry updates can slow down the main loop and reduce robot responsiveness. The good example updates telemetry only periodically (every 100ms) instead of every loop iteration, maintaining smooth robot control while still providing useful feedback."
    },
    {
      "type": "text",
      "title": "Performance and Safety Review Criteria",
      "content": "Performance and safety are critical for FTC robots. Reviewers must ensure code meets performance requirements and includes proper safety measures."
    },
    {
      "type": "rules-box",
      "title": "Performance Review Criteria",
      "items": [
        "Main loop runs at 50Hz (20ms per loop) or faster",
        "No blocking operations in the main loop",
        "Telemetry updates are limited to reasonable frequency",
        "Memory usage is optimized (no excessive object creation)",
        "Sensor readings are not performed too frequently",
        "Complex calculations are broken into smaller pieces"
      ]
    },
    {
      "type": "rules-box",
      "title": "Safety Review Criteria",
      "items": [
        "All operations have timeout limits",
        "Emergency stop functionality is implemented",
        "Motor powers are limited to safe values",
        "Proximity sensors are used to prevent collisions",
        "Hardware failures are handled gracefully",
        "Robot has a safe default state when stopped"
      ]
    },
    {
      "type": "text",
      "title": "Collaborative Development Workflows",
      "content": "Effective collaboration requires clear workflows, communication, and conflict resolution strategies. Teams need to work together efficiently while maintaining code quality."
    },
    {
      "type": "code",
      "title": "Git Workflow for Team Collaboration",
      "content": "Implement a collaborative Git workflow for FTC teams. This example shows how to structure your project with version control in mind:",
      "code": "// Git Workflow for FTC Team Collaboration\n\n/*\n * BRANCHING STRATEGY FOR FTC TEAMS\n * \n * Main Branch Structure:\n * - main: Production-ready code for competition\n * - development: Integration branch for testing\n * - feature/*: Individual feature branches\n * - hotfix/*: Emergency fixes for competition\n * \n * Workflow:\n * 1. Create feature branch from development\n * 2. Develop and test feature\n * 3. Create pull request to development\n * 4. Code review and testing\n * 5. Merge to development\n * 6. Integration testing\n * 7. Merge to main for competition\n * \n * Example Commands:\n * \n * # Start new feature\n * git checkout development\n * git pull origin development\n * git checkout -b feature/autonomous-collector\n * \n * # Develop feature\n * # ... make changes ...\n * git add .\n * git commit -m \"Add autonomous collector functionality\"\n * git push origin feature/autonomous-collector\n * \n * # Create pull request (on GitHub/GitLab)\n * # Review and merge to development\n * \n * # Prepare for competition\n * git checkout main\n * git merge development\n * git tag -a v1.0 -m \"Competition version 1.0\"\n * git push origin main --tags\n */"
    },
    {
      "type": "text",
      "title": "Understanding Git Workflow",
      "content": "The Git workflow provides a structured approach to team collaboration. Feature branches allow individual development, pull requests enable code review, and the main branch contains only competition-ready code. This ensures code quality and team coordination."
    },
    {
      "type": "exercise-box",
      "title": "Practice: Code Review Exercise",
      "description": "Practice code review skills with these exercises:",
      "tasks": [
        "Review a provided OpMode using the checklist",
        "Identify and fix common FTC code issues",
        "Create a well-structured OpMode following best practices",
        "Conduct a peer review of your code",
        "Document your review findings"
      ],
      "content": "// Sample OpMode to review:\nimport com.qualcomm.robotcore.eventloop.opmode.OpMode;\nimport com.qualcomm.robotcore.eventloop.opmode.TeleOp;\nimport com.qualcomm.robotcore.hardware.DcMotor;\nimport com.qualcomm.robotcore.hardware.Servo;\n\n@TeleOp(name = \"SampleOpMode\")\npublic class SampleOpMode extends OpMode {\n    \n    // Hardware components\n    private DcMotor leftMotor, rightMotor;\n    private Servo armServo;\n    \n    // State variables\n    private boolean isArmUp = false;\n    private double driveSpeed = 0.8;\n    \n    @Override\n    public void init() {\n        leftMotor = hardwareMap.get(DcMotor.class, \"left_motor\");\n        rightMotor = hardwareMap.get(DcMotor.class, \"right_motor\");\n        armServo = hardwareMap.get(Servo.class, \"arm_servo\");\n    }\n    \n    @Override\n    public void loop() {\n        // Drive control\n        double forward = gamepad1.left_stick_y;\n        double turn = gamepad1.right_stick_x;\n        \n        double leftPower = forward + turn;\n        double rightPower = forward - turn;\n        \n        leftMotor.setPower(leftPower);\n        rightMotor.setPower(rightPower);\n        \n        // Arm control\n        if (gamepad1.a) {\n            armServo.setPosition(1.0);\n            isArmUp = true;\n        } else if (gamepad1.b) {\n            armServo.setPosition(0.0);\n            isArmUp = false;\n        }\n        \n        // Telemetry\n        telemetry.addData(\"Left Power\", leftPower);\n        telemetry.addData(\"Right Power\", rightPower);\n        telemetry.addData(\"Arm Up\", isArmUp);\n        telemetry.update();\n    }\n} ",
      "answers": [
        {
          "task": "Identify and fix common FTC code issues",
          "content": "// FIXED VERSION:\nimport com.qualcomm.robotcore.eventloop.opmode.OpMode;\nimport com.qualcomm.robotcore.eventloop.opmode.TeleOp;\nimport com.qualcomm.robotcore.hardware.DcMotor;\nimport com.qualcomm.robotcore.hardware.Servo;\nimport android.util.Log;\n\n@TeleOp(name = \"FixedOpMode\")\npublic class FixedOpMode extends OpMode {\n    private static final String TAG = \"FixedOpMode\";\n    \n    // Constants - no magic numbers\n    private static final double MAX_DRIVE_SPEED = 0.8;\n    private static final double MAX_TURN_SPEED = 0.6;\n    private static final double DEADBAND_THRESHOLD = 0.1;\n    private static final double ARM_UP_POSITION = 1.0;\n    private static final double ARM_DOWN_POSITION = 0.0;\n    private static final long TELEMETRY_UPDATE_INTERVAL_MS = 100;\n    \n    // Hardware components - clearly named\n    private DcMotor leftMotor, rightMotor;\n    private Servo armServo;\n    \n    // State variables - descriptive names\n    private boolean isArmUp = false;\n    private long lastTelemetryUpdate = 0;\n    private boolean hardwareInitialized = false;\n    \n    @Override\n    public void init() {\n        try {\n            // Initialize hardware with error handling\n            leftMotor = hardwareMap.get(DcMotor.class, \"left_motor\");\n            rightMotor = hardwareMap.get(DcMotor.class, \"right_motor\");\n            armServo = hardwareMap.get(Servo.class, \"arm_servo\");\n            \n            // Set motor directions if needed\n            leftMotor.setDirection(DcMotor.Direction.FORWARD);\n            rightMotor.setDirection(DcMotor.Direction.REVERSE);\n            \n            // Initialize arm to safe position\n            armServo.setPosition(ARM_DOWN_POSITION);\n            \n            hardwareInitialized = true;\n            Log.i(TAG, \"Hardware initialized successfully\");\n            \n        } catch (Exception e) {\n            Log.e(TAG, \"Hardware initialization failed: \" + e.getMessage());\n            telemetry.addData(\"ERROR\", \"Hardware initialization failed\");\n            telemetry.update();\n        }\n    }\n    \n    @Override\n    public void loop() {\n        if (!hardwareInitialized) {\n            telemetry.addData(\"ERROR\", \"Hardware not initialized\");\n            telemetry.update();\n            return;\n        }\n        \n        // Process input with deadband\n        double forward = applyDeadband(gamepad1.left_stick_y);\n        double turn = applyDeadband(gamepad1.right_stick_x);\n        \n        // Calculate motor powers with limits\n        double leftPower = (forward + turn) * MAX_DRIVE_SPEED;\n        double rightPower = (forward - turn) * MAX_DRIVE_SPEED;\n        \n        // Apply power limits\n        leftPower = Math.max(-1.0, Math.min(1.0, leftPower));\n        rightPower = Math.max(-1.0, Math.min(1.0, rightPower));\n        \n        // Set motor powers\n        leftMotor.setPower(leftPower);\n        rightMotor.setPower(rightPower);\n        \n        // Arm control with safety checks\n        handleArmControl();\n        \n        // Update telemetry periodically\n        updateTelemetry();\n    }\n    \n    private double applyDeadband(double input) {\n        return Math.abs(input) < DEADBAND_THRESHOLD ? 0.0 : input;\n    }\n    \n    private void handleArmControl() {\n        // Arm control with proper state management\n        if (gamepad1.a && !isArmUp) {\n            armServo.setPosition(ARM_UP_POSITION);\n            isArmUp = true;\n            Log.d(TAG, \"Arm raised\");\n        } else if (gamepad1.b && isArmUp) {\n            armServo.setPosition(ARM_DOWN_POSITION);\n            isArmUp = false;\n            Log.d(TAG, \"Arm lowered\");\n        }\n    }\n    \n    private void updateTelemetry() {\n        long currentTime = System.currentTimeMillis();\n        if (currentTime - lastTelemetryUpdate > TELEMETRY_UPDATE_INTERVAL_MS) {\n            telemetry.addData(\"Status\", \"Running\");\n            telemetry.addData(\"Left Motor Power\", \"%.2f\", leftMotor.getPower());\n            telemetry.addData(\"Right Motor Power\", \"%.2f\", rightMotor.getPower());\n            telemetry.addData(\"Arm Position\", isArmUp ? \"UP\" : \"DOWN\");\n            telemetry.addData(\"Battery Voltage\", \"%.2f V\", getBatteryVoltage());\n            telemetry.update();\n            lastTelemetryUpdate = currentTime;\n        }\n    }\n    \n    private double getBatteryVoltage() {\n        try {\n            return hardwareMap.voltageSensor.get(\"Expansion Hub 2\").getVoltage();\n        } catch (Exception e) {\n            return 0.0;\n        }\n    }\n}"
        },
        {
          "task": "Create a well-structured OpMode following best practices",
          "content": "import com.qualcomm.robotcore.eventloop.opmode.OpMode;\nimport com.qualcomm.robotcore.eventloop.opmode.TeleOp;\nimport com.qualcomm.robotcore.hardware.DcMotor;\nimport com.qualcomm.robotcore.hardware.Servo;\nimport com.qualcomm.robotcore.hardware.ColorSensor;\nimport com.qualcomm.robotcore.hardware.DistanceSensor;\nimport android.util.Log;\n\n@TeleOp(name = \"WellStructuredOpMode\")\npublic class WellStructuredOpMode extends OpMode {\n    private static final String TAG = \"WellStructuredOpMode\";\n    \n    // Constants - organized by category\n    private static final class DriveConstants {\n        static final double MAX_DRIVE_SPEED = 0.8;\n        static final double MAX_TURN_SPEED = 0.6;\n        static final double DEADBAND_THRESHOLD = 0.1;\n        static final boolean REVERSE_LEFT_MOTOR = false;\n        static final boolean REVERSE_RIGHT_MOTOR = true;\n    }\n    \n    private static final class ArmConstants {\n        static final double ARM_UP_POSITION = 1.0;\n        static final double ARM_DOWN_POSITION = 0.0;\n        static final double ARM_SPEED = 0.5;\n        static final double CLAW_OPEN_POSITION = 0.8;\n        static final double CLAW_CLOSE_POSITION = 0.2;\n    }\n    \n    private static final class SensorConstants {\n        static final int RED_THRESHOLD = 100;\n        static final double SAFETY_DISTANCE_CM = 10.0;\n        static final long TELEMETRY_UPDATE_INTERVAL_MS = 100;\n    }\n    \n    // Hardware components - clearly named and grouped\n    private DcMotor leftDriveMotor, rightDriveMotor;\n    private Servo armServo, clawServo;\n    private ColorSensor gameElementDetector;\n    private DistanceSensor proximitySensor;\n    \n    // State variables - descriptive names\n    private boolean isEmergencyStopActive = false;\n    private long lastTelemetryUpdate = 0;\n    private double currentArmPosition = ArmConstants.ARM_DOWN_POSITION;\n    private boolean isClawOpen = false;\n    private boolean hardwareInitialized = false;\n    \n    // Performance tracking\n    private int loopCount = 0;\n    private double startTime = 0.0;\n    \n    @Override\n    public void init() {\n        startTime = getRuntime();\n        \n        try {\n            initializeHardware();\n            configureHardware();\n            hardwareInitialized = true;\n            \n            Log.i(TAG, \"OpMode initialized successfully\");\n            telemetry.addData(\"Status\", \"Initialized\");\n            telemetry.update();\n            \n        } catch (Exception e) {\n            Log.e(TAG, \"Initialization failed: \" + e.getMessage());\n            telemetry.addData(\"ERROR\", \"Initialization failed\");\n            telemetry.update();\n        }\n    }\n    \n    private void initializeHardware() {\n        // Initialize drive motors\n        leftDriveMotor = hardwareMap.get(DcMotor.class, \"left_drive_motor\");\n        rightDriveMotor = hardwareMap.get(DcMotor.class, \"right_drive_motor\");\n        \n        // Initialize arm components\n        armServo = hardwareMap.get(Servo.class, \"arm_servo\");\n        clawServo = hardwareMap.get(Servo.class, \"claw_servo\");\n        \n        // Initialize sensors\n        gameElementDetector = hardwareMap.get(ColorSensor.class, \"color_sensor\");\n        proximitySensor = hardwareMap.get(DistanceSensor.class, \"distance_sensor\");\n    }\n    \n    private void configureHardware() {\n        // Configure motor directions\n        leftDriveMotor.setDirection(DriveConstants.REVERSE_LEFT_MOTOR ? \n                                   DcMotor.Direction.REVERSE : DcMotor.Direction.FORWARD);\n        rightDriveMotor.setDirection(DriveConstants.REVERSE_RIGHT_MOTOR ? \n                                    DcMotor.Direction.REVERSE : DcMotor.Direction.FORWARD);\n        \n        // Set motor modes\n        leftDriveMotor.setMode(DcMotor.RunMode.RUN_USING_ENCODER);\n        rightDriveMotor.setMode(DcMotor.RunMode.RUN_USING_ENCODER);\n        \n        // Initialize servos to safe positions\n        armServo.setPosition(ArmConstants.ARM_DOWN_POSITION);\n        clawServo.setPosition(ArmConstants.CLAW_CLOSE_POSITION);\n    }\n    \n    @Override\n    public void loop() {\n        if (!hardwareInitialized || isEmergencyStopActive) {\n            handleEmergencyStop();\n            return;\n        }\n        \n        loopCount++;\n        \n        // Check for emergency stop\n        if (gamepad1.back) {\n            activateEmergencyStop();\n            return;\n        }\n        \n        // Process robot controls\n        handleDriveControl();\n        handleArmControl();\n        handleClawControl();\n        \n        // Update sensors and safety checks\n        updateSensors();\n        performSafetyChecks();\n        \n        // Update telemetry\n        updateTelemetry();\n    }\n    \n    private void handleDriveControl() {\n        // Apply deadband to prevent drift\n        double forward = applyDeadband(-gamepad1.left_stick_y);\n        double turn = applyDeadband(gamepad1.right_stick_x);\n        \n        // Calculate motor powers\n        double leftPower = (forward + turn) * DriveConstants.MAX_DRIVE_SPEED;\n        double rightPower = (forward - turn) * DriveConstants.MAX_DRIVE_SPEED;\n        \n        // Apply power limits\n        leftPower = Math.max(-1.0, Math.min(1.0, leftPower));\n        rightPower = Math.max(-1.0, Math.min(1.0, rightPower));\n        \n        // Set motor powers\n        leftDriveMotor.setPower(leftPower);\n        rightDriveMotor.setPower(rightPower);\n    }\n    \n    private void handleArmControl() {\n        // Gradual arm movement for smooth operation\n        if (gamepad1.a && currentArmPosition < ArmConstants.ARM_UP_POSITION) {\n            currentArmPosition = Math.min(ArmConstants.ARM_UP_POSITION, \n                                        currentArmPosition + ArmConstants.ARM_SPEED * 0.02);\n            armServo.setPosition(currentArmPosition);\n        } else if (gamepad1.b && currentArmPosition > ArmConstants.ARM_DOWN_POSITION) {\n            currentArmPosition = Math.max(ArmConstants.ARM_DOWN_POSITION, \n                                        currentArmPosition - ArmConstants.ARM_SPEED * 0.02);\n            armServo.setPosition(currentArmPosition);\n        }\n    }\n    \n    private void handleClawControl() {\n        // Claw open/close control\n        if (gamepad1.x && !isClawOpen) {\n            clawServo.setPosition(ArmConstants.CLAW_OPEN_POSITION);\n            isClawOpen = true;\n            Log.d(TAG, \"Claw opened\");\n        } else if (gamepad1.y && isClawOpen) {\n            clawServo.setPosition(ArmConstants.CLAW_CLOSE_POSITION);\n            isClawOpen = false;\n            Log.d(TAG, \"Claw closed\");\n        }\n    }\n    \n    private void updateSensors() {\n        // Update sensor readings (if sensors are available)\n        if (gameElementDetector != null) {\n            try {\n                int red = gameElementDetector.red();\n                int green = gameElementDetector.green();\n                int blue = gameElementDetector.blue();\n                \n                // Log significant color changes\n                if (red > SensorConstants.RED_THRESHOLD) {\n                    Log.d(TAG, \"Red object detected: R=\" + red + \", G=\" + green + \", B=\" + blue);\n                }\n            } catch (Exception e) {\n                Log.e(TAG, \"Color sensor error: \" + e.getMessage());\n            }\n        }\n        \n        // Update distance sensor readings\n        if (proximitySensor != null) {\n            try {\n                double distance = proximitySensor.getDistance(DistanceUnit.CM);\n                if (distance < SensorConstants.SAFETY_DISTANCE_CM) {\n                    Log.w(TAG, \"Object too close: \" + distance + \" cm\");\n                }\n            } catch (Exception e) {\n                Log.e(TAG, \"Distance sensor error: \" + e.getMessage());\n            }\n        }\n    }\n    \n    private void performSafetyChecks() {\n        // Check battery voltage\n        double batteryVoltage = getBatteryVoltage();\n        if (batteryVoltage < 11.0) {\n            Log.w(TAG, \"Low battery voltage: \" + batteryVoltage + \" V\");\n            telemetry.addData(\"WARNING\", \"Low battery: \" + batteryVoltage + \" V\");\n        }\n        \n        // Check for excessive motor power\n        double leftPower = Math.abs(leftDriveMotor.getPower());\n        double rightPower = Math.abs(rightDriveMotor.getPower());\n        if (leftPower > 0.95 || rightPower > 0.95) {\n            Log.w(TAG, \"High motor power detected: L=\" + leftPower + \", R=\" + rightPower);\n        }\n    }\n    \n    private void activateEmergencyStop() {\n        isEmergencyStopActive = true;\n        \n        // Stop all motors\n        leftDriveMotor.setPower(0);\n        rightDriveMotor.setPower(0);\n        \n        // Move arm to safe position\n        armServo.setPosition(ArmConstants.ARM_DOWN_POSITION);\n        clawServo.setPosition(ArmConstants.CLAW_CLOSE_POSITION);\n        \n        Log.w(TAG, \"Emergency stop activated\");\n        telemetry.addData(\"EMERGENCY\", \"STOP ACTIVATED\");\n        telemetry.update();\n    }\n    \n    private void handleEmergencyStop() {\n        telemetry.addData(\"Status\", isEmergencyStopActive ? \"EMERGENCY STOP\" : \"Not Initialized\");\n        telemetry.update();\n    }\n    \n    private double applyDeadband(double input) {\n        return Math.abs(input) < DriveConstants.DEADBAND_THRESHOLD ? 0.0 : input;\n    }\n    \n    private void updateTelemetry() {\n        long currentTime = System.currentTimeMillis();\n        if (currentTime - lastTelemetryUpdate > SensorConstants.TELEMETRY_UPDATE_INTERVAL_MS) {\n            telemetry.addData(\"Status\", \"Running\");\n            telemetry.addData(\"Loop Count\", loopCount);\n            telemetry.addData(\"Runtime\", \"%.1f s\", getRuntime());\n            telemetry.addData(\"Left Power\", \"%.2f\", leftDriveMotor.getPower());\n            telemetry.addData(\"Right Power\", \"%.2f\", rightDriveMotor.getPower());\n            telemetry.addData(\"Arm Position\", \"%.2f\", currentArmPosition);\n            telemetry.addData(\"Claw\", isClawOpen ? \"OPEN\" : \"CLOSED\");\n            telemetry.addData(\"Battery\", \"%.2f V\", getBatteryVoltage());\n            telemetry.update();\n            lastTelemetryUpdate = currentTime;\n        }\n    }\n    \n    private double getBatteryVoltage() {\n        try {\n            return hardwareMap.voltageSensor.get(\"Expansion Hub 2\").getVoltage();\n        } catch (Exception e) {\n            return 0.0;\n        }\n    }\n}"
        },
        {
          "task": "Conduct a peer review of your code",
          "content": "// PEER REVIEW CHECKLIST:\n\n// 1. CODE STRUCTURE AND ORGANIZATION\n// ✓ Constants are organized into logical groups\n// ✓ Hardware components are clearly named\n// ✓ State variables have descriptive names\n// ✓ Methods are properly separated by responsibility\n// ✓ Error handling is implemented throughout\n\n// 2. SAFETY AND RELIABILITY\n// ✓ Emergency stop functionality is implemented\n// ✓ Battery voltage monitoring is included\n// ✓ Motor power limits are enforced\n// ✓ Deadband is applied to prevent drift\n// ✓ Hardware initialization has error handling\n\n// 3. PERFORMANCE AND EFFICIENCY\n// ✓ Telemetry updates are throttled\n// ✓ Sensor readings are handled efficiently\n// ✓ No unnecessary object creation in loops\n// ✓ Proper use of constants instead of magic numbers\n\n// 4. DOCUMENTATION AND READABILITY\n// ✓ Clear method names that describe functionality\n// ✓ Comments explain complex logic\n// ✓ Constants are self-documenting\n// ✓ Code follows consistent formatting\n\n// 5. TESTING AND DEBUGGING\n// ✓ Logging is implemented for key events\n// ✓ Error conditions are logged\n// ✓ Performance metrics are tracked\n// ✓ State changes are logged\n\n// 6. COMPETITION READINESS\n// ✓ Emergency stop can be activated quickly\n// ✓ Robot returns to safe state on stop\n// ✓ Telemetry provides useful debugging info\n// ✓ Code handles hardware failures gracefully\n\n// REVIEWER COMMENTS:\n// \"This is a well-structured OpMode that follows FTC best practices. \n// The code is organized, safe, and maintainable. The emergency stop \n// functionality is particularly well implemented. The only suggestion \n// would be to add more detailed comments for complex calculations.\"\n\n// SUGGESTED IMPROVEMENTS:\n// 1. Add more detailed comments for the motor power calculation logic\n// 2. Consider adding a method to validate hardware configuration\n// 3. Add more granular error handling for individual components\n// 4. Consider adding a configuration file for constants\n// 5. Add unit tests for the utility methods"
        },
        {
          "task": "Document your review findings",
          "content": "// CODE REVIEW DOCUMENTATION\n\n// REVIEW DATE: [Current Date]\n// REVIEWER: [Your Name]\n// OPCODE: WellStructuredOpMode\n// VERSION: 1.0\n\n// SUMMARY:\n// This OpMode demonstrates excellent FTC programming practices with proper \n// organization, safety features, and error handling. The code is well-structured \n// and ready for competition use.\n\n// STRENGTHS:\n// 1. Excellent code organization with logical grouping of constants\n// 2. Comprehensive safety features including emergency stop\n// 3. Proper error handling throughout the code\n// 4. Good use of logging for debugging\n// 5. Efficient telemetry updates with throttling\n// 6. Clear method names and separation of concerns\n// 7. Proper hardware initialization and configuration\n// 8. Battery monitoring and performance tracking\n\n// AREAS FOR IMPROVEMENT:\n// 1. Add more detailed comments for complex calculations\n// 2. Consider adding hardware validation methods\n// 3. Add more granular error handling for individual sensors\n// 4. Consider externalizing constants to a configuration file\n// 5. Add unit tests for utility methods\n\n// CRITICAL ISSUES: None\n// MAJOR ISSUES: None\n// MINOR ISSUES: 5 (see above)\n\n// RECOMMENDATIONS:\n// 1. Add detailed comments explaining the motor power calculation logic\n// 2. Create a hardware validation method to check component availability\n// 3. Add try-catch blocks around individual sensor operations\n// 4. Consider creating a separate configuration class\n// 5. Write unit tests for applyDeadband and other utility methods\n\n// COMPETITION READINESS: EXCELLENT\n// The code is well-suited for competition use with proper safety features \n// and error handling. The emergency stop functionality is particularly \n// well implemented.\n\n// NEXT STEPS:\n// 1. Implement the suggested improvements\n// 2. Test the OpMode thoroughly on hardware\n// 3. Conduct a final review after improvements\n// 4. Document any hardware-specific configurations needed\n\n// REVIEW COMPLETED: [Date]\n// STATUS: APPROVED WITH MINOR IMPROVEMENTS"
        },
        {
          "task": "Complete code review exercise with all components",
          "content": "import com.qualcomm.robotcore.eventloop.opmode.OpMode;\nimport com.qualcomm.robotcore.eventloop.opmode.TeleOp;\nimport com.qualcomm.robotcore.hardware.DcMotor;\nimport com.qualcomm.robotcore.hardware.Servo;\nimport com.qualcomm.robotcore.hardware.ColorSensor;\nimport com.qualcomm.robotcore.hardware.DistanceSensor;\nimport com.qualcomm.robotcore.util.ElapsedTime;\nimport android.util.Log;\n\n@TeleOp(name = \"CompleteCodeReviewExample\")\npublic class CompleteCodeReviewExample extends OpMode {\n    private static final String TAG = \"CodeReviewExample\";\n    \n    // Constants organized by functionality\n    private static final class DriveConstants {\n        static final double MAX_DRIVE_SPEED = 0.8;\n        static final double MAX_TURN_SPEED = 0.6;\n        static final double DEADBAND_THRESHOLD = 0.1;\n        static final boolean REVERSE_LEFT_MOTOR = false;\n        static final boolean REVERSE_RIGHT_MOTOR = true;\n    }\n    \n    private static final class ArmConstants {\n        static final double ARM_UP_POSITION = 1.0;\n        static final double ARM_DOWN_POSITION = 0.0;\n        static final double ARM_SPEED = 0.5;\n        static final double CLAW_OPEN_POSITION = 0.8;\n        static final double CLAW_CLOSE_POSITION = 0.2;\n    }\n    \n    private static final class SafetyConstants {\n        static final double LOW_BATTERY_THRESHOLD = 11.0;\n        static final double HIGH_POWER_THRESHOLD = 0.95;\n        static final double SAFETY_DISTANCE_CM = 10.0;\n        static final long TELEMETRY_UPDATE_INTERVAL_MS = 100;\n    }\n    \n    // Hardware components with clear naming\n    private DcMotor leftDriveMotor, rightDriveMotor;\n    private Servo armServo, clawServo;\n    private ColorSensor gameElementDetector;\n    private DistanceSensor proximitySensor;\n    \n    // State tracking with descriptive names\n    private boolean isEmergencyStopActive = false;\n    private boolean isHardwareInitialized = false;\n    private double currentArmPosition = ArmConstants.ARM_DOWN_POSITION;\n    private boolean isClawOpen = false;\n    \n    // Performance and debugging\n    private ElapsedTime runtime = new ElapsedTime();\n    private long lastTelemetryUpdate = 0;\n    private int loopCount = 0;\n    \n    @Override\n    public void init() {\n        runtime.reset();\n        \n        try {\n            initializeHardware();\n            configureHardware();\n            isHardwareInitialized = true;\n            \n            Log.i(TAG, \"OpMode initialized successfully\");\n            telemetry.addData(\"Status\", \"Initialized\");\n            telemetry.update();\n            \n        } catch (Exception e) {\n            Log.e(TAG, \"Initialization failed: \" + e.getMessage());\n            telemetry.addData(\"ERROR\", \"Initialization failed: \" + e.getMessage());\n            telemetry.update();\n        }\n    }\n    \n    private void initializeHardware() {\n        // Initialize drive system\n        leftDriveMotor = hardwareMap.get(DcMotor.class, \"left_drive_motor\");\n        rightDriveMotor = hardwareMap.get(DcMotor.class, \"right_drive_motor\");\n        \n        // Initialize arm system\n        armServo = hardwareMap.get(Servo.class, \"arm_servo\");\n        clawServo = hardwareMap.get(Servo.class, \"claw_servo\");\n        \n        // Initialize sensors\n        gameElementDetector = hardwareMap.get(ColorSensor.class, \"color_sensor\");\n        proximitySensor = hardwareMap.get(DistanceSensor.class, \"distance_sensor\");\n    }\n    \n    private void configureHardware() {\n        // Configure motor directions and modes\n        leftDriveMotor.setDirection(DriveConstants.REVERSE_LEFT_MOTOR ? \n                                   DcMotor.Direction.REVERSE : DcMotor.Direction.FORWARD);\n        rightDriveMotor.setDirection(DriveConstants.REVERSE_RIGHT_MOTOR ? \n                                    DcMotor.Direction.REVERSE : DcMotor.Direction.FORWARD);\n        \n        leftDriveMotor.setMode(DcMotor.RunMode.RUN_USING_ENCODER);\n        rightDriveMotor.setMode(DcMotor.RunMode.RUN_USING_ENCODER);\n        \n        // Initialize servos to safe positions\n        armServo.setPosition(ArmConstants.ARM_DOWN_POSITION);\n        clawServo.setPosition(ArmConstants.CLAW_CLOSE_POSITION);\n    }\n    \n    @Override\n    public void loop() {\n        if (!isHardwareInitialized || isEmergencyStopActive) {\n            handleEmergencyStop();\n            return;\n        }\n        \n        loopCount++;\n        \n        // Check for emergency stop\n        if (gamepad1.back) {\n            activateEmergencyStop();\n            return;\n        }\n        \n        // Process robot controls\n        handleDriveControl();\n        handleArmControl();\n        handleClawControl();\n        \n        // Safety and monitoring\n        performSafetyChecks();\n        updateSensors();\n        updateTelemetry();\n    }\n    \n    private void handleDriveControl() {\n        // Apply deadband to prevent controller drift\n        double forward = applyDeadband(-gamepad1.left_stick_y);\n        double turn = applyDeadband(gamepad1.right_stick_x);\n        \n        // Calculate motor powers using differential drive formula\n        // leftPower = forward + turn (positive turn = left turn)\n        // rightPower = forward - turn (negative turn = right turn)\n        double leftPower = (forward + turn) * DriveConstants.MAX_DRIVE_SPEED;\n        double rightPower = (forward - turn) * DriveConstants.MAX_DRIVE_SPEED;\n        \n        // Clamp power values to prevent motor damage\n        leftPower = Math.max(-1.0, Math.min(1.0, leftPower));\n        rightPower = Math.max(-1.0, Math.min(1.0, rightPower));\n        \n        // Set motor powers\n        leftDriveMotor.setPower(leftPower);\n        rightDriveMotor.setPower(rightPower);\n    }\n    \n    private void handleArmControl() {\n        // Gradual arm movement for smooth operation\n        if (gamepad1.a && currentArmPosition < ArmConstants.ARM_UP_POSITION) {\n            currentArmPosition = Math.min(ArmConstants.ARM_UP_POSITION, \n                                        currentArmPosition + ArmConstants.ARM_SPEED * 0.02);\n            armServo.setPosition(currentArmPosition);\n        } else if (gamepad1.b && currentArmPosition > ArmConstants.ARM_DOWN_POSITION) {\n            currentArmPosition = Math.max(ArmConstants.ARM_DOWN_POSITION, \n                                        currentArmPosition - ArmConstants.ARM_SPEED * 0.02);\n            armServo.setPosition(currentArmPosition);\n        }\n    }\n    \n    private void handleClawControl() {\n        // Discrete claw control (open/close)\n        if (gamepad1.x && !isClawOpen) {\n            clawServo.setPosition(ArmConstants.CLAW_OPEN_POSITION);\n            isClawOpen = true;\n            Log.d(TAG, \"Claw opened\");\n        } else if (gamepad1.y && isClawOpen) {\n            clawServo.setPosition(ArmConstants.CLAW_CLOSE_POSITION);\n            isClawOpen = false;\n            Log.d(TAG, \"Claw closed\");\n        }\n    }\n    \n    private void performSafetyChecks() {\n        // Check battery voltage\n        double batteryVoltage = getBatteryVoltage();\n        if (batteryVoltage < SafetyConstants.LOW_BATTERY_THRESHOLD) {\n            Log.w(TAG, \"Low battery voltage: \" + batteryVoltage + \" V\");\n            telemetry.addData(\"WARNING\", \"Low battery: \" + batteryVoltage + \" V\");\n        }\n        \n        // Check for excessive motor power\n        double leftPower = Math.abs(leftDriveMotor.getPower());\n        double rightPower = Math.abs(rightDriveMotor.getPower());\n        if (leftPower > SafetyConstants.HIGH_POWER_THRESHOLD || \n            rightPower > SafetyConstants.HIGH_POWER_THRESHOLD) {\n            Log.w(TAG, \"High motor power detected: L=\" + leftPower + \", R=\" + rightPower);\n        }\n    }\n    \n    private void updateSensors() {\n        // Update color sensor readings\n        if (gameElementDetector != null) {\n            try {\n                int red = gameElementDetector.red();\n                int green = gameElementDetector.green();\n                int blue = gameElementDetector.blue();\n                \n                // Log significant color detections\n                if (red > 100 && red > green && red > blue) {\n                    Log.d(TAG, \"Red object detected: R=\" + red + \", G=\" + green + \", B=\" + blue);\n                }\n            } catch (Exception e) {\n                Log.e(TAG, \"Color sensor error: \" + e.getMessage());\n            }\n        }\n        \n        // Update distance sensor readings\n        if (proximitySensor != null) {\n            try {\n                double distance = proximitySensor.getDistance(DistanceUnit.CM);\n                if (distance < SafetyConstants.SAFETY_DISTANCE_CM) {\n                    Log.w(TAG, \"Object too close: \" + distance + \" cm\");\n                }\n            } catch (Exception e) {\n                Log.e(TAG, \"Distance sensor error: \" + e.getMessage());\n            }\n        }\n    }\n    \n    private void activateEmergencyStop() {\n        isEmergencyStopActive = true;\n        \n        // Stop all motors immediately\n        leftDriveMotor.setPower(0);\n        rightDriveMotor.setPower(0);\n        \n        // Move arm to safe position\n        armServo.setPosition(ArmConstants.ARM_DOWN_POSITION);\n        clawServo.setPosition(ArmConstants.CLAW_CLOSE_POSITION);\n        \n        Log.w(TAG, \"Emergency stop activated\");\n        telemetry.addData(\"EMERGENCY\", \"STOP ACTIVATED\");\n        telemetry.update();\n    }\n    \n    private void handleEmergencyStop() {\n        telemetry.addData(\"Status\", isEmergencyStopActive ? \"EMERGENCY STOP\" : \"Not Initialized\");\n        telemetry.update();\n    }\n    \n    private double applyDeadband(double input) {\n        return Math.abs(input) < DriveConstants.DEADBAND_THRESHOLD ? 0.0 : input;\n    }\n    \n    private void updateTelemetry() {\n        long currentTime = System.currentTimeMillis();\n        if (currentTime - lastTelemetryUpdate > SafetyConstants.TELEMETRY_UPDATE_INTERVAL_MS) {\n            telemetry.addData(\"Status\", \"Running\");\n            telemetry.addData(\"Loop Count\", loopCount);\n            telemetry.addData(\"Runtime\", \"%.1f s\", runtime.seconds());\n            telemetry.addData(\"Left Power\", \"%.2f\", leftDriveMotor.getPower());\n            telemetry.addData(\"Right Power\", \"%.2f\", rightDriveMotor.getPower());\n            telemetry.addData(\"Arm Position\", \"%.2f\", currentArmPosition);\n            telemetry.addData(\"Claw\", isClawOpen ? \"OPEN\" : \"CLOSED\");\n            telemetry.addData(\"Battery\", \"%.2f V\", getBatteryVoltage());\n            telemetry.update();\n            lastTelemetryUpdate = currentTime;\n        }\n    }\n    \n    private double getBatteryVoltage() {\n        try {\n            return hardwareMap.voltageSensor.get(\"Expansion Hub 2\").getVoltage();\n        } catch (Exception e) {\n            Log.e(TAG, \"Battery voltage error: \" + e.getMessage());\n            return 0.0;\n        }\n    }\n}"
        }
      ]
    },
    {
      "type": "link-grid",
      "title": "Additional Resources",
      "links": [
        "<a href=\"https://google.github.io/eng-practices/review/\" target=\"_blank\">Google Code Review Guidelines</a>",
        "<a href=\"https://git-scm.com/book/en/v2/Git-Branching-Branches-in-a-Nutshell\" target=\"_blank\">Git Branching</a>"
      ]
    }
  ]
} 