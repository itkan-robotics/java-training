{
  "title": "Code Review",
  "sections": [
    {
      "type": "text",
      "title": "Introduction to Code Review",
      "content": "Code review is a systematic process of examining code to find bugs, improve quality, and ensure consistency. For FTC teams, code reviews help catch issues early and improve team collaboration. This lesson covers how to conduct effective code reviews for robot programming."
    },
    {
      "type": "rules-box",
      "title": "Why Code Review Matters for FTC",
      "items": [
        "Catches bugs before they reach the robot during competition",
        "Improves code quality and maintainability",
        "Helps team members learn from each other",
        "Ensures safety and performance standards are met",
        "Maintains consistent coding standards across the team"
      ]
    },
    {
      "type": "text",
      "title": "Code Review Process for FTC Teams",
      "content": "Establishing a systematic code review process helps ensure all code changes are properly examined. A good review process includes checklists, feedback guidelines, and clear communication."
    },
    {
      "type": "code",
      "title": "Code Review Checklist Implementation",
      "content": "Implement a comprehensive code review checklist for FTC projects:",
      "code": "// Code Review Checklist for FTC Projects\n// This class provides a framework for systematic code reviews\n\npublic class CodeReviewChecklist {\n    \n    /**\n     * Main review categories for FTC code\n     */\n    public static class ReviewCategories {\n        public static final String FUNCTIONALITY = \"Functionality\";\n        public static final String SAFETY = \"Safety\";\n        public static final String PERFORMANCE = \"Performance\";\n        public static final String STYLE = \"Code Style\";\n        public static final String DOCUMENTATION = \"Documentation\";\n    }\n    \n    /**\n     * Comprehensive checklist for FTC code reviews\n     */\n    public static class FTCCodeReviewChecklist {\n        \n        // Functionality checks\n        public static final String[] FUNCTIONALITY_CHECKS = {\n            \"Does the code do what it's supposed to do?\",\n            \"Are all edge cases handled?\",\n            \"Does the code handle hardware failures gracefully?\",\n            \"Are there any infinite loops or deadlocks?\",\n            \"Does the autonomous sequence complete successfully?\",\n            \"Are gamepad controls intuitive and responsive?\",\n            \"Does the robot stop when it should?\"\n        };\n        \n        // Safety checks\n        public static final String[] SAFETY_CHECKS = {\n            \"Are there safety timeouts for all operations?\",\n            \"Does the robot stop if sensors detect obstacles?\",\n            \"Are motor powers limited to safe values?\",\n            \"Is there emergency stop functionality?\",\n            \"Does the code prevent the robot from damaging itself?\",\n            \"Are there checks for hardware initialization failures?\",\n            \"Does the robot have a safe default state?\"\n        };\n        \n        // Performance checks\n        public static final String[] PERFORMANCE_CHECKS = {\n            \"Does the main loop run at acceptable speed (50Hz)?\",\n            \"Are there any memory leaks or excessive object creation?\",\n            \"Are sensor readings optimized (not read too frequently)?\",\n            \"Are complex calculations broken into smaller pieces?\",\n            \"Is telemetry updated at reasonable intervals?\",\n            \"Are there any blocking operations in the main loop?\",\n            \"Is the code efficient for the target hardware?\"\n        };\n        \n        // Code style checks\n        public static final String[] STYLE_CHECKS = {\n            \"Are variable and method names descriptive?\",\n            \"Is the code properly indented and formatted?\",\n            \"Are there consistent naming conventions?\",\n            \"Is the code organized into logical methods?\",\n            \"Are magic numbers replaced with named constants?\",\n            \"Is the code readable and well-structured?\",\n            \"Are there appropriate comments for complex logic?\"\n        };\n        \n        // Documentation checks\n        public static final String[] DOCUMENTATION_CHECKS = {\n            \"Is there JavaDoc for public methods?\",\n            \"Are complex algorithms explained with comments?\",\n            \"Is there a README file for the project?\",\n            \"Are hardware configurations documented?\",\n            \"Are there comments explaining robot behavior?\",\n            \"Is the code self-documenting where possible?\",\n            \"Are there inline comments for non-obvious code?\"\n        };\n    }\n    \n    /**\n     * Example of a well-reviewed OpMode that follows the checklist\n     */\n    public static class ReviewedOpMode extends OpMode {\n        \n        // Constants - no magic numbers\n        private static final double MAX_DRIVE_SPEED = 0.8;\n        private static final double MAX_TURN_SPEED = 0.6;\n        private static final double DEADZONE_THRESHOLD = 0.1;\n        private static final double SAFETY_DISTANCE_CM = 10.0;\n        private static final long TELEMETRY_UPDATE_INTERVAL_MS = 100;\n        \n        // Hardware components - clearly named\n        private DcMotor leftDriveMotor, rightDriveMotor;\n        private Servo armServo, clawServo;\n        private ColorSensor gameElementDetector;\n        private DistanceSensor proximitySensor;\n        \n        // State variables - descriptive names\n        private boolean isEmergencyStopActive = false;\n        private long lastTelemetryUpdate = 0;\n        private double currentArmPosition = 0.5;\n        private boolean isClawOpen = false;\n        \n        /**\n         * Initializes the OpMode and all hardware components.\n         * Includes safety checks and error handling.\n         */\n        @Override\n        public void init() {\n            try {\n                initializeHardware();\n                configureHardware();\n                resetRobotState();\n                displayInitializationStatus();\n            } catch (Exception e) {\n                handleInitializationError(e);\n            }\n        }\n        \n        /**\n         * Main control loop with safety and performance considerations.\n         * Runs at approximately 50Hz for smooth robot control.\n         */\n        @Override\n        public void loop() {\n            // Check for emergency stop first\n            if (isEmergencyStopActive) {\n                stopAllMotors();\n                return;\n            }\n            \n            // Process input with safety checks\n            processDriverInput();\n            \n            // Update robot state\n            updateRobotState();\n            \n            // Apply safety checks\n            applySafetyChecks();\n            \n            // Update telemetry periodically for performance\n            updateTelemetryIfNeeded();\n        }\n        \n        /**\n         * Initializes all hardware components with error handling.\n         * Throws exception if critical hardware is missing.\n         */\n        private void initializeHardware() throws Exception {\n            // Initialize drive motors\n            leftDriveMotor = hardwareMap.get(DcMotor.class, \"left_drive\");\n            rightDriveMotor = hardwareMap.get(DcMotor.class, \"right_drive\");\n            \n            // Initialize servos\n            armServo = hardwareMap.get(Servo.class, \"arm_servo\");\n            clawServo = hardwareMap.get(Servo.class, \"claw_servo\");\n            \n            // Initialize sensors\n            gameElementDetector = hardwareMap.get(ColorSensor.class, \"color_sensor\");\n            proximitySensor = hardwareMap.get(DistanceSensor.class, \"distance_sensor\");\n            \n            // Verify critical hardware is available\n            if (leftDriveMotor == null || rightDriveMotor == null) {\n                throw new Exception(\"Critical drive motors not found\");\n            }\n        }\n        \n        /**\n         * Configures hardware settings for safe operation.\n         */\n        private void configureHardware() {\n            // Configure drive motors for safety\n            leftDriveMotor.setDirection(DcMotor.Direction.FORWARD);\n            rightDriveMotor.setDirection(DcMotor.Direction.REVERSE);\n            leftDriveMotor.setZeroPowerBehavior(DcMotor.ZeroPowerBehavior.BRAKE);\n            rightDriveMotor.setZeroPowerBehavior(DcMotor.ZeroPowerBehavior.BRAKE);\n            \n            // Set initial servo positions\n            if (armServo != null) armServo.setPosition(currentArmPosition);\n            if (clawServo != null) clawServo.setPosition(isClawOpen ? 1.0 : 0.0);\n        }\n        \n        /**\n         * Resets robot to a safe default state.\n         */\n        private void resetRobotState() {\n            isEmergencyStopActive = false;\n            currentArmPosition = 0.5;\n            isClawOpen = false;\n            lastTelemetryUpdate = 0;\n        }\n        \n        /**\n         * Processes driver input with safety limits and deadzone.\n         */\n        private void processDriverInput() {\n            // Read gamepad input with deadzone\n            double forward = applyDeadzone(-gamepad1.left_stick_y);\n            double turn = applyDeadzone(gamepad1.right_stick_x);\n            \n            // Apply speed limits for safety\n            forward *= MAX_DRIVE_SPEED;\n            turn *= MAX_TURN_SPEED;\n            \n            // Calculate motor powers\n            double leftPower = forward + turn;\n            double rightPower = forward - turn;\n            \n            // Set motor powers with safety check\n            setDrivePowers(leftPower, rightPower);\n            \n            // Process arm controls\n            processArmControls();\n            \n            // Process claw controls\n            processClawControls();\n        }\n        \n        /**\n         * Applies deadzone to prevent drift from controller.\n         * @param input The raw input value\n         * @return The input value with deadzone applied\n         */\n        private double applyDeadzone(double input) {\n            return Math.abs(input) < DEADZONE_THRESHOLD ? 0.0 : input;\n        }\n        \n        /**\n         * Processes arm control input with safety limits.\n         */\n        private void processArmControls() {\n            if (gamepad1.dpad_up) {\n                currentArmPosition = Math.min(1.0, currentArmPosition + 0.02);\n            } else if (gamepad1.dpad_down) {\n                currentArmPosition = Math.max(0.0, currentArmPosition - 0.02);\n            }\n            \n            if (armServo != null) {\n                armServo.setPosition(currentArmPosition);\n            }\n        }\n        \n        /**\n         * Processes claw control input.\n         */\n        private void processClawControls() {\n            if (gamepad1.a && !isClawOpen) {\n                openClaw();\n            } else if (gamepad1.b && isClawOpen) {\n                closeClaw();\n            }\n        }\n        \n        /**\n         * Updates robot state and performs periodic checks.\n         */\n        private void updateRobotState() {\n            // Check for emergency stop conditions\n            if (gamepad1.back) {\n                activateEmergencyStop();\n            }\n            \n            // Update sensor readings if needed\n            updateSensorReadings();\n        }\n        \n        /**\n         * Applies safety checks to prevent robot damage.\n         */\n        private void applySafetyChecks() {\n            // Check proximity sensor for obstacles\n            if (proximitySensor != null) {\n                double distance = proximitySensor.getDistance(DistanceUnit.CM);\n                if (distance < SAFETY_DISTANCE_CM && distance > 0) {\n                    // Too close to obstacle - stop driving\n                    setDrivePowers(0.0, 0.0);\n                    telemetry.addData(\"Safety\", \"Stopped - too close to obstacle\");\n                }\n            }\n            \n            // Check for hardware failures\n            if (leftDriveMotor == null || rightDriveMotor == null) {\n                activateEmergencyStop();\n            }\n        }\n        \n        /**\n         * Updates telemetry periodically for performance.\n         */\n        private void updateTelemetryIfNeeded() {\n            long currentTime = System.currentTimeMillis();\n            if (currentTime - lastTelemetryUpdate > TELEMETRY_UPDATE_INTERVAL_MS) {\n                updateTelemetry();\n                lastTelemetryUpdate = currentTime;\n            }\n        }\n        \n        /**\n         * Sets drive motor powers with safety limits.\n         * @param leftPower Left motor power (-1.0 to 1.0)\n         * @param rightPower Right motor power (-1.0 to 1.0)\n         */\n        private void setDrivePowers(double leftPower, double rightPower) {\n            // Apply safety limits\n            leftPower = Math.max(-1.0, Math.min(1.0, leftPower));\n            rightPower = Math.max(-1.0, Math.min(1.0, rightPower));\n            \n            if (leftDriveMotor != null) leftDriveMotor.setPower(leftPower);\n            if (rightDriveMotor != null) rightDriveMotor.setPower(rightPower);\n        }\n        \n        /**\n         * Opens the claw safely.\n         */\n        private void openClaw() {\n            if (clawServo != null) {\n                clawServo.setPosition(1.0);\n                isClawOpen = true;\n            }\n        }\n        \n        /**\n         * Closes the claw safely.\n         */\n        private void closeClaw() {\n            if (clawServo != null) {\n                clawServo.setPosition(0.0);\n                isClawOpen = false;\n            }\n        }\n        \n        /**\n         * Stops all motors for safety.\n         */\n        private void stopAllMotors() {\n            setDrivePowers(0.0, 0.0);\n        }\n        \n        /**\n         * Activates emergency stop mode.\n         */\n        private void activateEmergencyStop() {\n            isEmergencyStopActive = true;\n            stopAllMotors();\n            telemetry.addData(\"EMERGENCY\", \"Emergency stop activated\");\n        }\n        \n        /**\n         * Updates sensor readings efficiently.\n         */\n        private void updateSensorReadings() {\n            // Sensor readings are handled in applySafetyChecks()\n            // This method is for any additional sensor processing\n        }\n        \n        /**\n         * Updates telemetry with robot status information.\n         */\n        private void updateTelemetry() {\n            telemetry.addData(\"=== Robot Status ===\", \"\");\n            telemetry.addData(\"Emergency Stop\", isEmergencyStopActive ? \"ACTIVE\" : \"Inactive\");\n            telemetry.addData(\"Left Motor Power\", leftDriveMotor != null ? leftDriveMotor.getPower() : 0.0);\n            telemetry.addData(\"Right Motor Power\", rightDriveMotor != null ? rightDriveMotor.getPower() : 0.0);\n            telemetry.addData(\"Arm Position\", String.format(\"%.2f\", currentArmPosition));\n            telemetry.addData(\"Claw Status\", isClawOpen ? \"Open\" : \"Closed\");\n            \n            if (proximitySensor != null) {\n                telemetry.addData(\"Distance (cm)\", String.format(\"%.1f\", proximitySensor.getDistance(DistanceUnit.CM)));\n            }\n            \n            telemetry.addData(\"Runtime\", String.format(\"%.1f\", getRuntime()));\n        }\n        \n        /**\n         * Handles initialization errors gracefully.\n         * @param e The exception that occurred\n         */\n        private void handleInitializationError(Exception e) {\n            telemetry.addData(\"ERROR\", \"Initialization failed: \" + e.getMessage());\n            isEmergencyStopActive = true;\n        }\n        \n        /**\n         * Displays initialization status to driver.\n         */\n        private void displayInitializationStatus() {\n            telemetry.addData(\"Status\", \"Initialization complete\");\n            telemetry.addData(\"Hardware Ready\", (leftDriveMotor != null && rightDriveMotor != null) ? \"Yes\" : \"No\");\n        }\n    }\n}"
    },
    {
      "type": "text",
      "title": "Common FTC-Specific Code Issues",
      "content": "FTC code has specific patterns and common issues that reviewers should look for. Understanding these patterns helps identify potential problems before they cause issues during competition."
    },
    {
      "type": "code",
      "title": "Common Issues and Solutions",
      "content": "Examples of common FTC code issues and how to fix them:",
      "code": "// Common FTC Code Issues and Solutions\n\npublic class CommonIssuesExamples {\n    \n    /**\n     * ISSUE 1: No deadzone on gamepad input\n     * PROBLEM: Controller drift causes unwanted movement\n     * SOLUTION: Apply deadzone to prevent drift\n     */\n    public static class DeadzoneExample {\n        // BAD - No deadzone\n        public void badGamepadProcessing() {\n            double forward = gamepad1.left_stick_y;\n            double turn = gamepad1.right_stick_x;\n            // This can cause unwanted movement from controller drift\n        }\n        \n        // GOOD - With deadzone\n        public void goodGamepadProcessing() {\n            double forward = applyDeadzone(gamepad1.left_stick_y);\n            double turn = applyDeadzone(gamepad1.right_stick_x);\n            // Prevents unwanted movement from controller drift\n        }\n        \n        private double applyDeadzone(double input) {\n            return Math.abs(input) < 0.1 ? 0.0 : input;\n        }\n    }\n    \n    /**\n     * ISSUE 2: No safety timeouts\n     * PROBLEM: Robot can get stuck in operations\n     * SOLUTION: Add timeouts for all operations\n     */\n    public static class TimeoutExample {\n        private double operationStartTime;\n        private static final double OPERATION_TIMEOUT = 5.0; // 5 seconds\n        \n        // BAD - No timeout\n        public void badOperation() {\n            while (!isOperationComplete()) {\n                // Robot can get stuck here forever\n                performOperation();\n            }\n        }\n        \n        // GOOD - With timeout\n        public void goodOperation() {\n            operationStartTime = getRuntime();\n            while (!isOperationComplete() && !isTimeoutReached()) {\n                performOperation();\n            }\n            \n            if (isTimeoutReached()) {\n                handleTimeout();\n            }\n        }\n        \n        private boolean isTimeoutReached() {\n            return getRuntime() - operationStartTime > OPERATION_TIMEOUT;\n        }\n        \n        private void handleTimeout() {\n            // Stop operation and notify driver\n            stopOperation();\n            telemetry.addData(\"Warning\", \"Operation timed out\");\n        }\n    }\n    \n    /**\n     * ISSUE 3: No hardware failure handling\n     * PROBLEM: Code crashes if hardware is missing or fails\n     * SOLUTION: Check for null and handle exceptions\n     */\n    public static class HardwareFailureExample {\n        private DcMotor driveMotor;\n        \n        // BAD - No null check\n        public void badHardwareAccess() {\n            driveMotor = hardwareMap.get(DcMotor.class, \"drive_motor\");\n            driveMotor.setPower(0.5); // Crashes if motor is null\n        }\n        \n        // GOOD - With null check\n        public void goodHardwareAccess() {\n            driveMotor = hardwareMap.get(DcMotor.class, \"drive_motor\");\n            if (driveMotor != null) {\n                driveMotor.setPower(0.5);\n            } else {\n                telemetry.addData(\"ERROR\", \"Drive motor not found\");\n            }\n        }\n    }\n    \n    /**\n     * ISSUE 4: Inefficient telemetry updates\n     * PROBLEM: Too much telemetry slows down the main loop\n     * SOLUTION: Update telemetry periodically\n     */\n    public static class TelemetryExample {\n        private long lastTelemetryUpdate = 0;\n        private static final long TELEMETRY_INTERVAL = 100; // 100ms\n        \n        // BAD - Updates every loop\n        public void badTelemetryUpdate() {\n            telemetry.addData(\"Runtime\", getRuntime());\n            telemetry.addData(\"Motor Power\", motor.getPower());\n            telemetry.addData(\"Sensor Value\", sensor.getValue());\n            // This runs every 20ms, which is excessive\n        }\n        \n        // GOOD - Updates periodically\n        public void goodTelemetryUpdate() {\n            long currentTime = System.currentTimeMillis();\n            if (currentTime - lastTelemetryUpdate > TELEMETRY_INTERVAL) {\n                telemetry.addData(\"Runtime\", getRuntime());\n                telemetry.addData(\"Motor Power\", motor.getPower());\n                telemetry.addData(\"Sensor Value\", sensor.getValue());\n                lastTelemetryUpdate = currentTime;\n            }\n        }\n    }\n    \n    /**\n     * ISSUE 5: No emergency stop functionality\n     * PROBLEM: No way to stop robot quickly in emergency\n     * SOLUTION: Implement emergency stop\n     */\n    public static class EmergencyStopExample {\n        private boolean emergencyStopActive = false;\n        \n        // BAD - No emergency stop\n        public void badMainLoop() {\n            processInput();\n            updateRobot();\n            // No way to stop quickly\n        }\n        \n        // GOOD - With emergency stop\n        public void goodMainLoop() {\n            // Check for emergency stop first\n            if (emergencyStopActive) {\n                stopAllMotors();\n                return;\n            }\n            \n            // Check for emergency stop button\n            if (gamepad1.back) {\n                activateEmergencyStop();\n                return;\n            }\n            \n            processInput();\n            updateRobot();\n        }\n        \n        private void activateEmergencyStop() {\n            emergencyStopActive = true;\n            stopAllMotors();\n            telemetry.addData(\"EMERGENCY\", \"Emergency stop activated\");\n        }\n        \n        private void stopAllMotors() {\n            // Stop all motors\n        }\n    }\n    \n    /**\n     * ISSUE 6: Magic numbers in code\n     * PROBLEM: Hard to understand and maintain\n     * SOLUTION: Use named constants\n     */\n    public static class MagicNumbersExample {\n        // BAD - Magic numbers\n        public void badCode() {\n            motor.setPower(0.8); // What does 0.8 mean?\n            servo.setPosition(0.5); // What does 0.5 mean?\n            if (distance < 10.0) { // What does 10.0 mean?\n                stop();\n            }\n        }\n        \n        // GOOD - Named constants\n        public static class GoodCode {\n            private static final double MAX_DRIVE_SPEED = 0.8;\n            private static final double ARM_MIDDLE_POSITION = 0.5;\n            private static final double SAFETY_DISTANCE_CM = 10.0;\n            \n            public void goodCode() {\n                motor.setPower(MAX_DRIVE_SPEED);\n                servo.setPosition(ARM_MIDDLE_POSITION);\n                if (distance < SAFETY_DISTANCE_CM) {\n                    stop();\n                }\n            }\n        }\n    }\n    \n    /**\n     * ISSUE 7: No state management\n     * PROBLEM: Robot behavior is unpredictable\n     * SOLUTION: Use clear state machines\n     */\n    public static class StateManagementExample {\n        // BAD - No clear state\n        public void badStateManagement() {\n            if (gamepad1.a) {\n                // Do something\n            } else if (gamepad1.b) {\n                // Do something else\n            }\n            // Hard to understand what state the robot is in\n        }\n        \n        // GOOD - Clear state management\n        public static class GoodStateManagement {\n            private enum RobotState {\n                IDLE, COLLECTING, RETURNING, COMPLETED\n            }\n            \n            private RobotState currentState = RobotState.IDLE;\n            \n            public void goodStateManagement() {\n                switch (currentState) {\n                    case IDLE:\n                        handleIdleState();\n                        break;\n                    case COLLECTING:\n                        handleCollectingState();\n                        break;\n                    case RETURNING:\n                        handleReturningState();\n                        break;\n                    case COMPLETED:\n                        handleCompletedState();\n                        break;\n                }\n            }\n            \n            private void handleIdleState() {\n                // Clear behavior for idle state\n            }\n            \n            private void handleCollectingState() {\n                // Clear behavior for collecting state\n            }\n            \n            private void handleReturningState() {\n                // Clear behavior for returning state\n            }\n            \n            private void handleCompletedState() {\n                // Clear behavior for completed state\n            }\n        }\n    }\n}"
    },
    {
      "type": "text",
      "title": "Performance and Safety Review Criteria",
      "content": "Performance and safety are critical for FTC robots. Reviewers must ensure code meets performance requirements and includes proper safety measures."
    },
    {
      "type": "rules-box",
      "title": "Performance Review Criteria",
      "items": [
        "Main loop runs at 50Hz (20ms per loop) or faster",
        "No blocking operations in the main loop",
        "Telemetry updates are limited to reasonable frequency",
        "Memory usage is optimized (no excessive object creation)",
        "Sensor readings are not performed too frequently",
        "Complex calculations are broken into smaller pieces"
      ]
    },
    {
      "type": "rules-box",
      "title": "Safety Review Criteria",
      "items": [
        "All operations have timeout limits",
        "Emergency stop functionality is implemented",
        "Motor powers are limited to safe values",
        "Proximity sensors are used to prevent collisions",
        "Hardware failures are handled gracefully",
        "Robot has a safe default state when stopped"
      ]
    },
    {
      "type": "text",
      "title": "Collaborative Development Workflows",
      "content": "Effective collaboration requires clear workflows, communication, and conflict resolution strategies. Teams need to work together efficiently while maintaining code quality."
    },
    {
      "type": "code",
      "title": "Git Workflow for Team Collaboration",
      "content": "Implement a collaborative Git workflow for FTC teams:",
      "code": "// Git Workflow for FTC Team Collaboration\n\n/*\n * BRANCHING STRATEGY FOR FTC TEAMS\n * \n * Main Branch Structure:\n * - main: Production-ready code for competition\n * - development: Integration branch for testing\n * - feature/*: Individual feature branches\n * - hotfix/*: Emergency fixes for competition\n * \n * Workflow:\n * 1. Create feature branch from development\n * 2. Develop and test feature\n * 3. Create pull request to development\n * 4. Code review and testing\n * 5. Merge to development\n * 6. Integration testing\n * 7. Merge to main for competition\n * \n * Example Commands:\n * \n * # Start new feature\n * git checkout development\n * git pull origin development\n * git checkout -b feature/autonomous-collector\n * \n * # Develop feature\n * # ... make changes ...\n * git add .\n * git commit -m \"Add autonomous collector functionality\"\n * git push origin feature/autonomous-collector\n * \n * # Create pull request (on GitHub/GitLab)\n * # Review and merge to development\n * \n * # Prepare for competition\n * git checkout main\n * git merge development\n * git tag -a v1.0 -m \"Competition version 1.0\"\n * git push origin main --tags\n */\n\n// Example of team collaboration in code\npublic class TeamCollaborationExample {\n    \n    /**\n     * Configuration class that can be easily modified by team members\n     * without affecting core functionality\n     */\n    public static class TeamConfiguration {\n        // Drive configuration - can be adjusted by drive team\n        public static final double DRIVE_SPEED_MULTIPLIER = 0.8;\n        public static final double TURN_SPEED_MULTIPLIER = 0.6;\n        public static final double DEADZONE_THRESHOLD = 0.1;\n        \n        // Autonomous configuration - can be adjusted by programming team\n        public static final double AUTONOMOUS_DRIVE_SPEED = 0.5;\n        public static final double COLLECTION_TIMEOUT = 3.0;\n        public static final double RETURN_TIMEOUT = 5.0;\n        \n        // Safety configuration - can be adjusted by safety officer\n        public static final double SAFETY_DISTANCE_CM = 10.0;\n        public static final boolean ENABLE_EMERGENCY_STOP = true;\n        public static final double MAX_MOTOR_POWER = 0.9;\n        \n        // Competition-specific settings\n        public static final String COMPETITION_NAME = \"Regional Championship\";\n        public static final String TEAM_NUMBER = \"1234\";\n        public static final String ROBOT_NAME = \"CompetitionBot\";\n    }\n    \n    /**\n     * Modular OpMode that allows different team members to work on\n     * different components independently\n     */\n    public static class CollaborativeOpMode extends OpMode {\n        \n        // Controllers that can be developed independently\n        private DriveController driveController;\n        private ArmController armController;\n        private SensorController sensorController;\n        private AutonomousController autonomousController;\n        \n        @Override\n        public void init() {\n            // Initialize all controllers\n            initializeControllers();\n            \n            // Display team information\n            displayTeamInfo();\n        }\n        \n        @Override\n        public void loop() {\n            // Check for emergency stop first\n            if (TeamConfiguration.ENABLE_EMERGENCY_STOP && isEmergencyStopRequested()) {\n                handleEmergencyStop();\n                return;\n            }\n            \n            // Process input based on current mode\n            if (isAutonomousMode()) {\n                autonomousController.update();\n            } else {\n                processTeleopInput();\n            }\n            \n            // Update all controllers\n            updateControllers();\n            \n            // Apply safety checks\n            applySafetyChecks();\n            \n            // Update telemetry\n            updateTelemetry();\n        }\n        \n        /**\n         * Initialize all controllers - each can be developed by different team members\n         */\n        private void initializeControllers() {\n            driveController = new DriveController(hardwareMap);\n            armController = new ArmController(hardwareMap);\n            sensorController = new SensorController(hardwareMap);\n            autonomousController = new AutonomousController(driveController, armController, sensorController);\n            \n            // Configure controllers with team settings\n            driveController.setMaxSpeed(TeamConfiguration.MAX_MOTOR_POWER);\n            armController.setSpeed(0.02);\n        }\n        \n        /**\n         * Display team and competition information\n         */\n        private void displayTeamInfo() {\n            telemetry.addData(\"Team\", TeamConfiguration.TEAM_NUMBER);\n            telemetry.addData(\"Robot\", TeamConfiguration.ROBOT_NAME);\n            telemetry.addData(\"Competition\", TeamConfiguration.COMPETITION_NAME);\n            telemetry.addData(\"Version\", getVersionInfo());\n        }\n        \n        /**\n         * Process teleop input with team configuration\n         */\n        private void processTeleopInput() {\n            // Apply team-specific speed multipliers\n            double forward = applyDeadzone(-gamepad1.left_stick_y) * TeamConfiguration.DRIVE_SPEED_MULTIPLIER;\n            double turn = applyDeadzone(gamepad1.right_stick_x) * TeamConfiguration.TURN_SPEED_MULTIPLIER;\n            \n            driveController.drive(forward, turn);\n            \n            // Process arm controls\n            if (gamepad1.dpad_up) armController.moveUp();\n            if (gamepad1.dpad_down) armController.moveDown();\n            \n            // Process claw controls\n            if (gamepad1.a) armController.toggleClaw();\n            \n            // Toggle autonomous mode\n            if (gamepad1.x) toggleAutonomousMode();\n        }\n        \n        /**\n         * Update all controllers\n         */\n        private void updateControllers() {\n            sensorController.update();\n            \n            if (isAutonomousMode()) {\n                autonomousController.update();\n            }\n        }\n        \n        /**\n         * Apply safety checks using team configuration\n         */\n        private void applySafetyChecks() {\n            // Check proximity using team safety distance\n            if (sensorController.getDistance() < TeamConfiguration.SAFETY_DISTANCE_CM) {\n                driveController.stop();\n                telemetry.addData(\"Safety\", \"Stopped - too close to obstacle\");\n            }\n            \n            // Check for hardware failures\n            if (!driveController.isHealthy() || !armController.isHealthy()) {\n                handleHardwareFailure();\n            }\n        }\n        \n        // Helper methods\n        private double applyDeadzone(double input) {\n            return Math.abs(input) < TeamConfiguration.DEADZONE_THRESHOLD ? 0.0 : input;\n        }\n        \n        private boolean isEmergencyStopRequested() {\n            return gamepad1.back;\n        }\n        \n        private void handleEmergencyStop() {\n            driveController.stop();\n            armController.stop();\n            telemetry.addData(\"EMERGENCY\", \"Emergency stop activated\");\n        }\n        \n        private boolean isAutonomousMode() {\n            // Implementation for autonomous mode toggle\n            return false; // Placeholder\n        }\n        \n        private void toggleAutonomousMode() {\n            // Implementation for toggling autonomous mode\n        }\n        \n        private void handleHardwareFailure() {\n            driveController.stop();\n            armController.stop();\n            telemetry.addData(\"ERROR\", \"Hardware failure detected\");\n        }\n        \n        private String getVersionInfo() {\n            return \"1.0.0\"; // This could be read from a version file\n        }\n        \n        private void updateTelemetry() {\n            telemetry.addData(\"Mode\", isAutonomousMode() ? \"Autonomous\" : \"Teleop\");\n            telemetry.addData(\"Drive Status\", driveController.getStatus());\n            telemetry.addData(\"Arm Status\", armController.getStatus());\n            telemetry.addData(\"Distance (cm)\", String.format(\"%.1f\", sensorController.getDistance()));\n        }\n    }\n    \n    // Placeholder controller classes - these would be implemented by different team members\n    public static class DriveController {\n        public DriveController(HardwareMap hardwareMap) {}\n        public void setMaxSpeed(double speed) {}\n        public void drive(double forward, double turn) {}\n        public void stop() {}\n        public boolean isHealthy() { return true; }\n        public String getStatus() { return \"OK\"; }\n    }\n    \n    public static class ArmController {\n        public ArmController(HardwareMap hardwareMap) {}\n        public void setSpeed(double speed) {}\n        public void moveUp() {}\n        public void moveDown() {}\n        public void toggleClaw() {}\n        public void stop() {}\n        public boolean isHealthy() { return true; }\n        public String getStatus() { return \"OK\"; }\n    }\n    \n    public static class SensorController {\n        public SensorController(HardwareMap hardwareMap) {}\n        public void update() {}\n        public double getDistance() { return 100.0; }\n    }\n    \n    public static class AutonomousController {\n        public AutonomousController(DriveController drive, ArmController arm, SensorController sensor) {}\n        public void update() {}\n    }\n}"
    },
    {
      "type": "exercise-box",
      "title": "Code Review Exercise",
      "description": "Practice conducting code reviews by reviewing a sample OpMode and identifying issues using the checklist provided in this lesson.",
      "tasks": [
        "Review the provided sample OpMode using the checklist",
        "Identify at least 5 issues in the code",
        "Suggest specific improvements for each issue",
        "Write a code review report with findings",
        "Implement fixes for the identified issues",
        "Conduct a follow-up review of the improved code"
      ],
      "content": "// Sample OpMode for code review exercise\npublic class CodeReviewExerciseOpMode extends OpMode {\n    // TODO: This OpMode has several issues that need to be identified\n    // TODO: Use the checklist to find problems\n    // TODO: Suggest improvements\n    // TODO: Implement fixes\n    \n    private DcMotor left, right;\n    private Servo arm;\n    private ColorSensor sensor;\n    \n    @Override\n    public void init() {\n        left = hardwareMap.get(DcMotor.class, \"left\");\n        right = hardwareMap.get(DcMotor.class, \"right\");\n        arm = hardwareMap.get(Servo.class, \"arm\");\n        sensor = hardwareMap.get(ColorSensor.class, \"sensor\");\n    }\n    \n    @Override\n    public void loop() {\n        // TODO: Identify issues in this code\n        // TODO: Apply fixes based on review findings\n    }\n}"
    },
    {
      "type": "link-grid",
      "title": "Additional Resources",
      "links": [
        "<a href=\"https://google.github.io/eng-practices/review/\" target=\"_blank\">Google Code Review Guidelines</a>",
        "<a href=\"https://gm0.org/en/latest/docs/software/tutorials/common-mistakes.html\" target=\"_blank\">gm0: Common Mistakes</a>",
        "<a href=\"https://ftc-docs.firstinspires.org/en/latest/programming_resources/safety/safety.html\" target=\"_blank\">FTC Safety Documentation</a>",
        "<a href=\"https://git-scm.com/book/en/v2/Git-Branching-Branches-in-a-Nutshell\" target=\"_blank\">Git Branching</a>"
      ]
    }
  ]
} 