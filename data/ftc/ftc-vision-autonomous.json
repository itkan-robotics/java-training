{
  "title": "Vision-Based Autonomous",
  "sections": [
    {
      "title": "Introduction to Vision-Based Autonomous",
      "content": "Vision-based autonomous combines computer vision with advanced autonomous programming to create robots that can navigate and interact with their environment intelligently. This is the cutting edge of FTC autonomous programming."
    },
    {
      "title": "Vision Navigation",
      "content": "Using vision for precise navigation and positioning:\n\n```java\npublic class VisionNavigation {\n    private AprilTagDetector aprilTagDetector;\n    private ColorShapeDetector objectDetector;\n    private DcMotor leftMotor, rightMotor;\n    private BNO055IMU imu;\n    \n    public void navigateToAprilTag(int targetTagId, double targetDistance) {\n        AprilTagDetection targetTag = aprilTagDetector.getTagById(targetTagId);\n        \n        if (targetTag != null) {\n            // Get tag pose information\n            double distance = targetTag.pose.z; // Distance to tag\n            double angle = Math.atan2(targetTag.pose.x, targetTag.pose.z); // Angle to tag\n            \n            // Navigate to tag\n            while (Math.abs(distance - targetDistance) > 0.05 || Math.abs(angle) > 0.1) {\n                // Calculate motor powers based on distance and angle\n                double forwardPower = (distance - targetDistance) * 0.5;\n                double turnPower = angle * 0.8;\n                \n                // Apply powers\n                leftMotor.setPower(forwardPower - turnPower);\n                rightMotor.setPower(forwardPower + turnPower);\n                \n                // Update detection\n                targetTag = aprilTagDetector.getTagById(targetTagId);\n                if (targetTag != null) {\n                    distance = targetTag.pose.z;\n                    angle = Math.atan2(targetTag.pose.x, targetTag.pose.z);\n                }\n                \n                sleep(10);\n            }\n            \n            // Stop motors\n            leftMotor.setPower(0);\n            rightMotor.setPower(0);\n        }\n    }\n}\n```"
    },
    {
      "title": "Object Tracking and Following",
      "content": "Tracking and following objects using vision:\n\n```java\npublic class ObjectTracker {\n    private ColorShapeDetector detector;\n    private DcMotor leftMotor, rightMotor;\n    private String targetColor;\n    private String targetShape;\n    \n    public void trackObject(String color, String shape) {\n        this.targetColor = color;\n        this.targetShape = shape;\n        \n        while (opModeIsActive()) {\n            List<ColorShapeDetector.DetectedObject> objects = detector.getDetectedObjects();\n            ColorShapeDetector.DetectedObject targetObject = null;\n            \n            // Find target object\n            for (ColorShapeDetector.DetectedObject obj : objects) {\n                if (obj.color.equals(targetColor) && obj.shape.equals(targetShape)) {\n                    targetObject = obj;\n                    break;\n                }\n            }\n            \n            if (targetObject != null) {\n                // Calculate object position relative to camera center\n                double imageCenterX = 320; // Assuming 640x480 camera\n                double objectX = targetObject.center.x;\n                double error = objectX - imageCenterX;\n                \n                // Proportional control for tracking\n                double turnPower = error * 0.01; // kP = 0.01\n                double forwardPower = 0.3; // Constant forward speed\n                \n                // Apply motor powers\n                leftMotor.setPower(forwardPower - turnPower);\n                rightMotor.setPower(forwardPower + turnPower);\n                \n                telemetry.addData(\"Tracking\", \"Target found - Error: \" + error);\n            } else {\n                // Target not found - search\n                leftMotor.setPower(0.2);\n                rightMotor.setPower(-0.2);\n                telemetry.addData(\"Tracking\", \"Searching for target...\");\n            }\n            \n            telemetry.update();\n            sleep(10);\n        }\n    }\n}\n```"
    },
    {
      "title": "Vision-Based Path Planning",
      "content": "Using vision to plan and execute complex paths:\n\n```java\npublic class VisionPathPlanner {\n    private AprilTagDetector aprilTagDetector;\n    private ColorShapeDetector objectDetector;\n    private DcMotor leftMotor, rightMotor;\n    \n    public void executeVisionPath() {\n        // Phase 1: Navigate to starting position using AprilTag\n        navigateToAprilTag(1, 0.5); // Tag 1, 0.5m distance\n        \n        // Phase 2: Scan for game elements\n        List<ColorShapeDetector.DetectedObject> elements = scanForGameElements();\n        \n        // Phase 3: Navigate to each element and interact\n        for (ColorShapeDetector.DetectedObject element : elements) {\n            navigateToObject(element);\n            interactWithObject(element);\n        }\n        \n        // Phase 4: Return to scoring position\n        navigateToAprilTag(2, 0.3); // Tag 2, 0.3m distance\n        \n        // Phase 5: Score elements\n        scoreElements();\n    }\n    \n    private List<ColorShapeDetector.DetectedObject> scanForGameElements() {\n        List<ColorShapeDetector.DetectedObject> elements = new ArrayList<>();\n        \n        // Rotate robot to scan environment\n        for (int i = 0; i < 360; i += 30) { // Scan every 30 degrees\n            rotateToAngle(i);\n            \n            List<ColorShapeDetector.DetectedObject> detected = objectDetector.getDetectedObjects();\n            for (ColorShapeDetector.DetectedObject obj : detected) {\n                if (isGameElement(obj)) {\n                    elements.add(obj);\n                }\n            }\n        }\n        \n        return elements;\n    }\n    \n    private void navigateToObject(ColorShapeDetector.DetectedObject object) {\n        // Calculate distance and angle to object\n        double distance = estimateDistance(object.area);\n        double angle = calculateAngle(object.center);\n        \n        // Navigate to object\n        while (distance > 0.2 || Math.abs(angle) > 0.1) { // 20cm distance, 0.1 rad angle\n            // Proportional control\n            double forwardPower = distance * 0.5;\n            double turnPower = angle * 0.8;\n            \n            leftMotor.setPower(forwardPower - turnPower);\n            rightMotor.setPower(forwardPower + turnPower);\n            \n            // Update object detection\n            ColorShapeDetector.DetectedObject updatedObject = getUpdatedObject(object);\n            if (updatedObject != null) {\n                distance = estimateDistance(updatedObject.area);\n                angle = calculateAngle(updatedObject.center);\n            }\n            \n            sleep(10);\n        }\n        \n        // Stop at object\n        leftMotor.setPower(0);\n        rightMotor.setPower(0);\n    }\n    \n    private double estimateDistance(double area) {\n        // Estimate distance based on object area in image\n        // This requires calibration for your specific setup\n        return 1000.0 / area; // Simplified estimation\n    }\n    \n    private double calculateAngle(Point objectCenter) {\n        double imageCenterX = 320; // Camera center\n        double pixelError = objectCenter.x - imageCenterX;\n        return pixelError * 0.001; // Convert pixels to radians\n    }\n}\n```"
    },
    {
      "title": "Practice Exercise",
      "content": "Create a vision-based autonomous program that:\n\n1. **Uses AprilTags for positioning** and navigation\n2. **Detects and tracks game elements** by color and shape\n3. **Plans optimal paths** to collect and score elements\n4. **Adapts to changing conditions** in real-time\n\n**Requirements**:\n- Implement AprilTag-based navigation\n- Add object detection and tracking\n- Create vision-based path planning\n- Include error handling and recovery\n- Optimize for speed and accuracy\n\n**Advanced Challenge**:\n- Implement multi-camera vision systems\n- Add predictive object tracking\n- Create adaptive path planning\n- Integrate with advanced control systems"
    },
    {
      "title": "Common Issues and Solutions",
      "content": "**Problem**: Vision processing is too slow\n- **Solution**: Reduce image resolution, optimize algorithms\n\n**Problem**: False detections\n- **Solution**: Add validation checks, improve lighting\n\n**Problem**: Navigation is inaccurate\n- **Solution**: Calibrate camera parameters, improve PID tuning\n\n**Problem**: Vision fails in different lighting\n- **Solution**: Use adaptive thresholds, add lighting compensation\n\n**Problem**: Objects move during tracking\n- **Solution**: Implement predictive tracking, increase update rate"
    },
    {
      "title": "Next Steps",
      "content": "You now have advanced vision-based autonomous capabilities! In the next lessons, you'll learn about:\n\n- Advanced control systems and PID tuning\n- Performance optimization and debugging\n\nPractice implementing vision-based autonomous and experiment with different algorithms to maximize your robot's capabilities."
    }
  ]
} 