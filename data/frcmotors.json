{
    "id": "motors",
    "title": "Motors in FRC",
    "sections": [
      {
        "type": "text",
        "title": "Introduction to FRC Motors",
        "content": "Motors are the muscles of an FRC robot, converting electrical energy into mechanical motion. Understanding how they work and how to control them is fundamental to building a functional robot. FRC robots typically use brushed DC motors or brushless DC (BLDC) motors, controlled by motor controllers."
      },
      {
        "type": "text",
        "title": "Key Motor Properties",
        "content": "When selecting and using motors in FRC, several properties are crucial:\n<ul>\n  <li><strong>Stall Torque:</strong> The maximum torque a motor can produce when its shaft is prevented from rotating. Important for applications requiring high force at low speeds (e.g., climbing, pushing).</li>\n  <li><strong>Free Speed:</strong> The maximum rotational speed of a motor's shaft when no load is applied. Important for applications requiring high speed (e.g., shooters, drivetrains).</li>\n  <li><strong>Stall Current:</strong> The current drawn by the motor when stalled. High stall currents can trip breakers and damage components.</li>\n  <li><strong>Free Current:</strong> The current drawn by the motor when running at free speed with no load.</li>\n  <li><strong>Power:</strong> The rate at which a motor can do work. Calculated as Torque Ã— Speed.</li>\n  <li><strong>Efficiency:</strong> How effectively a motor converts electrical power into mechanical power.</li>\n</ul>\nThese properties are often provided in motor datasheets and are critical for proper mechanism design and motor selection."
      },
      {
        "type": "text",
        "title": "Motor Controllers",
        "content": "Motor controllers are electronic devices that regulate the power delivered to a motor, thereby controlling its speed and direction. They receive commands from the RoboRIO (via PWM, CAN, or USB) and translate them into appropriate voltage and current for the motor. Modern FRC motor controllers offer advanced features like PID control, current limiting, and built-in encoders."
      },
      {
        "type": "text",
        "title": "CAN vs. PWM Control",
        "content": "FRC motor controllers primarily use two communication protocols:\n<ul>\n  <li><strong>PWM (Pulse Width Modulation):</strong> An older, simpler protocol where the RoboRIO sends a series of pulses to the motor controller. The width of the pulse determines the motor speed. Each motor controller requires a dedicated PWM port on the RoboRIO.</li>\n  <li><strong>CAN (Controller Area Network):</strong> A more advanced, robust, and commonly used serial communication bus. Multiple CAN-enabled motor controllers (and other devices) can be daisy-chained together and communicate over a single pair of wires. CAN allows for more complex data exchange, such as sending sensor feedback from the motor controller back to the RoboRIO.</li>\n</ul>\nCAN is generally preferred in modern FRC robots due to its reduced wiring complexity, improved data integrity, and advanced features."
      },
      {
        "type": "text",
        "title": "Common FRC Motors and Controllers",
        "content": "FRC teams commonly use motors from various manufacturers, often paired with specific motor controllers:\n<ul>\n  <li><strong>NEO / NEO 550 (REV Robotics):</strong> Brushless motors often paired with the REV SPARK MAX motor controller.</li>\n  <li><strong>Falcon 500 (CTRE):</strong> Brushless motor with an integrated motor controller (Talon FX).</li>\n  <li><strong>CIM / Mini CIM (VEXpro):</strong> Brushed motors, typically controlled by CTRE Talon SRX or REV SPARK MAX (in brushed mode).</li>\n  <li><strong>Kraken X60 (CTRE):</strong> New high-performance brushless motor with an integrated motor controller (Talon FX).</li>\n</ul>"
      },
      {
        "type": "text",
        "title": "Example: Controlling a REV SPARK MAX (Java)",
        "content": "The REV SPARK MAX is a popular motor controller used in FRC robotics, often paired with brushless motors like the NEO and NEO 550 from REV Robotics. It offers a compact design, built-in current limiting, and a versatile control interface. You can control SPARK MAX controllers through PWM or CAN, providing flexibility in wiring and communication. While they're a solid choice, they can sometimes present challenges with firmware updates and maintaining consistent performance across all units, especially in high-demand situations like competitive matches. For more information, you can view the <a href=\"https://docs.revrobotics.com/revlib/\" target=\"_blank\">REVLib Documentation</a> or the <a href=\"https://codedocs.revrobotics.com/java/com/revrobotics/spark/sparkmax/\" target=\"_blank\">REVLib API</a>."
      },
      {
        "type": "code",
        "content": "import com.revrobotics.CANSparkMax;\nimport com.revrobotics.CANSparkMaxLowLevel.MotorType;\n\npublic class Robot {\n    private CANSparkMax m_leftMotor;\n    private CANSparkMax m_rightMotor;\n\n    public Robot() {\n        // Initialize SPARK MAX controllers on CAN bus IDs 1 and 2\n        // MotorType.kBrushless for NEO/NEO 550, MotorType.kBrushed for CIM/MiniCIM\n        m_leftMotor = new CANSparkMax(1, MotorType.kBrushless);\n        m_rightMotor = new CANSparkMax(2, MotorType.kBrushless);\n\n        // Restore factory defaults (optional, good for initial setup)\n        m_leftMotor.restoreFactoryDefaults();\n        m_rightMotor.restoreFactoryDefaults();\n\n        // Invert one side of the drivetrain if necessary\n        m_rightMotor.setInverted(true);\n\n        // Set ramp rate to prevent sudden changes in motor speed\n        m_leftMotor.setOpenLoopRampRate(0.5); // seconds from 0 to full speed\n        m_rightMotor.setOpenLoopRampRate(0.5);\n /**\n     * Sets the speed of the drivetrain motors.\n     *\n     * @param leftSpeed  Speed for the left motor (-1.0 to 1.0)\n     * @param rightSpeed Speed for the right motor (-1.0 to 1.0)\n     */\n    public void drive(double leftSpeed, double rightSpeed) {\n        m_leftMotor.set(leftSpeed);\n        m_rightMotor.set(rightSpeed);\n    }\n\n    /**\n     * Stops both drivetrain motors.\n     */\n    public void stop() {\n        m_leftMotor.set(0);\n        m_rightMotor.set(0);\n    }\n}\n"
      },
      {
        "type": "text",
        "title": "Example: Controlling a CTRE Talon FX (Java)",
        "content": "The CTRE Talon FX is another brushless motor controller, but it's integrated directly into the Falcon 500 and Kraken X60 motors, also from CTRE. This integrated design simplifies wiring and reduces the number of points of failure. Talon FX controllers communicate over CAN and are known for their robust performance, reliability, and advanced features like closed-loop control modes (e.g., velocity, position). They tend to be more resistant to brownouts (sudden voltage drops) and offer more consistent behavior under heavy loads compared to other options. For more information, you can view the <a href=\"https://v6.docs.ctr-electronics.com/en/2023-v6/docs/api-reference/device-specific/talonfx/index.html/\" target=\"blank/\">CTRE Phoenix 6 Documentation for TalonFX</a> or the <a href=\"https://api.ctr-electronics.com/phoenix6/release/java/index.html/\" target=\"_blank\">CTRE Phoenix 6 API</a>."
      },
      {
        "type": "code",
        "content": "import com.ctre.phoenix6.hardware.TalonFX;\nimport com.ctre.phoenix6.signals.NeutralModeValue;\n\npublic class Robot {\n    private TalonFX m_leftMotor;\n    private TalonFX m_rightMotor;\n\n    public Robot() {\n        // Initialize Talon FX controllers on CAN bus IDs 1 and 2\n        m_leftMotor = new TalonFX(1);\n        m_rightMotor = new TalonFX(2);\n\n        // Configure factory defaults (optional but recommended)\n        m_leftMotor.getConfigurator().apply(new TalonFXConfiguration());\n        m_rightMotor.getConfigurator().apply(new TalonFXConfiguration());\n\n        // Set neutral mode to brake (optional but common for drivetrains)\n        m_leftMotor.setNeutralMode(NeutralModeValue.Brake);\n        m_rightMotor.setNeutralMode(NeutralModeValue.Brake);\n\n        // Invert one side of the drivetrain if necessary\n        m_rightMotor.setInverted(true);\n    }\n\n    /**\n     * Sets the speed of the drivetrain motors.\n     *\n     * @param leftSpeed  Speed for the left motor (-1.0 to 1.0)\n     * @param rightSpeed Speed for the right motor (-1.0 to 1.0)\n     */\n    public void drive(double leftSpeed, double rightSpeed) {\n        m_leftMotor.set(leftSpeed);\n        m_rightMotor.set(rightSpeed);\n    }\n\n    /**\n     * Stops both drivetrain motors.\n     */\n    public void stop() {\n        m_leftMotor.set(0);\n        m_rightMotor.set(0);\n    }\n}\n"
      },
      {
        "type": "exercise-box",
        "title": "Exercise: Talon FX Motor Control",
        "subtitle": "Create a simple control system for two Talon FX motors",
        "content": "Design a Java class to control two Talon FX motors (simulating an intake/shooting mechanism) with the following specifications:",
        "hint": "Remember that positive power rotates a motor clockwise. Use appropriate power levels (between -1.0 and 1.0) to achieve the desired actions. In this scenario, assume that intaking requires the left motor to spin counterclockwise.",
        "tasks": [
          "intake(): Sets both motors to rotate in opposite directions to simulate intaking an object. Assume positive power rotates a motor clockwise, and negative power counterclockwise.",
          "shoot(): Sets both motors to rotate in the oppposite directions to simulate shooting an object.",
          "stop(): Stops both motors.",
          "Each method should print a message to the console indicating the action taken and the power levels sent to the motors (e.g., \"Intaking: Left motor -0.5, Right motor 0.5\")."
        ],
        "answers": [
          {
            "task": "intake(): Sets both motors to rotate in opposite directions to simulate intaking an object. Assume positive power rotates a motor clockwise, and negative power counterclockwise.",
            "code": "public void intake() {\n    double intakePower = 0.5; // Adjust as needed (0.0 to 1.0)\n    System.out.println(\"Intaking: \" + leftMotorName + \" \" + -intakePower + \", \" + rightMotorName + \" \" + intakePower);\n    // In a real implementation, you would set motor powers here:\n    // m_leftMotor.set(-intakePower);\n    // m_rightMotor.set(intakePower);\n}"
          },
          {
            "task": "shoot(): Sets both motors to rotate in the same direction to simulate shooting an object.",
            "code": "public void shoot() {\n    double shootPower = 0.8; // Adjust as needed (0.0 to 1.0)\n    System.out.println(\"Shooting: \" + leftMotorName + \" \" + shootPower + \", \" + rightMotorName + \" \" + shootPower);\n    // In a real implementation, you would set motor powers here:\n    // m_leftMotor.set(shootPower);\n    // m_rightMotor.set(shootPower);\n}"
          },
          {
            "task": "stop(): Sets both motors to stop.",
            "code": "public void stop() {\n    System.out.println(\"Stopping motors: \" + leftMotorName + \" 0.0, \" + rightMotorName + \" 0.0\");\n    // In a real implementation, you would stop the motors here:\n    // m_leftMotor.set(0.0);\n    // m_rightMotor.set(0.0);\n}"
          },
          { "task": "Final Code",
            "code": "// TalonFXMotorControl.java\npublic class TalonFXMotorControl {\n    private final String leftMotorName = \"Left Motor\";\n    private final String rightMotorName = \"Right Motor\";\n\n    public void intake() {\n        double intakePower = 0.5; // Adjust as needed (0.0 to 1.0)\n        System.out.println(\"Intaking: \" + leftMotorName + \" \" + -intakePower + \", \" + rightMotorName + \" \" + intakePower);\n        // In a real implementation, you would set motor powers here:\n        // m_leftMotor.set(-intakePower);\n        // m_rightMotor.set(intakePower);\n    }\n\n    public void shoot() {\n        double shootPower = 0.8; // Adjust as needed (0.0 to 1.0)\n        System.out.println(\"Shooting: \" + leftMotorName + \" \" + shootPower + \", \" + rightMotorName + \" \" + shootPower);\n        // In a real implementation, you would set motor powers here:\n        // m_leftMotor.set(shootPower);\n        // m_rightMotor.set(shootPower);\n    }\n\n    public void stop() {\n        System.out.println(\"Stopping motors: \" + leftMotorName + \" 0.0, \" + rightMotorName + \" 0.0\");\n        // In a real implementation, you would stop the motors here:\n        // m_leftMotor.set(0.0);\n        // m_rightMotor.set(0.0);\n    }\n}\n\n// Example Usage:\n// public class Main {\n//     public static void main(String[] args) {\n//         TalonFXMotorControl mechanism = new TalonFXMotorControl();\n//         mechanism.intake();\n//         mechanism.shoot();\n//         mechanism.stop();\n//     }\n// }"
          }  
        ]
    }
  ]
}      