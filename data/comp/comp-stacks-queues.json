{
  "id": "comp-stacks-queues",
  "title": "Stacks & Queues",
  "sections": [
    {
      "type": "text",
      "title": "Stack Data Structure",
      "content": "A stack follows LIFO (Last In, First Out) principle. Think of it like a stack of plates - you can only add or remove from the top."
    },
    {
      "type": "code",
      "title": "Stack Operations",
      "content": "// Using Java's Stack class\nStack<Integer> stack = new Stack<>();\n\n// Push element\nstack.push(5);\n\n// Pop element\nint top = stack.pop();\n\n// Peek at top element\nint peek = stack.peek();\n\n// Check if empty\nboolean isEmpty = stack.isEmpty();\n\n// Get size\nint size = stack.size();\n\n// Using Deque as stack (recommended)\nDeque<Integer> stack2 = new ArrayDeque<>();\nstack2.push(5);\nint val = stack2.pop();"
    },
    {
      "type": "text",
      "title": "Queue Data Structure",
      "content": "A queue follows FIFO (First In, First Out) principle. Think of it like a line of people - first person in line is served first."
    },
    {
      "type": "code",
      "title": "Queue Operations",
      "content": "// Using Java's Queue interface\nQueue<Integer> queue = new LinkedList<>();\n\n// Add element\nqueue.offer(5);\n\n// Remove and return element\nint first = queue.poll();\n\n// Peek at first element\nint peek = queue.peek();\n\n// Check if empty\nboolean isEmpty = queue.isEmpty();\n\n// Get size\nint size = queue.size();\n\n// Using Deque for double-ended queue\nDeque<Integer> deque = new ArrayDeque<>();\ndeque.offerFirst(1);  // Add to front\ndeque.offerLast(2);   // Add to back\ndeque.pollFirst();     // Remove from front\ndeque.pollLast();      // Remove from back"
    },
    {
      "type": "text",
      "title": "Common Applications",
      "content": "<ul><li><strong>Stack Applications:</strong><ul><li>Parentheses matching</li><li>Function call stack</li><li>Undo operations</li><li>Depth-first search</li><li>Expression evaluation</li></ul></li><li><strong>Queue Applications:</strong><ul><li>Breadth-first search</li><li>Task scheduling</li><li>Print spooling</li><li>Level-order traversal</li></ul></li></ul>"
    },
    {
      "type": "code",
      "title": "Parentheses Matching Example",
      "content": "boolean isValid(String s) {\n    Stack<Character> stack = new Stack<>();\n    for (char c : s.toCharArray()) {\n        if (c == '(' || c == '{' || c == '[') {\n            stack.push(c);\n        } else {\n            if (stack.isEmpty()) return false;\n            char top = stack.pop();\n            if ((c == ')' && top != '(') || \n                (c == '}' && top != '{') || \n                (c == ']' && top != '[')) {\n                return false;\n            }\n        }\n    }\n    return stack.isEmpty();\n}"
    }
  ]
} 