{
  "title": "Exponential Motion Profiles",
  "sections": [
    {
      "type": "text",
      "title": "Introduction to Exponential Profiles",
      "content": "Exponential motion profiles use exponential functions to create smooth acceleration and deceleration. Unlike trapezoidal profiles with distinct phases, exponential profiles provide continuous, natural-feeling motion with gradually changing acceleration.<br><br>Exponential profiles are simpler to implement than trapezoidal profiles and work well for mechanisms that don't need precise timing or maximum speed. They're excellent for elevators, arms, and other mechanisms where smooth, natural motion is more important than optimal performance.<br><br>Exponential profiles are particularly useful for elevators because they provide smooth motion that reduces mechanical stress and creates comfortable, predictable movement. They automatically handle acceleration and deceleration without requiring complex trajectory planning.<br><br>CTRE has a great explanation of exponential profiles <a href='https://v6.docs.ctr-electronics.com/en/latest/docs/api-reference/device-specific/talonfx/motion-magic.html#motion-magic-expo' target='_blank'>here</a>."
    },
    {
      "type": "text",
      "title": "Exponential vs Trapezoidal Profiles",
      "content": "Understanding when to use each profile type helps you choose the right solution:<br><br><strong>Use Exponential Profiles When:</strong> You need simple, natural motion; you're controlling elevators or arms; you don't need precise timing; you want easy implementation; or smooth motion is more important than maximum speed.<br><br><strong>Use Trapezoidal Profiles When:</strong> You need maximum speed; you need precise timing; you have complex mechanisms; you need to respect strict constraints; or you need optimal performance.<br><br><strong>Trade-offs:</strong> Exponential profiles are simpler but may not reach maximum speed as quickly. Trapezoidal profiles are more complex but provide better performance for demanding applications. For elevators, exponential profiles often provide the best balance of simplicity and smooth motion."
    },
    {
      "type": "text",
      "title": "Exponential Profile Math",
      "content": "Exponential profiles use exponential decay/growth functions based on system characteristics:<br><br><strong>Constraints:</strong> Exponential profiles are defined by constraints including maximum velocity (kMaxV), velocity gain (kV), and acceleration gain (kA). These constraints are derived from the physical characteristics of your mechanism.<br><br><strong>State-Based Calculation:</strong> The profile calculates position and velocity states over time, smoothly transitioning from the current state to the goal state while respecting the constraints.<br><br><strong>Continuous Motion:</strong> Unlike trapezoidal profiles with distinct phases, exponential profiles provide smooth, continuous motion from start to finish. The profile automatically handles acceleration and deceleration phases.<br><br><strong>Mechanism Characteristics:</strong> For elevators, constraints are typically calculated from motor characteristics, mechanism weight, drum radius, and gearing to ensure the profile respects physical limits."
    },
    {
      "type": "text",
      "title": "Exponential Profile Classes",
      "content": "Different libraries provide exponential profile implementations:<br><br><strong>WPILib ExponentialProfile:</strong> Uses Constraints.fromCharacteristics() to create constraints from kMaxV, kV, and kA. Calculates State objects containing position and velocity at each time step.<br><br><strong>YAMS ExponentialProfilePIDController:</strong> Uses createElevatorConstraints() to automatically calculate constraints from mechanism characteristics (voltage, motors, weight, radius, gearing). Integrates directly with motor controllers.<br><br><strong>CTRE MotionMagicExpo:</strong> Uses MotionMagicExpoVoltage control request with MotionMagicExpo_kV and MotionMagicExpo_kA configuration. Provides exponential profile motion directly on the motor controller.<br><br>Each approach has advantages: WPILib provides flexibility, YAMS simplifies setup with automatic constraint calculation, and CTRE offloads computation to the motor controller."
    },
    {
      "type": "code-tabs",
      "title": "Elevator with Exponential Profile",
      "content": "Complete elevator implementation using exponential profiles for smooth motion control:",
      "tabs": [
        {
          "label": "WPILib",
          "code": "package frc.robot.subsystems;\n\nimport edu.wpi.first.math.controller.PIDController;\nimport edu.wpi.first.math.trajectory.ExponentialProfile;\nimport edu.wpi.first.wpilibj.motorcontrol.PWMSparkMax;\nimport edu.wpi.first.wpilibj.Encoder;\nimport edu.wpi.first.wpilibj.smartdashboard.SmartDashboard;\nimport edu.wpi.first.wpilibj2.command.SubsystemBase;\n\npublic class Elevator extends SubsystemBase {\n    private final PWMSparkMax m_motor = new PWMSparkMax(3);\n    private final Encoder m_encoder = new Encoder(0, 1);\n    private final PIDController m_pidController = new PIDController(0.1, 0.0, 0.01);\n    \n    // Exponential profile constraints\n    // kMaxV: Maximum velocity (rotations per second)\n    // kV: Velocity gain (volts per rotation per second)\n    // kA: Acceleration gain (volts per rotation per second squared)\n    private static final double kMaxV = 10.0;  // Max velocity in rotations/second\n    private static final double kV = 0.12;     // Velocity gain\n    private static final double kA = 0.01;     // Acceleration gain\n    \n    private final ExponentialProfile.Constraints m_constraints = \n        ExponentialProfile.Constraints.fromCharacteristics(kMaxV, kV, kA);\n    private final ExponentialProfile m_profile = new ExponentialProfile(m_constraints);\n    \n    // Profile state tracking\n    private ExponentialProfile.State m_profiledReference = \n        new ExponentialProfile.State(0.0, 0.0);\n    private ExponentialProfile.State m_goalState = \n        new ExponentialProfile.State(0.0, 0.0);\n    \n    // Conversion: encoder counts to inches (example: 4\" diameter spool)\n    private static final double SPOOL_CIRCUMFERENCE = 4.0 * Math.PI;  // inches\n    private static final double COUNTS_PER_INCH = 42.0 / SPOOL_CIRCUMFERENCE;  // NEO: 42 counts/rev\n    \n    // Preset heights (in inches)\n    public static final double BOTTOM = 0.0;\n    public static final double MID = 24.0;\n    public static final double TOP = 48.0;\n    \n    private double m_lastTime = 0.0;\n    \n    public Elevator() {\n        m_encoder.setDistancePerPulse(1.0 / COUNTS_PER_INCH);  // inches per count\n        m_lastTime = System.currentTimeMillis() / 1000.0;\n    }\n    \n    public void setHeight(double inches) {\n        // Convert inches to rotations\n        double targetRotations = inches * COUNTS_PER_INCH / 42.0;\n        \n        m_goalState = new ExponentialProfile.State(targetRotations, 0.0);\n    }\n    \n    @Override\n    public void periodic() {\n        double currentTime = System.currentTimeMillis() / 1000.0;\n        double deltaTime = currentTime - m_lastTime;\n        \n        double currentPosition = m_encoder.getDistance() * 42.0 / SPOOL_CIRCUMFERENCE;\n        double currentVelocity = m_encoder.getRate() * 42.0 / SPOOL_CIRCUMFERENCE;\n        ExponentialProfile.State currentState = \n            new ExponentialProfile.State(currentPosition, currentVelocity);\n        \n        m_profiledReference = m_profile.calculate(deltaTime, currentState, m_goalState);\n        \n        double output = m_pidController.calculate(\n            currentPosition, \n            m_profiledReference.position\n        );\n        \n        m_motor.set(output);\n        \n        m_lastTime = currentTime;\n        \n        SmartDashboard.putNumber(\"Elevator Height\", getHeight());\n        SmartDashboard.putNumber(\"Target Height\", m_goalState.position * SPOOL_CIRCUMFERENCE / 42.0);\n    }\n    \n    public double getHeight() {\n        return m_encoder.getDistance();\n    }\n}"
        },
        {
          "label": "YAMS",
          "code": "package frc.robot.subsystems;\n\nimport static edu.wpi.first.units.Units.Amps;\nimport static edu.wpi.first.units.Units.Inches;\nimport static edu.wpi.first.units.Units.Meters;\nimport static edu.wpi.first.units.Units.Millimeters;\nimport static edu.wpi.first.units.Units.Pounds;\nimport static edu.wpi.first.units.Units.Seconds;\nimport static edu.wpi.first.units.Units.Volts;\n\nimport edu.wpi.first.math.controller.ElevatorFeedforward;\nimport edu.wpi.first.math.system.plant.DCMotor;\nimport edu.wpi.first.units.measure.Distance;\nimport edu.wpi.first.units.measure.Mass;\nimport edu.wpi.first.wpilibj2.command.Command;\nimport edu.wpi.first.wpilibj2.command.SubsystemBase;\nimport yams.gearing.GearBox;\nimport yams.gearing.MechanismGearing;\nimport yams.math.ExponentialProfilePIDController;\nimport yams.mechanisms.config.ElevatorConfig;\nimport yams.mechanisms.positional.Elevator;\nimport yams.motorcontrollers.SmartMotorController;\nimport yams.motorcontrollers.SmartMotorControllerConfig;\nimport yams.motorcontrollers.SmartMotorControllerConfig.ControlMode;\nimport yams.motorcontrollers.SmartMotorControllerConfig.MotorMode;\nimport yams.motorcontrollers.SmartMotorControllerConfig.TelemetryVerbosity;\nimport yams.motorcontrollers.remote.TalonFXWrapper;\nimport com.ctre.phoenix6.hardware.TalonFX;\n\npublic class Elevator extends SubsystemBase {\n    // Mechanism physical characteristics for exponential profile constraints\n    private final MechanismGearing gearing = new MechanismGearing(new GearBox(new double[]{5}));\n    private final DCMotor motors = DCMotor.getKrakenX60(1);\n    private final Mass weight = Pounds.of(6);\n    private final Distance radius = Millimeters.of(168).div(2 * Math.PI);\n    \n    // Configure motor controller with exponential profile PID controller\n    private final SmartMotorControllerConfig smcConfig = \n        new SmartMotorControllerConfig(this)\n            .withControlMode(ControlMode.CLOSED_LOOP)\n            // Mechanism circumference: distance traveled per rotation\n            .withMechanismCircumference(Millimeters.of(168))\n            // Exponential profile PID controller with automatically calculated constraints\n            .withClosedLoopController(\n                new ExponentialProfilePIDController(\n                    3,   // kP\n                    0,   // kI\n                    0.15, // kD\n                    ExponentialProfilePIDController.createElevatorConstraints(\n                        Volts.of(12), // Maximum voltage during profile\n                        motors,        // Motor characteristics\n                        weight,        // Carriage weight\n                        radius,        // Drum radius\n                        gearing        // Gearing\n                    )\n                )\n            )\n            // Feedforward for improved control\n            .withFeedforward(new ElevatorFeedforward(0, 0.2, 0.129, 0.0064))\n            .withTelemetry(\"ElevatorMotor\", TelemetryVerbosity.HIGH)\n            .withGearing(gearing)\n            .withMotorInverted(false)\n            .withIdleMode(MotorMode.BRAKE)\n            .withStatorCurrentLimit(Amps.of(40));\n    \n    // Vendor motor controller\n    private final TalonFX leftMotor = new TalonFX(13);\n    \n    private final SmartMotorController elevatorMotorsController = \n        new TalonFXWrapper(leftMotor, DCMotor.getKrakenX60(1), smcConfig);\n    \n    // Configure elevator mechanism\n    private final ElevatorConfig elevConfig = \n        new ElevatorConfig(elevatorMotorsController)\n            .withStartingHeight(Meters.of(0.0))\n            .withHardLimits(Inches.of(0), Inches.of(84))\n            .withTelemetry(\"Elevator\", TelemetryVerbosity.HIGH)\n            .withMass(Pounds.of(6));\n    \n    // Elevator mechanism with exponential profile\n    private final Elevator elevator = new Elevator(elevConfig);\n    \n    /**\n     * Set the height of the elevator using exponential profile motion.\n     *\n     * @param height Target height\n     */\n    public Command setHeight(Distance height) {\n        return elevator.setHeight(height);\n    }\n    \n    /**\n     * Move the elevator manually (for testing/debugging).\n     *\n     * @param dutycycle Speed [-1, 1]\n     */\n    public Command set(double dutycycle) {\n        return elevator.set(dutycycle);\n    }\n    \n    @Override\n    public void periodic() {\n        elevator.updateTelemetry();\n    }\n    \n    @Override\n    public void simulationPeriodic() {\n        elevator.simIterate();\n    }\n}"
        },
        {
          "label": "CTRE",
          "code": "package frc.robot.subsystems;\n\nimport com.ctre.phoenix6.hardware.TalonFX;\nimport com.ctre.phoenix6.controls.MotionMagicExpoVoltage;\nimport com.ctre.phoenix6.configs.TalonFXConfiguration;\nimport com.ctre.phoenix6.configs.Slot0Configs;\nimport com.ctre.phoenix6.configs.MotionMagicConfigs;\nimport com.ctre.phoenix6.signals.FeedbackSensorSourceValue;\nimport edu.wpi.first.wpilibj.smartdashboard.SmartDashboard;\nimport edu.wpi.first.wpilibj2.command.SubsystemBase;\n\npublic class Elevator extends SubsystemBase {\n    private final TalonFX m_motor = new TalonFX(3);\n    \n    // Control request with exponential profile (reusable)\n    private final MotionMagicExpoVoltage m_expoRequest = new MotionMagicExpoVoltage(0);\n    \n    // Conversion: rotations to inches (example: 4\" diameter spool)\n    private static final double SPOOL_CIRCUMFERENCE = 4.0 * Math.PI;  // inches\n    private static final double ROTATIONS_PER_INCH = 1.0 / SPOOL_CIRCUMFERENCE;\n    \n    // Preset heights (in inches)\n    public static final double BOTTOM = 0.0;\n    public static final double MID = 24.0;\n    public static final double TOP = 48.0;\n    \n    public Elevator() {\n        TalonFXConfiguration talonFXConfigs = new TalonFXConfiguration();\n        \n        // Configure feedback sensor\n        talonFXConfigs.Feedback.FeedbackSensorSource = FeedbackSensorSourceValue.RotorSensor;\n        \n        // Configure Slot 0 gains\n        Slot0Configs slot0Configs = talonFXConfigs.Slot0;\n        slot0Configs.kS = 0.25;  // Add 0.25 V output to overcome static friction\n        slot0Configs.kV = 0.12;  // A velocity target of 1 rps results in 0.12 V output\n        slot0Configs.kA = 0.01;  // An acceleration of 1 rps/s requires 0.01 V output\n        slot0Configs.kP = 4.8;   // A position error of 2.5 rotations results in 12 V output\n        slot0Configs.kI = 0;     // No output for integrated error\n        slot0Configs.kD = 0.1;   // A velocity error of 1 rps results in 0.1 V output\n        \n        // Configure Motion Magic Expo settings\n        MotionMagicConfigs motionMagicConfigs = talonFXConfigs.MotionMagic;\n        motionMagicConfigs.MotionMagicCruiseVelocity = 0;      // Unlimited cruise velocity\n        motionMagicConfigs.MotionMagicExpo_kV = 0.12;           // kV is around 0.12 V/rps\n        motionMagicConfigs.MotionMagicExpo_kA = 0.1;\n        \n        m_motor.getConfigurator().apply(talonFXConfigs);\n        \n        m_motor.setPosition(0);\n    }\n    \n    public void setHeight(double inches) {\n        // Convert inches to rotations\n        double targetRotations = inches * ROTATIONS_PER_INCH;\n        \n        m_motor.setControl(m_expoRequest.withPosition(targetRotations));\n    }\n    \n    public double getHeight() {\n        double position = m_motor.getPosition().getValue();\n        return position / ROTATIONS_PER_INCH;\n    }\n    \n    public boolean isAtHeight(double targetHeight, double tolerance) {\n        double currentHeight = getHeight();\n        return Math.abs(currentHeight - targetHeight) < tolerance;\n    }\n    \n    @Override\n    public void periodic() {\n        SmartDashboard.putNumber(\"Elevator Height\", getHeight());\n    }\n}"
        }
      ]
    },
    {
      "type": "text",
      "title": "Using Exponential Profiles for Elevators",
      "content": "Exponential profiles are ideal for elevators because they provide smooth, natural motion:<br><br><strong>Automatic Smoothing:</strong> The profile automatically handles acceleration and deceleration, creating smooth motion without sudden changes. This reduces mechanical stress on the elevator mechanism.<br><br><strong>Constraint-Based:</strong> Profiles respect physical constraints (maximum velocity, motor characteristics, mechanism weight) ensuring safe operation within physical limits.<br><br><strong>State-Based Control:</strong> The profile calculates both position and velocity states, allowing the control system to follow a smooth trajectory rather than just reaching a target position.<br><br><strong>Continuous Updates:</strong> Update the profile calculation every robot loop (20ms) to ensure smooth motion. The profile automatically adjusts as the goal state changes."
    },
    {
      "type": "text",
      "title": "Tuning Exponential Profiles",
      "content": "Tuning exponential profiles involves adjusting the constraints and gains:<br><br><strong>WPILib Tuning:</strong> Adjust kMaxV, kV, and kA based on your mechanism's physical characteristics. Test with different values to find the right balance of speed and smoothness.<br><br><strong>YAMS Tuning:</strong> The constraints are automatically calculated from mechanism characteristics. Tune the PID gains (kP, kI, kD) and adjust mechanism parameters (weight, radius, gearing) if needed.<br><br><strong>CTRE Tuning:</strong> Adjust MotionMagicExpo_kV and MotionMagicExpo_kA to control the exponential profile shape. Higher kA creates faster response, lower kA creates smoother motion. Tune PID gains (kP, kI, kD) for position control accuracy.<br><br><strong>Testing:</strong> Test with different heights and observe motion smoothness. Adjust parameters to balance speed and smoothness for your specific elevator mechanism."
    },
    {
      "type": "link-grid",
      "title": "Related Topics and Documentation",
      "links": [
        {
          "label": "Motion Profiling Basics",
          "id": "motion-profiling-basics"
        },
        {
          "label": "Trapezoidal Profiles",
          "id": "trapezoidal-profiles"
        },
        {
          "label": "PID Control Introduction",
          "id": "pid-control-intro"
        }
      ]
    }
  ]
}