{
  "title": "Introduction to PID Control",
  "sections": [
    {
      "type": "text",
      "title": "What is PID Control?",
      "content": "PID (Proportional-Integral-Derivative) control is a feedback control algorithm used to maintain a desired output by continuously adjusting control inputs based on the difference between the desired value (setpoint) and the actual value (process variable). PID controllers are essential in robotics for achieving precise control of position, velocity, angle, and other physical quantities.<br><br>In FRC robotics, PID control enables mechanisms to move to exact positions, maintain consistent speeds, and hold angles accurately. Without PID control, mechanisms would overshoot targets, oscillate, or fail to reach desired states. PID control automatically corrects errors and handles disturbances, making it a fundamental tool for competitive robotics.<br><br>Learn more: <a href='https://docs.wpilib.org/en/stable/docs/software/advanced-controls/introduction/index.html' target='_blank'>WPILib: Control System Basics</a>"
    },
    {
      "type": "rules-box",
      "title": "PID Control Benefits",
      "subtitle": "Why PID control is essential:",
      "items": [
        "Precise control (moves to exact position or maintains exact speed)",
        "Automatic error correction (continuously adjusts to reduce error)",
        "Handles disturbances (compensates for load changes, friction, etc.)",
        "Stable operation (prevents oscillation and overshoot when tuned correctly)",
        "Versatile (works for position, velocity, angle, and other control types)",
        "Industry standard (widely used in robotics and automation)",
        "Predictable behavior (well-understood algorithm with established tuning methods)",
        "Real-time response (adjusts output continuously based on current error)"
      ]
    },
    {
      "type": "text",
      "title": "The Control Problem",
      "content": "To understand why PID control is necessary, consider what happens without it:<br><br><strong>Simple On/Off Control:</strong> If you try to move an arm to a specific angle using simple on/off control, you might turn the motor on when the arm is below the target and off when it's above. This results in oscillation around the target - the arm overshoots, then undershoots, never settling at the desired position.<br><br><strong>Open-Loop Control:</strong> Setting a fixed motor power might work in some cases, but it doesn't account for variations in load, battery voltage, or friction. The mechanism won't reach the same position consistently.<br><br><strong>Feedback Control Solution:</strong> PID control uses feedback from sensors (encoders, gyros, etc.) to continuously measure the error and adjust motor output accordingly. This creates a closed-loop system that automatically corrects itself, achieving precise and stable control."
    },
    {
      "type": "text",
      "title": "PID Components Explained",
      "content": "PID control combines three components, each responding to different aspects of the error:<br><br><strong>Proportional (P):</strong> Responds to the current error. The output is proportional to how far away you are from the target. If you're far from the target, P provides a large correction. If you're close, P provides a small correction. However, P alone often results in overshoot and oscillation.<br><br><strong>Integral (I):</strong> Responds to accumulated error over time. If there's a persistent error (steady-state error), I gradually increases the output to eliminate it. I is useful for overcoming friction or constant disturbances, but too much I can cause oscillation and windup.<br><br><strong>Derivative (D):</strong> Responds to the rate of change of error. D predicts future error based on how quickly the error is changing. It acts as a dampening force, reducing overshoot and oscillation. D helps stabilize the system but can be sensitive to noise.<br><br>These three components work together: <code>Output = P + I + D</code>"
    },
    {
      "type": "text",
      "title": "How PID Works",
      "content": "PID control operates in a continuous feedback loop:<br><br><strong>1. Setpoint:</strong> You specify the desired value (e.g., arm angle of 45 degrees, velocity of 100 RPM).<br><br><strong>2. Process Variable:</strong> A sensor measures the current value (e.g., current arm angle, current motor velocity).<br><br><strong>3. Error Calculation:</strong> Error = Setpoint - Process Variable (e.g., if target is 45° and current is 40°, error = 5°).<br><br><strong>4. PID Calculation:</strong> The PID algorithm calculates three terms:<br>- P term = kP × error<br>- I term = kI × accumulated error<br>- D term = kD × rate of error change<br><br><strong>5. Output:</strong> The three terms are summed to produce the control output, which is applied to the motor.<br><br><strong>6. Repeat:</strong> The process repeats continuously (typically every 20ms in FRC), creating a closed-loop control system that automatically corrects errors."
    },
    {
      "type": "code",
      "title": "Basic PID Concept Demonstration",
      "content": "This example demonstrates the PID calculation conceptually (not using WPILib classes yet):\n\npackage frc.robot.examples;\n\npublic class PIDConceptDemo {\n    // PID gains (these would be tuned for your mechanism)\n    private static final double kP = 0.1;\n    private static final double kI = 0.0;\n    private static final double kD = 0.01;\n    \n    // Control variables\n    private double m_setpoint = 0.0;  // Desired value\n    private double m_previousError = 0.0;\n    private double m_integral = 0.0;\n    \n    /**\n     * Calculate PID output given current sensor reading\n     * @param currentValue Current sensor value\n     * @return Motor output (-1.0 to 1.0)\n     */\n    public double calculate(double currentValue) {\n        // Calculate error\n        double error = m_setpoint - currentValue;\n        \n        // Proportional term\n        double pTerm = kP * error;\n        \n        // Integral term (accumulate error over time)\n        m_integral += error;\n        double iTerm = kI * m_integral;\n        \n        // Derivative term (rate of error change)\n        double derivative = error - m_previousError;\n        double dTerm = kD * derivative;\n        \n        // Calculate output\n        double output = pTerm + iTerm + dTerm;\n        \n        // Store error for next iteration\n        m_previousError = error;\n        \n        // Clamp output to valid range\n        return Math.max(-1.0, Math.min(1.0, output));\n    }\n    \n    public void setSetpoint(double setpoint) {\n        m_setpoint = setpoint;\n        // Reset integral when setpoint changes\n        m_integral = 0.0;\n    }\n}"
    },
    {
      "type": "text",
      "title": "PID Output Calculation",
      "content": "The PID output is calculated by summing the three components:<br><br><strong>Output = (kP × error) + (kI × integral) + (kD × derivative)</strong><br><br>Where:<br>- <strong>error</strong> = setpoint - process variable (current error)<br>- <strong>integral</strong> = sum of all previous errors (accumulated error)<br>- <strong>derivative</strong> = change in error since last calculation (rate of change)<br><br><strong>How Each Component Contributes:</strong><br>- <strong>P term:</strong> Provides immediate response proportional to error. Large error = large correction.<br>- <strong>I term:</strong> Eliminates persistent errors. If error persists, I gradually increases output.<br>- <strong>D term:</strong> Dampens oscillations. If error is changing quickly, D opposes the change.<br><br><strong>Example:</strong> If you're 10 units away from target (error = 10), with kP = 0.1, kI = 0.0, kD = 0.01, and error is decreasing at 5 units/second:<br>- P = 0.1 × 10 = 1.0<br>- I = 0.0 × accumulated = 0.0<br>- D = 0.01 × (-5) = -0.05<br>- Output = 1.0 + 0.0 - 0.05 = 0.95"
    },
    {
      "type": "text",
      "title": "When to Use PID Control",
      "content": "PID control is appropriate for many FRC applications:<br><br><strong>Position Control:</strong> Moving mechanisms to specific positions (arms to angles, elevators to heights, turrets to rotations). PID ensures the mechanism reaches and holds the exact target position.<br><br><strong>Velocity Control:</strong> Maintaining consistent speeds (flywheels at specific RPM, intakes at constant speed, drivetrain at target velocity). PID compensates for load changes and maintains speed.<br><br><strong>Angle Control:</strong> Rotating to specific angles (turret rotation, swerve module angle, arm elevation). PID handles angle wraparound and precise positioning.<br><br><strong>When NOT to Use PID:</strong> Simple mechanisms that don't need precision (basic on/off intakes, simple mechanisms with mechanical stops) may not need PID. However, PID can still improve performance even in these cases."
    },
    {
      "type": "code",
      "title": "Open-Loop vs Closed-Loop Control Comparison",
      "content": "This example demonstrates the difference between open-loop and closed-loop control:\n\npackage frc.robot.examples;\n\npublic class ControlComparison {\n    private double m_motorOutput = 0.0;\n    private double m_currentPosition = 0.0;  // Simulated position\n    \n    // Open-loop control: fixed output, no feedback\n    public void openLoopControl(double targetPosition) {\n        // Just set a fixed power - no feedback!\n        // This won't account for load, battery voltage, etc.\n        m_motorOutput = 0.5;  // Fixed 50% power\n        // Problem: Mechanism may not reach target, or overshoot\n    }\n    \n    // Closed-loop control: uses feedback to adjust output\n    public void closedLoopControl(double targetPosition) {\n        // Calculate error\n        double error = targetPosition - m_currentPosition;\n        \n        // Adjust output based on error (simplified PID)\n        if (Math.abs(error) > 5.0) {\n            // Far from target: use more power\n            m_motorOutput = 0.8;\n        } else if (Math.abs(error) > 1.0) {\n            // Close to target: use less power\n            m_motorOutput = 0.3;\n        } else {\n            // At target: stop\n            m_motorOutput = 0.0;\n        }\n        // This is still simplified - real PID is smoother and more accurate\n    }\n    \n    // Real PID control (using WPILib PIDController - covered in later lessons)\n    // Provides smooth, accurate control with automatic error correction\n}"
    },
    {
      "type": "text",
      "title": "Common PID Applications in FRC",
      "content": "PID control is used throughout FRC robots:<br><br><strong>Drivetrain:</strong> Maintaining straight driving, turning to specific angles, velocity control for autonomous paths.<br><br><strong>Arms:</strong> Moving to specific angles for scoring positions, holding position against gravity.<br><br><strong>Elevators:</strong> Moving to specific heights for different game piece levels, maintaining position.<br><br><strong>Flywheels:</strong> Maintaining consistent RPM for accurate shooting, compensating for battery voltage changes.<br><br><strong>Intakes:</strong> Maintaining constant intake speed, controlling roller velocity.<br><br><strong>Turrets:</strong> Rotating to specific angles for aiming, tracking targets.<br><br><strong>Swerve Modules:</strong> Rotating wheels to specific angles, maintaining module orientation."
    },
    {
      "type": "link-grid",
      "title": "Documentation Resources",
      "links": [
        { "label": "WPILib Control System Basics", "id": "https://docs.wpilib.org/en/stable/docs/software/advanced-controls/introduction/index.html" },
        { "label": "WPILib PIDController", "id": "https://docs.wpilib.org/en/stable/docs/software/advanced-controls/controllers/pidcontroller.html" },
        { "label": "WPILib Introduction to PID", "id": "https://docs.wpilib.org/en/stable/docs/software/advanced-controls/introduction/introduction-to-pid.html" }
      ]
    }
  ]
}

