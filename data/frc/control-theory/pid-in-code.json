{
  "title": "PID In Robot Code",
  "sections": [
    {
      "type": "text",
      "title": "Introduction to In-Code PID",
      "content": "In-code PID uses WPILib's PIDController class to implement PID control in your robot code, running on the roboRIO. This approach provides flexibility for custom control logic, complex calculations, and coordination between multiple mechanisms.<br><br>WPILib's PIDController is a powerful, easy-to-use class that handles all PID calculations. It's ideal for mechanisms that need custom control strategies, non-standard sensors, or coordination with other systems. While it runs at 20ms intervals (50Hz) compared to on-controller PID's 1ms rate, it's sufficient for most FRC applications.<br><br>Learn more: <a href='https://docs.wpilib.org/en/stable/docs/software/advanced-controls/controllers/pidcontroller.html' target='_blank'>WPILib: PIDController</a>"
    },
    {
      "type": "text",
      "title": "WPILib PIDController Class",
      "content": "WPILib's PIDController class provides a complete PID implementation:<br><br><strong>Creating PIDController:</strong> Create a PIDController object with kP, kI, and kD values. You can also set tolerance, output limits, and continuous input mode.<br><br><strong>Setting Setpoints:</strong> Use setSetpoint() to specify the target value. The PIDController will calculate output to reach this target.<br><br><strong>Calculating Output:</strong> Call calculate() with the current sensor value to get the PID output. This should be called every robot loop (20ms) in your periodic() method.<br><br><strong>Checking Completion:</strong> Use atSetpoint() to check if the mechanism has reached the target within tolerance. Useful for commands that wait for completion."
    },
    {
      "type": "text",
      "title": "PIDController Methods",
      "content": "Key methods of the PIDController class:<br><br><strong>Constructor:</strong> <code>new PIDController(kP, kI, kD)</code> - Creates PIDController with specified gains<br><br><strong>setP(), setI(), setD():</strong> Update PID gains at runtime (useful for tuning)<br><br><strong>setSetpoint(double setpoint):</strong> Set the target value<br><br><strong>calculate(double measurement):</strong> Calculate PID output based on current sensor reading. Returns the control output.<br><br><strong>atSetpoint():</strong> Returns true if the system is at the setpoint within tolerance<br><br><strong>setTolerance(double positionTolerance):</strong> Set how close to setpoint is considered \"at setpoint\"<br><br><strong>setIntegratorRange(double min, double max):</strong> Limit integral term to prevent windup<br><br><strong>setOutputRange(double min, double max):</strong> Limit PID output to valid range<br><br><strong>enableContinuousInput(double minInput, double maxInput):</strong> Enable continuous input mode for angles (0° = 360°)<br><br><strong>reset():</strong> Reset the controller (clears integral, resets state)"
    },
    {
      "type": "code",
      "title": "Basic PIDController Usage (Position Control)",
      "content": "This example shows basic position control using PIDController:\n\npackage frc.robot.subsystems;\n\nimport edu.wpi.first.math.controller.PIDController;\nimport edu.wpi.first.wpilibj.Encoder;\nimport edu.wpi.first.wpilibj.motorcontrol.PWMSparkMax;\nimport edu.wpi.first.wpilibj2.command.SubsystemBase;\n\npublic class Arm extends SubsystemBase {\n    private final PWMSparkMax m_armMotor = new PWMSparkMax(0);\n    private final Encoder m_encoder = new Encoder(0, 1);\n    \n    // Create PIDController with tuned values\n    private final PIDController m_pidController = new PIDController(0.1, 0.0, 0.01);\n    \n    private double m_targetAngle = 0.0;\n    \n    public Arm() {\n        // Configure encoder (example: 42 counts per revolution)\n        m_encoder.setDistancePerPulse(360.0 / 42.0);  // degrees per count\n        \n        // Set tolerance (consider \"at setpoint\" if within 2 degrees)\n        m_pidController.setTolerance(2.0);\n        \n        // Set output limits (safety)\n        m_pidController.setIntegratorRange(-0.5, 0.5);\n    }\n    \n    public void setTargetAngle(double angle) {\n        m_targetAngle = angle;\n        m_pidController.setSetpoint(angle);\n    }\n    \n    @Override\n    public void periodic() {\n        // Read current position\n        double currentAngle = m_encoder.getDistance();\n        \n        // Calculate PID output\n        double output = m_pidController.calculate(currentAngle);\n        \n        // Apply to motor\n        m_armMotor.set(output);\n    }\n    \n    public boolean isAtTarget() {\n        return m_pidController.atSetpoint();\n    }\n    \n    public double getCurrentAngle() {\n        return m_encoder.getDistance();\n    }\n}"
    },
    {
      "type": "text",
      "title": "Position Control with PIDController",
      "content": "Position control moves a mechanism to a specific position and holds it:<br><br><strong>Setting Target:</strong> Use setSetpoint() to specify the target position. The PIDController will calculate output to reach this position.<br><br><strong>Reading Sensor:</strong> Read the current position from your sensor (encoder, potentiometer, etc.) every robot loop.<br><br><strong>Calculating Output:</strong> Call calculate() with the current sensor reading. The PIDController returns the control output needed to reach the setpoint.<br><br><strong>Applying Output:</strong> Apply the output to your motor. The PIDController automatically adjusts the output as the mechanism approaches the target.<br><br><strong>Checking Completion:</strong> Use atSetpoint() to determine when the mechanism has reached the target. Useful for commands that wait for completion."
    },
    {
      "type": "text",
      "title": "Velocity Control with PIDController",
      "content": "Velocity control maintains a specific speed:<br><br><strong>Setting Target Velocity:</strong> Use setSetpoint() to specify the target velocity (RPM, encoder units per second, etc.).<br><br><strong>Reading Current Velocity:</strong> Read velocity from your sensor (encoder rate, gyro rate, etc.) every robot loop.<br><br><strong>Calculating Output:</strong> Call calculate() with the current velocity. The PIDController adjusts output to maintain target speed.<br><br><strong>Load Compensation:</strong> When load changes, the PIDController automatically increases or decreases output to maintain speed. This is especially useful for flywheels and intakes.<br><br><strong>Feedforward:</strong> Consider adding feedforward (kV term) for velocity control to improve performance. This predicts the needed output based on target velocity."
    },
    {
      "type": "text",
      "title": "Angle Control with PIDController",
      "content": "Angle control handles rotation with wraparound (0° = 360°):<br><br><strong>Continuous Input Mode:</strong> Use enableContinuousInput(0.0, 360.0) to enable wraparound. This tells the PIDController that 0° and 360° are the same, so it will take the shortest path.<br><br><strong>Example:</strong> If current angle is 10° and target is 350°, without continuous input, the controller would rotate 340° counterclockwise. With continuous input, it rotates 20° clockwise (the shorter path).<br><br><strong>Use Cases:</strong> Turret rotation, swerve module angle, any mechanism that rotates 360° and needs to take the shortest path to target.<br><br><strong>Setting Up:</strong> Call enableContinuousInput() in constructor with the minimum and maximum angle values (typically 0.0 and 360.0 for degrees, or 0.0 and 2π for radians)."
    },
    {
      "type": "code",
      "title": "PIDController for Angle Control (with Continuous Input)",
      "content": "This example shows angle control with wraparound:\n\npackage frc.robot.subsystems;\n\nimport edu.wpi.first.math.controller.PIDController;\nimport edu.wpi.first.wpilibj.Encoder;\nimport edu.wpi.first.wpilibj.motorcontrol.PWMSparkMax;\nimport edu.wpi.first.wpilibj2.command.SubsystemBase;\n\npublic class Turret extends SubsystemBase {\n    private final PWMSparkMax m_turretMotor = new PWMSparkMax(1);\n    private final Encoder m_encoder = new Encoder(2, 3);\n    \n    // Create PIDController for angle control\n    private final PIDController m_pidController = new PIDController(0.05, 0.0, 0.005);\n    \n    private double m_targetAngle = 0.0;\n    \n    public Turret() {\n        // Configure encoder (example: 360 counts per revolution)\n        m_encoder.setDistancePerPulse(360.0 / 360.0);  // 1 degree per count\n        \n        // Enable continuous input for angle wraparound\n        // This makes 0° and 360° the same, so controller takes shortest path\n        m_pidController.enableContinuousInput(0.0, 360.0);\n        \n        // Set tolerance\n        m_pidController.setTolerance(3.0);  // Within 3 degrees\n        \n        // Limit integral to prevent windup\n        m_pidController.setIntegratorRange(-0.3, 0.3);\n    }\n    \n    public void setTargetAngle(double angle) {\n        // Normalize angle to 0-360 range\n        m_targetAngle = ((angle % 360) + 360) % 360;\n        m_pidController.setSetpoint(m_targetAngle);\n    }\n    \n    @Override\n    public void periodic() {\n        // Read current angle (normalized to 0-360)\n        double currentAngle = ((m_encoder.getDistance() % 360) + 360) % 360;\n        \n        // Calculate PID output (will take shortest path due to continuous input)\n        double output = m_pidController.calculate(currentAngle);\n        \n        // Apply to motor\n        m_turretMotor.set(output);\n    }\n    \n    public boolean isAtTarget() {\n        return m_pidController.atSetpoint();\n    }\n    \n    public double getCurrentAngle() {\n        double angle = m_encoder.getDistance();\n        return ((angle % 360) + 360) % 360;\n    }\n}"
    },
    {
      "type": "text",
      "title": "PIDController Integration",
      "content": "PIDController integrates seamlessly with WPILib's command-based framework:<br><br><strong>In Subsystems:</strong> Create PIDController as a field, call calculate() in periodic(), and provide methods for commands to set targets and check status.<br><br><strong>In Commands:</strong> Commands can set setpoints, check atSetpoint() in isFinished(), and coordinate multiple PIDControllers for complex behaviors.<br><br><strong>Periodic Updates:</strong> Always call calculate() in your subsystem's periodic() method, which runs every 20ms. This ensures continuous PID control.<br><br><strong>State Management:</strong> Store the target setpoint in your subsystem so commands can query it, and provide methods to check if the mechanism is at target."
    },
    {
      "type": "code",
      "title": "PIDController in a Command",
      "content": "This example shows how to use PIDController in a command:\n\npackage frc.robot.commands;\n\nimport edu.wpi.first.wpilibj2.command.Command;\nimport frc.robot.subsystems.Arm;\n\npublic class MoveArmToAngle extends Command {\n    private final Arm m_arm;\n    private final double m_targetAngle;\n    \n    public MoveArmToAngle(Arm arm, double targetAngle) {\n        m_arm = arm;\n        m_targetAngle = targetAngle;\n        addRequirements(arm);\n    }\n    \n    @Override\n    public void initialize() {\n        // Set target angle when command starts\n        m_arm.setTargetAngle(m_targetAngle);\n    }\n    \n    @Override\n    public void execute() {\n        // PIDController calculates output in Arm.periodic()\n        // Command just needs to set target and check completion\n    }\n    \n    @Override\n    public boolean isFinished() {\n        // Command finishes when arm reaches target\n        return m_arm.isAtTarget();\n    }\n    \n    @Override\n    public void end(boolean interrupted) {\n        // Optional: stop motor or hold position\n        // Arm's PIDController will continue holding if setpoint remains\n    }\n}"
    },
    {
      "type": "text",
      "title": "Advanced PIDController Features",
      "content": "PIDController includes several advanced features:<br><br><strong>Continuous Input:</strong> enableContinuousInput() handles wraparound for angles. The controller takes the shortest path to the target.<br><br><strong>Tolerance Settings:</strong> setTolerance() defines how close to setpoint is considered \"at setpoint\". Useful for commands that wait for completion.<br><br><strong>Output Limits:</strong> setIntegratorRange() and output clamping prevent excessive outputs and integral windup. Important for safety and stability.<br><br><strong>Reset Methods:</strong> reset() clears the integral term and resets controller state. Useful when changing setpoints or recovering from errors.<br><br><strong>Runtime Tuning:</strong> setP(), setI(), setD() allow changing gains at runtime, useful for adaptive control or tuning interfaces."
    },
    {
      "type": "text",
      "title": "In-Code vs On-Controller PID",
      "content": "Choose the right approach for your application:<br><br><strong>Use In-Code PID When:</strong> You need custom control logic, you're coordinating multiple mechanisms, you're using non-standard sensors, you need complex calculations, or you want easier debugging and modification.<br><br><strong>Use On-Controller PID When:</strong> You need maximum speed (1ms updates), you want to offload roboRIO processing, you're using standard position/velocity control, or you need consistent timing regardless of roboRIO load.<br><br><strong>Hybrid Approach:</strong> Use on-controller PID for individual motor control and in-code PID for higher-level coordination. Both can work together in the same robot."
    },
    {
      "type": "link-grid",
      "title": "Related Topics",
      "links": [
        {
		  "label": "PID Control Introduction", 
		  "url": "pid-control-intro"},
        {
		  "label": "PID Tuning", 
		  "url": "pid-tuning"},
        {
		  "label": "PID On Controller", 
		  "url": "pid-on-controller"}
      ]
    }
  ]
}

