{
  "title": "Feedforward Control",
  "sections": [
    {
      "type": "text",
      "title": "Introduction to Feedforward Control",
      "content": "Feedforward control is a control technique that predicts the required output based on the desired setpoint, rather than reacting to error like feedback control (PID). Feedforward uses a mathematical model of the system to calculate the output needed to achieve a target, reducing error before it occurs.<br><br>Feedforward is often combined with PID feedback control for optimal performance. Feedforward provides the predicted output, while PID corrects for any remaining error. This combination enables faster response, better accuracy, and improved disturbance rejection.<br><br>Learn more: <a href='https://docs.wpilib.org/en/stable/docs/software/advanced-controls/controllers/feedforward.html' target='_blank'>WPILib: Feedforward Control</a>"
    },
    {
      "type": "text",
      "title": "Feedforward vs Feedback",
      "content": "Understanding the difference between feedforward and feedback helps you use both effectively:<br><br><strong>Feedback Control (PID):</strong> Reacts to error after it occurs. Measures the difference between desired and actual, then adjusts output to reduce error. Excellent for handling unknown disturbances and ensuring accuracy.<br><br><strong>Feedforward Control:</strong> Predicts required output before error occurs. Uses a model of the system to calculate output needed for the desired setpoint. Excellent for known system characteristics and faster response.<br><br><strong>Why Combine Them:</strong> Feedforward provides the predicted output, but the model may not be perfect. PID corrects for modeling errors and unknown disturbances. Together, they provide optimal control: feedforward for speed, PID for accuracy."
    },
    {
      "type": "text",
      "title": "Types of Feedforward",
      "content": "WPILib supports several types of feedforward:<br><br><strong>Velocity Feedforward (kV):</strong> Predicts output needed to maintain a specific velocity. Based on the relationship between voltage and velocity. Essential for velocity control (flywheels, constant-speed mechanisms).<br><br><strong>Acceleration Feedforward (kA):</strong> Predicts output needed for acceleration. Based on the relationship between voltage and acceleration. Useful for motion profiling and dynamic control.<br><br><strong>Static Feedforward (kS):</strong> Compensates for static friction and other constant forces. A constant offset that overcomes friction at rest. Important for mechanisms with significant friction.<br><br><strong>Gravity Feedforward (kG):</strong> Compensates for gravity in mechanisms like arms. Predicts output needed to hold position against gravity. Essential for arms and elevators."
    },
    {
      "type": "text",
      "title": "Feedforward Math",
      "content": "Feedforward uses mathematical models to predict output:<br><br><strong>Simple Motor Feedforward:</strong> <code>Output = kV × velocity + kA × acceleration + kS × sign(velocity)</code><br>- kV compensates for velocity-dependent losses<br>- kA compensates for acceleration needs<br>- kS compensates for static friction<br><br><strong>Arm Feedforward:</strong> <code>Output = kV × velocity + kA × acceleration + kG × cos(angle)</code><br>- Includes gravity compensation (kG) based on arm angle<br>- Gravity effect varies with angle (maximum at horizontal)<br><br><strong>Model-Based:</strong> Feedforward gains are determined by characterizing your mechanism. You measure how the mechanism responds to inputs and calculate the gains that best match the model."
    },
    {
      "type": "text",
      "title": "WPILib Feedforward Classes",
      "content": "WPILib provides feedforward classes for different mechanism types:<br><br><strong>SimpleMotorFeedforward:</strong> For mechanisms without gravity (drivetrains, flywheels, elevators with counterbalance). Includes kV, kA, and kS terms. Use calculate(velocity) or calculate(velocity, acceleration) methods.<br><br><strong>ArmFeedforward:</strong> For arms with gravity (rotating arms, elevators without counterbalance). Includes kV, kA, kS, and kG terms. Use calculate(angle, velocity) or calculate(angle, velocity, acceleration) methods.<br><br><strong>Creating Feedforward Objects:</strong> Create feedforward objects with the appropriate gains. These objects calculate feedforward output based on setpoints (velocity, acceleration, angle)."
    },
    {
      "type": "code",
      "title": "Basic SimpleMotorFeedforward Usage",
      "content": "This example shows how to use SimpleMotorFeedforward:\n\npackage frc.robot.subsystems;\n\nimport edu.wpi.first.math.controller.SimpleMotorFeedforward;\nimport edu.wpi.first.math.controller.PIDController;\nimport edu.wpi.first.wpilibj.Encoder;\nimport edu.wpi.first.wpilibj.motorcontrol.PWMSparkMax;\nimport edu.wpi.first.wpilibj2.command.SubsystemBase;\n\npublic class Flywheel extends SubsystemBase {\n    private final PWMSparkMax m_flywheelMotor = new PWMSparkMax(0);\n    private final Encoder m_encoder = new Encoder(0, 1);\n    \n    // PID for feedback control\n    private final PIDController m_pidController = new PIDController(0.05, 0.0, 0.0);\n    \n    // Feedforward for velocity control\n    // kV: volts per (unit per second) - determined by characterization\n    // kS: volts to overcome static friction\n    private final SimpleMotorFeedforward m_feedforward = \n        new SimpleMotorFeedforward(0.12, 0.0, 0.01);  // kV, kA, kS\n    \n    private double m_targetVelocity = 0.0;  // RPM\n    \n    public void setTargetVelocity(double velocity) {\n        m_targetVelocity = velocity;\n        m_pidController.setSetpoint(velocity);\n    }\n    \n    @Override\n    public void periodic() {\n        // Read current velocity\n        double currentVelocity = m_encoder.getRate();  // RPM\n        \n        // Calculate feedforward output (predicts needed voltage)\n        double feedforwardOutput = m_feedforward.calculate(m_targetVelocity);\n        \n        // Calculate PID output (corrects for error)\n        double pidOutput = m_pidController.calculate(currentVelocity);\n        \n        // Combine feedforward and PID\n        double totalOutput = feedforwardOutput + pidOutput;\n        \n        // Apply to motor (convert to motor output range if needed)\n        m_flywheelMotor.set(totalOutput / 12.0);  // Assuming 12V nominal\n    }\n}"
    },
    {
      "type": "code",
      "title": "ArmFeedforward for Arm Control",
      "content": "This example shows how to use ArmFeedforward for gravity compensation:\n\npackage frc.robot.subsystems;\n\nimport edu.wpi.first.math.controller.ArmFeedforward;\nimport edu.wpi.first.math.controller.PIDController;\nimport edu.wpi.first.wpilibj.Encoder;\nimport edu.wpi.first.wpilibj.motorcontrol.PWMSparkMax;\nimport edu.wpi.first.wpilibj2.command.SubsystemBase;\n\npublic class Arm extends SubsystemBase {\n    private final PWMSparkMax m_armMotor = new PWMSparkMax(1);\n    private final Encoder m_encoder = new Encoder(2, 3);\n    \n    // PID for feedback control\n    private final PIDController m_pidController = new PIDController(0.1, 0.0, 0.01);\n    \n    // Feedforward with gravity compensation\n    // kV: volts per (radian per second)\n    // kG: volts to hold arm horizontal (gravity compensation)\n    // kS: volts to overcome static friction\n    private final ArmFeedforward m_feedforward = \n        new ArmFeedforward(0.0, 0.0, 0.5, 0.01);  // kS, kG, kV, kA\n    \n    private double m_targetAngle = 0.0;  // degrees\n    \n    public void setTargetAngle(double angle) {\n        m_targetAngle = angle;\n        m_pidController.setSetpoint(angle);\n    }\n    \n    @Override\n    public void periodic() {\n        // Read current angle (convert to radians for feedforward)\n        double currentAngleRad = Math.toRadians(m_encoder.getDistance());\n        double currentVelocityRad = Math.toRadians(m_encoder.getRate());\n        double targetAngleRad = Math.toRadians(m_targetAngle);\n        \n        // Calculate feedforward output (includes gravity compensation)\n        // Feedforward predicts output needed for target angle and velocity\n        double feedforwardOutput = m_feedforward.calculate(\n            targetAngleRad, currentVelocityRad);\n        \n        // Calculate PID output (corrects for position error)\n        double pidOutput = m_pidController.calculate(m_encoder.getDistance());\n        \n        // Combine feedforward and PID\n        double totalOutput = feedforwardOutput + pidOutput;\n        \n        // Apply to motor (convert to motor output range if needed)\n        m_armMotor.set(totalOutput / 12.0);  // Assuming 12V nominal\n    }\n}"
    },
    {
      "type": "code",
      "title": "Feedforward Combined with PIDController",
      "content": "This example shows the complete pattern of combining feedforward with PID:\n\npackage frc.robot.subsystems;\n\nimport edu.wpi.first.math.controller.SimpleMotorFeedforward;\nimport edu.wpi.first.math.controller.PIDController;\nimport edu.wpi.first.wpilibj.Encoder;\nimport edu.wpi.first.wpilibj.motorcontrol.PWMSparkMax;\nimport edu.wpi.first.wpilibj2.command.SubsystemBase;\n\npublic class Elevator extends SubsystemBase {\n    private final PWMSparkMax m_elevatorMotor = new PWMSparkMax(2);\n    private final Encoder m_encoder = new Encoder(4, 5);\n    \n    // PID for feedback\n    private final PIDController m_pidController = new PIDController(0.15, 0.0, 0.02);\n    \n    // Feedforward for velocity/acceleration\n    private final SimpleMotorFeedforward m_feedforward = \n        new SimpleMotorFeedforward(0.1, 0.05, 0.02);  // kV, kA, kS\n    \n    private double m_targetPosition = 0.0;\n    private double m_targetVelocity = 0.0;\n    \n    public void setTarget(double position, double velocity) {\n        m_targetPosition = position;\n        m_targetVelocity = velocity;\n        m_pidController.setSetpoint(position);\n    }\n    \n    @Override\n    public void periodic() {\n        // Read current state\n        double currentPosition = m_encoder.getDistance();\n        double currentVelocity = m_encoder.getRate();\n        \n        // Calculate acceleration (simplified - in real implementation, \n        // get from motion profile or estimate)\n        double acceleration = (m_targetVelocity - currentVelocity) * 10.0;  // Simplified\n        \n        // Calculate feedforward (predicts needed output)\n        double feedforwardOutput = m_feedforward.calculate(m_targetVelocity, acceleration);\n        \n        // Calculate PID (corrects for error)\n        double pidOutput = m_pidController.calculate(currentPosition);\n        \n        // Combine: feedforward provides base, PID corrects\n        double totalOutput = feedforwardOutput + pidOutput;\n        \n        // Apply to motor\n        m_elevatorMotor.set(totalOutput / 12.0);\n    }\n}"
    },
    {
      "type": "text",
      "title": "Using Feedforward",
      "content": "Using feedforward involves several steps:<br><br><strong>Creating Feedforward Objects:</strong> Create SimpleMotorFeedforward or ArmFeedforward objects with the appropriate gains (kV, kA, kS, kG). These gains are determined through mechanism characterization.<br><br><strong>Calculating Feedforward Output:</strong> Call calculate() with the desired setpoint (velocity, acceleration, angle). The feedforward returns the predicted output needed to achieve that setpoint.<br><br><strong>Combining with PID:</strong> Add feedforward output to PID output. Feedforward provides the predicted base output, PID corrects for any remaining error.<br><br><strong>Applying to Mechanisms:</strong> Apply the combined output to your motor. The feedforward improves response speed, while PID ensures accuracy."
    },
    {
      "type": "text",
      "title": "Combining Feedforward with PID",
      "content": "The best control combines feedforward and PID:<br><br><strong>Feedforward Role:</strong> Provides the predicted output based on the desired setpoint. Handles known system characteristics (friction, gravity, velocity relationships). Reduces error before it occurs.<br><br><strong>PID Role:</strong> Corrects for any remaining error. Handles modeling errors, unknown disturbances, and ensures accuracy. Provides feedback to fine-tune the output.<br><br><strong>Combined Output:</strong> <code>Total Output = Feedforward Output + PID Output</code>. Feedforward does the heavy lifting, PID does the fine-tuning.<br><br><strong>Best Practices:</strong> Use feedforward for the primary output, PID for correction. Tune PID with feedforward enabled. Feedforward reduces PID workload, allowing lower PID gains."
    },
    {
      "type": "text",
      "title": "Feedforward Tuning",
      "content": "Feedforward gains are determined through mechanism characterization:<br><br><strong>Characterization Process:</strong> Measure how your mechanism responds to different inputs. For velocity feedforward, measure velocity at different voltages. For gravity feedforward, measure holding voltage at different angles.<br><br><strong>Finding kV:</strong> Apply different voltages and measure resulting velocity. kV = voltage / velocity (volts per unit per second). Use linear regression to find the best fit.<br><br><strong>Finding kS:</strong> Measure the minimum voltage needed to overcome static friction. kS = that voltage (volts).<br><br><strong>Finding kG:</strong> For arms, measure voltage needed to hold arm at different angles. kG = voltage at horizontal position (volts).<br><br><strong>Tools:</strong> Use WPILib's characterization tools, AdvantageKit logging, or manual testing to determine feedforward gains."
    },
    {
      "type": "link-grid",
      "title": "Related Topics",
      "links": [
        {
		  "label": "PID Control Introduction", 
		  "url": "pid-control-intro"},
        {
		  "label": "Trapezoidal Profiles", 
		  "url": "trapezoidal-profiles"},
        {
		  "label": "Motion Profiling Basics", 
		  "url": "motion-profiling-basics"}
      ]
    }
  ]
}

