{
    "title": "Motion Profiling",
    "sections": [
        {
            "type": "text",
            "title": "From Position Control to Motion Profiling",
            "content": "Your elevator now has precise position control - it can move to any height and hold there reliably. But there's a problem: when you command it to move from home to the high position, it accelerates instantly, overshoots, oscillates, and takes longer than necessary to settle. The motion is jerky, stressful on the mechanism, and inconsistent.<br><br>Motion profiling solves this by planning the entire motion path before execution. Instead of instantly commanding the target position, a motion profile generates a smooth trajectory that respects your mechanism's physical limits. The result? Fast, smooth, predictable motion that reduces mechanical stress and improves accuracy.<br><br>Think of it like the difference between flooring the gas pedal and slamming the brakes versus smoothly accelerating, cruising, and gently decelerating. Both get you to your destination, but one is far more elegant and efficient."
        },
        {
            "type": "text",
            "title": "The Problem Without Profiling",
            "content": "Without motion profiling, your elevator exhibits several frustrating behaviors:<br><br><strong>Jerky Motion:</strong> Instantly applying full power causes sudden acceleration. The elevator lurches to life, creating uncomfortable motion and mechanical stress. Your mechanism feels like it's fighting itself.<br><br><strong>Overshoot:</strong> Without controlled deceleration, the elevator overshoots its target. Commanding 100 units might result in reaching 105 units before settling back, wasting time and energy. Every movement becomes a correction exercise.<br><br><strong>Inconsistent Timing:</strong> Without a planned motion path, the time to reach a target varies based on starting conditions, load, and battery voltage. Your autonomous routines become unreliable because the elevator never arrives when expected.<br><br><strong>Mechanical Stress:</strong> Sudden starts and stops stress mechanical components - belts stretch, gears wear, and components fatigue. Your robot's lifespan decreases with every jarring movement.<br><br>Motion profiles eliminate these problems by generating smooth acceleration and deceleration curves, creating fast, accurate, repeatable motion that your mechanism can actually achieve."
        },
        {
            "type": "text",
            "title": "Understanding Motion Profiles",
            "content": "A motion profile is a mathematical description of how your mechanism should move over time. It specifies the desired position, velocity, and acceleration at every moment from start to finish. Instead of just saying \"go to position 100,\" a profile says \"accelerate smoothly for 0.5 seconds, cruise at maximum speed for 1.0 seconds, then decelerate smoothly to stop at position 100.\"<br><br>Motion profiles work by respecting constraints - maximum velocity and maximum acceleration - that represent your mechanism's physical capabilities. The profile calculates the optimal path that gets you to your target as quickly as possible while never exceeding these limits. It's like having a smart navigation system that knows your car's acceleration and top speed, planning the fastest route that's actually achievable.<br><br>There are two main profile types you'll use for elevators: trapezoidal profiles (fast, predictable, with distinct phases) and exponential profiles (smooth, natural-feeling, with continuous motion). Both solve the same problem but with different characteristics - we'll explore both so you can choose the right tool for your mechanism."
        },
        {
            "type": "text",
            "title": "Trapezoidal Profiles: Characteristics and Implementation",
            "content": "Trapezoidal motion profiles are the workhorse of FRC motion control. They generate motion with three distinct phases that create a trapezoid shape on a velocity-time graph, giving them their name.<br><br><strong>Acceleration Phase:</strong> Your elevator accelerates at maximum acceleration until reaching maximum velocity. During this phase, velocity increases linearly, and position increases quadratically. The mechanism builds up speed efficiently.<br><br><strong>Cruise Phase:</strong> Your elevator moves at constant maximum velocity. This phase only occurs if the distance is long enough to reach maximum velocity. During cruise, velocity is constant, and position increases linearly. This is where you cover ground quickly.<br><br><strong>Deceleration Phase:</strong> Your elevator decelerates at maximum (negative) acceleration until reaching zero velocity at the target. During this phase, velocity decreases linearly, and position approaches the target smoothly. The mechanism comes to a precise stop.<br><br>For short distances, the profile may not reach maximum velocity, resulting in only acceleration and deceleration phases (creating a triangular profile). The profile automatically handles this - you just specify constraints and target, and it calculates the optimal path.<br><br><strong>Built-in Trapezoidal Profiles:</strong> Both SPARK MAX (MAXMotion) and Talon FX (Motion Magic) have built-in trapezoidal motion profiling. Instead of manually implementing profiles with WPILib's TrapezoidProfile class, you configure the motor controller's motion parameters and use the appropriate control type. The motor controller automatically generates and follows the trapezoidal profile, making implementation much simpler."
        },
        {
            "type": "text",
            "title": "Setting Maximum Velocity",
            "content": "The maximum velocity constraint defines the highest speed your elevator will reach during the profile. This should be based on your mechanism's capabilities, motor characteristics, and safety requirements. Too high can cause overshoot or mechanical stress; too low makes motion unnecessarily slow.<br><br>For elevators, typical values range from 2000-4000 RPM (SPARK MAX MAXMotion) or 5-20 rotations per second (Talon FX Motion Magic), depending on gearing and mechanism design. Start conservative - you can always increase it during tuning. Test with your actual mechanism to find the sweet spot where motion is fast but still smooth and controllable.<br><br><strong>Note:</strong> MAXMotion uses RPM (revolutions per minute) by default, while Motion Magic uses rotations per second. Use encoder conversion factors to work with your mechanism's units."
        },
        {
            "type": "code-tabs",
            "title": "Maximum Velocity Configuration",
            "content": "Configure maximum velocity in your motor controller:",
            "tabs": [
                {
                    "label": "SPARK MAX (MAXMotion)",
                    "code": "import com.revrobotics.spark.config.SparkMaxConfig;\nimport com.revrobotics.spark.ClosedLoopSlot;\n\n// Maximum velocity in RPM (revolutions per minute)\n// Typical range: 2000-4000 RPM for elevators\nprivate static final double MAX_VELOCITY_RPM = 3000.0;\n\n// Configure in SparkMaxConfig:\nSparkMaxConfig motorConfig = new SparkMaxConfig();\nmotorConfig.closedLoop.maxMotion\n    .maxVelocity(MAX_VELOCITY_RPM, ClosedLoopSlot.kSlot0);"
                },
                {
                    "label": "Talon FX (Motion Magic)",
                    "code": "import com.ctre.phoenix6.configs.MotionMagicConfigs;\n\n// Maximum velocity in rotations per second\n// Typical range: 5-20 for elevators\nprivate static final double CRUISE_VELOCITY = 10.0;\n\n// Configure in TalonFXConfiguration:\nMotionMagicConfigs motionMagicConfigs = config.MotionMagic;\nmotionMagicConfigs.MotionMagicCruiseVelocity = CRUISE_VELOCITY;"
                }
            ]
        },
        {
            "type": "text",
            "title": "Setting Maximum Acceleration",
            "content": "The maximum acceleration constraint determines how quickly your elevator can change velocity. This controls both how fast it accelerates and how fast it decelerates. Based on motor torque, gearing, mechanism inertia, and safety considerations.<br><br>Typical values range from 1500-3000 RPM per second (SPARK MAX MAXMotion) or 10-50 rotations per second squared (Talon FX Motion Magic). Higher acceleration means faster response but can cause mechanical stress. Lower acceleration is gentler but slower. Balance speed with mechanism safety - your elevator should feel responsive but not aggressive.<br><br><strong>Optional: Jerk (Talon FX):</strong> Motion Magic also supports jerk (rate of change of acceleration) for S-curve profiles. This creates even smoother motion by limiting how quickly acceleration changes. Typical values: 50-200 rotations per second cubed."
        },
        {
            "type": "code-tabs",
            "title": "Maximum Acceleration Configuration",
            "content": "Configure maximum acceleration in your motor controller:",
            "tabs": [
                {
                    "label": "SPARK MAX (MAXMotion)",
                    "code": "import com.revrobotics.spark.config.SparkMaxConfig;\nimport com.revrobotics.spark.ClosedLoopSlot;\n\n// Maximum acceleration in RPM per second\n// Typical range: 1500-3000 RPM/s for elevators\nprivate static final double MAX_ACCELERATION_RPM_PER_SEC = 2000.0;\n\n// Configure in SparkMaxConfig:\nSparkMaxConfig motorConfig = new SparkMaxConfig();\nmotorConfig.closedLoop.maxMotion\n    .maxAcceleration(MAX_ACCELERATION_RPM_PER_SEC, ClosedLoopSlot.kSlot0);"
                },
                {
                    "label": "Talon FX (Motion Magic)",
                    "code": "import com.ctre.phoenix6.configs.MotionMagicConfigs;\n\n// Maximum acceleration in rotations per second squared\n// Typical range: 10-50 for elevators\nprivate static final double ACCELERATION = 20.0;\n\n// Optional: Jerk for S-curve profiles (rotations per second cubed)\nprivate static final double JERK = 100.0;\n\n// Configure in TalonFXConfiguration:\nMotionMagicConfigs motionMagicConfigs = config.MotionMagic;\nmotionMagicConfigs.MotionMagicAcceleration = ACCELERATION;\nmotionMagicConfigs.MotionMagicJerk = JERK;  // Optional"
                }
            ]
        },
        {
            "type": "text",
            "title": "Configuring PID for Motion Profiling",
            "content": "Both MAXMotion and Motion Magic run on top of internal PID controllers. You need to configure PID constants (kP, kI, kD) for smooth motion. Tune these values similar to regular position control, but they may need adjustment once you set velocity and acceleration parameters.<br><br><strong>Important Notes:</strong><br>- For MAXMotion: kF (feedforward) is not recommended and may lead to unexpected results<br>- For Motion Magic: kV, kS, and kA can be used for feedforward, but are optional<br>- Start with basic PID tuning, then adjust after setting motion parameters<br>- kI is typically set to 0.0 for position control"
        },
        {
            "type": "code-tabs",
            "title": "Configuring PID Constants",
            "content": "Configure PID for your motor controller:",
            "tabs": [
                {
                    "label": "SPARK MAX (MAXMotion)",
                    "code": "import com.revrobotics.spark.config.SparkMaxConfig;\nimport com.revrobotics.spark.config.ClosedLoopConfig.FeedbackSensor;\nimport com.revrobotics.spark.ClosedLoopSlot;\n\n// PID constants (Slot 0)\nprivate static final double POSITION_KP = 0.1;\nprivate static final double POSITION_KI = 0.0;\nprivate static final double POSITION_KD = 0.01;\n\n// Configure in SparkMaxConfig:\nSparkMaxConfig motorConfig = new SparkMaxConfig();\nmotorConfig.closedLoop\n    .feedbackSensor(FeedbackSensor.kPrimaryEncoder)\n    .p(POSITION_KP, ClosedLoopSlot.kSlot0)\n    .i(POSITION_KI, ClosedLoopSlot.kSlot0)\n    .d(POSITION_KD, ClosedLoopSlot.kSlot0);\n    // Note: kF (feedforward) is not recommended for MAXMotion"
                },
                {
                    "label": "Talon FX (Motion Magic)",
                    "code": "import com.ctre.phoenix6.configs.Slot0Configs;\n\n// PID constants (Slot0)\nprivate static final double POSITION_KP = 0.1;\nprivate static final double POSITION_KI = 0.0;\nprivate static final double POSITION_KD = 0.01;\n\n// Configure in TalonFXConfiguration:\nSlot0Configs slot0Configs = config.Slot0;\nslot0Configs.kP = POSITION_KP;\nslot0Configs.kI = POSITION_KI;\nslot0Configs.kD = POSITION_KD;\nslot0Configs.kV = 0.0;  // Optional velocity feedforward\nslot0Configs.kA = 0.0;  // Optional acceleration feedforward"
                }
            ]
        },
        {
            "type": "text",
            "title": "Using Built-in Trapezoidal Profiles",
            "content": "Once configured, using trapezoidal profiles is simple - just set the target position using the appropriate control type. The motor controller automatically generates and follows the trapezoidal profile based on your configured velocity and acceleration limits.<br><br><strong>How It Works:</strong><br>1. You set the target position using MAXMotion or Motion Magic control<br>2. The motor controller calculates the motion profile based on current position, target position, and your configured constraints<br>3. The controller automatically accelerates, cruises, and decelerates<br>4. PID control ensures accurate following of the profile<br>5. The controller holds at the target position<br><br><strong>No Manual Profile Management:</strong> Unlike manual WPILib TrapezoidProfile implementation, you don't need to track time, query the profile each loop, or manage profile states. The motor controller handles everything automatically."
        },
        {
            "type": "code-tabs",
            "title": "Using Trapezoidal Motion Profiles",
            "content": "Set target position - the motor controller handles the profile:",
            "tabs": [
                {
                    "label": "SPARK MAX (MAXMotion)",
                    "code": "package frc.robot.subsystems;\n\nimport com.revrobotics.spark.SparkMax;\nimport com.revrobotics.spark.SparkLowLevel.MotorType;\nimport com.revrobotics.spark.SparkClosedLoopController;\nimport com.revrobotics.spark.SparkBase.ControlType;\nimport com.revrobotics.spark.SparkBase.PersistMode;\nimport com.revrobotics.spark.SparkBase.ResetMode;\nimport com.revrobotics.spark.config.SparkMaxConfig;\nimport com.revrobotics.spark.config.ClosedLoopConfig.FeedbackSensor;\nimport com.revrobotics.spark.ClosedLoopSlot;\nimport com.revrobotics.RelativeEncoder;\nimport edu.wpi.first.wpilibj2.command.SubsystemBase;\n\npublic class ArmWithMAXMotion extends SubsystemBase {\n    private final SparkMax m_armMotor = new SparkMax(3, MotorType.kBrushless);\n    private final SparkClosedLoopController m_closedLoopController = m_armMotor.getClosedLoopController();\n    private final RelativeEncoder m_encoder = m_armMotor.getEncoder();\n    \n    // Conversion: encoder counts to degrees\n    // NEO encoder: 42 counts per revolution\n    private static final double COUNTS_PER_DEGREE = 42.0 / 360.0;\n    \n    // MAXMotion parameters (RPM)\n    private static final double MAX_VELOCITY = 3000.0;  // RPM\n    private static final double MAX_ACCELERATION = 2000.0;  // RPM per second\n    \n    public ArmWithMAXMotion() {\n        SparkMaxConfig motorConfig = new SparkMaxConfig();\n        \n        // Configure encoder\n        motorConfig.encoder\n            .positionConversionFactor(1)\n            .velocityConversionFactor(1);\n        \n        // Configure closed loop controller\n        motorConfig.closedLoop\n            .feedbackSensor(FeedbackSensor.kPrimaryEncoder)\n            .p(0.1, ClosedLoopSlot.kSlot0)\n            .i(0.0, ClosedLoopSlot.kSlot0)\n            .d(0.01, ClosedLoopSlot.kSlot0)\n            .outputRange(-1, 1, ClosedLoopSlot.kSlot0);\n        \n        // Configure MAXMotion parameters\n        motorConfig.closedLoop.maxMotion\n            .maxVelocity(MAX_VELOCITY, ClosedLoopSlot.kSlot0)\n            .maxAcceleration(MAX_ACCELERATION, ClosedLoopSlot.kSlot0)\n            .allowedClosedLoopError(1, ClosedLoopSlot.kSlot0);\n        \n        // Apply configuration\n        m_armMotor.configure(motorConfig, ResetMode.kResetSafeParameters, PersistMode.kNoPersistParameters);\n        \n        m_encoder.setPosition(0);\n    }\n    \n    public void setAngle(double degrees) {\n        // Convert degrees to encoder counts\n        double targetCounts = degrees * COUNTS_PER_DEGREE;\n        \n        m_closedLoopController.setReference(\n            targetCounts, \n            ControlType.kMAXMotionPositionControl, \n            ClosedLoopSlot.kSlot0\n        );\n    }\n    \n    public double getAngle() {\n        double position = m_encoder.getPosition();\n        return position / COUNTS_PER_DEGREE;\n    }\n}"
                },
                {
                    "label": "Talon FX (Motion Magic)",
                    "code": "package frc.robot.subsystems;\n\nimport com.ctre.phoenix6.hardware.TalonFX;\nimport com.ctre.phoenix6.controls.MotionMagicVoltage;\nimport com.ctre.phoenix6.configs.TalonFXConfiguration;\nimport com.ctre.phoenix6.signals.FeedbackSensorSourceValue;\nimport edu.wpi.first.wpilibj2.command.SubsystemBase;\n\npublic class ArmWithMotionMagic extends SubsystemBase {\n    private final TalonFX m_armMotor = new TalonFX(3);\n    \n    // Control request (reusable)\n    private final MotionMagicVoltage m_motionMagicRequest = new MotionMagicVoltage(0);\n    \n    // Conversion: rotations to degrees\n    private static final double ROTATIONS_PER_DEGREE = 1.0 / 360.0;\n    \n    // Motion Magic parameters (rotations/second)\n    private static final double CRUISE_VELOCITY = 10.0;\n    private static final double ACCELERATION = 10.0;\n    private static final double JERK = 100.0;\n    \n    public ArmWithMotionMagic() {\n        TalonFXConfiguration config = new TalonFXConfiguration();\n        \n        // Configure feedback sensor\n        config.Feedback.FeedbackSensorSource = FeedbackSensorSourceValue.RotorSensor;\n        \n        // Configure PID\n        config.Slot0.kP = 0.1;\n        config.Slot0.kI = 0.0;\n        config.Slot0.kD = 0.01;\n        config.Slot0.kV = 0.0;\n        \n        // Configure Motion Magic\n        config.MotionMagic.MotionMagicCruiseVelocity = CRUISE_VELOCITY;\n        config.MotionMagic.MotionMagicAcceleration = ACCELERATION;\n        config.MotionMagic.MotionMagicJerk = JERK;\n        \n        m_armMotor.setPosition(0);\n        \n        m_armMotor.getConfigurator().apply(config);\n    }\n    \n    public void setAngle(double degrees) {\n        // Convert degrees to rotations\n        double targetRotations = degrees * ROTATIONS_PER_DEGREE;\n        \n        m_armMotor.setControl(m_motionMagicRequest.withPosition(targetRotations));\n    }\n    \n    public double getAngle() {\n        double position = m_armMotor.getPosition().getValueAsDouble();\n        return position / ROTATIONS_PER_DEGREE;\n    }\n}"
                }
            ]
        },
        {
            "type": "text",
            "title": "S-Curve Profiles (Motion Magic)",
            "content": "Motion Magic uses jerk to control the smoothness of acceleration and deceleration. Jerk is the rate of change of acceleration, which creates smoother motion profiles (S-Curve profiles).<br><br><strong>Low Jerk:</strong><br>- More linear acceleration and deceleration<br>- Faster to reach cruise velocity<br>- May feel slightly jerky<br>- Simpler motion profile<br><br><strong>High Jerk:</strong><br>- Very smooth acceleration and deceleration<br>- Acceleration rate changes smoothly<br>- More comfortable motion<br>- Reduces mechanical stress<br>- Slightly slower to reach cruise velocity<br><br><strong>Jerk Values:</strong><br>- Typical range: 50-200 rotations/second³<br>- Lower values (50-100) = faster, less smooth<br>- Higher values (150-200) = smoother, slightly slower<br>- Very high values may make motion feel sluggish<br><br><strong>Choosing Jerk:</strong> Start with moderate jerk (100), then adjust based on your mechanism's needs. Higher values reduce jerk (the physical phenomenon) but may make motion feel slower to start."
        },
        {
            "type": "code-tabs",
            "title": "Monitoring Motion Status",
            "content": "Monitor motion status to determine when motion is complete or to display telemetry:",
            "tabs": [
                {
                    "label": "SPARK MAX (MAXMotion)",
                    "code": "import com.revrobotics.spark.SparkMax;\nimport com.revrobotics.spark.SparkLowLevel.MotorType;\nimport com.revrobotics.spark.SparkClosedLoopController;\nimport com.revrobotics.spark.SparkBase.ControlType;\nimport com.revrobotics.spark.ClosedLoopSlot;\nimport com.revrobotics.RelativeEncoder;\nimport edu.wpi.first.wpilibj.smartdashboard.SmartDashboard;\n\npublic class MAXMotionStatus {\n    private final SparkMax m_motor = new SparkMax(1, MotorType.kBrushless);\n    private final SparkClosedLoopController m_closedLoopController = m_motor.getClosedLoopController();\n    private final RelativeEncoder m_encoder = m_motor.getEncoder();\n    \n    private double m_targetPosition = 0.0;\n    \n    public void setPosition(double position) {\n        m_targetPosition = position;\n        m_closedLoopController.setReference(\n            position, \n            ControlType.kMAXMotionPositionControl, \n            ClosedLoopSlot.kSlot0\n        );\n    }\n    \n    public void updateStatus() {\n        // Current position and velocity\n        double position = m_encoder.getPosition();\n        double velocity = m_encoder.getVelocity();\n        \n        // Motor output\n        double output = m_motor.get();\n        \n        double error = m_targetPosition - position;\n        \n        SmartDashboard.putNumber(\"Position\", position);\n        SmartDashboard.putNumber(\"Velocity\", velocity);\n        SmartDashboard.putNumber(\"Target Position\", m_targetPosition);\n        SmartDashboard.putNumber(\"Error\", error);\n        SmartDashboard.putNumber(\"Output\", output);\n        \n        // Check if motion is complete (tolerance in encoder counts)\n        boolean isComplete = Math.abs(error) < 5.0 && Math.abs(velocity) < 10.0;\n        SmartDashboard.putBoolean(\"Motion Complete\", isComplete);\n    }\n}"
                },
                {
                    "label": "Talon FX (Motion Magic)",
                    "code": "import com.ctre.phoenix6.hardware.TalonFX;\nimport com.ctre.phoenix6.BaseStatusSignal;\nimport com.ctre.phoenix6.controls.MotionMagicVoltage;\nimport edu.wpi.first.wpilibj.smartdashboard.SmartDashboard;\n\npublic class MotionMagicStatus {\n    private final TalonFX m_motor = new TalonFX(1);\n    private final MotionMagicVoltage m_motionMagicRequest = new MotionMagicVoltage(0);\n    \n    // Status signals for efficient reading\n    private final BaseStatusSignal[] m_signals = {\n        m_motor.getPosition(),\n        m_motor.getVelocity(),\n        m_motor.getDutyCycle()\n    };\n    \n    public void updateStatus() {\n        // Refresh all signals at once (efficient)\n        BaseStatusSignal.refreshAll(m_signals);\n        \n        // Current position and velocity\n        double position = m_motor.getPosition().getValueAsDouble();\n        double velocity = m_motor.getVelocity().getValueAsDouble();\n        \n        // Motor output\n        double output = m_motor.getDutyCycle().getValueAsDouble();\n        \n        // Note: In Phoenix 6, you track the target yourself\n        double targetPosition = m_motionMagicRequest.Position;\n        double error = targetPosition - position;\n        \n        SmartDashboard.putNumber(\"Position\", position);\n        SmartDashboard.putNumber(\"Velocity\", velocity);\n        SmartDashboard.putNumber(\"Target Position\", targetPosition);\n        SmartDashboard.putNumber(\"Error\", error);\n        SmartDashboard.putNumber(\"Output\", output);\n        \n        // Check if motion is complete (tolerance in rotations)\n        boolean isComplete = Math.abs(error) < 0.1 && Math.abs(velocity) < 0.5;\n        SmartDashboard.putBoolean(\"Motion Complete\", isComplete);\n    }\n}"
                }
            ]
        },
        {
            "type": "code-tabs",
            "title": "Tuning Helper with SmartDashboard",
            "content": "Helper code for tuning motion profiling parameters from SmartDashboard:",
            "tabs": [
                {
                    "label": "SPARK MAX (MAXMotion)",
                    "code": "package frc.robot.subsystems;\n\nimport com.revrobotics.spark.SparkMax;\nimport com.revrobotics.spark.config.SparkMaxConfig;\nimport com.revrobotics.spark.ClosedLoopSlot;\nimport com.revrobotics.spark.SparkBase.PersistMode;\nimport com.revrobotics.spark.SparkBase.ResetMode;\nimport edu.wpi.first.wpilibj.smartdashboard.SmartDashboard;\n\npublic class MAXMotionTuning {\n    private final SparkMax m_motor;\n    \n    public MAXMotionTuning(SparkMax motor) {\n        m_motor = motor;\n    }\n    \n    public void updateFromDashboard() {\n        double maxVel = SmartDashboard.getNumber(\"MAXMotion Max Velocity\", 3000.0);\n        double maxAccel = SmartDashboard.getNumber(\"MAXMotion Max Acceleration\", 2000.0);\n        \n        double kP = SmartDashboard.getNumber(\"PID kP\", 0.1);\n        double kI = SmartDashboard.getNumber(\"PID kI\", 0.0);\n        double kD = SmartDashboard.getNumber(\"PID kD\", 0.01);\n        \n        SparkMaxConfig config = new SparkMaxConfig();\n        config.closedLoop\n            .p(kP, ClosedLoopSlot.kSlot0)\n            .i(kI, ClosedLoopSlot.kSlot0)\n            .d(kD, ClosedLoopSlot.kSlot0);\n        \n        config.closedLoop.maxMotion\n            .maxVelocity(maxVel, ClosedLoopSlot.kSlot0)\n            .maxAcceleration(maxAccel, ClosedLoopSlot.kSlot0);\n        \n        // Apply configuration (don't reset or persist for tuning)\n        m_motor.configure(config, ResetMode.kNoResetSafeParameters, PersistMode.kNoPersistParameters);\n    }\n    \n    public void displayStatus() {\n        SmartDashboard.putNumber(\"MAXMotion Position\", m_motor.getEncoder().getPosition());\n        SmartDashboard.putNumber(\"MAXMotion Velocity\", m_motor.getEncoder().getVelocity());\n        SmartDashboard.putNumber(\"MAXMotion Output\", m_motor.get());\n    }\n}"
                },
                {
                    "label": "Talon FX (Motion Magic)",
                    "code": "package frc.robot.subsystems;\n\nimport com.ctre.phoenix6.hardware.TalonFX;\nimport com.ctre.phoenix6.configs.MotionMagicConfigs;\nimport com.ctre.phoenix6.configs.Slot0Configs;\nimport edu.wpi.first.wpilibj.smartdashboard.SmartDashboard;\n\npublic class MotionMagicTuning {\n    private final TalonFX m_motor;\n    \n    public MotionMagicTuning(TalonFX motor) {\n        m_motor = motor;\n    }\n    \n    public void updateFromDashboard() {\n        double cruiseVel = SmartDashboard.getNumber(\"MM Cruise Velocity\", 10.0);\n        double accel = SmartDashboard.getNumber(\"MM Acceleration\", 10.0);\n        double jerk = SmartDashboard.getNumber(\"MM Jerk\", 100.0);\n        \n        MotionMagicConfigs mmConfig = new MotionMagicConfigs();\n        mmConfig.MotionMagicCruiseVelocity = cruiseVel;\n        mmConfig.MotionMagicAcceleration = accel;\n        mmConfig.MotionMagicJerk = jerk;\n        m_motor.getConfigurator().apply(mmConfig);\n        \n        double kP = SmartDashboard.getNumber(\"PID kP\", 0.1);\n        double kI = SmartDashboard.getNumber(\"PID kI\", 0.0);\n        double kD = SmartDashboard.getNumber(\"PID kD\", 0.01);\n        \n        Slot0Configs slotConfig = new Slot0Configs();\n        slotConfig.kP = kP;\n        slotConfig.kI = kI;\n        slotConfig.kD = kD;\n        m_motor.getConfigurator().apply(slotConfig);\n    }\n    \n    public void displayStatus() {\n        SmartDashboard.putNumber(\"MM Position\", m_motor.getPosition().getValueAsDouble());\n        SmartDashboard.putNumber(\"MM Velocity\", m_motor.getVelocity().getValueAsDouble());\n        SmartDashboard.putNumber(\"MM Output\", m_motor.getDutyCycle().getValueAsDouble());\n    }\n}"
                }
            ]
        },
        {
            "type": "text",
            "title": "Exponential Profiles: Characteristics and Implementation",
            "content": "Exponential motion profiles offer a different approach to smooth motion. Instead of distinct acceleration, cruise, and deceleration phases, exponential profiles provide continuous, natural-feeling motion with gradually changing acceleration. The motion feels more organic - like how a real mechanism would naturally accelerate and decelerate.<br><br>Exponential profiles are simpler to implement than trapezoidal profiles and work exceptionally well for elevators. They automatically handle acceleration and deceleration without requiring you to think about phases or cruise velocity. The profile smoothly transitions from current state to goal state, creating motion that reduces mechanical stress and feels comfortable to watch.<br><br>While trapezoidal profiles are optimized for maximum speed and precise timing, exponential profiles prioritize smoothness and simplicity. For elevators, where smooth motion is often more important than shaving milliseconds off movement time, exponential profiles can be the perfect choice."
        },
        {
            "type": "text",
            "title": "Setting kMaxV (Maximum Velocity)",
            "content": "For exponential profiles, kMaxV defines the maximum velocity your mechanism will reach. Similar to trapezoidal profiles, this should match your mechanism's capabilities. Typical values are similar to trapezoidal maximum velocity - 50-200 encoder units per second for SPARK MAX or 5-20 rotations per second for Talon FX.<br><br>Unlike trapezoidal profiles where maximum velocity is a hard limit, exponential profiles approach this velocity asymptotically. The mechanism accelerates quickly at first, then the acceleration gradually decreases as it approaches maximum velocity, creating smooth, natural motion."
        },
        {
            "type": "code-tabs",
            "title": "kMaxV Constant",
            "content": "Define maximum velocity for exponential profile:",
            "tabs": [
                {
                    "label": "SPARK MAX",
                    "code": "// Maximum velocity in encoder units per second\n// Typical range: 50-200 for elevators\nprivate static final double kMaxV = 100.0;"
                },
                {
                    "label": "Talon FX",
                    "code": "// Maximum velocity in rotations per second\n// Typical range: 5-20 for elevators\n// Note: For CTRE, this is configured differently (see MotionMagicExpo_kV)"
                }
            ]
        },
        {
            "type": "text",
            "title": "Setting kV (Velocity Gain)",
            "content": "The kV parameter represents the relationship between voltage and velocity. It tells you how much voltage is needed to achieve a given velocity. If your mechanism needs 0.12 volts to move at 1 unit per second, then kV = 0.12.<br><br>kV is typically determined through mechanism characterization - you measure velocity at different voltages and calculate the relationship. For elevators, typical values range from 0.1 to 0.2 volts per (unit per second). This gain helps the profile predict the output needed to maintain velocity, making the motion smoother and more accurate."
        },
        {
            "type": "code-tabs",
            "title": "kV Constant",
            "content": "Define velocity gain:",
            "tabs": [
                {
                    "label": "SPARK MAX",
                    "code": "// Velocity gain: volts per (encoder unit per second)\n// Determined through characterization\n// Typical range: 0.1-0.2 for elevators\nprivate static final double kV = 0.12;"
                },
                {
                    "label": "Talon FX",
                    "code": "// Velocity gain: volts per (rotation per second)\n// Configured in MotionMagicExpo_kV\n// Typical range: 0.1-0.2 for elevators\nmotionMagicConfigs.MotionMagicExpo_kV = 0.12;"
                }
            ]
        },
        {
            "type": "text",
            "title": "Setting kA (Acceleration Gain)",
            "content": "The kA parameter represents the relationship between voltage and acceleration. It tells you how much extra voltage is needed to accelerate at a given rate. If your mechanism needs 0.01 volts to accelerate at 1 unit per second squared, then kA = 0.01.<br><br>kA is also determined through characterization, though it's often smaller than kV. Typical values range from 0.005 to 0.02 volts per (unit per second squared). This gain helps the profile predict the output needed for acceleration, improving the profile's ability to follow the desired motion path."
        },
        {
            "type": "code-tabs",
            "title": "kA Constant",
            "content": "Define acceleration gain:",
            "tabs": [
                {
                    "label": "SPARK MAX",
                    "code": "// Acceleration gain: volts per (encoder unit per second squared)\n// Determined through characterization\n// Typical range: 0.005-0.02 for elevators\nprivate static final double kA = 0.01;"
                },
                {
                    "label": "Talon FX",
                    "code": "// Acceleration gain: volts per (rotation per second squared)\n// Configured in MotionMagicExpo_kA\n// Typical range: 0.005-0.02 for elevators\nmotionMagicConfigs.MotionMagicExpo_kA = 0.1;"
                }
            ]
        },
        {
            "type": "text",
            "title": "Creating Exponential Profile Constraints",
            "content": "For WPILib's ExponentialProfile, create constraints using the fromCharacteristics() method. This static method takes kMaxV, kV, and kA and creates a Constraints object. Unlike trapezoidal profiles where you pass velocity and acceleration directly, exponential profiles use these three characteristics to define the profile's behavior.<br><br>The constraints object is reusable - create it once and use it for all exponential profiles. Store it as a final field in your subsystem. For CTRE, the constraints are configured directly in the motor controller configuration, not as a separate object."
        },
        {
            "type": "code-tabs",
            "title": "Creating Constraints",
            "content": "Create exponential profile constraints:",
            "tabs": [
                {
                    "label": "SPARK MAX",
                    "code": "import edu.wpi.first.math.trajectory.ExponentialProfile;\n\nprivate static final double kMaxV = 100.0;\nprivate static final double kV = 0.12;\nprivate static final double kA = 0.01;\n\nprivate final ExponentialProfile.Constraints m_constraints = \n    ExponentialProfile.Constraints.fromCharacteristics(kMaxV, kV, kA);"
                },
                {
                    "label": "Talon FX",
                    "code": "import com.ctre.phoenix6.configs.MotionMagicConfigs;\n\n// In TalonFXConfiguration:\nMotionMagicConfigs motionMagicConfigs = config.MotionMagic;\nmotionMagicConfigs.MotionMagicCruiseVelocity = 0;  // Unlimited\nmotionMagicConfigs.MotionMagicExpo_kV = 0.12;\nmotionMagicConfigs.MotionMagicExpo_kA = 0.1;"
                }
            ]
        },
        {
            "type": "text",
            "title": "Creating the Exponential Profile",
            "content": "For WPILib, create an ExponentialProfile instance with your constraints. Unlike TrapezoidProfile which is created with states, ExponentialProfile is created once and reused. You update the goal state each time you want to move to a new position.<br><br>For CTRE, you don't create a profile object - the motor controller handles it internally. You just configure the MotionMagicExpo parameters and use the MotionMagicExpoVoltage control request."
        },
        {
            "type": "code-tabs",
            "title": "Creating the Profile",
            "content": "Create the exponential profile:",
            "tabs": [
                {
                    "label": "SPARK MAX",
                    "code": "import edu.wpi.first.math.trajectory.ExponentialProfile;\n\n// Create profile once with constraints\nprivate final ExponentialProfile m_profile = \n    new ExponentialProfile(m_constraints);"
                },
                {
                    "label": "Talon FX",
                    "code": "import com.ctre.phoenix6.controls.MotionMagicExpoVoltage;\n\n// Create control request (profile handled by motor controller)\nprivate final MotionMagicExpoVoltage m_expoRequest = \n    new MotionMagicExpoVoltage(0);"
                }
            ]
        },
        {
            "type": "text",
            "title": "Tracking Current and Goal States",
            "content": "For WPILib exponential profiles, you need to track both the current state (where you are now) and the goal state (where you want to go). The profile smoothly transitions from current to goal. Update the goal state when you want to move to a new position. The current state is read from your encoder each loop.<br><br>For CTRE, you don't need to track states manually - the motor controller handles this internally. You just set the target position, and the controller generates the profile automatically."
        },
        {
            "type": "code-tabs",
            "title": "State Tracking",
            "content": "Track current and goal states:",
            "tabs": [
                {
                    "label": "SPARK MAX",
                    "code": "import edu.wpi.first.math.trajectory.ExponentialProfile;\n\n// Profile state tracking\nprivate ExponentialProfile.State m_profiledReference = \n    new ExponentialProfile.State(0.0, 0.0);\nprivate ExponentialProfile.State m_goalState = \n    new ExponentialProfile.State(0.0, 0.0);\n\n// Set goal state when moving to new position\npublic void setHeightWithProfile(double height) {\n    m_goalState = new ExponentialProfile.State(height, 0.0);\n}"
                },
                {
                    "label": "Talon FX",
                    "code": "// No manual state tracking needed - CTRE handles it\n// Just set the target position\npublic void setHeightWithProfile(double height) {\n    m_elevatorMotor.setControl(m_expoRequest.withPosition(height));\n}"
                }
            ]
        },
        {
            "type": "text",
            "title": "Calculating Exponential Profile",
            "content": "For WPILib exponential profiles, call calculate() each loop with the time delta (time since last call), current state, and goal state. Unlike trapezoidal profiles which use absolute elapsed time, exponential profiles use delta time - the time between calls. This makes them reactive to goal state changes.<br><br>The profile returns a new profiled reference state that's closer to the goal. Use this profiled reference position as your PID setpoint. The profile automatically handles smooth acceleration and deceleration. For CTRE, calculation happens automatically on the motor controller - you don't call calculate() yourself."
        },
        {
            "type": "code-tabs",
            "title": "Calculating Profile State",
            "content": "Calculate desired state each loop:",
            "tabs": [
                {
                    "label": "SPARK MAX",
                    "code": "import edu.wpi.first.wpilibj.Timer;\n\n// Track last time\nprivate double m_lastTime = 0.0;\n\n// In periodic():\ndouble currentTime = Timer.getFPGATimestamp();\ndouble deltaTime = currentTime - m_lastTime;\n\n// Get current state from encoder\ndouble currentPosition = m_encoder.getPosition();\ndouble currentVelocity = m_encoder.getVelocity();\nExponentialProfile.State currentState = \n    new ExponentialProfile.State(currentPosition, currentVelocity);\n\n// Calculate profiled reference\nm_profiledReference = m_profile.calculate(\n    deltaTime, \n    currentState, \n    m_goalState\n);\n\nm_lastTime = currentTime;"
                },
                {
                    "label": "Talon FX",
                    "code": "// No calculation needed - CTRE handles it automatically\n// Just set the target position, motor controller does the rest\nm_elevatorMotor.setControl(m_expoRequest.withPosition(targetHeight));"
                }
            ]
        },
        {
            "type": "text",
            "title": "Using Exponential Profile Output",
            "content": "For WPILib, use the profiled reference position as your PID setpoint, just like with trapezoidal profiles. The profile smoothly moves the setpoint toward the goal, creating natural motion. For CTRE, the motor controller automatically uses the profile - you just command the target position, and it handles the rest.<br><br>Exponential profiles are particularly elegant because they're reactive - if you change the goal state mid-motion, the profile smoothly adjusts. This makes them great for operator-controlled mechanisms where targets might change frequently."
        },
        {
            "type": "code-tabs",
            "title": "Applying Profile to Motor Control",
            "content": "Use profile output for motor control:",
            "tabs": [
                {
                    "label": "SPARK MAX",
                    "code": "import com.revrobotics.spark.SparkClosedLoopController;\nimport com.revrobotics.spark.SparkBase.ControlType;\nimport com.revrobotics.spark.ClosedLoopSlot;\n\n// Use profiled reference position as PID setpoint\nm_closedLoopController.setReference(\n    m_profiledReference.position, \n    ControlType.kPosition, \n    ClosedLoopSlot.kSlot0\n);"
                },
                {
                    "label": "Talon FX",
                    "code": "// Profile is automatically applied by motor controller\n// Just set target position - controller handles profile\nm_elevatorMotor.setControl(m_expoRequest.withPosition(targetHeight));"
                }
            ]
        },
        {
            "type": "text",
            "title": "Motion Magic Expo (Talon FX)",
            "content": "Motion Magic® Expo provides exponential motion profiles that offer smooth, natural-feeling motion. Unlike standard Motion Magic which uses trapezoidal/S-Curve profiles, Motion Magic Expo uses exponential profiles with continuous acceleration changes.<br><br><strong>Motion Magic Expo Parameters:</strong><br>- <strong>MotionMagicExpo_kV:</strong> Velocity gain (volts per rotation per second)<br>- <strong>MotionMagicExpo_kA:</strong> Acceleration gain (volts per rotation per second squared)<br>- <strong>MotionMagicCruiseVelocity:</strong> Maximum velocity (set to 0 for unlimited)<br><br><strong>Benefits:</strong><br>- Smooth, natural-feeling motion<br>- Continuous acceleration changes (no distinct phases)<br>- Simpler to tune than standard Motion Magic<br>- Works exceptionally well for elevators and arms<br><br><strong>Configuration:</strong> Motion Magic Expo is configured in the MotionMagic config group, not in the PID slot. The kV and kA values are typically determined through mechanism characterization."
        },
        {
            "type": "code",
            "title": "Configuring Motion Magic Expo",
            "content": "import com.ctre.phoenix6.hardware.TalonFX;\nimport com.ctre.phoenix6.configs.TalonFXConfiguration;\nimport com.ctre.phoenix6.configs.MotionMagicConfigs;\nimport com.ctre.phoenix6.configs.Slot0Configs;\nimport com.ctre.phoenix6.signals.FeedbackSensorSourceValue;\n\npublic class MotionMagicExpoConfig {\n    private final TalonFX m_motor = new TalonFX(1);\n    \n    public MotionMagicExpoConfig() {\n        TalonFXConfiguration config = new TalonFXConfiguration();\n        \n        // Configure feedback sensor\n        config.Feedback.FeedbackSensorSource = FeedbackSensorSourceValue.RotorSensor;\n        \n        // Configure PID (Slot0)\n        Slot0Configs slot0Configs = config.Slot0;\n        slot0Configs.kP = 4.8;\n        slot0Configs.kI = 0.0;\n        slot0Configs.kD = 0.1;\n        slot0Configs.kV = 0.0;  // Not used with Motion Magic Expo\n        slot0Configs.kS = 0.25;  // Static friction compensation\n        slot0Configs.kA = 0.0;  // Not used with Motion Magic Expo\n        \n        // Configure Motion Magic Expo\n        MotionMagicConfigs motionMagicConfigs = config.MotionMagic;\n        motionMagicConfigs.MotionMagicCruiseVelocity = 0;  // Unlimited cruise velocity\n        motionMagicConfigs.MotionMagicExpo_kV = 0.12;  // V/rps\n        motionMagicConfigs.MotionMagicExpo_kA = 0.1;  // V/(rps/s)\n        \n        m_motor.getConfigurator().apply(config);\n    }\n}"
        },
        {
            "type": "code",
            "title": "Using Motion Magic Expo",
            "content": "package frc.robot.subsystems;\n\nimport com.ctre.phoenix6.hardware.TalonFX;\nimport com.ctre.phoenix6.controls.MotionMagicExpoVoltage;\nimport com.ctre.phoenix6.configs.TalonFXConfiguration;\nimport com.ctre.phoenix6.configs.MotionMagicConfigs;\nimport com.ctre.phoenix6.configs.Slot0Configs;\nimport com.ctre.phoenix6.signals.FeedbackSensorSourceValue;\nimport edu.wpi.first.wpilibj2.command.SubsystemBase;\n\npublic class ElevatorWithMotionMagicExpo extends SubsystemBase {\n    private final TalonFX m_elevatorMotor = new TalonFX(3);\n    \n    // Control request (reusable)\n    private final MotionMagicExpoVoltage m_expoRequest = new MotionMagicExpoVoltage(0);\n    \n    public ElevatorWithMotionMagicExpo() {\n        TalonFXConfiguration config = new TalonFXConfiguration();\n        \n        // Configure feedback sensor\n        config.Feedback.FeedbackSensorSource = FeedbackSensorSourceValue.RotorSensor;\n        \n        // Configure PID (Slot0)\n        Slot0Configs slot0Configs = config.Slot0;\n        slot0Configs.kP = 4.8;\n        slot0Configs.kI = 0.0;\n        slot0Configs.kD = 0.1;\n        slot0Configs.kV = 0.0;\n        slot0Configs.kS = 0.25;\n        slot0Configs.kA = 0.0;\n        \n        // Configure Motion Magic Expo\n        MotionMagicConfigs motionMagicConfigs = config.MotionMagic;\n        motionMagicConfigs.MotionMagicCruiseVelocity = 0;  // Unlimited\n        motionMagicConfigs.MotionMagicExpo_kV = 0.12;\n        motionMagicConfigs.MotionMagicExpo_kA = 0.1;\n        \n        m_elevatorMotor.setPosition(0);\n        m_elevatorMotor.getConfigurator().apply(config);\n    }\n    \n    public void setHeight(double rotations) {\n        m_elevatorMotor.setControl(m_expoRequest.withPosition(rotations));\n    }\n    \n    public double getHeight() {\n        return m_elevatorMotor.getPosition().getValueAsDouble();\n    }\n}"
        },
        {
            "type": "text",
            "title": "Profile Type Selection: Exponential vs Trapezoidal",
            "content": "Understanding when to use each profile type helps you choose the right solution for your mechanism:<br><br><strong>Use Exponential Profiles When:</strong> You need simple, natural motion; you're controlling elevators or arms; you don't need precise timing; you want easy implementation; or smooth motion is more important than maximum speed. Exponential profiles excel at making mechanisms feel polished and professional. For SPARK MAX, you'll use WPILib's ExponentialProfile. For Talon FX, use Motion Magic Expo.<br><br><strong>Use Trapezoidal Profiles When:</strong> You need maximum speed; you need precise timing for autonomous routines; you have complex mechanisms with strict constraints; or you need optimal performance. Trapezoidal profiles are the choice when every millisecond matters. For SPARK MAX, use MAXMotion (built-in trapezoidal). For Talon FX, use Motion Magic (built-in trapezoidal).<br><br><strong>The Trade-off:</strong> Exponential profiles are simpler but may not reach maximum speed as quickly. Trapezoidal profiles provide better performance for demanding applications. Both MAXMotion and Motion Magic make trapezoidal profiles easy to use - you just configure parameters and set the target position. For elevators, both profile types work well - choose based on whether you prioritize smoothness (exponential) or maximum speed (trapezoidal)."
        },
        {
            "type": "text",
            "title": "Feedforward Control",
            "content": "So far, we've used PID feedback control - it reacts to error after it occurs. But what if we could predict the required output before error happens? That's feedforward control - it uses a mathematical model of your system to calculate the output needed to achieve a target, reducing error before it occurs.<br><br>Feedforward is like having a crystal ball for your mechanism. Instead of waiting to see that you're going too slow and then correcting, feedforward predicts \"to maintain this velocity, I'll need this much voltage\" and provides it immediately. The result? Faster response, better accuracy, and improved disturbance rejection.<br><br>Feedforward is almost always combined with PID feedback control. Feedforward provides the predicted output (doing the heavy lifting), while PID corrects for any remaining error (handling the fine-tuning). Together, they create optimal control: feedforward for speed, PID for accuracy."
        },
        {
            "type": "text",
            "title": "Combining Feedforward with Motion Profiles",
            "content": "Motion profiles and feedforward are a perfect match. The profile tells you where you should be and how fast you should be moving. Feedforward predicts the output needed to achieve that velocity and acceleration. Together, they create smooth, accurate motion.<br><br>When following a motion profile, you use the profile's desired velocity for velocity feedforward (kV) and the profile's desired acceleration for acceleration feedforward (kA). This provides most of the control effort, reducing the workload on your PID controller. The PID only needs to correct for small errors, allowing you to use lower PID gains for smoother, more stable control.<br><br>The combination is powerful: the profile plans the motion, feedforward predicts the needed output, and PID ensures accuracy. Your elevator moves smoothly, quickly, and precisely - exactly what you want for professional robot performance."
        },
        {
            "type": "code-tabs",
            "title": "Complete Elevator with Motion Profiling",
            "content": "Your fully configured elevator with motion profiling - choose trapezoidal or exponential based on your needs:",
            "tabs": [
                {
                    "label": "SPARK MAX - Trapezoidal (MAXMotion)",
                    "code": "package frc.robot.subsystems;\n\nimport com.revrobotics.spark.SparkMax;\nimport com.revrobotics.spark.SparkLowLevel.MotorType;\nimport com.revrobotics.spark.SparkClosedLoopController;\nimport com.revrobotics.spark.SparkBase.ControlType;\nimport com.revrobotics.spark.SparkBase.PersistMode;\nimport com.revrobotics.spark.SparkBase.ResetMode;\nimport com.revrobotics.spark.config.SparkMaxConfig;\nimport com.revrobotics.spark.config.SparkBaseConfig.IdleMode;\nimport com.revrobotics.spark.config.ClosedLoopConfig.FeedbackSensor;\nimport com.revrobotics.spark.ClosedLoopSlot;\nimport com.revrobotics.RelativeEncoder;\nimport edu.wpi.first.wpilibj.smartdashboard.SmartDashboard;\nimport edu.wpi.first.wpilibj2.command.SubsystemBase;\n\npublic class Elevator extends SubsystemBase {\n    private final SparkMax m_elevatorMotor = new SparkMax(4, MotorType.kBrushless);\n    private final SparkClosedLoopController m_closedLoopController = m_elevatorMotor.getClosedLoopController();\n    private final RelativeEncoder m_encoder = m_elevatorMotor.getEncoder();\n    \n    // Conversion: encoder counts to inches (assuming 4\" diameter spool, 42 counts/rev)\n    private static final double COUNTS_PER_REVOLUTION = 42.0;\n    private static final double SPOOL_CIRCUMFERENCE = 4.0 * Math.PI;  // inches\n    private static final double COUNTS_PER_INCH = COUNTS_PER_REVOLUTION / SPOOL_CIRCUMFERENCE;\n    \n    // MAXMotion parameters (RPM)\n    private static final double MAX_VELOCITY = 3000.0;  // RPM\n    private static final double MAX_ACCELERATION = 2000.0;  // RPM per second\n    \n    // Preset positions (in inches)\n    public static final double BOTTOM = 0.0;\n    public static final double MID = 24.0;\n    public static final double TOP = 48.0;\n    \n    private double m_targetHeight = 0.0;\n    \n    public Elevator() {\n        SparkMaxConfig motorConfig = new SparkMaxConfig();\n        \n        // Basic motor configuration\n        motorConfig.idleMode(IdleMode.kBrake);\n        \n        // Configure encoder\n        motorConfig.encoder\n            .positionConversionFactor(1)\n            .velocityConversionFactor(1);\n        \n        // Configure closed loop controller\n        motorConfig.closedLoop\n            .feedbackSensor(FeedbackSensor.kPrimaryEncoder)\n            .p(0.15, ClosedLoopSlot.kSlot0)\n            .i(0.0, ClosedLoopSlot.kSlot0)\n            .d(0.02, ClosedLoopSlot.kSlot0)\n            .outputRange(-1, 1, ClosedLoopSlot.kSlot0);\n        \n        // Configure MAXMotion parameters\n        motorConfig.closedLoop.maxMotion\n            .maxVelocity(MAX_VELOCITY, ClosedLoopSlot.kSlot0)\n            .maxAcceleration(MAX_ACCELERATION, ClosedLoopSlot.kSlot0)\n            .allowedClosedLoopError(1, ClosedLoopSlot.kSlot0);\n        \n        // Configure soft limits (in encoder counts)\n        motorConfig.softLimit\n            .forwardSoftLimit((float)(TOP * COUNTS_PER_INCH))\n            .reverseSoftLimit((float)(BOTTOM * COUNTS_PER_INCH))\n            .forwardSoftLimitEnabled(true)\n            .reverseSoftLimitEnabled(true);\n        \n        // Apply configuration\n        m_elevatorMotor.configure(motorConfig, ResetMode.kResetSafeParameters, PersistMode.kNoPersistParameters);\n        \n        m_encoder.setPosition(0);\n    }\n    \n    public void setHeight(double inches) {\n        m_targetHeight = inches;\n        double targetCounts = inches * COUNTS_PER_INCH;\n        m_closedLoopController.setReference(\n            targetCounts, \n            ControlType.kMAXMotionPositionControl, \n            ClosedLoopSlot.kSlot0\n        );\n    }\n    \n    public double getHeight() {\n        double position = m_encoder.getPosition();\n        return position / COUNTS_PER_INCH;\n    }\n    \n    public boolean isAtHeight(double targetHeight, double tolerance) {\n        double currentHeight = getHeight();\n        return Math.abs(currentHeight - targetHeight) < tolerance;\n    }\n    \n    public boolean isMotionComplete() {\n        // Check if within tolerance and velocity is low\n        double currentPos = m_encoder.getPosition();\n        double velocity = Math.abs(m_encoder.getVelocity());\n        double targetCounts = m_targetHeight * COUNTS_PER_INCH;\n        double error = Math.abs(targetCounts - currentPos);\n        return error < 5.0 && velocity < 10.0;\n    }\n    \n    @Override\n    public void periodic() {\n        SmartDashboard.putNumber(\"Elevator Height\", getHeight());\n        SmartDashboard.putBoolean(\"Motion Complete\", isMotionComplete());\n    }\n}"
                },
                {
                    "label": "SPARK MAX - Exponential",
                    "code": "package frc.robot.subsystems;\n\nimport com.revrobotics.spark.SparkMax;\nimport com.revrobotics.spark.SparkLowLevel.MotorType;\nimport com.revrobotics.spark.SparkClosedLoopController;\nimport com.revrobotics.spark.SparkBase.ControlType;\nimport com.revrobotics.spark.SparkBase.PersistMode;\nimport com.revrobotics.spark.SparkBase.ResetMode;\nimport com.revrobotics.spark.config.SparkMaxConfig;\nimport com.revrobotics.spark.config.SparkBaseConfig.IdleMode;\nimport com.revrobotics.spark.config.ClosedLoopConfig.FeedbackSensor;\nimport com.revrobotics.spark.ClosedLoopSlot;\nimport com.revrobotics.RelativeEncoder;\nimport edu.wpi.first.math.trajectory.ExponentialProfile;\nimport edu.wpi.first.wpilibj.Timer;\nimport edu.wpi.first.wpilibj.smartdashboard.SmartDashboard;\nimport edu.wpi.first.wpilibj2.command.SubsystemBase;\n\npublic class Elevator extends SubsystemBase {\n    private final SparkMax m_elevatorMotor = new SparkMax(3, MotorType.kBrushless);\n    private final SparkClosedLoopController m_closedLoopController = m_elevatorMotor.getClosedLoopController();\n    private final RelativeEncoder m_encoder = m_elevatorMotor.getEncoder();\n    \n    // Configuration constants\n    private static final int CURRENT_LIMIT = 40;\n    private static final int SECONDARY_CURRENT_LIMIT = 60;\n    private static final double VOLTAGE_COMPENSATION = 12.0;\n    private static final double RAMP_RATE = 0.5;\n    private static final double MAX_HEIGHT = 100.0;\n    private static final double GEAR_RATIO = 10.0;\n    \n    // PID constants (Slot 0)\n    private static final double POSITION_KP = 0.5;\n    private static final double POSITION_KI = 0.0;\n    private static final double POSITION_KD = 0.1;\n    \n    // Exponential profile constraints\n    private static final double kMaxV = 100.0;\n    private static final double kV = 0.12;\n    private static final double kA = 0.01;\n    \n    private final ExponentialProfile.Constraints m_constraints = \n        ExponentialProfile.Constraints.fromCharacteristics(kMaxV, kV, kA);\n    private final ExponentialProfile m_profile = new ExponentialProfile(m_constraints);\n    \n    // Profile state tracking\n    private ExponentialProfile.State m_profiledReference = \n        new ExponentialProfile.State(0.0, 0.0);\n    private ExponentialProfile.State m_goalState = \n        new ExponentialProfile.State(0.0, 0.0);\n    \n    private double m_lastTime = 0.0;\n    \n    public Elevator() {\n        SparkMaxConfig motorConfig = new SparkMaxConfig();\n        \n        // Motor configuration\n        motorConfig\n            .inverted(false)\n            .idleMode(IdleMode.kBrake)\n            .smartCurrentLimit(CURRENT_LIMIT)\n            .secondaryCurrentLimit(SECONDARY_CURRENT_LIMIT)\n            .voltageCompensation(VOLTAGE_COMPENSATION)\n            .openLoopRampRate(RAMP_RATE)\n            .closedLoopRampRate(RAMP_RATE);\n        \n        // Encoder configuration\n        motorConfig.encoder\n            .positionConversionFactor(1.0 / GEAR_RATIO)\n            .velocityConversionFactor(1.0 / GEAR_RATIO);\n        \n        // Soft limits\n        motorConfig.softLimit\n            .reverseSoftLimit(0.0f)\n            .forwardSoftLimit((float)MAX_HEIGHT)\n            .reverseSoftLimitEnabled(true)\n            .forwardSoftLimitEnabled(true);\n        \n        // Configure closed loop controller\n        motorConfig.closedLoop\n            .feedbackSensor(FeedbackSensor.kPrimaryEncoder)\n            .p(POSITION_KP, ClosedLoopSlot.kSlot0)\n            .i(POSITION_KI, ClosedLoopSlot.kSlot0)\n            .d(POSITION_KD, ClosedLoopSlot.kSlot0)\n            .outputRange(-1, 1, ClosedLoopSlot.kSlot0);\n        \n        // Apply configuration\n        m_elevatorMotor.configure(motorConfig, ResetMode.kResetSafeParameters, PersistMode.kNoPersistParameters);\n        \n        // Reset encoder position after configuration\n        m_encoder.setPosition(0);\n        \n        m_lastTime = Timer.getFPGATimestamp();\n    }\n    \n    public void setHeightWithProfile(double height) {\n        m_goalState = new ExponentialProfile.State(height, 0.0);\n        m_lastTime = Timer.getFPGATimestamp();\n    }\n    \n    public double getHeight() {\n        return m_encoder.getPosition();\n    }\n    \n    @Override\n    public void periodic() {\n        double currentTime = Timer.getFPGATimestamp();\n        double deltaTime = currentTime - m_lastTime;\n        \n        double currentPosition = m_encoder.getPosition();\n        double currentVelocity = m_encoder.getVelocity();\n        ExponentialProfile.State currentState = \n            new ExponentialProfile.State(currentPosition, currentVelocity);\n        \n        m_profiledReference = m_profile.calculate(deltaTime, currentState, m_goalState);\n        \n        m_closedLoopController.setReference(\n            m_profiledReference.position, \n            ControlType.kPosition, \n            ClosedLoopSlot.kSlot0\n        );\n        \n        m_lastTime = currentTime;\n        \n        SmartDashboard.putNumber(\"Elevator Height\", getHeight());\n    }\n}"
                },
                {
                    "label": "Talon FX - Trapezoidal (Motion Magic)",
                    "code": "package frc.robot.subsystems;\n\nimport com.ctre.phoenix6.hardware.TalonFX;\nimport com.ctre.phoenix6.controls.MotionMagicVoltage;\nimport com.ctre.phoenix6.configs.TalonFXConfiguration;\nimport com.ctre.phoenix6.signals.FeedbackSensorSourceValue;\nimport edu.wpi.first.wpilibj.smartdashboard.SmartDashboard;\nimport edu.wpi.first.wpilibj2.command.SubsystemBase;\n\npublic class Elevator extends SubsystemBase {\n    private final TalonFX m_elevatorMotor = new TalonFX(4);\n    \n    // Control request (reusable)\n    private final MotionMagicVoltage m_motionMagicRequest = new MotionMagicVoltage(0);\n    \n    // Conversion: rotations to inches (assuming 4\" diameter spool)\n    private static final double SPOOL_CIRCUMFERENCE = 4.0 * Math.PI;  // inches\n    private static final double ROTATIONS_PER_INCH = 1.0 / SPOOL_CIRCUMFERENCE;\n    \n    // Motion Magic parameters (rotations/second)\n    private static final double CRUISE_VELOCITY = 15.0;\n    private static final double ACCELERATION = 15.0;\n    private static final double JERK = 150.0;\n    \n    // Preset positions (in inches)\n    public static final double BOTTOM = 0.0;\n    public static final double MID = 24.0;\n    public static final double TOP = 48.0;\n    \n    public Elevator() {\n        TalonFXConfiguration config = new TalonFXConfiguration();\n        \n        // Configure feedback sensor\n        config.Feedback.FeedbackSensorSource = FeedbackSensorSourceValue.RotorSensor;\n        \n        // Configure PID\n        config.Slot0.kP = 0.15;\n        config.Slot0.kI = 0.0;\n        config.Slot0.kD = 0.02;\n        config.Slot0.kV = 0.0;\n        \n        // Configure Motion Magic\n        config.MotionMagic.MotionMagicCruiseVelocity = CRUISE_VELOCITY;\n        config.MotionMagic.MotionMagicAcceleration = ACCELERATION;\n        config.MotionMagic.MotionMagicJerk = JERK;\n        \n        // Configure soft limits (in rotations)\n        config.SoftwareLimitSwitch.ForwardSoftLimitEnable = true;\n        config.SoftwareLimitSwitch.ForwardSoftLimitThreshold = TOP * ROTATIONS_PER_INCH;\n        config.SoftwareLimitSwitch.ReverseSoftLimitEnable = true;\n        config.SoftwareLimitSwitch.ReverseSoftLimitThreshold = BOTTOM * ROTATIONS_PER_INCH;\n        \n        m_elevatorMotor.setPosition(0);\n        \n        m_elevatorMotor.getConfigurator().apply(config);\n    }\n    \n    public void setHeight(double inches) {\n        double targetRotations = inches * ROTATIONS_PER_INCH;\n        m_elevatorMotor.setControl(m_motionMagicRequest.withPosition(targetRotations));\n    }\n    \n    public double getHeight() {\n        double position = m_elevatorMotor.getPosition().getValueAsDouble();\n        return position / ROTATIONS_PER_INCH;\n    }\n    \n    public boolean isAtHeight(double targetHeight, double tolerance) {\n        double currentHeight = getHeight();\n        return Math.abs(currentHeight - targetHeight) < tolerance;\n    }\n    \n    public boolean isMotionComplete() {\n        double target = m_motionMagicRequest.Position;\n        double current = m_elevatorMotor.getPosition().getValueAsDouble();\n        double error = Math.abs(target - current);\n        double velocity = Math.abs(m_elevatorMotor.getVelocity().getValueAsDouble());\n        return error < 0.1 && velocity < 0.5;  // Tolerance in rotations\n    }\n    \n    @Override\n    public void periodic() {\n        SmartDashboard.putNumber(\"Elevator Height\", getHeight());\n        SmartDashboard.putBoolean(\"Motion Complete\", isMotionComplete());\n    }\n}"
                },
                {
                    "label": "Talon FX - Exponential",
                    "code": "package frc.robot.subsystems;\n\nimport com.ctre.phoenix6.hardware.TalonFX;\nimport com.ctre.phoenix6.controls.MotionMagicExpoVoltage;\nimport com.ctre.phoenix6.configs.TalonFXConfiguration;\nimport com.ctre.phoenix6.configs.Slot0Configs;\nimport com.ctre.phoenix6.configs.MotionMagicConfigs;\nimport com.ctre.phoenix6.signals.InvertedValue;\nimport com.ctre.phoenix6.signals.NeutralModeValue;\nimport com.ctre.phoenix6.signals.FeedbackSensorSourceValue;\nimport edu.wpi.first.wpilibj.smartdashboard.SmartDashboard;\nimport edu.wpi.first.wpilibj2.command.SubsystemBase;\n\npublic class Elevator extends SubsystemBase {\n    private final TalonFX m_elevatorMotor = new TalonFX(3);\n    private final MotionMagicExpoVoltage m_expoRequest = new MotionMagicExpoVoltage(0);\n    \n    // Configuration constants\n    private static final double CURRENT_LIMIT = 40.0;\n    private static final double CURRENT_THRESHOLD = 50.0;\n    private static final double CURRENT_TIME = 0.5;\n    private static final double VOLTAGE_PEAK = 12.0;\n    private static final double RAMP_RATE = 0.5;\n    private static final double MAX_HEIGHT = 10.0;\n    private static final double GEAR_RATIO = 10.0;\n    \n    // PID constants (Slot0)\n    private static final double POSITION_KP = 0.5;\n    private static final double POSITION_KI = 0.0;\n    private static final double POSITION_KD = 0.1;\n    \n    public Elevator() {\n        TalonFXConfiguration config = new TalonFXConfiguration();\n        \n        // Motor configuration\n        config.MotorOutput.Inverted = InvertedValue.CounterClockwise_Positive;\n        config.MotorOutput.NeutralMode = NeutralModeValue.Brake;\n        config.CurrentLimits.StatorCurrentLimitEnable = true;\n        config.CurrentLimits.StatorCurrentLimit = CURRENT_LIMIT;\n        config.CurrentLimits.SupplyCurrentLimitEnable = true;\n        config.CurrentLimits.SupplyCurrentLimit = CURRENT_LIMIT;\n        config.Voltage.PeakForwardVoltage = VOLTAGE_PEAK;\n        config.Voltage.PeakReverseVoltage = -VOLTAGE_PEAK;\n        \n        // Encoder configuration\n        config.Feedback.FeedbackSensorSource = FeedbackSensorSourceValue.RotorSensor;\n        config.Feedback.SensorToMechanismRatio = GEAR_RATIO;\n        config.Feedback.FeedbackRotorOffset = 0.0;\n        \n        // Soft limits\n        config.SoftwareLimitSwitch.ReverseSoftLimitEnable = true;\n        config.SoftwareLimitSwitch.ReverseSoftLimitThreshold = 0.0;\n        config.SoftwareLimitSwitch.ForwardSoftLimitEnable = true;\n        config.SoftwareLimitSwitch.ForwardSoftLimitThreshold = MAX_HEIGHT;\n        \n        // Closed loop ramp settings\n        config.ClosedLoopRamps.VoltageClosedLoopRampPeriod = RAMP_RATE;\n        config.ClosedLoopRamps.TorqueClosedLoopRampPeriod = RAMP_RATE;\n        \n        // PID configuration (Slot0)\n        Slot0Configs slot0Configs = config.Slot0;\n        slot0Configs.kP = POSITION_KP;\n        slot0Configs.kI = POSITION_KI;\n        slot0Configs.kD = POSITION_KD;\n        slot0Configs.kV = 0.0;\n        slot0Configs.kS = 0.0;\n        slot0Configs.kA = 0.0;\n        \n        // Motion Magic Expo configuration\n        MotionMagicConfigs motionMagicConfigs = config.MotionMagic;\n        motionMagicConfigs.MotionMagicCruiseVelocity = 0;\n        motionMagicConfigs.MotionMagicExpo_kV = 0.12;\n        motionMagicConfigs.MotionMagicExpo_kA = 0.1;\n        \n        m_elevatorMotor.getConfigurator().apply(config);\n        m_elevatorMotor.setPosition(0.0);\n    }\n    \n    public void setHeightWithProfile(double height) {\n        m_elevatorMotor.setControl(m_expoRequest.withPosition(height));\n    }\n    \n    public double getHeight() {\n        return m_elevatorMotor.getPosition().getValueAsDouble();\n    }\n    \n    @Override\n    public void periodic() {\n        SmartDashboard.putNumber(\"Elevator Height\", getHeight());\n    }\n}"
                }
            ]
        },
        {
            "type": "rules-box",
            "title": "Key Takeaways",
            "subtitle": "What you've learned about motion profiling:",
            "items": [
                "Motion profiles plan smooth motion paths that respect physical constraints",
                "Trapezoidal profiles provide fast, predictable motion with distinct phases",
                "Exponential profiles provide smooth, natural motion with continuous acceleration",
                "Profile constraints must match your mechanism's capabilities",
                "Tune constraints through testing - start conservative, increase gradually",
                "Motion profiling eliminates jerky motion, overshoot, and inconsistent timing"
            ]
        },
        {
            "type": "link-grid",
            "title": "Related Topics and Documentation",
            "links": [
                {
                    "label": "Motor Controller PID Control",
                    "id": "motor-pid-control"
                },
                {
                    "label": "PID Control for Elevators",
                    "id": "pid-control"
                },
                {
                    "label": "WPILib Advanced Controls",
                    "url": "https://docs.wpilib.org/en/stable/docs/software/advanced-controls/index.html"
                },
                {
                    "label": "CTRE Motion Magic Documentation",
                    "url": "https://v6.docs.ctr-electronics.com/en/latest/docs/api-reference/device-specific/talonfx/motion-magic.html"
                },
                {
                    "label": "REV MAXMotion Documentation",
                    "url": "https://docs.revrobotics.com/revlib/spark/closed-loop/maxmotion-position-control"
                }
            ]
        }
    ]
}