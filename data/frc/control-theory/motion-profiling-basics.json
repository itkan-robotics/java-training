{
  "title": "Motion Profiling Basics",
  "sections": [
    {
      "type": "text",
      "title": "Introduction to Motion Profiling",
      "content": "Motion profiling is a technique for generating smooth, predictable motion paths for robot mechanisms. Instead of instantly changing from one state to another (which causes jerky motion and overshoot), motion profiles generate a series of intermediate states that create smooth acceleration, constant velocity, and smooth deceleration.<br><br>Motion profiling is essential for mechanisms that need to move quickly and accurately, such as arms moving to scoring positions, elevators moving between levels, or drivetrains following autonomous paths. By controlling how the mechanism accelerates and decelerates, motion profiles enable faster, smoother, and more accurate movement.<br><br>Learn more: <a href='https://docs.wpilib.org/en/stable/docs/software/advanced-controls/trajectories/index.html' target='_blank'>WPILib: Trajectories and Motion Profiling</a>"
    },
    {
      "type": "text",
      "title": "The Problem Without Profiling",
      "content": "Without motion profiling, mechanisms exhibit several problems:<br><br><strong>Jerky Motion:</strong> Instantly applying full power causes sudden acceleration, creating jerky, uncomfortable motion. The mechanism lurches to life and slams to a stop.<br><br><strong>Overshoot:</strong> Without controlled deceleration, mechanisms overshoot their targets. An arm moving to 45° might overshoot to 50° before settling back, wasting time and energy.<br><br><strong>Inconsistent Timing:</strong> Without a planned motion path, the time to reach a target varies based on starting conditions, load, and other factors. This makes autonomous routines unreliable.<br><br><strong>Mechanical Stress:</strong> Sudden starts and stops stress mechanical components, leading to wear, breakage, and reduced robot lifespan.<br><br><strong>Solution:</strong> Motion profiles generate smooth acceleration and deceleration curves, eliminating these problems and enabling fast, accurate, repeatable motion."
    },
    {
      "type": "text",
      "title": "Types of Motion Profiles",
      "content": "Several types of motion profiles are used in FRC:<br><br><strong>Trapezoidal Profiles:</strong> Constant acceleration to maximum velocity, constant velocity cruise phase, then constant deceleration to stop. Simple and effective, widely used in FRC. Creates a trapezoid shape on a velocity-time graph.<br><br><strong>S-Curve Profiles:</strong> Smooth acceleration with gradually increasing then decreasing acceleration (jerk-limited). Creates smoother motion than trapezoidal but more complex. Creates an S-curve shape on a velocity-time graph.<br><br><strong>Exponential Profiles:</strong> Natural exponential acceleration and deceleration. Simple to implement, creates smooth motion. Good for input smoothing and simple mechanisms. Creates exponential curves.<br><br><strong>Custom Profiles:</strong> Profiles tailored to specific mechanisms or constraints. Can optimize for specific requirements but require more development effort."
    },
    {
      "type": "text",
      "title": "Profile Generation",
      "content": "Motion profiles are generated based on constraints and desired motion:<br><br><strong>Constraints:</strong> Maximum velocity (how fast the mechanism can move) and maximum acceleration (how quickly it can change speed). These are determined by your mechanism's capabilities and safety requirements.<br><br><strong>Start and End States:</strong> The profile needs to know where you're starting (position and velocity) and where you want to end (position and velocity). Typically, you start and end at zero velocity (stopped).<br><br><strong>State Calculation:</strong> The profile calculates position, velocity, and acceleration at any point in time. You can query the profile to get the desired state at the current time.<br><br><strong>Time-Based:</strong> Profiles are time-based - they generate states for specific times. You follow the profile by querying it at the current time and applying the resulting state to your mechanism."
    },
    {
      "type": "text",
      "title": "Profile Following",
      "content": "Following a motion profile involves using the profile's generated states to control your mechanism:<br><br><strong>Query Profile:</strong> At each time step (typically every 20ms), query the profile for the desired position and velocity at the current time.<br><br><strong>Closed-Loop Control:</strong> Use PID control to move your mechanism to the profile's desired position and velocity. The profile provides the setpoint, and PID ensures the mechanism follows it.<br><br><strong>Time Tracking:</strong> Track elapsed time since the profile started. Use this time to query the profile for the current desired state.<br><br><strong>Completion:</strong> When the profile time exceeds the total profile duration, the mechanism should be at the target. Check if the mechanism has reached the target position."
    },
    {
      "type": "text",
      "title": "Motion Profile Components",
      "content": "Motion profiles consist of several key components:<br><br><strong>Start State:</strong> Initial position and velocity. Typically position is current sensor reading, velocity is zero (starting from rest).<br><br><strong>End State:</strong> Target position and velocity. Typically position is the desired target, velocity is zero (stopping at target).<br><br><strong>Constraints:</strong> Maximum velocity (cruise velocity) and maximum acceleration. These limit how fast the mechanism can move and how quickly it can change speed.<br><br><strong>Time-Based States:</strong> The profile generates position, velocity, and acceleration values for any time. These states form the motion path the mechanism should follow.<br><br><strong>Duration:</strong> The total time required to complete the profile, calculated based on distance, constraints, and start/end states."
    },
    {
      "type": "code",
      "title": "Basic Motion Profile Concept",
      "content": "package frc.robot.examples;\n\npublic class MotionProfileConcept {\n    // Profile constraints\n    private static final double MAX_VELOCITY = 100.0;  // units per second\n    private static final double MAX_ACCELERATION = 50.0;  // units per second squared\n    \n    // Profile states\n    private double m_startPosition = 0.0;\n    private double m_endPosition = 0.0;\n    private double m_currentTime = 0.0;\n    \n    public void generateProfile(double startPos, double endPos) {\n        m_startPosition = startPos;\n        m_endPosition = endPos;\n        m_currentTime = 0.0;\n    }\n    \n    /**\n     * Get desired state at current time\n     * @return Desired position at current time\n     */\n    public double getDesiredPosition(double currentTime) {\n        double distance = m_endPosition - m_startPosition;\n        double totalTime = calculateProfileTime(distance);\n        \n        if (currentTime >= totalTime) {\n            // Profile complete, return end position\n            return m_endPosition;\n        }\n        \n        // Simplified: linear motion (real profiles are more complex)\n        // Real profiles have acceleration, cruise, and deceleration phases\n        double progress = currentTime / totalTime;\n        return m_startPosition + (distance * progress);\n    }\n    \n    private double calculateProfileTime(double distance) {\n        // Simplified calculation\n        // Real profiles calculate time based on acceleration and velocity constraints\n        return Math.abs(distance) / MAX_VELOCITY;\n    }\n    \n    public void update(double deltaTime) {\n        m_currentTime += deltaTime;\n    }\n}"
    },
    {
      "type": "code",
      "title": "Profile Following with PIDController",
      "content": "package frc.robot.subsystems;\n\nimport edu.wpi.first.math.controller.PIDController;\nimport edu.wpi.first.wpilibj.Encoder;\nimport edu.wpi.first.wpilibj.motorcontrol.PWMSparkMax;\nimport edu.wpi.first.wpilibj2.command.SubsystemBase;\n\npublic class ProfiledArm extends SubsystemBase {\n    private final PWMSparkMax m_armMotor = new PWMSparkMax(0);\n    private final Encoder m_encoder = new Encoder(0, 1);\n    private final PIDController m_pidController = new PIDController(0.1, 0.0, 0.01);\n    \n    // Profile tracking\n    private boolean m_profileActive = false;\n    private double m_profileStartTime = 0.0;\n    private double m_targetPosition = 0.0;\n    \n    // Profile would be created using TrapezoidProfile (covered in next lesson)\n    // For now, this shows the concept\n    \n    public void startProfile(double targetPosition, double startTime) {\n        m_targetPosition = targetPosition;\n        m_profileStartTime = startTime;\n        m_profileActive = true;\n    }\n    \n    @Override\n    public void periodic() {\n        if (m_profileActive) {\n            double currentTime = System.currentTimeMillis() / 1000.0;  // Convert to seconds\n            double elapsedTime = currentTime - m_profileStartTime;\n            \n            // Query profile for desired position at current time\n            // (In real implementation, use TrapezoidProfile.calculate())\n            double desiredPosition = calculateDesiredPosition(elapsedTime);\n            \n            double currentPosition = m_encoder.getDistance();\n            \n            double output = m_pidController.calculate(currentPosition, desiredPosition);\n            \n            m_armMotor.set(output);\n            \n            // Check if profile complete\n            if (elapsedTime >= getProfileDuration()) {\n                m_profileActive = false;\n            }\n        }\n    }\n    \n    private double calculateDesiredPosition(double time) {\n        // Simplified - real implementation uses TrapezoidProfile\n        // This would calculate position based on acceleration, cruise, deceleration phases\n        return m_targetPosition;  // Placeholder\n    }\n    \n    private double getProfileDuration() {\n        return 2.0;  // Placeholder\n    }\n}"
    },
    {
      "type": "text",
      "title": "Applying Profiles to Mechanisms",
      "content": "Motion profiles can be applied to various FRC mechanisms:<br><br><strong>Arm Movement:</strong> Move arm smoothly from current angle to target angle. Profile controls acceleration and deceleration, preventing overshoot and reducing mechanical stress.<br><br><strong>Elevator:</strong> Move elevator smoothly between levels. Profile ensures smooth acceleration and controlled deceleration at target height.<br><br><strong>Drivetrain:</strong> Follow autonomous paths smoothly. Profiles generate velocity and acceleration commands for smooth driving and turning.<br><br><strong>Turret:</strong> Rotate turret smoothly to target angle. Profile prevents sudden starts/stops that could affect aim.<br><br><strong>Any Mechanism:</strong> Any mechanism that needs to move from one position to another can benefit from motion profiling for smoother, faster, more accurate motion."
    },
    {
      "type": "link-grid",
      "title": "Related Topics and Documentation",
      "links": [
        {
          "label": "Trapezoidal Profiles",
          "id": "trapezoidal-profiles"
        },
        {
          "label": "Exponential Profiles",
          "id": "exponential-profiles"
        },
        {
          "label": "PID Control Introduction",
          "id": "pid-control-intro"
        }
      ]
    }
  ]
}