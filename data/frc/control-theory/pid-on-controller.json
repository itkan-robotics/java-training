{
  "title": "PID On Motor Controllers",
  "sections": [
    {
      "type": "text",
      "title": "Introduction to On-Controller PID",
      "content": "On-controller PID refers to PID control that runs directly on the motor controller hardware (SPARK MAX or Talon FX) rather than in robot code. The PID algorithm executes on the motor controller's processor, providing extremely fast response times (typically 1ms update rate) and offloading computation from the roboRIO.<br><br>On-controller PID is ideal for mechanisms that require high-performance control, such as flywheels maintaining precise RPM, arms moving to exact positions, or elevators holding specific heights. The fast update rate and dedicated processing make it superior to in-code PID for many applications.<br><br>For vendor-specific implementation details, refer to the <a href='#motor-pid-control' target='_blank'>Motor PID Control</a> lesson in the hardware vendors section."
    },
    {
      "type": "text",
      "title": "How On-Controller PID Works",
      "content": "On-controller PID operates differently from in-code PID:<br><br><strong>Control Loop on Device:</strong> The motor controller reads its connected sensor (encoder, CANcoder, etc.) directly, calculates the PID output, and applies it to the motor - all without communication with the roboRIO. This creates a tight control loop with minimal delay.<br><br><strong>Update Rates:</strong> Motor controllers typically update PID at 1ms intervals, compared to 20ms (50Hz) for roboRIO-based control. This 20x faster response enables better control of fast-moving mechanisms.<br><br><strong>Sensor Feedback:</strong> The motor controller reads sensor values directly via CAN bus or direct connections. For SPARK MAX, this is typically the built-in encoder. For Talon FX, this can be the integrated encoder or external sensors like CANcoder.<br><br><strong>Setpoint Communication:</strong> Your robot code sends setpoints (target position or velocity) to the motor controller, and the controller handles all PID calculations internally."
    },
    {
      "type": "text",
      "title": "Motor Controller PID Features",
      "content": "Both SPARK MAX and Talon FX support advanced PID features:<br><br><strong>Multiple PID Slots/Configurations:</strong> You can configure multiple PID parameter sets (slots) for different control scenarios. For example, Slot 0 for position control and Slot 1 for velocity control, each with optimized parameters.<br><br><strong>Position and Velocity Control Modes:</strong> Motor controllers support both position control (move to specific encoder count) and velocity control (maintain specific speed). Each mode can use different PID parameters.<br><br><strong>Feedforward Support:</strong> Both controllers support feedforward terms (kV, kS, kA) that can be combined with PID for improved performance. Feedforward predicts the needed output, reducing error before it occurs.<br><br><strong>Ramp Rates:</strong> You can configure acceleration and deceleration ramps to smooth motion profiles, preventing sudden changes in motor output.<br><br><strong>Output Limits:</strong> Set maximum and minimum output values to prevent excessive motor power and protect mechanisms."
    },
    {
      "type": "text",
      "title": "Configuring PID on Motor Controllers",
      "content": "PID configuration can be done in two ways:<br><br><strong>Vendor Tools (Graphical):</strong> REV Hardware Client (for SPARK MAX) and Phoenix Tuner (for Talon FX) provide visual interfaces for configuring PID parameters. This is excellent for initial setup and testing, as you can see real-time feedback and adjust values interactively.<br><br><strong>Code-Based Configuration:</strong> Configure PID parameters in your robot code using vendor-specific APIs. This ensures consistent configuration across deployments and allows version control of your settings. Recommended for production code.<br><br><strong>Best Practice:</strong> Use vendor tools for initial tuning and testing, but configure everything in code for your final robot program. This documents your configuration and ensures consistency."
    },
    {
      "type": "text",
      "title": "PID Slots and Multiple Configurations",
      "content": "Motor controllers support multiple PID configurations (slots) to optimize performance for different control types:<br><br><strong>SPARK MAX:</strong> Supports multiple PID slots (typically 0-3). Each slot has independent kP, kI, kD, and kFF values. When setting a setpoint, you specify which slot to use.<br><br><strong>Talon FX:</strong> Supports multiple slots (Slot0, Slot1, etc.) configured in the TalonFXConfiguration object. Control requests (PositionVoltage, VelocityVoltage) specify which slot to use.<br><br><strong>Common Usage:</strong> Use Slot 0 for position control (optimized for accuracy and stability) and Slot 1 for velocity control (optimized for speed maintenance). This allows you to tune each control type independently for optimal performance.<br><br><strong>Switching Slots:</strong> You can switch between slots at runtime based on the control mode needed. For example, use position control slot when moving to a target, then switch to velocity control slot when maintaining speed."
    },
    {
      "type": "text",
      "title": "Position Control with On-Controller PID",
      "content": "Position control uses on-controller PID to move a mechanism to a specific encoder position and hold it there:<br><br><strong>Setting Position Setpoints:</strong> Your code sends a target position (in encoder units) to the motor controller. The controller calculates the error and adjusts motor output to reach the target.<br><br><strong>Encoder Feedback:</strong> The motor controller continuously reads the encoder position and compares it to the setpoint. It automatically adjusts output to minimize error.<br><br><strong>Holding Position:</strong> Once at the target position, the PID controller maintains that position, automatically compensating for disturbances (gravity, load changes, etc.).<br><br><strong>Use Cases:</strong> Arms moving to specific angles, elevators moving to specific heights, turrets rotating to specific positions. Any mechanism requiring precise positioning benefits from on-controller position control."
    },
    {
      "type": "text",
      "title": "Velocity Control with On-Controller PID",
      "content": "Velocity control uses on-controller PID to maintain a specific motor speed:<br><br><strong>Setting Velocity Setpoints:</strong> Your code sends a target velocity (in RPM or encoder units per second) to the motor controller. The controller adjusts output to maintain that speed.<br><br><strong>Velocity Feedback:</strong> The motor controller reads encoder velocity and compares it to the setpoint. It continuously adjusts output to maintain the target speed.<br><br><strong>Load Compensation:</strong> When load changes (e.g., battery voltage drops, mechanism encounters resistance), the PID controller automatically increases output to maintain speed.<br><br><strong>Use Cases:</strong> Flywheels maintaining consistent RPM for shooting, intakes maintaining constant speed, drivetrain maintaining target velocity. Any mechanism requiring consistent speed benefits from on-controller velocity control."
    },
    {
      "type": "text",
      "title": "On-Controller vs In-Code PID",
      "content": "Understanding when to use each approach helps you choose the best solution:<br><br><strong>Use On-Controller PID When:</strong> You need fast response (flywheels, high-speed mechanisms), you want to offload roboRIO processing, you're using position or velocity control, you need consistent timing, or you're using motor controller features (feedforward, ramps).<br><br><strong>Use In-Code PID When:</strong> You need custom control logic, you're controlling multiple mechanisms together, you need complex calculations, you're using non-standard sensors, or you need flexibility in control algorithms.<br><br><strong>Hybrid Approach:</strong> You can use both! Use on-controller PID for individual motor control, and in-code PID for higher-level coordination or complex control strategies."
    },
    {
      "type": "link-grid",
      "title": "Related Topics and Documentation",
      "links": [
        {
		  "label": "PID Control Introduction", 
		  "id": "pid-control-intro"},
        {
		  "label": "PID Tuning", 
		  "id": "pid-tuning"},
        {
		  "label": "Motor PID Control", 
		  "id": "motor-pid-control"}
      ]
    }
  ]
}

