{
    "title": "Command-Based Programming",
    "sections": [
        {
            "type": "text",
            "title": "Introduction to Command-Based Programming",
            "content": "Imagine you're building an intake subsystem for your FRC robot. You need it to spin motors forward to collect game pieces, reverse to eject them, and stop on command. In traditional robot code, this logic might be scattered throughout your codebase, making it hard to maintain and reuse.<br><br>Command-based programming solves this by organizing your robot into <strong>subsystems</strong> (hardware abstractions) and <strong>commands</strong> (discrete actions). Your intake becomes a subsystem with simple methods like <code>run()</code> and <code>stop()</code>, and commands like <code>IntakeGamePiece</code> use those methods to accomplish tasks. This architecture makes your code modular, testable, and easier to understand.<br><br>Throughout this lesson, we'll build a complete intake subsystem using command-based programming. By the end, you'll understand how all the pieces fit together and be ready to apply these patterns to any robot mechanism.<br><br>Learn more: <a href='https://docs.wpilib.org/en/stable/docs/software/commandbased/what-is-command-based.html' target='_blank'>WPILib: What is Command-Based Programming?</a>"
        },
        {
            "type": "text",
            "title": "The Four Pillars of Command-Based Programming",
            "content": "Command-based programming consists of four main components working in harmony:<br><br><strong>Subsystems:</strong> These encapsulate your hardware and provide a clean interface. Think of a subsystem as a remote control for a mechanism—commands press buttons (call methods) without knowing how the mechanism works internally. Our intake subsystem will provide methods like <code>run()</code> and <code>stop()</code> that hide all the motor controller complexity.<br><br><strong>Commands:</strong> These are discrete actions your robot can perform. A command uses subsystems to accomplish a task. For example, <code>IntakeGamePiece</code> might run the intake motor until a sensor detects a game piece, then stop. Commands are reusable building blocks that you can combine into complex behaviors.<br><br><strong>Command Scheduler:</strong> This is the execution manager running in the background. Every 20ms, it calls your commands' lifecycle methods, manages which commands are running, and ensures subsystems aren't being controlled by conflicting commands. You rarely interact with it directly, but it's always working.<br><br><strong>Robot Container:</strong> This is your robot's central configuration hub. It creates all your subsystems, sets up default behaviors, and connects user input (buttons, joysticks) to commands. Think of it as your robot's control panel where everything gets wired together."
        },
        {
            "type": "text",
            "title": "Creating an Intake Subsystem",
            "content": "Let's start by creating the intake subsystem. A subsystem is a class that extends <code>SubsystemBase</code> and encapsulates your hardware. The key principle is <strong>encapsulation</strong>—the subsystem hides hardware details from commands.<br><br>For our intake, we need a motor controller. We'll create methods that commands can use: <code>run(double speed)</code> to spin the intake at a given speed, and <code>stop()</code> to stop it. Commands won't need to know about CAN IDs, motor types, or any hardware configuration—that's all handled inside the subsystem.<br><br>Here's what we'll do:<br>1. Create a class extending <code>SubsystemBase</code><br>2. Initialize the motor controller in the constructor<br>3. Provide simple, clear methods for commands to use<br>4. Optionally use <code>periodic()</code> for continuous updates (like reading sensors)<br><br>This pattern works for any mechanism—drivetrain, arm, elevator, shooter—once you understand subsystems, you can apply the same principles everywhere."
        },
        {
            "type": "code-tabs",
            "title": "Basic Intake Subsystem Structure",
            "content": "Here's a minimal intake subsystem. Notice how it encapsulates the motor and provides simple methods:",
            "tabs": [
                {
                    "label": "SPARK MAX",
                    "code": "package frc.robot.subsystems;\n\nimport com.revrobotics.spark.SparkMax;\nimport com.revrobotics.spark.SparkBase.PersistMode;\nimport com.revrobotics.spark.SparkBase.ResetMode;\nimport com.revrobotics.spark.config.SparkMaxConfig;\nimport com.revrobotics.spark.config.SparkBaseConfig.IdleMode;\nimport com.revrobotics.spark.SparkLowLevel.MotorType;\nimport edu.wpi.first.wpilibj2.command.SubsystemBase;\n\npublic class Intake extends SubsystemBase {\n    private final SparkMax m_motor = new SparkMax(5, MotorType.kBrushless);\n    \n    public Intake() {\n        // Configure motor for intake use\n        SparkMaxConfig config = new SparkMaxConfig();\n        config\n            .idleMode(IdleMode.kCoast)\n            .smartCurrentLimit(30);\n        \n        // Persist parameters during initial setup\n        m_motor.configure(config, \n            ResetMode.kResetSafeParameters, \n            PersistMode.kPersistParameters);\n    }\n    \n    public void run(double speed) {\n        m_motor.set(speed);\n    }\n    \n    public void stop() {\n        m_motor.set(0);\n    }\n    \n    @Override\n    public void periodic() {\n        // Runs every 20ms - use for sensor reading, state updates, etc.\n    }\n}"
                },
                {
                    "label": "Talon FX",
                    "code": "package frc.robot.subsystems;\n\nimport com.ctre.phoenix6.hardware.TalonFX;\nimport com.ctre.phoenix6.configs.TalonFXConfiguration;\nimport com.ctre.phoenix6.signals.NeutralModeValue;\nimport com.ctre.phoenix6.controls.DutyCycleOut;\nimport edu.wpi.first.wpilibj2.command.SubsystemBase;\n\npublic class Intake extends SubsystemBase {\n    private final TalonFX m_motor = new TalonFX(5);\n    private final DutyCycleOut m_dutyCycleRequest = new DutyCycleOut(0);\n    \n    public Intake() {\n        // Configure motor for intake use\n        TalonFXConfiguration config = new TalonFXConfiguration();\n        config.MotorOutput.NeutralMode = NeutralModeValue.Coast;\n        config.CurrentLimits.StatorCurrentLimitEnable = true;\n        config.CurrentLimits.StatorCurrentLimit = 30.0;\n        m_motor.getConfigurator().apply(config);\n    }\n    \n    public void run(double speed) {\n        m_motor.setControl(m_dutyCycleRequest.withOutput(speed));\n    }\n    \n    public void stop() {\n        m_motor.setControl(m_dutyCycleRequest.withOutput(0));\n    }\n    \n    @Override\n    public void periodic() {\n        // Runs every 20ms - use for sensor reading, state updates, etc.\n    }\n}"
                }
            ]
        },
        {
            "type": "text",
            "title": "Understanding Command Lifecycle",
            "content": "Before we create commands for our intake, let's understand the command lifecycle. Every command has four lifecycle methods that the scheduler calls automatically:<br><br><strong>initialize():</strong> Called once when the command is scheduled. This is your setup phase—reset sensors, prepare state, or log that the command started. For an intake command, you might start the motor here.<br><br><strong>execute():</strong> Called repeatedly every 20ms while the command is active. This is where the magic happens—your command's main logic runs here. The intake command might check sensors or continue running the motor.<br><br><strong>isFinished():</strong> Called after each <code>execute()</code> to check if the command should end. Return <code>true</code> when the task is complete (like when a sensor detects a game piece), or <code>false</code> to keep running. Commands that run until interrupted (like manual control) should always return <code>false</code>.<br><br><strong>end(boolean interrupted):</strong> Called once when the command ends, either because it finished normally or because it was interrupted. The <code>interrupted</code> parameter tells you which happened. Use this to clean up—stop motors, reset state, or log completion. Always stop motors here to ensure safe behavior."
        },
        {
            "type": "text",
            "title": "Creating Commands",
            "content": "Now let's create a command for running the intake. Commands extend the <code>Command</code> class and implement the four lifecycle methods we just discussed. The key concept is <strong>requirements</strong>—commands must declare which subsystems they need using <code>addRequirements()</code>.<br><br>When a command requires a subsystem, it gets exclusive access to it. If another command tries to use the same subsystem, the scheduler automatically interrupts the first command. This prevents conflicts—you can't have two commands trying to control the intake at the same time.<br><br>For our intake command, we'll create <code>RunIntakeCommand</code> that runs the intake at a specified speed. It will run continuously until interrupted (when the operator releases a button, for example). This pattern is perfect for operator-controlled mechanisms."
        },
        {
            "type": "code",
            "title": "RunIntakeCommand Example",
            "content": "This command runs the intake at a specified speed until interrupted. Since commands use the subsystem interface, the code is the same regardless of motor controller:\n\npackage frc.robot.commands;\n\nimport edu.wpi.first.wpilibj2.command.Command;\nimport frc.robot.subsystems.Intake;\n\npublic class RunIntakeCommand extends Command {\n    private final Intake m_intake;\n    private final double m_speed;\n    \n    public RunIntakeCommand(Intake intake, double speed) {\n        m_intake = intake;\n        m_speed = speed;\n        \n        // Declare subsystem requirement\n        addRequirements(intake);\n    }\n    \n    @Override\n    public void initialize() {\n        // Start the intake motor\n        m_intake.run(m_speed);\n    }\n    \n    @Override\n    public void execute() {\n        // Keep running at the set speed\n        m_intake.run(m_speed);\n    }\n    \n    @Override\n    public boolean isFinished() {\n        // Run until interrupted\n        return false;\n    }\n    \n    @Override\n    public void end(boolean interrupted) {\n        // Always stop the motor when command ends\n        m_intake.stop();\n    }\n}"
        },
        {
            "type": "text",
            "title": "Inline Commands: Quick and Simple",
            "content": "Sometimes you don't need a full command class for simple actions. WPILib provides inline command factories that let you create commands using lambda expressions directly in your code. This is perfect for simple commands that don't need their own class.<br><br>Inline commands use the <code>Commands</code> utility class, which provides factory methods for common command patterns. The most useful for simple subsystems are:<br><br><strong>Commands.runOnce():</strong> Executes an action once and finishes immediately. Perfect for one-time actions like resetting encoders or activating solenoids.<br><br><strong>Commands.run():</strong> Continuously executes an action until interrupted. Perfect for operator-controlled mechanisms like running an intake while a button is held.<br><br><strong>Commands.startEnd():</strong> Executes one action when the command starts and another when it ends. Perfect for starting motors and stopping them when done.<br><br>Inline commands are especially useful for simple operations where creating a full command class would be overkill. They keep your code concise and readable."
        },
        {
            "type": "code-tabs",
            "title": "Inline Command Examples",
            "content": "Here are inline command examples for your intake. These commands work the same way regardless of motor controller since they use the subsystem interface:",
            "tabs": [
                {
                    "label": "SPARK MAX",
                    "code": "import edu.wpi.first.wpilibj2.command.Commands;\nimport frc.robot.subsystems.Intake;\n\n// Run intake continuously until interrupted\nCommand runIntakeCommand = Commands.run(\n    () -> m_intake.run(0.6),\n    m_intake\n);\n\n// Stop intake once (instant command)\nCommand stopIntakeCommand = Commands.runOnce(\n    () -> m_intake.stop(),\n    m_intake\n);\n\n// Start running, stop when command ends\nCommand startEndCommand = Commands.startEnd(\n    () -> m_intake.run(0.6),  // Start action\n    () -> m_intake.stop(),     // End action\n    m_intake\n);"
                },
                {
                    "label": "Talon FX",
                    "code": "import edu.wpi.first.wpilibj2.command.Commands;\nimport frc.robot.subsystems.Intake;\n\n// Run intake continuously until interrupted\nCommand runIntakeCommand = Commands.run(\n    () -> m_intake.run(0.6),\n    m_intake\n);\n\n// Stop intake once (instant command)\nCommand stopIntakeCommand = Commands.runOnce(\n    () -> m_intake.stop(),\n    m_intake\n);\n\n// Start running, stop when command ends\nCommand startEndCommand = Commands.startEnd(\n    () -> m_intake.run(0.6),  // Start action\n    () -> m_intake.stop(),     // End action\n    m_intake\n);"
                }
            ]
        },
        {
            "type": "text",
            "title": "Using Inline Commands in RobotContainer",
            "content": "Inline commands are particularly useful in RobotContainer for trigger bindings and default commands. Instead of creating separate command classes for simple actions, you can define them inline right where they're used. This keeps related code together and reduces the number of files in your project.<br><br>When using inline commands, you can create them directly in your trigger bindings or default command setup. They work exactly like regular commands—you can chain decorators like <code>withTimeout()</code>, use them in command groups, and they respect subsystem requirements just like any other command."
        },
        {
            "type": "code",
            "title": "RobotContainer with Inline Commands",
            "content": "Here's how to use inline commands in RobotContainer. This works the same way regardless of motor controller:\n\npackage frc.robot;\n\nimport edu.wpi.first.wpilibj2.command.Commands;\nimport edu.wpi.first.wpilibj2.command.button.CommandXboxController;\nimport frc.robot.subsystems.Intake;\n\npublic class RobotContainer {\n    private final Intake m_intake = new Intake();\n    private final CommandXboxController m_operatorController = new CommandXboxController(1);\n    \n    public RobotContainer() {\n        configureDefaultCommands();\n        configureButtonBindings();\n    }\n    \n    private void configureDefaultCommands() {\n        // Default: keep intake stopped using inline command\n        m_intake.setDefaultCommand(\n            Commands.run(() -> m_intake.stop(), m_intake)\n        );\n    }\n    \n    private void configureButtonBindings() {\n        // Run intake forward using inline command\n        m_operatorController.x()\n            .whileTrue(Commands.run(() -> m_intake.run(0.6), m_intake));\n        \n        // Run intake reverse using inline command\n        m_operatorController.y()\n            .whileTrue(Commands.run(() -> m_intake.run(-0.4), m_intake));\n    }\n    \n    public Intake getIntake() {\n        return m_intake;\n    }\n}"
        },
        {
            "type": "code-tabs",
            "title": "Complete Intake Subsystem and Command Code",
            "content": "Here's the complete code for both the subsystem and command:",
            "tabs": [
                {
                    "label": "SPARK MAX",
                    "code": "package frc.robot.subsystems;\n\nimport com.revrobotics.spark.SparkMax;\nimport com.revrobotics.spark.SparkBase.PersistMode;\nimport com.revrobotics.spark.SparkBase.ResetMode;\nimport com.revrobotics.spark.config.SparkMaxConfig;\nimport com.revrobotics.spark.config.SparkBaseConfig.IdleMode;\nimport com.revrobotics.spark.SparkLowLevel.MotorType;\nimport edu.wpi.first.wpilibj2.command.SubsystemBase;\n\npublic class Intake extends SubsystemBase {\n    private final SparkMax m_motor = new SparkMax(5, MotorType.kBrushless);\n    \n    public Intake() {\n        // Configure motor for intake use\n        SparkMaxConfig config = new SparkMaxConfig();\n        config\n            .idleMode(IdleMode.kCoast)\n            .smartCurrentLimit(30);\n        \n        // Persist parameters during initial setup\n        m_motor.configure(config, \n            ResetMode.kResetSafeParameters, \n            PersistMode.kPersistParameters);\n    }\n    \n    public void run(double speed) {\n        m_motor.set(speed);\n    }\n    \n    public void stop() {\n        m_motor.set(0);\n    }\n    \n    @Override\n    public void periodic() {\n        // Runs every 20ms - use for sensor reading, state updates, etc.\n    }\n}"
                },
                {
                    "label": "Talon FX",
                    "code": "package frc.robot.subsystems;\n\nimport com.ctre.phoenix6.hardware.TalonFX;\nimport com.ctre.phoenix6.configs.TalonFXConfiguration;\nimport com.ctre.phoenix6.signals.NeutralModeValue;\nimport com.ctre.phoenix6.controls.DutyCycleOut;\nimport edu.wpi.first.wpilibj2.command.SubsystemBase;\n\npublic class Intake extends SubsystemBase {\n    private final TalonFX m_motor = new TalonFX(5);\n    private final DutyCycleOut m_dutyCycleRequest = new DutyCycleOut(0);\n    \n    public Intake() {\n        // Configure motor for intake use\n        TalonFXConfiguration config = new TalonFXConfiguration();\n        config.MotorOutput.NeutralMode = NeutralModeValue.Coast;\n        config.CurrentLimits.StatorCurrentLimitEnable = true;\n        config.CurrentLimits.StatorCurrentLimit = 30.0;\n        m_motor.getConfigurator().apply(config);\n    }\n    \n    public void run(double speed) {\n        m_motor.setControl(m_dutyCycleRequest.withOutput(speed));\n    }\n    \n    public void stop() {\n        m_motor.setControl(m_dutyCycleRequest.withOutput(0));\n    }\n    \n    @Override\n    public void periodic() {\n        // Runs every 20ms - use for sensor reading, state updates, etc.\n    }\n}"
                },
                {
                    "label": "RunIntakeCommand",
                    "code": "package frc.robot.commands;\n\nimport edu.wpi.first.wpilibj2.command.Command;\nimport frc.robot.subsystems.Intake;\n\npublic class RunIntakeCommand extends Command {\n    private final Intake m_intake;\n    private final double m_speed;\n    \n    public RunIntakeCommand(Intake intake, double speed) {\n        m_intake = intake;\n        m_speed = speed;\n        addRequirements(intake);\n    }\n    \n    @Override\n    public void initialize() {\n        m_intake.run(m_speed);\n    }\n    \n    @Override\n    public void execute() {\n        m_intake.run(m_speed);\n    }\n    \n    @Override\n    public boolean isFinished() {\n        return false;\n    }\n    \n    @Override\n    public void end(boolean interrupted) {\n        m_intake.stop();\n    }\n}"
                }
            ]
        },
        {
            "type": "text",
            "title": "Default Commands: Continuous Behavior",
            "content": "Your intake needs to respond to operator input continuously during teleop. You could manually schedule commands every loop, but there's a better way: <strong>default commands</strong>. A default command runs automatically whenever its subsystem isn't being used by another command.<br><br>Think of default commands as background behaviors. When you press a button to run intake forward, that command interrupts the default command and takes control. When you release the button, the command ends and the default command automatically resumes.<br><br>For our intake, a good default command might stop the intake (safe default behavior). Or, if you want manual control, the default command could read joystick input and run the intake accordingly. The scheduler handles all the interruption and resumption automatically—you just set it up once."
        },
        {
            "type": "code",
            "title": "Setting a Default Command",
            "content": "package frc.robot;\n\nimport edu.wpi.first.wpilibj2.command.Command;\nimport frc.robot.commands.StopIntakeCommand;\nimport frc.robot.subsystems.Intake;\n\npublic class RobotContainer {\n    private final Intake m_intake = new Intake();\n    \n    public RobotContainer() {\n        configureDefaultCommands();\n    }\n    \n    private void configureDefaultCommands() {\n        // Default command: keep intake stopped when no other command is running\n        m_intake.setDefaultCommand(new StopIntakeCommand(m_intake));\n    }\n}"
        },
        {
            "type": "code-tabs",
            "title": "Complete Default Command Code",
            "content": "Here's the StopIntakeCommand and RobotContainer setup:",
            "tabs": [
                {
                    "label": "StopIntakeCommand",
                    "code": "package frc.robot.commands;\n\nimport edu.wpi.first.wpilibj2.command.Command;\nimport frc.robot.subsystems.Intake;\n\npublic class StopIntakeCommand extends Command {\n    private final Intake m_intake;\n    \n    public StopIntakeCommand(Intake intake) {\n        m_intake = intake;\n        addRequirements(intake);\n    }\n    \n    @Override\n    public void initialize() {\n        m_intake.stop();\n    }\n    \n    @Override\n    public void execute() {\n        m_intake.stop();\n    }\n    \n    @Override\n    public boolean isFinished() {\n        return false; // Run until interrupted\n    }\n    \n    @Override\n    public void end(boolean interrupted) {\n        // No cleanup needed\n    }\n}"
                },
                {
                    "label": "RobotContainer with Default Command",
                    "code": "package frc.robot;\n\nimport frc.robot.commands.StopIntakeCommand;\nimport frc.robot.subsystems.Intake;\n\npublic class RobotContainer {\n    private final Intake m_intake = new Intake();\n    \n    public RobotContainer() {\n        configureDefaultCommands();\n    }\n    \n    private void configureDefaultCommands() {\n        m_intake.setDefaultCommand(new StopIntakeCommand(m_intake));\n    }\n    \n    public Intake getIntake() {\n        return m_intake;\n    }\n}"
                }
            ]
        },
        {
            "type": "text",
            "title": "Command Groups for Complex Behaviors",
            "content": "Real robots don't just run single commands—they need to do multiple things in sequence or simultaneously. Command groups let you compose commands into complex behaviors. You can run commands one after another (sequential), at the same time (parallel), or with timing conditions.<br><br>Imagine your autonomous routine needs to: drive forward, run the intake to collect a game piece, then stop. You could schedule these manually, but a command group makes it clean and reusable. You create the group once, then schedule it just like any other command.<br><br>For our intake, we might create an autonomous command group that runs the intake while driving forward until a sensor detects a game piece, then stops both. Command groups are commands themselves, so they can be nested and combined in unlimited ways."
        },
        {
            "type": "text",
            "title": "Sequential Command Groups",
            "content": "Sequential groups execute commands one after another. Each command must finish before the next starts. This is perfect for autonomous routines where actions must happen in order. For example: run intake for 2 seconds, then stop and wait 0.5 seconds, then reverse intake briefly to eject any stuck pieces."
        },
        {
            "type": "code",
            "title": "Sequential Command Group Example",
            "content": "This sequential group runs the intake, waits, then reverses it. Command groups work the same way regardless of motor controller:\n\npackage frc.robot.commands.auto;\n\nimport edu.wpi.first.wpilibj2.command.SequentialCommandGroup;\nimport edu.wpi.first.wpilibj2.command.WaitCommand;\nimport frc.robot.commands.RunIntakeCommand;\nimport frc.robot.subsystems.Intake;\n\npublic class IntakeSequenceCommand extends SequentialCommandGroup {\n    public IntakeSequenceCommand(Intake intake) {\n        addCommands(\n            // Run intake forward for 2 seconds\n            new RunIntakeCommand(intake, 0.6).withTimeout(2.0),\n            \n            // Wait 0.5 seconds\n            new WaitCommand(0.5),\n            \n            // Reverse intake briefly\n            new RunIntakeCommand(intake, -0.3).withTimeout(0.5)\n        );\n    }\n}"
        },
        {
            "type": "text",
            "title": "Parallel Command Groups",
            "content": "Parallel groups execute multiple commands simultaneously. All commands start at once and run concurrently. The group finishes when all commands finish. This is perfect for doing multiple independent things at the same time—like running the intake while driving forward. Just remember: commands in a parallel group cannot require the same subsystem, since they run at the same time."
        },
        {
            "type": "code",
            "title": "Parallel Command Group Example",
            "content": "This parallel group runs the intake while driving (assuming you have a Drivetrain subsystem). Command groups work the same way regardless of motor controller:\n\npackage frc.robot.commands.auto;\n\nimport edu.wpi.first.wpilibj2.command.ParallelCommandGroup;\nimport frc.robot.commands.RunIntakeCommand;\nimport frc.robot.commands.DriveForwardCommand;\nimport frc.robot.subsystems.Intake;\nimport frc.robot.subsystems.Drivetrain;\n\npublic class DriveAndIntakeCommand extends ParallelCommandGroup {\n    public DriveAndIntakeCommand(Drivetrain drivetrain, Intake intake, double duration) {\n        addCommands(\n            // Drive forward for specified duration\n            new DriveForwardCommand(drivetrain, 0.5).withTimeout(duration),\n            \n            // Run intake at the same time\n            new RunIntakeCommand(intake, 0.6).withTimeout(duration)\n        );\n        // Both commands run simultaneously\n        // Group finishes when both finish\n    }\n}"
        },
        {
            "type": "text",
            "title": "Trigger Bindings: Connecting Input to Commands",
            "content": "Your operators need a way to control the intake. That's where triggers come in. Triggers connect user input (buttons, joysticks) to commands. When an operator presses a button, the trigger automatically schedules the associated command.<br><br>Triggers provide several binding methods:<br>- <code>onTrue()</code>: Schedule command when button is pressed<br>- <code>whileTrue()</code>: Run command while button is held, cancel when released<br>- <code>toggleOnTrue()</code>: Toggle command on/off with each button press<br><br>For our intake, <code>whileTrue()</code> is perfect—operator holds a button to run intake, releases to stop. The scheduler handles everything automatically, including interrupting the default command when the button is pressed."
        },
        {
            "type": "code",
            "title": "Setting Up Trigger Bindings",
            "content": "Here's how to bind buttons to intake commands in RobotContainer. The trigger binding code is the same regardless of motor controller:\n\npackage frc.robot;\n\nimport edu.wpi.first.wpilibj2.command.button.CommandXboxController;\nimport frc.robot.commands.RunIntakeCommand;\nimport frc.robot.subsystems.Intake;\n\npublic class RobotContainer {\n    private final Intake m_intake = new Intake();\n    private final CommandXboxController m_operatorController = new CommandXboxController(1);\n    \n    public RobotContainer() {\n        configureDefaultCommands();\n        configureButtonBindings();\n    }\n    \n    private void configureDefaultCommands() {\n        // Set up default commands\n    }\n    \n    private void configureButtonBindings() {\n        // Run intake forward while X button is held\n        m_operatorController.x()\n            .whileTrue(new RunIntakeCommand(m_intake, 0.6));\n        \n        // Run intake reverse while Y button is held\n        m_operatorController.y()\n            .whileTrue(new RunIntakeCommand(m_intake, -0.4));\n    }\n    \n    public Intake getIntake() {\n        return m_intake;\n    }\n}"
        },
        {
            "type": "text",
            "title": "RobotContainer: Configuration and Organization",
            "content": "RobotContainer is your robot's central configuration hub. It creates all subsystems, sets up default commands, configures trigger bindings, and organizes everything. Think of it as the control panel where all the wiring comes together.<br><br>The typical RobotContainer structure includes:<br>- Subsystem creation (stored as private fields)<br>- Controller setup (joysticks, gamepads)<br>- Default command configuration<br>- Trigger binding setup<br>- Getter methods for accessing subsystems<br><br>RobotContainer is created once in <code>robotInit()</code> and lives for the entire robot program. It's not a WPILib class—it's a pattern you implement yourself, following the structure shown here."
        },
        {
            "type": "code",
            "title": "Complete RobotContainer Example",
            "content": "\npackage frc.robot;\n\nimport edu.wpi.first.wpilibj2.command.button.CommandXboxController;\nimport frc.robot.commands.RunIntakeCommand;\nimport frc.robot.commands.StopIntakeCommand;\nimport frc.robot.subsystems.Intake;\n\npublic class RobotContainer {\n    // Subsystems\n    private final Intake m_intake = new Intake();\n    \n    // Controllers\n    private final CommandXboxController m_operatorController = new CommandXboxController(1);\n    \n    public RobotContainer() {\n        configureDefaultCommands();\n        configureButtonBindings();\n    }\n    \n    private void configureDefaultCommands() {\n        // Default: keep intake stopped\n        m_intake.setDefaultCommand(new StopIntakeCommand(m_intake));\n    }\n    \n    private void configureButtonBindings() {\n        // Run intake forward while X is held\n        m_operatorController.x()\n            .whileTrue(new RunIntakeCommand(m_intake, 0.6));\n        \n        // Run intake reverse while Y is held\n        m_operatorController.y()\n            .whileTrue(new RunIntakeCommand(m_intake, -0.4));\n    }\n    \n    public Intake getIntake() {\n        return m_intake;\n    }\n}"
        },
        {
            "type": "text",
            "title": "The Command Scheduler: Execution Management",
            "content": "The command scheduler runs in the background, managing all command execution. You rarely interact with it directly, but understanding how it works helps you write better commands.<br><br>Every 20ms, the scheduler:<br>1. Processes new command schedules<br>2. Checks for subsystem conflicts and interrupts commands if needed<br>3. Calls <code>initialize()</code> on newly scheduled commands<br>4. Calls <code>execute()</code> on all active commands<br>5. Checks <code>isFinished()</code> and ends commands that are done<br>6. Calls <code>end()</code> on finished commands<br>7. Runs default commands for subsystems not in use<br><br>The scheduler runs automatically when you call <code>CommandScheduler.getInstance().run()</code> in your Robot class's periodic methods. It handles all the complexity of managing command execution, so you can focus on writing commands and subsystems."
        },
        {
            "type": "code",
            "title": "Robot Class with Command Scheduler",
            "content": "package frc.robot;\n\nimport edu.wpi.first.wpilibj.TimedRobot;\nimport edu.wpi.first.wpilibj2.command.Command;\nimport edu.wpi.first.wpilibj2.command.CommandScheduler;\n\npublic class Robot extends TimedRobot {\n    private RobotContainer m_robotContainer;\n    private Command m_autonomousCommand;\n    \n    @Override\n    public void robotInit() {\n        m_robotContainer = new RobotContainer();\n    }\n    \n    @Override\n    public void robotPeriodic() {\n        // Run the scheduler every loop\n        CommandScheduler.getInstance().run();\n    }\n    \n    @Override\n    public void autonomousInit() {\n        // Get and schedule autonomous command\n        m_autonomousCommand = m_robotContainer.getAutonomousCommand();\n        if (m_autonomousCommand != null) {\n            m_autonomousCommand.schedule();\n        }\n    }\n    \n    @Override\n    public void teleopInit() {\n        // Cancel autonomous if still running\n        if (m_autonomousCommand != null) {\n            m_autonomousCommand.cancel();\n        }\n    }\n    \n    @Override\n    public void testPeriodic() {\n        CommandScheduler.getInstance().run();\n    }\n}"
        },
        {
            "type": "code-tabs",
            "title": "Complete Intake System Code",
            "content": "Here's the complete code for the entire intake system. Each file is shown separately—subsystems differ between vendors, but commands and RobotContainer are the same:",
            "tabs": [
                {
                    "label": "Intake (SPARK MAX)",
                    "code": "package frc.robot.subsystems;\n\nimport com.revrobotics.spark.SparkMax;\nimport com.revrobotics.spark.SparkBase.PersistMode;\nimport com.revrobotics.spark.SparkBase.ResetMode;\nimport com.revrobotics.spark.config.SparkMaxConfig;\nimport com.revrobotics.spark.config.SparkBaseConfig.IdleMode;\nimport com.revrobotics.spark.SparkLowLevel.MotorType;\nimport edu.wpi.first.wpilibj2.command.Command;\nimport edu.wpi.first.wpilibj2.command.Commands;\nimport edu.wpi.first.wpilibj2.command.SubsystemBase;\n\npublic class Intake extends SubsystemBase {\n    private final SparkMax m_motor = new SparkMax(5, MotorType.kBrushless);\n    \n    public Intake() {\n        // Configure motor for intake use\n        SparkMaxConfig config = new SparkMaxConfig();\n        config\n            .idleMode(IdleMode.kCoast)\n            .smartCurrentLimit(30);\n        \n        // Persist parameters during initial setup\n        m_motor.configure(config, \n            ResetMode.kResetSafeParameters, \n            PersistMode.kPersistParameters);\n    }\n    \n    public void run(double speed) {\n        m_motor.set(speed);\n    }\n    \n    public void stop() {\n        m_motor.set(0);\n    }\n    \n    // Inline command factories\n    public Command runCommand(double speed) {\n        return Commands.run(() -> run(speed), this);\n    }\n    \n    public Command stopCommand() {\n        return Commands.run(() -> stop(), this);\n    }\n    \n    @Override\n    public void periodic() {\n    }\n}"
                },
                {
                    "label": "Intake (Talon FX)",
                    "code": "package frc.robot.subsystems;\n\nimport com.ctre.phoenix6.hardware.TalonFX;\nimport com.ctre.phoenix6.configs.TalonFXConfiguration;\nimport com.ctre.phoenix6.signals.NeutralModeValue;\nimport com.ctre.phoenix6.controls.DutyCycleOut;\nimport edu.wpi.first.wpilibj2.command.Command;\nimport edu.wpi.first.wpilibj2.command.Commands;\nimport edu.wpi.first.wpilibj2.command.SubsystemBase;\n\npublic class Intake extends SubsystemBase {\n    private final TalonFX m_motor = new TalonFX(5);\n    private final DutyCycleOut m_dutyCycleRequest = new DutyCycleOut(0);\n    \n    public Intake() {\n        TalonFXConfiguration config = new TalonFXConfiguration();\n        config.MotorOutput.NeutralMode = NeutralModeValue.Coast;\n        config.CurrentLimits.StatorCurrentLimitEnable = true;\n        config.CurrentLimits.StatorCurrentLimit = 30.0;\n        m_motor.getConfigurator().apply(config);\n    }\n    \n    public void run(double speed) {\n        m_motor.setControl(m_dutyCycleRequest.withOutput(speed));\n    }\n    \n    public void stop() {\n        m_motor.setControl(m_dutyCycleRequest.withOutput(0));\n    }\n    \n    // Inline command factories\n    public Command runCommand(double speed) {\n        return Commands.run(() -> run(speed), this);\n    }\n    \n    public Command stopCommand() {\n        return Commands.run(() -> stop(), this);\n    }\n    \n    @Override\n    public void periodic() {\n    }\n}"
                },
                {
                    "label": "RunIntakeCommand",
                    "code": "package frc.robot.commands;\n\nimport edu.wpi.first.wpilibj2.command.Command;\nimport frc.robot.subsystems.Intake;\n\npublic class RunIntakeCommand extends Command {\n    private final Intake m_intake;\n    private final double m_speed;\n    \n    public RunIntakeCommand(Intake intake, double speed) {\n        m_intake = intake;\n        m_speed = speed;\n        addRequirements(intake);\n    }\n    \n    @Override\n    public void initialize() {\n        m_intake.run(m_speed);\n    }\n    \n    @Override\n    public void execute() {\n        m_intake.run(m_speed);\n    }\n    \n    @Override\n    public boolean isFinished() {\n        return false;\n    }\n    \n    @Override\n    public void end(boolean interrupted) {\n        m_intake.stop();\n    }\n}"
                },
                {
                    "label": "StopIntakeCommand",
                    "code": "package frc.robot.commands;\n\nimport edu.wpi.first.wpilibj2.command.Command;\nimport frc.robot.subsystems.Intake;\n\npublic class StopIntakeCommand extends Command {\n    private final Intake m_intake;\n    \n    public StopIntakeCommand(Intake intake) {\n        m_intake = intake;\n        addRequirements(intake);\n    }\n    \n    @Override\n    public void initialize() {\n        m_intake.stop();\n    }\n    \n    @Override\n    public void execute() {\n        m_intake.stop();\n    }\n    \n    @Override\n    public boolean isFinished() {\n        return false;\n    }\n    \n    @Override\n    public void end(boolean interrupted) {\n    }\n}"
                },
                {
                    "label": "RobotContainer",
                    "code": "package frc.robot;\n\nimport edu.wpi.first.wpilibj2.command.Commands;\nimport edu.wpi.first.wpilibj2.command.button.CommandXboxController;\nimport frc.robot.commands.RunIntakeCommand;\nimport frc.robot.commands.StopIntakeCommand;\nimport frc.robot.subsystems.Intake;\n\npublic class RobotContainer {\n    private final Intake m_intake = new Intake();\n    private final CommandXboxController m_operatorController = new CommandXboxController(1);\n    \n    public RobotContainer() {\n        configureDefaultCommands();\n        configureButtonBindings();\n    }\n    \n    private void configureDefaultCommands() {\n        // Using inline command for default\n        m_intake.setDefaultCommand(m_intake.stopCommand());\n    }\n    \n    private void configureButtonBindings() {\n        // Using inline commands for trigger bindings\n        m_operatorController.x()\n            .whileTrue(m_intake.runCommand(0.6));\n        \n        m_operatorController.y()\n            .whileTrue(m_intake.runCommand(-0.4));\n        \n        // Or use full command classes if preferred\n        // m_operatorController.a()\n        //     .whileTrue(new RunIntakeCommand(m_intake, 0.6));\n    }\n    \n    public Intake getIntake() {\n        return m_intake;\n    }\n}"
                }
            ]
        },
        {
            "type": "text",
            "title": "Next Steps",
            "content": "Congratulations! You've learned the fundamentals of command-based programming by building an intake subsystem. The same patterns apply to any mechanism:<br><br>- Create a subsystem that encapsulates hardware<br>- Write commands that use subsystem methods<br>- Set default commands for continuous behavior<br>- Bind triggers to schedule commands from input<br>- Organize everything in RobotContainer<br><br>Now you can apply these concepts to build more complex subsystems like drivetrains, arms, elevators, and shooters. Each mechanism follows the same pattern, just with different hardware and methods. As you build more subsystems and commands, you'll discover how powerful command groups become for creating sophisticated autonomous routines.<br><br>Remember: the scheduler handles all the complexity of execution management. Your job is to create well-designed subsystems and commands, and let the scheduler do the rest."
        },
        {
            "type": "link-grid",
            "title": "Related Topics and Documentation",
            "links": [
                {
                    "label": "WPILib Command-Based Documentation",
                    "url": "https://docs.wpilib.org/en/stable/docs/software/commandbased/index.html"
                },
                {
                    "label": "WPILib Commands",
                    "url": "https://docs.wpilib.org/en/stable/docs/software/commandbased/commands.html"
                },
                {
                    "label": "WPILib Subsystems",
                    "url": "https://docs.wpilib.org/en/stable/docs/software/commandbased/subsystems.html"
                },
                {
                    "label": "WPILib Command Groups",
                    "url": "https://docs.wpilib.org/en/stable/docs/software/commandbased/command-groups.html"
                },
                {
                    "label": "WPILib Trigger Bindings",
                    "url": "https://docs.wpilib.org/en/stable/docs/software/commandbased/binding-commands-to-triggers.html"
                }
            ]
        }
    ]
}