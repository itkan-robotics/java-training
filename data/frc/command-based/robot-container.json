{
  "title": "Robot Container",
  "sections": [
    {
      "type": "text",
      "title": "Introduction to RobotContainer",
      "content": "RobotContainer is a design pattern used in WPILib command-based programming to organize robot code. It serves as the central configuration point for subsystems, commands, trigger bindings, and default commands. The RobotContainer pattern provides a clean, organized structure for command-based robots.<br><br>RobotContainer is not a WPILib class - it's a pattern you implement yourself. It's a container class that holds all robot components and configures how they work together. This pattern makes robot code more maintainable and easier to understand."
    },
    {
      "type": "rules-box",
      "title": "RobotContainer Benefits",
      "subtitle": "Why use RobotContainer:",
      "items": [
        "Centralized configuration (all robot setup in one place)",
        "Clear code organization (subsystems, commands, bindings together)",
        "Easy to find and modify robot behavior",
        "Simplifies Robot class (Robot class becomes very simple)",
        "Better testability (can test RobotContainer independently)",
        "Consistent structure across projects",
        "Makes codebase more maintainable"
      ]
    },
    {
      "type": "text",
      "title": "RobotContainer Structure",
      "content": "RobotContainer typically contains several key components:<br><br><strong>Subsystem Creation:</strong> RobotContainer creates and stores all subsystem instances. These are typically stored as private final fields.<br><br><strong>Command Creation:</strong> RobotContainer can create command instances, either directly or through factory methods. Commands are often created on-demand rather than stored.<br><br><strong>Trigger Binding Configuration:</strong> RobotContainer has a <code>configureButtonBindings()</code> method that sets up all trigger bindings, connecting user input to commands.<br><br><strong>Default Command Setup:</strong> RobotContainer sets default commands for subsystems in the constructor, ensuring subsystems have safe default behavior."
    },
    {
      "type": "text",
      "title": "Creating RobotContainer",
      "content": "RobotContainer is a regular Java class that you create in your robot project. It follows a standard pattern:<br><br><strong>Constructor:</strong> The constructor creates subsystems, sets default commands, and calls <code>configureButtonBindings()</code>. This is where all robot initialization happens.<br><br><strong>Organization:</strong> Keep RobotContainer in the <code>frc.robot</code> package, typically as <code>RobotContainer.java</code>. It's the main configuration class for your robot.<br><br><strong>Access Methods:</strong> RobotContainer often provides getter methods for subsystems so the Robot class can access them for autonomous routines or other purposes."
    },
    {
      "type": "code",
      "title": "Basic RobotContainer Structure",
      "content": "package frc.robot;\n\nimport edu.wpi.first.wpilibj2.command.button.CommandXboxController;\nimport frc.robot.subsystems.Drivetrain;\n\npublic class RobotContainer {\n    // Subsystems\n    private final Drivetrain m_drivetrain = new Drivetrain();\n    \n    // Controllers\n    private final CommandXboxController m_driverController = new CommandXboxController(0);\n    \n    public RobotContainer() {\n        // Configure default commands\n        configureDefaultCommands();\n        \n        // Configure trigger bindings\n        configureButtonBindings();\n    }\n    \n    private void configureDefaultCommands() {\n        // Set default commands for subsystems\n    }\n    \n    private void configureButtonBindings() {\n        // Set up trigger bindings\n    }\n    \n    // Getter methods for subsystems (for Robot class)\n    public Drivetrain getDrivetrain() {\n        return m_drivetrain;\n    }\n}"
    },
    {
      "type": "text",
      "title": "Subsystem Organization",
      "content": "RobotContainer creates and stores all subsystem instances. These are the foundation of your robot's command-based architecture:<br><br><strong>Creating Subsystems:</strong> Create subsystem instances as private final fields in RobotContainer. Initialize them when RobotContainer is constructed.<br><br><strong>Storing Subsystems:</strong> Store subsystems as fields so they can be accessed by commands, trigger bindings, and default command setup. They're also available to the Robot class for autonomous routines.<br><br><strong>Getter Methods:</strong> Provide getter methods for subsystems that need to be accessed from outside RobotContainer (e.g., for autonomous command creation in Robot class)."
    },
    {
      "type": "code",
      "title": "RobotContainer with Subsystems",
      "content": "package frc.robot;\n\nimport frc.robot.subsystems.*;\n\npublic class RobotContainer {\n    // Create all subsystems\n    private final Drivetrain m_drivetrain = new Drivetrain();\n    private final Arm m_arm = new Arm();\n    private final Elevator m_elevator = new Elevator();\n    private final Intake m_intake = new Intake();\n    private final Shooter m_shooter = new Shooter();\n    \n    public RobotContainer() {\n        configureDefaultCommands();\n        configureButtonBindings();\n    }\n    \n    private void configureDefaultCommands() {\n        // Configure default commands using subsystems\n    }\n    \n    private void configureButtonBindings() {\n        // Configure bindings using subsystems\n    }\n    \n    // Getter methods for Robot class\n    public Drivetrain getDrivetrain() {\n        return m_drivetrain;\n    }\n    \n    public Arm getArm() {\n        return m_arm;\n    }\n    \n    public Elevator getElevator() {\n        return m_elevator;\n    }\n    \n    public Intake getIntake() {\n        return m_intake;\n    }\n    \n    public Shooter getShooter() {\n        return m_shooter;\n    }\n}"
    },
    {
      "type": "text",
      "title": "Command Factory Methods",
      "content": "RobotContainer can provide factory methods for creating commands. These methods encapsulate command creation logic and can parameterize commands:<br><br><strong>Factory Pattern:</strong> Create methods that return command instances. These methods can accept parameters to customize command behavior.<br><br><strong>Benefits:</strong> Factory methods centralize command creation, make it easy to create commands with consistent parameters, and can provide default values for common scenarios.<br><br><strong>Use Cases:</strong> Creating autonomous commands with specific parameters, creating commands for trigger bindings, or providing convenient methods for command creation."
    },
    {
      "type": "code",
      "title": "Command Factory Methods",
      "content": "package frc.robot;\n\nimport edu.wpi.first.wpilibj2.command.Command;\nimport frc.robot.commands.MoveArmCommand;\nimport frc.robot.subsystems.Arm;\n\npublic class RobotContainer {\n    private final Arm m_arm = new Arm();\n    \n    // Factory method for creating arm movement commands\n    public Command moveArmToLowPosition() {\n        return new MoveArmCommand(m_arm, 30.0, 0.3, 2.0);\n    }\n    \n    public Command moveArmToHighPosition() {\n        return new MoveArmCommand(m_arm, 60.0, 0.3, 2.0);\n    }\n    \n    public Command moveArmToAngle(double angle) {\n        // Parameterized factory method\n        return new MoveArmCommand(m_arm, angle, 0.3, 2.0);\n    }\n    \n    // Use factory methods in bindings\n    private void configureButtonBindings() {\n        m_operatorController.a()\n            .onTrue(moveArmToLowPosition());\n        \n        m_operatorController.b()\n            .onTrue(moveArmToHighPosition());\n    }\n}"
    },
    {
      "type": "text",
      "title": "Trigger Configuration",
      "content": "RobotContainer's <code>configureButtonBindings()</code> method sets up all trigger bindings, connecting user input to commands:<br><br><strong>Method Organization:</strong> Create a <code>configureButtonBindings()</code> method that contains all trigger bindings. Call this method from the constructor.<br><br><strong>Binding Setup:</strong> In this method, create triggers from input sources (buttons, joysticks) and bind them to commands. Use descriptive comments to document bindings.<br><br><strong>Grouping:</strong> Group related bindings together (e.g., all drivetrain bindings, all mechanism bindings) for better organization."
    },
    {
      "type": "code",
      "title": "RobotContainer with Trigger Bindings",
      "content": "package frc.robot;\n\nimport edu.wpi.first.wpilibj2.command.button.CommandXboxController;\nimport frc.robot.commands.*;\nimport frc.robot.subsystems.*;\n\npublic class RobotContainer {\n    private final Drivetrain m_drivetrain = new Drivetrain();\n    private final Arm m_arm = new Arm();\n    private final Intake m_intake = new Intake();\n    \n    private final CommandXboxController m_driverController = new CommandXboxController(0);\n    private final CommandXboxController m_operatorController = new CommandXboxController(1);\n    \n    public RobotContainer() {\n        configureDefaultCommands();\n        configureButtonBindings();\n    }\n    \n    private void configureButtonBindings() {\n        // Driver Controller\n        m_driverController.a()\n            .onTrue(new EmergencyStopCommand());\n        \n        // Operator Controller\n        m_operatorController.a()\n            .onTrue(new MoveArmCommand(m_arm, 30.0, 0.3, 2.0));\n        \n        m_operatorController.b()\n            .onTrue(new MoveArmCommand(m_arm, 60.0, 0.3, 2.0));\n        \n        m_operatorController.x()\n            .whileTrue(new RunIntakeCommand(m_intake, 0.6));\n    }\n    \n    private void configureDefaultCommands() {\n        // Set default commands\n    }\n}"
    },
    {
      "type": "text",
      "title": "Default Command Setup",
      "content": "RobotContainer sets default commands for subsystems in the constructor or a dedicated method:<br><br><strong>Setting Defaults:</strong> Call <code>subsystem.setDefaultCommand(command)</code> for each subsystem that needs a default command. This is typically done in a <code>configureDefaultCommands()</code> method called from the constructor.<br><br><strong>Default Command Selection:</strong> Choose default commands that provide safe, continuous behavior. Common defaults include arcade drive for drivetrain, hold position for arms, or manual control for intakes.<br><br><strong>Timing:</strong> Set default commands during RobotContainer construction, before the robot enters any mode. This ensures defaults are active from the start."
    },
    {
      "type": "code",
      "title": "Complete RobotContainer Example",
      "content": "package frc.robot;\n\nimport edu.wpi.first.wpilibj2.command.Command;\nimport edu.wpi.first.wpilibj2.command.button.CommandXboxController;\nimport frc.robot.commands.*;\nimport frc.robot.subsystems.*;\n\npublic class RobotContainer {\n    // Subsystems\n    private final Drivetrain m_drivetrain = new Drivetrain();\n    private final Arm m_arm = new Arm();\n    private final Elevator m_elevator = new Elevator();\n    private final Intake m_intake = new Intake();\n    \n    // Controllers\n    private final CommandXboxController m_driverController = new CommandXboxController(0);\n    private final CommandXboxController m_operatorController = new CommandXboxController(1);\n    \n    public RobotContainer() {\n        configureDefaultCommands();\n        configureButtonBindings();\n    }\n    \n    private void configureDefaultCommands() {\n        // Drivetrain: Arcade drive from joystick\n        m_drivetrain.setDefaultCommand(\n            new ArcadeDriveCommand(\n                m_drivetrain,\n                () -> m_driverController.getLeftY(),\n                () -> m_driverController.getRightX()\n            )\n        );\n        \n        // Arm: Hold current position\n        m_arm.setDefaultCommand(\n            new HoldArmPositionCommand(m_arm)\n        );\n        \n        // Intake: Manual control\n        m_intake.setDefaultCommand(\n            new ManualIntakeCommand(\n                m_intake,\n                () -> m_operatorController.getRightTriggerAxis() > 0.5\n            )\n        );\n    }\n    \n    private void configureButtonBindings() {\n        // Driver Controller\n        m_driverController.a()\n            .onTrue(new EmergencyStopCommand());\n        \n        // Operator Controller\n        m_operatorController.a()\n            .onTrue(new MoveArmCommand(m_arm, 30.0, 0.3, 2.0));\n        \n        m_operatorController.b()\n            .onTrue(new MoveArmCommand(m_arm, 60.0, 0.3, 2.0));\n        \n        m_operatorController.x()\n            .whileTrue(new RunIntakeCommand(m_intake, 0.6));\n        \n        m_operatorController.y()\n            .whileTrue(new RunIntakeCommand(m_intake, -0.4));\n        \n        m_operatorController.povUp()\n            .whileTrue(new MoveElevatorCommand(m_elevator, 48.0, 0.5, 0.5));\n        \n        m_operatorController.povDown()\n            .whileTrue(new MoveElevatorCommand(m_elevator, 0.0, 0.5, 0.5));\n    }\n    \n    // Getter methods for Robot class\n    public Drivetrain getDrivetrain() {\n        return m_drivetrain;\n    }\n    \n    public Arm getArm() {\n        return m_arm;\n    }\n    \n    public Elevator getElevator() {\n        return m_elevator;\n    }\n    \n    public Intake getIntake() {\n        return m_intake;\n    }\n    \n    // Factory method for autonomous\n    public Command getAutonomousCommand() {\n        return new SimpleAutonomousRoutine(m_drivetrain, m_arm, m_intake);\n    }\n}"
    },
    {
      "type": "text",
      "title": "RobotContainer Organization Patterns",
      "content": "There are several ways to organize RobotContainer depending on your team's preferences:<br><br><strong>Single Method:</strong> Put all configuration in the constructor. Simple but can become large.<br><br><strong>Separate Methods:</strong> Split configuration into <code>configureDefaultCommands()</code> and <code>configureButtonBindings()</code>. More organized and easier to navigate.<br><br><strong>Factory Methods:</strong> Use factory methods for command creation. Makes it easy to create commands with consistent parameters.<br><br><strong>Constants:</strong> Define constants for command parameters (speeds, positions, etc.) at the top of the class. Makes it easy to tune values.<br><br>Choose the pattern that works best for your team and project size."
    },
    {
      "type": "code",
      "title": "RobotContainer Organization Patterns",
      "content": "package frc.robot;\n\nimport edu.wpi.first.wpilibj2.command.button.CommandXboxController;\nimport frc.robot.commands.MoveArmCommand;\nimport frc.robot.subsystems.Arm;\n\npublic class RobotContainer {\n    // Constants for easy tuning\n    private static final double ARM_LOW_ANGLE = 30.0;\n    private static final double ARM_HIGH_ANGLE = 60.0;\n    private static final double ARM_SPEED = 0.3;\n    private static final double ARM_TOLERANCE = 2.0;\n    \n    private final Arm m_arm = new Arm();\n    private final CommandXboxController m_operatorController = new CommandXboxController(1);\n    \n    public RobotContainer() {\n        configureDefaultCommands();\n        configureButtonBindings();\n    }\n    \n    private void configureDefaultCommands() {\n        // Default command configuration\n    }\n    \n    private void configureButtonBindings() {\n        // Use constants for consistency\n        m_operatorController.a()\n            .onTrue(new MoveArmCommand(m_arm, ARM_LOW_ANGLE, ARM_SPEED, ARM_TOLERANCE));\n        \n        m_operatorController.b()\n            .onTrue(new MoveArmCommand(m_arm, ARM_HIGH_ANGLE, ARM_SPEED, ARM_TOLERANCE));\n    }\n    \n    // Factory methods for common commands\n    private MoveArmCommand moveArmToLow() {\n        return new MoveArmCommand(m_arm, ARM_LOW_ANGLE, ARM_SPEED, ARM_TOLERANCE);\n    }\n    \n    private MoveArmCommand moveArmToHigh() {\n        return new MoveArmCommand(m_arm, ARM_HIGH_ANGLE, ARM_SPEED, ARM_TOLERANCE);\n    }\n}"
    },
    {
      "type": "text",
      "title": "Robot Class Integration",
      "content": "RobotContainer integrates with the Robot class to provide a complete command-based robot:<br><br><strong>Robot Class:</strong> The Robot class becomes very simple - it creates RobotContainer and calls <code>CommandScheduler.getInstance().run()</code> in periodic methods.<br><br><strong>Autonomous:</strong> The Robot class can get autonomous commands from RobotContainer (via a factory method) and schedule them in <code>autonomousInit()</code>.<br><br><strong>Access:</strong> Robot class accesses subsystems through RobotContainer getter methods when needed for autonomous or other purposes."
    },
    {
      "type": "code",
      "title": "Robot Class with RobotContainer",
      "content": "package frc.robot;\n\nimport edu.wpi.first.wpilibj.TimedRobot;\nimport edu.wpi.first.wpilibj2.command.Command;\nimport edu.wpi.first.wpilibj2.command.CommandScheduler;\n\npublic class Robot extends TimedRobot {\n    private RobotContainer m_robotContainer;\n    private Command m_autonomousCommand;\n    \n    @Override\n    public void robotInit() {\n        // Create RobotContainer (sets up everything)\n        m_robotContainer = new RobotContainer();\n    }\n    \n    @Override\n    public void robotPeriodic() {\n        // Run scheduler (handles all command execution)\n        CommandScheduler.getInstance().run();\n    }\n    \n    @Override\n    public void autonomousInit() {\n        // Get autonomous command from RobotContainer\n        m_autonomousCommand = m_robotContainer.getAutonomousCommand();\n        \n        // Schedule autonomous command\n        if (m_autonomousCommand != null) {\n            m_autonomousCommand.schedule();\n        }\n    }\n    \n    @Override\n    public void autonomousPeriodic() {\n        // Scheduler runs in robotPeriodic, but can also run here\n    }\n    \n    @Override\n    public void teleopInit() {\n        // Cancel autonomous command if still running\n        if (m_autonomousCommand != null) {\n            m_autonomousCommand.cancel();\n        }\n    }\n    \n    @Override\n    public void teleopPeriodic() {\n        // Scheduler runs in robotPeriodic\n        // Default commands and trigger bindings handle teleop\n    }\n    \n    @Override\n    public void testPeriodic() {\n        CommandScheduler.getInstance().run();\n    }\n}"
    },
    {
      "type": "rules-box",
      "title": "RobotContainer Best Practices",
      "subtitle": "Tips for effective RobotContainer design:",
      "items": [
        "Create all subsystems as private final fields",
        "Organize configuration into separate methods (configureDefaultCommands, configureButtonBindings)",
        "Use factory methods for command creation when helpful",
        "Provide getter methods for subsystems needed by Robot class",
        "Document button bindings with comments",
        "Use constants for tunable parameters",
        "Keep RobotContainer focused on configuration (not business logic)",
        "Test RobotContainer independently when possible"
      ]
    },
    {
      "type": "text",
      "title": "Alternative Patterns",
      "content": "While RobotContainer is the recommended pattern, there are alternatives:<br><br><strong>No RobotContainer:</strong> You can organize code differently, but RobotContainer provides clear structure and is widely used in the FRC community.<br><br><strong>Multiple Containers:</strong> For very large robots, you might split configuration into multiple container classes (e.g., <code>DrivetrainContainer</code>, <code>MechanismContainer</code>), though this is usually unnecessary.<br><br><strong>Best Practice:</strong> Use RobotContainer for most robots. It provides excellent organization and is the standard pattern in WPILib examples and documentation."
    },
    {
      "type": "link-grid",
      "title": "Related Topics",
      "links": [
        { "label": "Trigger Bindings", "id": "trigger-bindings" },
        { "label": "Default Commands", "id": "default-commands" },
        { "label": "Subsystem Design", "id": "subsystem-design" }
      ]
    }
  ]
}

