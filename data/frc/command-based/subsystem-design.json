{
  "title": "Subsystem Design",
  "sections": [
    {
      "type": "text",
      "title": "Introduction to Subsystems",
      "content": "Subsystems are hardware abstractions that encapsulate robot mechanisms and provide a clean interface for commands to interact with hardware. They manage hardware initialization, state tracking, and provide methods that commands use to control mechanisms.<br><br>Subsystems are the foundation of command-based programming. They abstract away hardware details, making it easier to write commands and test code. A well-designed subsystem provides a clear, consistent interface for controlling robot mechanisms.<br><br>Learn more: <a href='https://docs.wpilib.org/en/stable/docs/software/commandbased/subsystems.html' target='_blank'>WPILib: Subsystems</a>"
    },
    {
      "type": "rules-box",
      "title": "Subsystem Design Principles",
      "subtitle": "Key principles for good subsystem design:",
      "items": [
        "Encapsulate hardware (hide implementation details from commands)",
        "Provide clear, consistent interfaces (methods should be intuitive)",
        "Manage state internally (track position, velocity, etc. within subsystem)",
        "Handle safety features (default commands, limits, safety checks)",
        "Use proper initialization (configure hardware in constructor)",
        "Document public methods (commands need to know how to use subsystems)",
        "Keep subsystems focused (one mechanism per subsystem typically)",
        "Use periodic() for continuous updates (sensor reading, state tracking)"
      ]
    },
    {
      "type": "text",
      "title": "Subsystem Responsibilities",
      "content": "Subsystems have several key responsibilities in command-based programming:<br><br><strong>Hardware Abstraction:</strong> Subsystems hide hardware implementation details from commands. Commands don't need to know about specific motor controllers, encoders, or sensors - they just call subsystem methods.<br><br><strong>State Management:</strong> Subsystems track and manage their own state (position, velocity, enabled/disabled, etc.). This state is available to commands and other parts of the robot code.<br><br><strong>Safety Features:</strong> Subsystems can implement safety limits, default behaviors, and safety checks. Default commands provide safe behavior when no other command is running.<br><br><strong>Encapsulation:</strong> Subsystems encapsulate hardware access, preventing commands from directly manipulating hardware in unsafe ways. All hardware interaction goes through subsystem methods."
    },
    {
      "type": "text",
      "title": "Creating Subsystems",
      "content": "Subsystems are created by extending <code>SubsystemBase</code> from WPILib. The <code>SubsystemBase</code> class provides the foundation for command-based subsystems, including integration with the command scheduler.<br><br><strong>Basic Structure:</strong> Create a class that extends <code>SubsystemBase</code>, initialize hardware in the constructor, provide public methods for commands to use, and optionally override <code>periodic()</code> for continuous updates.<br><br><strong>Constructor Pattern:</strong> Initialize all hardware objects, configure settings, and set up any required state in the constructor. This ensures the subsystem is ready to use when created."
    },
    {
      "type": "code",
      "title": "Basic Subsystem Structure",
      "content": "package frc.robot.subsystems;\n\nimport edu.wpi.first.wpilibj.motorcontrol.MotorControllerGroup;\nimport edu.wpi.first.wpilibj.motorcontrol.PWMSparkMax;\nimport edu.wpi.first.wpilibj2.command.SubsystemBase;\n\npublic class Drivetrain extends SubsystemBase {\n    // Hardware objects (private - encapsulated)\n    private final PWMSparkMax m_leftFront = new PWMSparkMax(0);\n    private final PWMSparkMax m_leftBack = new PWMSparkMax(1);\n    private final PWMSparkMax m_rightFront = new PWMSparkMax(2);\n    private final PWMSparkMax m_rightBack = new PWMSparkMax(3);\n    \n    private final MotorControllerGroup m_leftGroup = \n        new MotorControllerGroup(m_leftFront, m_leftBack);\n    private final MotorControllerGroup m_rightGroup = \n        new MotorControllerGroup(m_rightFront, m_rightBack);\n    \n    public Drivetrain() {\n        // Configure hardware in constructor\n        m_rightGroup.setInverted(true);\n        \n        // Set any initial state\n        stop();\n    }\n    \n    // Public methods for commands to use\n    public void drive(double leftSpeed, double rightSpeed) {\n        m_leftGroup.set(leftSpeed);\n        m_rightGroup.set(rightSpeed);\n    }\n    \n    public void stop() {\n        m_leftGroup.set(0);\n        m_rightGroup.set(0);\n    }\n    \n    @Override\n    public void periodic() {\n        // Called every robot loop (20ms)\n        // Use for periodic tasks like updating sensors\n    }\n}"
    },
    {
      "type": "text",
      "title": "Hardware Initialization",
      "content": "Hardware initialization happens in the subsystem constructor. This is where you create hardware objects, configure settings, and prepare the subsystem for use.<br><br><strong>Initialization Steps:</strong><br>1. Create hardware objects (motors, sensors, etc.)<br>2. Configure hardware settings (inversion, limits, etc.)<br>3. Set initial state (stop motors, reset encoders, etc.)<br>4. Configure any safety features<br><br><strong>Best Practice:</strong> Initialize hardware immediately when creating objects. Use <code>final</code> for hardware objects to prevent reassignment and ensure they're initialized once."
    },
    {
      "type": "code",
      "title": "Subsystem with Hardware",
      "content": "package frc.robot.subsystems;\n\nimport com.revrobotics.CANSparkMax;\nimport com.revrobotics.CANSparkLowLevel.MotorType;\nimport com.revrobotics.RelativeEncoder;\nimport edu.wpi.first.wpilibj2.command.SubsystemBase;\n\npublic class Arm extends SubsystemBase {\n    // Hardware objects\n    private final CANSparkMax m_motor = new CANSparkMax(5, MotorType.kBrushless);\n    private final RelativeEncoder m_encoder = m_motor.getEncoder();\n    \n    // State tracking\n    private double m_targetAngle = 0.0;\n    \n    public Arm() {\n        // Configure hardware\n        m_motor.setIdleMode(CANSparkMax.IdleMode.kBrake);\n        m_motor.setInverted(false);\n        m_motor.setSmartCurrentLimit(40);\n        \n        // Reset encoder\n        m_encoder.setPosition(0);\n        \n        // Set initial state\n        m_targetAngle = 0.0;\n    }\n    \n    // Public methods for commands\n    public void setSpeed(double speed) {\n        m_motor.set(speed);\n    }\n    \n    public void setTargetAngle(double angle) {\n        m_targetAngle = angle;\n    }\n    \n    public double getAngle() {\n        // Convert encoder position to degrees\n        return m_encoder.getPosition() * (360.0 / 42.0);\n    }\n    \n    public double getTargetAngle() {\n        return m_targetAngle;\n    }\n    \n    public boolean isAtTarget(double tolerance) {\n        double error = Math.abs(getAngle() - m_targetAngle);\n        return error < tolerance;\n    }\n    \n    public void stop() {\n        m_motor.set(0);\n    }\n    \n    @Override\n    public void periodic() {\n        // Update state, read sensors, etc.\n        // This runs every 20ms\n    }\n}"
    },
    {
      "type": "text",
      "title": "Subsystem Methods",
      "content": "Subsystems provide public methods that commands use to interact with hardware. These methods should be clear, well-named, and focused on specific operations.<br><br><strong>Method Design:</strong><br>- Use descriptive names that indicate what the method does<br>- Keep methods focused (one operation per method typically)<br>- Handle hardware details internally (commands shouldn't need to know about motor controllers)<br>- Return useful information when appropriate (position, velocity, state)<br>- Document complex methods<br><br><strong>Common Method Patterns:</strong><br>- <code>setSpeed()</code> - Set motor speed<br>- <code>setPosition()</code> - Move to position<br>- <code>getPosition()</code> - Get current position<br>- <code>isAtTarget()</code> - Check if at target<br>- <code>stop()</code> - Stop mechanism"
    },
    {
      "type": "text",
      "title": "State Management",
      "content": "Subsystems manage their own state, tracking information like position, velocity, enabled status, and target values. This state is available to commands and other parts of the robot code.<br><br><strong>State Tracking:</strong> Store state as private member variables. Update state in <code>periodic()</code> or when methods are called. Provide getter methods for commands to read state.<br><br><strong>State Examples:</strong><br>- Current position (from encoders)<br>- Current velocity<br>- Target position or speed<br>- Enabled/disabled status<br>- Mechanism mode (manual, automatic, etc.)<br><br><strong>Best Practice:</strong> Keep state synchronized with actual hardware. Read sensors in <code>periodic()</code> to keep state current."
    },
    {
      "type": "code",
      "title": "Subsystem with State Management",
      "content": "package frc.robot.subsystems;\n\nimport com.revrobotics.CANSparkMax;\nimport com.revrobotics.CANSparkLowLevel.MotorType;\nimport com.revrobotics.RelativeEncoder;\nimport edu.wpi.first.wpilibj.smartdashboard.SmartDashboard;\nimport edu.wpi.first.wpilibj2.command.SubsystemBase;\n\npublic class Elevator extends SubsystemBase {\n    private final CANSparkMax m_motor = new CANSparkMax(6, MotorType.kBrushless);\n    private final RelativeEncoder m_encoder = m_motor.getEncoder();\n    \n    // State variables\n    private double m_targetHeight = 0.0;  // Target height in inches\n    private boolean m_isMoving = false;\n    private double m_maxHeight = 48.0;  // Maximum height in inches\n    private double m_minHeight = 0.0;   // Minimum height in inches\n    \n    // Conversion: encoder counts to inches\n    private static final double COUNTS_PER_INCH = 42.0 / (4.0 * Math.PI);\n    \n    public Elevator() {\n        m_motor.setIdleMode(CANSparkMax.IdleMode.kBrake);\n        m_motor.setSmartCurrentLimit(40);\n        m_encoder.setPosition(0);\n    }\n    \n    public void setTargetHeight(double height) {\n        // Clamp height to limits\n        m_targetHeight = Math.max(m_minHeight, Math.min(m_maxHeight, height));\n        m_isMoving = true;\n    }\n    \n    public void setSpeed(double speed) {\n        double currentHeight = getHeight();\n        \n        // Safety: prevent moving beyond limits\n        if ((currentHeight >= m_maxHeight && speed > 0) || \n            (currentHeight <= m_minHeight && speed < 0)) {\n            speed = 0;\n        }\n        \n        m_motor.set(speed);\n        m_isMoving = speed != 0;\n    }\n    \n    public double getHeight() {\n        return m_encoder.getPosition() / COUNTS_PER_INCH;\n    }\n    \n    public double getTargetHeight() {\n        return m_targetHeight;\n    }\n    \n    public boolean isAtTarget(double tolerance) {\n        return Math.abs(getHeight() - m_targetHeight) < tolerance;\n    }\n    \n    public boolean isMoving() {\n        return m_isMoving;\n    }\n    \n    public void stop() {\n        m_motor.set(0);\n        m_isMoving = false;\n    }\n    \n    @Override\n    public void periodic() {\n        // Update state every loop\n        // Check if at target\n        if (m_isMoving && isAtTarget(0.5)) {\n            stop();\n        }\n        \n        // Update dashboard\n        SmartDashboard.putNumber(\"Elevator Height\", getHeight());\n        SmartDashboard.putNumber(\"Elevator Target\", m_targetHeight);\n        SmartDashboard.putBoolean(\"Elevator Moving\", m_isMoving);\n    }\n}"
    },
    {
      "type": "text",
      "title": "Safety Features",
      "content": "Subsystems should implement safety features to prevent damage and ensure safe operation:<br><br><strong>Default Commands:</strong> Set default commands that provide safe behavior when no other command is running. For example, a drivetrain default command might stop the robot, or an arm default might hold position.<br><br><strong>Safety Limits:</strong> Implement software limits (position limits, speed limits, etc.) to prevent mechanisms from moving beyond safe ranges. Check limits in methods before applying commands.<br><br><strong>Safety Checks:</strong> Validate inputs, check for error conditions, and handle edge cases. For example, prevent setting speed to invalid values or moving beyond physical limits."
    },
    {
      "type": "text",
      "title": "Subsystem Examples",
      "content": "Different types of mechanisms require different subsystem designs. Here are common subsystem patterns:<br><br><strong>Drivetrain:</strong> Manages multiple motors, provides drive methods (arcade, tank, etc.), may include odometry or sensor reading.<br><br><strong>Arm:</strong> Controls arm motor, tracks position with encoder, provides methods to move to angles or set speed.<br><br><strong>Elevator:</strong> Manages elevator motor, tracks height, implements position limits, provides height control methods.<br><br><strong>Intake:</strong> Controls intake motors, may include sensor reading (game piece detection), provides run/stop methods.<br><br>Each subsystem follows the same basic pattern but adapts to the specific mechanism's needs."
    },
    {
      "type": "code",
      "title": "Multiple Subsystem Example",
      "content": "package frc.robot.subsystems;\n\nimport com.revrobotics.CANSparkMax;\nimport com.revrobotics.CANSparkLowLevel.MotorType;\nimport edu.wpi.first.wpilibj2.command.SubsystemBase;\n\n// Intake subsystem\npublic class Intake extends SubsystemBase {\n    private final CANSparkMax m_motor = new CANSparkMax(7, MotorType.kBrushless);\n    \n    public Intake() {\n        m_motor.setIdleMode(CANSparkMax.IdleMode.kCoast);\n        m_motor.setSmartCurrentLimit(30);\n    }\n    \n    public void run(double speed) {\n        m_motor.set(speed);\n    }\n    \n    public void stop() {\n        m_motor.set(0);\n    }\n}\n\n// Shooter subsystem\npublic class Shooter extends SubsystemBase {\n    private final CANSparkMax m_motor = new CANSparkMax(8, MotorType.kBrushless);\n    \n    public Shooter() {\n        m_motor.setIdleMode(CANSparkMax.IdleMode.kCoast);\n        m_motor.setSmartCurrentLimit(40);\n    }\n    \n    public void setSpeed(double speed) {\n        m_motor.set(speed);\n    }\n    \n    public void stop() {\n        m_motor.set(0);\n    }\n    \n    public double getVelocity() {\n        return m_motor.getEncoder().getVelocity();\n    }\n}\n\n// Complete robot with multiple subsystems\npublic class RobotContainer {\n    private final Drivetrain m_drivetrain = new Drivetrain();\n    private final Arm m_arm = new Arm();\n    private final Elevator m_elevator = new Elevator();\n    private final Intake m_intake = new Intake();\n    private final Shooter m_shooter = new Shooter();\n    \n    // Each subsystem is independent and can be used by commands\n}"
    },
    {
      "type": "rules-box",
      "title": "Subsystem Best Practices",
      "subtitle": "Tips for effective subsystem design:",
      "items": [
        "Initialize all hardware in constructor",
        "Use final for hardware objects to prevent reassignment",
        "Keep hardware objects private (encapsulation)",
        "Provide clear, descriptive method names",
        "Track state internally and update in periodic()",
        "Implement safety limits and checks",
        "Set default commands for safe behavior",
        "Document complex methods and state variables",
        "Keep subsystems focused on one mechanism"
      ]
    },
    {
      "type": "text",
      "title": "Common Subsystem Patterns",
      "content": "There are several common patterns for organizing subsystems:<br><br><strong>Singleton Pattern:</strong> Some teams use singleton subsystems (one instance globally accessible). This can be useful but isn't required - RobotContainer typically manages subsystem instances.<br><br><strong>Multiple Instances:</strong> For mechanisms that exist in multiple places (e.g., swerve modules), you might create multiple subsystem instances. Each instance manages its own hardware.<br><br><strong>Organization:</strong> Keep all subsystems in the <code>subsystems</code> package. Use descriptive names that indicate the mechanism. Group related subsystems if needed (e.g., <code>subsystems.drivetrain</code> for swerve modules)."
    },
    {
      "type": "link-grid",
      "title": "Related Topics",
      "links": [
        { "label": "Command Creation", "id": "command-creation" },
        { "label": "Default Commands", "id": "default-commands" },
        { "label": "Command-Based Introduction", "id": "command-based-intro" }
      ]
    }
  ]
}

