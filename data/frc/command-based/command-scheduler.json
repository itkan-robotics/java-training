{
  "title": "Command Scheduler",
  "sections": [
    {
      "type": "text",
      "title": "Introduction to Command Scheduler",
      "content": "The Command Scheduler is the execution manager for command-based programming. It runs continuously, scheduling commands, executing their lifecycle methods, managing subsystem ownership, and handling command interruption. Understanding how the scheduler works is essential for effective command-based programming.<br><br>The scheduler runs automatically in command-based robots, calling <code>CommandScheduler.getInstance().run()</code> in the robot's periodic methods. It manages all command execution, ensuring commands run correctly and subsystems are used safely."
    },
    {
      "type": "rules-box",
      "title": "Scheduler Responsibilities",
      "subtitle": "What the scheduler does:",
      "items": [
        "Schedules commands when requested",
        "Executes command lifecycle methods (initialize, execute, isFinished, end)",
        "Manages subsystem ownership and prevents conflicts",
        "Interrupts commands when necessary",
        "Runs default commands when no other command requires subsystems",
        "Updates command state every robot loop (20ms)",
        "Handles command cancellation and cleanup",
        "Monitors active commands and their status"
      ]
    },
    {
      "type": "text",
      "title": "How Scheduling Works",
      "content": "The command scheduler follows a specific process for managing commands:<br><br><strong>Scheduling Process:</strong><br>1. Command is scheduled (via <code>schedule()</code> or trigger binding)<br>2. Scheduler checks if command's required subsystems are available<br>3. If subsystems are in use, scheduler interrupts conflicting commands<br>4. Command's <code>initialize()</code> is called once<br>5. Command enters active state<br><br><strong>Execution Order:</strong> The scheduler processes commands in a specific order each loop:<br>1. Check for new commands to schedule<br>2. Interrupt commands if needed (subsystem conflicts)<br>3. Call <code>initialize()</code> on newly scheduled commands<br>4. Call <code>execute()</code> on all active commands<br>5. Check <code>isFinished()</code> on all active commands<br>6. Call <code>end()</code> on finished commands<br>7. Run default commands for subsystems not in use<br><br><strong>Update Cycle:</strong> This entire process happens every 20ms (50 times per second), synchronized with the robot's main control loop."
    },
    {
      "type": "text",
      "title": "Command Execution",
      "content": "Once a command is scheduled, the scheduler manages its execution through the command lifecycle:<br><br><strong>initialize():</strong> Called once when the command is first scheduled, before the first <code>execute()</code> call. Use this for one-time setup.<br><br><strong>execute():</strong> Called repeatedly (every 20ms) while the command is active. This is where the command's main logic runs. The scheduler calls this on all active commands each loop.<br><br><strong>isFinished():</strong> Called after each <code>execute()</code> call. The scheduler checks this to determine if the command should end. If it returns <code>true</code>, the command will be ended in the same loop.<br><br><strong>end(boolean interrupted):</strong> Called once when the command finishes, either because <code>isFinished()</code> returned <code>true</code> or because the command was interrupted. The scheduler passes <code>true</code> if the command was interrupted, <code>false</code> if it finished normally."
    },
    {
      "type": "code",
      "title": "Scheduling Commands Manually",
      "content": "package frc.robot;\n\nimport edu.wpi.first.wpilibj.TimedRobot;\nimport edu.wpi.first.wpilibj2.command.Command;\nimport edu.wpi.first.wpilibj2.command.CommandScheduler;\nimport frc.robot.commands.DriveForwardCommand;\nimport frc.robot.subsystems.Drivetrain;\n\npublic class Robot extends TimedRobot {\n    private RobotContainer m_robotContainer;\n    private Drivetrain m_drivetrain;\n    \n    @Override\n    public void robotInit() {\n        m_robotContainer = new RobotContainer();\n        m_drivetrain = m_robotContainer.getDrivetrain();\n    }\n    \n    @Override\n    public void autonomousInit() {\n        // Schedule a command manually\n        Command driveCommand = new DriveForwardCommand(m_drivetrain, 0.5);\n        CommandScheduler.getInstance().schedule(driveCommand);\n    }\n    \n    @Override\n    public void teleopPeriodic() {\n        // Scheduler must run in periodic methods\n        CommandScheduler.getInstance().run();\n    }\n    \n    @Override\n    public void autonomousPeriodic() {\n        // Scheduler runs in autonomous too\n        CommandScheduler.getInstance().run();\n    }\n    \n    @Override\n    public void testPeriodic() {\n        CommandScheduler.getInstance().run();\n    }\n    \n    @Override\n    public void robotPeriodic() {\n        // Scheduler can run here too (runs in all modes)\n        CommandScheduler.getInstance().run();\n    }\n}"
    },
    {
      "type": "text",
      "title": "Command Requirements and Interruption",
      "content": "The scheduler uses command requirements to manage subsystem ownership and prevent conflicts:<br><br><strong>Subsystem Ownership:</strong> When a command requires a subsystem (via <code>addRequirements()</code>), it gets exclusive access to that subsystem. No other command can use that subsystem while the command is active.<br><br><strong>Interrupting Commands:</strong> If a new command is scheduled that requires a subsystem already in use, the scheduler automatically interrupts the conflicting command. The interrupted command's <code>end(true)</code> method is called, and the new command takes control.<br><br><strong>Requirement Conflicts:</strong> Commands that require the same subsystem cannot run simultaneously. The scheduler ensures only one command controls each subsystem at a time, preventing conflicts and ensuring predictable behavior."
    },
    {
      "type": "code",
      "title": "Command Interruption Example",
      "content": "package frc.robot.commands;\n\nimport edu.wpi.first.wpilibj2.command.Command;\nimport frc.robot.subsystems.Drivetrain;\n\npublic class DriveForwardCommand extends Command {\n    private final Drivetrain m_drivetrain;\n    private final double m_speed;\n    \n    public DriveForwardCommand(Drivetrain drivetrain, double speed) {\n        m_drivetrain = drivetrain;\n        m_speed = speed;\n        addRequirements(drivetrain);\n    }\n    \n    @Override\n    public void initialize() {\n        System.out.println(\"DriveForwardCommand: Starting\");\n    }\n    \n    @Override\n    public void execute() {\n        m_drivetrain.drive(m_speed, m_speed);\n    }\n    \n    @Override\n    public boolean isFinished() {\n        return false;  // Runs until interrupted\n    }\n    \n    @Override\n    public void end(boolean interrupted) {\n        m_drivetrain.stop();\n        \n        if (interrupted) {\n            // This command was interrupted by another command\n            System.out.println(\"DriveForwardCommand: Interrupted by another command\");\n        } else {\n            System.out.println(\"DriveForwardCommand: Completed normally\");\n        }\n    }\n}\n\n// When another command requiring drivetrain is scheduled:\n// CommandScheduler.getInstance().schedule(new TurnCommand(drivetrain, 90));\n// DriveForwardCommand will be interrupted automatically"
    },
    {
      "type": "code",
      "title": "Requirement Conflict Handling",
      "content": "package frc.robot;\n\nimport edu.wpi.first.wpilibj2.command.CommandScheduler;\nimport frc.robot.commands.DriveForwardCommand;\nimport frc.robot.commands.TurnCommand;\nimport frc.robot.subsystems.Drivetrain;\n\npublic class ConflictExample {\n    private Drivetrain m_drivetrain;\n    \n    public void demonstrateConflicts() {\n        // Schedule first command\n        Command driveCommand = new DriveForwardCommand(m_drivetrain, 0.5);\n        CommandScheduler.getInstance().schedule(driveCommand);\n        \n        // driveCommand is now active and controls drivetrain\n        \n        // Schedule second command requiring same subsystem\n        Command turnCommand = new TurnCommand(m_drivetrain, 90);\n        CommandScheduler.getInstance().schedule(turnCommand);\n        \n        // Scheduler automatically:\n        // 1. Interrupts driveCommand (calls end(true))\n        // 2. Schedules turnCommand (calls initialize())\n        // 3. turnCommand now has exclusive control of drivetrain\n        \n        // driveCommand is no longer active\n        // turnCommand is now active\n    }\n}"
    },
    {
      "type": "text",
      "title": "Scheduler Methods",
      "content": "The command scheduler provides several methods for managing commands:<br><br><strong>schedule(Command... commands):</strong> Schedules one or more commands. If a command requires subsystems already in use, conflicting commands are interrupted automatically.<br><br><strong>cancel(Command... commands):</strong> Cancels specific commands. The commands' <code>end(true)</code> methods are called, and they're removed from the scheduler.<br><br><strong>cancelAll():</strong> Cancels all currently scheduled commands. Useful for emergency stops or mode transitions.<br><br><strong>run():</strong> Runs the scheduler for one iteration. This should be called in robot periodic methods. It processes all scheduled commands, executes lifecycle methods, and manages subsystem ownership."
    },
    {
      "type": "code",
      "title": "Scheduler Methods Usage",
      "content": "import edu.wpi.first.wpilibj2.command.Command;\nimport edu.wpi.first.wpilibj2.command.CommandScheduler;\n\npublic class SchedulerMethodsExample {\n    private Command m_activeCommand;\n    \n    public void scheduleCommand(Command command) {\n        // Schedule a command\n        CommandScheduler.getInstance().schedule(command);\n        m_activeCommand = command;\n    }\n    \n    public void cancelActiveCommand() {\n        // Cancel specific command\n        if (m_activeCommand != null) {\n            CommandScheduler.getInstance().cancel(m_activeCommand);\n            m_activeCommand = null;\n        }\n    }\n    \n    public void emergencyStop() {\n        // Cancel all commands (emergency stop)\n        CommandScheduler.getInstance().cancelAll();\n        m_activeCommand = null;\n    }\n    \n    public void runScheduler() {\n        // Run scheduler (called in robot periodic methods)\n        CommandScheduler.getInstance().run();\n    }\n}"
    },
    {
      "type": "text",
      "title": "Monitoring Scheduler",
      "content": "You can monitor the scheduler to see what commands are active and debug command execution:<br><br><strong>Getting Active Commands:</strong> The scheduler provides methods to query active commands and their status. This is useful for debugging and displaying telemetry.<br><br><strong>Debugging:</strong> Use scheduler monitoring to understand why commands aren't running, which commands are active, and how subsystem ownership is being managed.<br><br><strong>Telemetry:</strong> Display active commands on the dashboard to help drivers and operators understand what the robot is doing."
    },
    {
      "type": "code",
      "title": "Monitoring Active Commands",
      "content": "package frc.robot;\n\nimport edu.wpi.first.wpilibj.smartdashboard.SmartDashboard;\nimport edu.wpi.first.wpilibj2.command.Command;\nimport edu.wpi.first.wpilibj2.command.CommandScheduler;\n\npublic class SchedulerMonitoring {\n    public void updateTelemetry() {\n        // Get scheduler instance\n        CommandScheduler scheduler = CommandScheduler.getInstance();\n        \n        // Note: Direct access to active commands is limited in current WPILib API\n        // Use command-specific methods or subsystem state to track activity\n        \n        // Example: Track command state through subsystems\n        // Subsystems can track which command is using them\n        \n        // Display scheduler status\n        SmartDashboard.putBoolean(\"Scheduler Running\", true);\n        \n        // In practice, track command state through:\n        // - Subsystem methods that indicate active commands\n        // - Command-specific state variables\n        // - RobotContainer tracking active commands\n    }\n}"
    },
    {
      "type": "code",
      "title": "Scheduler Debugging",
      "content": "package frc.robot;\n\nimport edu.wpi.first.wpilibj2.command.Command;\nimport edu.wpi.first.wpilibj2.command.CommandScheduler;\n\npublic class SchedulerDebugging {\n    public void debugScheduler() {\n        CommandScheduler scheduler = CommandScheduler.getInstance();\n        \n        // Enable command scheduling (if disabled)\n        scheduler.enable();\n        \n        // Disable command scheduling (for testing)\n        // scheduler.disable();\n        \n        // Check if scheduler is enabled\n        // boolean isEnabled = scheduler.isScheduled(...);\n        \n        // In practice, debugging involves:\n        // 1. Adding print statements in command lifecycle methods\n        // 2. Monitoring subsystem state\n        // 3. Checking trigger bindings\n        // 4. Verifying command requirements\n        \n        System.out.println(\"Scheduler is running\");\n    }\n}"
    },
    {
      "type": "link-grid",
      "title": "Related Topics",
      "links": [
        {
		  "label": "Command Creation", 
		  "url": "command-creation"},
        {
		  "label": "Command Requirements", 
		  "url": "command-requirements"},
        {
		  "label": "Default Commands", 
		  "url": "default-commands"}
      ]
    }
  ]
}

