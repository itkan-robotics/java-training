{
  "title": "Command Groups",
  "sections": [
    {
      "type": "text",
      "title": "Introduction to Command Groups",
      "content": "Command groups allow you to compose multiple commands into complex behaviors. They enable you to run commands sequentially (one after another), in parallel (simultaneously), or in combinations of both. Command groups are essential for building autonomous routines and coordinating multiple mechanisms.<br><br>Command groups are commands themselves, so they can be scheduled, interrupted, and composed with other commands. This makes them powerful building blocks for complex robot behaviors. Learn more: <a href='https://docs.wpilib.org/en/stable/docs/software/commandbased/command-groups.html' target='_blank'>WPILib: Command Groups</a>"
    },
    {
      "type": "rules-box",
      "title": "Command Group Types",
      "subtitle": "Available command group types:",
      "items": [
        "<strong>SequentialCommandGroup:</strong> Commands execute one after another",
        "<strong>ParallelCommandGroup:</strong> Commands execute simultaneously",
        "<strong>ParallelRaceGroup:</strong> Commands run in parallel, first to finish ends group",
        "<strong>ParallelDeadlineGroup:</strong> Commands run in parallel, ends when deadline command finishes",
        "<strong>Command Decorators:</strong> Modify command behavior (timeout, interrupt, repeat)"
      ]
    },
    {
      "type": "text",
      "title": "Sequential Command Groups",
      "content": "Sequential command groups execute commands one after another. Each command must finish before the next command starts. This is perfect for autonomous routines where actions must happen in order.<br><br><strong>How It Works:</strong> The group schedules the first command. When that command finishes, it schedules the next command. This continues until all commands have executed.<br><br><strong>Use Cases:</strong> Autonomous routines (drive forward, then turn, then extend arm), multi-step operations (pick up game piece, then move to scoring position, then score), or any sequence of actions that must happen in order.<br><br><strong>Requirements:</strong> A sequential group requires all subsystems required by any of its commands. Commands in the sequence can share subsystems since they run one at a time."
    },
    {
      "type": "code",
      "title": "Sequential Command Group Example",
      "content": "package frc.robot.commands.auto;\n\nimport edu.wpi.first.wpilibj2.command.SequentialCommandGroup;\nimport edu.wpi.first.wpilibj2.command.WaitCommand;\nimport frc.robot.commands.DriveForwardCommand;\nimport frc.robot.commands.TurnCommand;\nimport frc.robot.commands.MoveArmCommand;\nimport frc.robot.subsystems.Drivetrain;\nimport frc.robot.subsystems.Arm;\n\npublic class SimpleAutonomousRoutine extends SequentialCommandGroup {\n    public SimpleAutonomousRoutine(Drivetrain drivetrain, Arm arm) {\n        // Add commands in the order they should execute\n        addCommands(\n            // Drive forward for 2 seconds\n            new DriveForwardCommand(drivetrain, 0.5).withTimeout(2.0),\n            \n            // Wait 0.5 seconds\n            new WaitCommand(0.5),\n            \n            // Turn 90 degrees\n            new TurnCommand(drivetrain, 90),\n            \n            // Move arm to scoring position\n            new MoveArmCommand(arm, 45.0),\n            \n            // Wait 1 second\n            new WaitCommand(1.0),\n            \n            // Drive forward again\n            new DriveForwardCommand(drivetrain, 0.5).withTimeout(1.0)\n        );\n        \n        // This group requires both drivetrain and arm\n        // (inherited from the commands it contains)\n    }\n}"
    },
    {
      "type": "text",
      "title": "Parallel Command Groups",
      "content": "Parallel command groups execute multiple commands simultaneously. All commands start at the same time and run concurrently. The group finishes when all commands finish.<br><br><strong>How It Works:</strong> The group schedules all commands at once. They all run in parallel, sharing the scheduler's execution time. The group finishes when every command has finished.<br><br><strong>Use Cases:</strong> Operating multiple mechanisms at once (intake while driving, extend arm while moving elevator), performing simultaneous actions (shoot while moving, intake while positioning), or any scenario where multiple independent actions should happen together.<br><br><strong>Requirements:</strong> Commands in a parallel group cannot require the same subsystems. They must use different subsystems since they run simultaneously. If commands share subsystems, use a sequential group instead."
    },
    {
      "type": "code",
      "title": "Parallel Command Group Example",
      "content": "package frc.robot.commands.auto;\n\nimport edu.wpi.first.wpilibj2.command.ParallelCommandGroup;\nimport frc.robot.commands.MoveElevatorCommand;\nimport frc.robot.commands.MoveArmCommand;\nimport frc.robot.commands.RunIntakeCommand;\nimport frc.robot.subsystems.Elevator;\nimport frc.robot.subsystems.Arm;\nimport frc.robot.subsystems.Intake;\n\npublic class PrepareForScoringCommand extends ParallelCommandGroup {\n    public PrepareForScoringCommand(Elevator elevator, Arm arm, Intake intake) {\n        // All commands start simultaneously\n        addCommands(\n            // Move elevator to scoring height\n            new MoveElevatorCommand(elevator, 36.0, 0.5, 0.5),\n            \n            // Move arm to scoring angle\n            new MoveArmCommand(arm, 60.0, 0.3, 2.0),\n            \n            // Run intake to hold game piece\n            new RunIntakeCommand(intake, 0.2)\n        );\n        \n        // All three mechanisms operate simultaneously\n        // Group finishes when all three commands finish\n        // Note: Each command must use a different subsystem\n    }\n}"
    },
    {
      "type": "text",
      "title": "Parallel Race Groups",
      "content": "Parallel race groups execute commands in parallel, but the group finishes when the first command finishes. All other commands are interrupted when the first one completes.<br><br><strong>How It Works:</strong> All commands start simultaneously. As soon as any command finishes, the group ends and interrupts all remaining commands.<br><br><strong>Use Cases:</strong> Timeout scenarios (drive until sensor detects something, then stop), race conditions (first mechanism to finish wins), or any scenario where you want to stop as soon as one condition is met.<br><br><strong>Example:</strong> Drive forward until a sensor detects a game piece, then stop. The drive command and sensor check command run in parallel, and the group ends when the sensor detects the piece."
    },
    {
      "type": "code",
      "title": "Parallel Race Group Example",
      "content": "package frc.robot.commands.auto;\n\nimport edu.wpi.first.wpilibj2.command.ParallelRaceGroup;\nimport frc.robot.commands.DriveForwardCommand;\nimport frc.robot.commands.WaitForGamePieceCommand;\nimport frc.robot.subsystems.Drivetrain;\nimport frc.robot.subsystems.Intake;\n\npublic class DriveUntilGamePieceCommand extends ParallelRaceGroup {\n    public DriveUntilGamePieceCommand(Drivetrain drivetrain, Intake intake) {\n        // Both commands start simultaneously\n        addCommands(\n            // Drive forward (runs until interrupted)\n            new DriveForwardCommand(drivetrain, 0.4),\n            \n            // Wait for game piece detection (finishes when detected)\n            new WaitForGamePieceCommand(intake)\n        );\n        \n        // When WaitForGamePieceCommand detects a game piece:\n        // 1. WaitForGamePieceCommand finishes\n        // 2. Group ends immediately\n        // 3. DriveForwardCommand is interrupted\n        // 4. Robot stops\n    }\n}"
    },
    {
      "type": "text",
      "title": "Parallel Deadline Groups",
      "content": "Parallel deadline groups execute commands in parallel, but the group finishes when a specific \"deadline\" command finishes. All other commands continue running until the deadline command completes, then they're interrupted.<br><br><strong>How It Works:</strong> All commands start simultaneously. The group monitors the deadline command. When the deadline command finishes, the group ends and interrupts all other commands.<br><br><strong>Use Cases:</strong> Coordinated actions (run intake for 3 seconds while driving, then stop both), timed operations (operate mechanism for specific duration while doing other things), or scenarios where one command determines when the group should end.<br><br><strong>Example:</strong> Drive forward while running intake for 5 seconds, then stop both. The 5-second wait is the deadline command."
    },
    {
      "type": "code",
      "title": "Parallel Deadline Group Example",
      "content": "package frc.robot.commands.auto;\n\nimport edu.wpi.first.wpilibj2.command.ParallelDeadlineGroup;\nimport edu.wpi.first.wpilibj2.command.WaitCommand;\nimport frc.robot.commands.DriveForwardCommand;\nimport frc.robot.commands.RunIntakeCommand;\nimport frc.robot.subsystems.Drivetrain;\nimport frc.robot.subsystems.Intake;\n\npublic class DriveAndIntakeForTimeCommand extends ParallelDeadlineGroup {\n    public DriveAndIntakeForTimeCommand(Drivetrain drivetrain, Intake intake, double duration) {\n        // Deadline command (determines when group ends)\n        super(new WaitCommand(duration));\n        \n        // Other commands (run until deadline finishes)\n        addCommands(\n            // Drive forward\n            new DriveForwardCommand(drivetrain, 0.5),\n            \n            // Run intake\n            new RunIntakeCommand(intake, 0.6)\n        );\n        \n        // When WaitCommand finishes (after duration):\n        // 1. Group ends\n        // 2. DriveForwardCommand is interrupted\n        // 3. RunIntakeCommand is interrupted\n        // 4. Both mechanisms stop\n    }\n}"
    },
    {
      "type": "text",
      "title": "Nested Command Groups",
      "content": "Command groups can contain other command groups, creating complex behaviors. This allows you to build sophisticated autonomous routines by composing simpler groups.<br><br><strong>Nesting Patterns:</strong> You can nest groups in various ways:<br>- Sequential group containing parallel groups (do multiple things at once, then do more things)<br>- Parallel group containing sequential groups (multiple sequences running simultaneously)<br>- Any combination that makes sense for your robot<br><br><strong>Benefits:</strong> Nesting allows you to break complex routines into manageable pieces, reuse command groups in different contexts, and build sophisticated behaviors from simple components."
    },
    {
      "type": "code",
      "title": "Nested Command Groups Example",
      "content": "package frc.robot.commands.auto;\n\nimport edu.wpi.first.wpilibj2.command.SequentialCommandGroup;\nimport edu.wpi.first.wpilibj2.command.ParallelCommandGroup;\nimport frc.robot.commands.DriveForwardCommand;\nimport frc.robot.commands.TurnCommand;\nimport frc.robot.commands.MoveElevatorCommand;\nimport frc.robot.commands.MoveArmCommand;\nimport frc.robot.subsystems.Drivetrain;\nimport frc.robot.subsystems.Elevator;\nimport frc.robot.subsystems.Arm;\n\npublic class ComplexAutonomousRoutine extends SequentialCommandGroup {\n    public ComplexAutonomousRoutine(Drivetrain drivetrain, Elevator elevator, Arm arm) {\n        addCommands(\n            // Step 1: Drive forward\n            new DriveForwardCommand(drivetrain, 0.5).withTimeout(2.0),\n            \n            // Step 2: Prepare mechanism (parallel - elevator and arm move together)\n            new ParallelCommandGroup(\n                new MoveElevatorCommand(elevator, 24.0, 0.5, 0.5),\n                new MoveArmCommand(arm, 45.0, 0.3, 2.0)\n            ),\n            \n            // Step 3: Turn\n            new TurnCommand(drivetrain, 90),\n            \n            // Step 4: Drive and prepare (parallel - drive while adjusting mechanism)\n            new ParallelCommandGroup(\n                new DriveForwardCommand(drivetrain, 0.4).withTimeout(3.0),\n                new SequentialCommandGroup(\n                    new MoveArmCommand(arm, 60.0, 0.3, 2.0),\n                    new MoveElevatorCommand(elevator, 36.0, 0.5, 0.5)\n                )\n            )\n        );\n    }\n}"
    },
    {
      "type": "text",
      "title": "Command Decorators",
      "content": "Command decorators modify command behavior without changing the command itself. They wrap commands with additional functionality like timeouts, interrupt conditions, or repetition.<br><br><strong>withTimeout(double seconds):</strong> Adds a timeout to a command. The command is interrupted if it doesn't finish within the specified time. Useful for preventing commands from running indefinitely.<br><br><strong>withInterrupt(Runnable interrupt):</strong> Adds an interrupt condition. The command is interrupted when the condition becomes true. Useful for stopping commands based on sensor readings or other conditions.<br><br><strong>repeatedly():</strong> Makes a command repeat indefinitely. When the command finishes, it immediately restarts. Useful for continuous operations.<br><br>Decorators can be chained to combine multiple behaviors."
    },
    {
      "type": "code",
      "title": "Command Decorators Usage",
      "content": "package frc.robot.commands;\n\nimport edu.wpi.first.wpilibj2.command.Command;\nimport frc.robot.subsystems.Drivetrain;\n\npublic class DecoratorExamples {\n    private Drivetrain m_drivetrain;\n    \n    public void demonstrateDecorators() {\n        Command baseCommand = new DriveForwardCommand(m_drivetrain, 0.5);\n        \n        // Add timeout (command stops after 3 seconds)\n        Command withTimeout = baseCommand.withTimeout(3.0);\n        \n        // Add interrupt condition\n        Command withInterrupt = baseCommand.withInterrupt(() -> {\n            // Interrupt if some condition is true\n            return m_drivetrain.getDistance() > 10.0;\n        });\n        \n        // Make command repeat\n        Command repeated = baseCommand.repeatedly();\n        \n        // Chain decorators\n        Command complex = baseCommand\n            .withTimeout(5.0)\n            .withInterrupt(() -> m_drivetrain.getDistance() > 8.0);\n    }\n}"
    },
    {
      "type": "text",
      "title": "Command Group Examples",
      "content": "Command groups are essential for building autonomous routines and coordinating mechanisms:<br><br><strong>Autonomous Routine:</strong> A sequential group that performs a series of actions in order (drive, turn, score, etc.). This is the most common use of command groups.<br><br><strong>Complex Mechanism Control:</strong> A parallel group that coordinates multiple mechanisms simultaneously (elevator and arm moving together, intake and drive operating together).<br><br><strong>Conditional Behaviors:</strong> Using race groups or deadline groups to create behaviors that respond to conditions (drive until sensor, operate for time, etc.)."
    },
    {
      "type": "code",
      "title": "Complete Autonomous Routine Example",
      "content": "package frc.robot.commands.auto;\n\nimport edu.wpi.first.wpilibj2.command.SequentialCommandGroup;\nimport edu.wpi.first.wpilibj2.command.ParallelCommandGroup;\nimport edu.wpi.first.wpilibj2.command.ParallelRaceGroup;\nimport edu.wpi.first.wpilibj2.command.WaitCommand;\nimport frc.robot.commands.*;\nimport frc.robot.subsystems.*;\n\npublic class CompleteAutonomousRoutine extends SequentialCommandGroup {\n    public CompleteAutonomousRoutine(\n            Drivetrain drivetrain,\n            Elevator elevator,\n            Arm arm,\n            Intake intake) {\n        \n        addCommands(\n            // Phase 1: Drive to game piece while preparing mechanism\n            new ParallelCommandGroup(\n                new DriveForwardCommand(drivetrain, 0.5).withTimeout(3.0),\n                new MoveElevatorCommand(elevator, 12.0, 0.5, 0.5),\n                new MoveArmCommand(arm, 30.0, 0.3, 2.0)\n            ),\n            \n            // Phase 2: Intake game piece (drive until detected)\n            new ParallelRaceGroup(\n                new DriveForwardCommand(drivetrain, 0.3),\n                new IntakeGamePieceCommand(intake, 0.6)\n            ),\n            \n            // Phase 3: Wait and prepare for scoring\n            new WaitCommand(0.5),\n            \n            new ParallelCommandGroup(\n                new MoveElevatorCommand(elevator, 36.0, 0.5, 0.5),\n                new MoveArmCommand(arm, 60.0, 0.3, 2.0)\n            ),\n            \n            // Phase 4: Drive to scoring position\n            new TurnCommand(drivetrain, 90),\n            new DriveForwardCommand(drivetrain, 0.4).withTimeout(2.0),\n            \n            // Phase 5: Score game piece\n            new ScoreGamePieceCommand(intake, 0.8).withTimeout(1.0)\n        );\n    }\n}"
    },
    {
      "type": "link-grid",
      "title": "Related Topics",
      "links": [
        {
		  "label": "Command Creation", 
		  "url": "command-creation"},
        {
		  "label": "Command Scheduler", 
		  "url": "command-scheduler"},
        {
		  "label": "Robot Container", 
		  "url": "robot-container"}
      ]
    }
  ]
}

