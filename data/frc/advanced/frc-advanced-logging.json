{
  "title": "Advanced Logging and Data Analysis",
  "sections": [
    {
      "type": "text",
      "title": "Introduction to Advanced Logging",
      "content": "Advanced logging goes beyond simple data recording to provide comprehensive insights into robot behavior, performance, and debugging information. This lesson covers sophisticated logging techniques that help teams understand and optimize their robots."
    },
    {
      "type": "rules-box",
      "title": "Advanced Logging Benefits",
      "items": [
        "<strong>Structured Data:</strong> Organized, searchable log data",
        "<strong>Performance Analysis:</strong> Detailed performance metrics and trends",
        "<strong>Debugging Support:</strong> Comprehensive error tracking and analysis",
        "<strong>Predictive Maintenance:</strong> Identify issues before they cause failures",
        "<strong>Competition Analysis:</strong> Understand match performance and strategy",
        "<strong>Team Learning:</strong> Share insights across team members"
      ],
      "subtitle": "Advanced logging provides:"
    },
    {
      "type": "text",
      "title": "Structured Logging Framework",
      "content": "A structured logging framework organizes data hierarchically and provides consistent formatting for easy analysis."
    },
    {
      "type": "code",
      "title": "Structured Logging Implementation",
      "content": "import java.util.HashMap;\nimport java.util.Map;\nimport java.util.concurrent.ConcurrentHashMap;\nimport edu.wpi.first.wpilibj.Timer;\n\npublic class StructuredLogger {\n  private final Map<String, Object> m_logData;\n  private final Timer m_timer;\n  private final String m_robotId;\n  private final String m_sessionId;\n  \n  public StructuredLogger(String robotId) {\n    m_logData = new ConcurrentHashMap<>();\n    m_timer = new Timer();\n    m_robotId = robotId;\n    m_sessionId = generateSessionId();\n    \n    // Initialize session data\n    logSessionStart();\n  }\n  \n  public void log(String category, String key, Object value) {\n    String fullKey = String.format(\"%s/%s\", category, key);\n    m_logData.put(fullKey, value);\n    \n    // Also log with timestamp\n    String timeKey = String.format(\"%s/%s_Time\", category, key);\n    m_logData.put(timeKey, m_timer.get());\n  }\n  \n  public void logEvent(String eventType, String description, Map<String, Object> data) {\n    String eventKey = String.format(\"Events/%s_%d\", eventType, (int)(m_timer.get() * 1000));\n    m_logData.put(eventKey + \"/Description\", description);\n    m_logData.put(eventKey + \"/Timestamp\", m_timer.get());\n    \n    if (data != null) {\n      for (Map.Entry<String, Object> entry : data.entrySet()) {\n        m_logData.put(eventKey + \"/\" + entry.getKey(), entry.getValue());\n      }\n    }\n  }\n  \n  public void logError(String errorType, String message, Exception exception) {\n    Map<String, Object> errorData = new HashMap<>();\n    errorData.put(\"Message\", message);\n    errorData.put(\"ExceptionType\", exception.getClass().getSimpleName());\n    errorData.put(\"StackTrace\", getStackTrace(exception));\n    \n    logEvent(\"ERROR\", errorType, errorData);\n  }\n  \n  public void logPerformance(String metric, double value, String unit) {\n    String perfKey = String.format(\"Performance/%s\", metric);\n    m_logData.put(perfKey + \"/Value\", value);\n    m_logData.put(perfKey + \"/Unit\", unit);\n    m_logData.put(perfKey + \"/Timestamp\", m_timer.get());\n  }\n  \n  private void logSessionStart() {\n    m_logData.put(\"Session/RobotId\", m_robotId);\n    m_logData.put(\"Session/SessionId\", m_sessionId);\n    m_logData.put(\"Session/StartTime\", m_timer.get());\n    m_logData.put(\"Session/Version\", \"1.0.0\");\n  }\n  \n  private String generateSessionId() {\n    return String.format(\"%s_%d\", m_robotId, System.currentTimeMillis());\n  }\n  \n  private String getStackTrace(Exception exception) {\n    StringBuilder sb = new StringBuilder();\n    for (StackTraceElement element : exception.getStackTrace()) {\n      sb.append(element.toString()).append(\"\\n\");\n    }\n    return sb.toString();\n  }\n  \n  public Map<String, Object> getLogData() {\n    return new HashMap<>(m_logData);\n  }\n}"
    },
    {
      "type": "text",
      "title": "Performance Monitoring",
      "content": "Advanced performance monitoring tracks detailed metrics about robot operation and identifies performance bottlenecks."
    },
    {
      "type": "code",
      "title": "Performance Monitoring System",
      "content": "public class PerformanceMonitor {\n  private final StructuredLogger m_logger;\n  private final Map<String, PerformanceMetric> m_metrics;\n  private final Timer m_timer;\n  \n  public PerformanceMonitor(StructuredLogger logger) {\n    m_logger = logger;\n    m_metrics = new HashMap<>();\n    m_timer = new Timer();\n  }\n  \n  public void startMetric(String name) {\n    PerformanceMetric metric = new PerformanceMetric();\n    metric.startTime = m_timer.get();\n    metric.name = name;\n    m_metrics.put(name, metric);\n  }\n  \n  public void endMetric(String name) {\n    PerformanceMetric metric = m_metrics.get(name);\n    if (metric != null) {\n      metric.endTime = m_timer.get();\n      metric.duration = metric.endTime - metric.startTime;\n      \n      // Log the metric\n      m_logger.log(\"Performance\", name + \"_Duration\", metric.duration);\n      m_logger.log(\"Performance\", name + \"_StartTime\", metric.startTime);\n      m_logger.log(\"Performance\", name + \"_EndTime\", metric.endTime);\n    }\n  }\n  \n  public void trackMemoryUsage() {\n    Runtime runtime = Runtime.getRuntime();\n    long totalMemory = runtime.totalMemory();\n    long freeMemory = runtime.freeMemory();\n    long usedMemory = totalMemory - freeMemory;\n    \n    m_logger.log(\"System\", \"Memory_Total\", totalMemory);\n    m_logger.log(\"System\", \"Memory_Free\", freeMemory);\n    m_logger.log(\"System\", \"Memory_Used\", usedMemory);\n    m_logger.log(\"System\", \"Memory_UsagePercent\", (double) usedMemory / totalMemory * 100.0);\n  }\n  \n  public void trackLoopTiming() {\n    static double lastLoopTime = 0.0;\n    double currentTime = m_timer.get();\n    double loopTime = currentTime - lastLoopTime;\n    \n    m_logger.log(\"System\", \"LoopTime\", loopTime);\n    m_logger.log(\"System\", \"LoopFrequency\", 1.0 / loopTime);\n    \n    lastLoopTime = currentTime;\n  }\n  \n  public static class PerformanceMetric {\n    public String name;\n    public double startTime;\n    public double endTime;\n    public double duration;\n  }\n}"
    },
    {
      "type": "text",
      "title": "Command and State Logging",
      "content": "Logging command execution and state transitions provides insights into robot behavior and helps debug autonomous sequences."
    },
    {
      "type": "code",
      "title": "Command and State Logging",
      "content": "import edu.wpi.first.wpilibj2.command.Command;\nimport edu.wpi.first.wpilibj2.command.CommandScheduler;\nimport java.util.Stack;\n\npublic class CommandLogger {\n  private final StructuredLogger m_logger;\n  private final Stack<String> m_commandStack;\n  private final Map<String, CommandInfo> m_commandInfo;\n  \n  public CommandLogger(StructuredLogger logger) {\n    m_logger = logger;\n    m_commandStack = new Stack<>();\n    m_commandInfo = new HashMap<>();\n  }\n  \n  public void logCommandStart(Command command) {\n    String commandName = command.getClass().getSimpleName();\n    double startTime = Timer.getFPGATimestamp();\n    \n    m_commandStack.push(commandName);\n    \n    CommandInfo info = new CommandInfo();\n    info.startTime = startTime;\n    info.command = command;\n    m_commandInfo.put(commandName, info);\n    \n    Map<String, Object> data = new HashMap<>();\n    data.put(\"CommandName\", commandName);\n    data.put(\"StartTime\", startTime);\n    data.put(\"CommandStackDepth\", m_commandStack.size());\n    \n    m_logger.logEvent(\"COMMAND_START\", \"Command started execution\", data);\n  }\n  \n  public void logCommandEnd(Command command, boolean interrupted) {\n    String commandName = command.getClass().getSimpleName();\n    double endTime = Timer.getFPGATimestamp();\n    \n    if (!m_commandStack.isEmpty() && m_commandStack.peek().equals(commandName)) {\n      m_commandStack.pop();\n    }\n    \n    CommandInfo info = m_commandInfo.get(commandName);\n    if (info != null) {\n      info.endTime = endTime;\n      info.duration = endTime - info.startTime;\n      info.interrupted = interrupted;\n    }\n    \n    Map<String, Object> data = new HashMap<>();\n    data.put(\"CommandName\", commandName);\n    data.put(\"EndTime\", endTime);\n    data.put(\"Duration\", info != null ? info.duration : 0.0);\n    data.put(\"Interrupted\", interrupted);\n    \n    m_logger.logEvent(\"COMMAND_END\", \"Command finished execution\", data);\n  }\n  \n  public void logStateTransition(String fromState, String toState, String reason) {\n    Map<String, Object> data = new HashMap<>();\n    data.put(\"FromState\", fromState);\n    data.put(\"ToState\", toState);\n    data.put(\"Reason\", reason);\n    data.put(\"Timestamp\", Timer.getFPGATimestamp());\n    \n    m_logger.logEvent(\"STATE_TRANSITION\", \"Robot state changed\", data);\n  }\n  \n  public static class CommandInfo {\n    public Command command;\n    public double startTime;\n    public double endTime;\n    public double duration;\n    public boolean interrupted;\n  }\n}"
    },
    {
      "type": "text",
      "title": "Error Tracking and Analysis",
      "content": "Comprehensive error tracking helps identify and resolve issues quickly, improving robot reliability."
    },
    {
      "type": "code",
      "title": "Error Tracking System",
      "content": "import java.util.concurrent.ConcurrentLinkedQueue;\nimport java.util.concurrent.atomic.AtomicInteger;\n\npublic class ErrorTracker {\n  private final StructuredLogger m_logger;\n  private final ConcurrentLinkedQueue<ErrorRecord> m_errors;\n  private final AtomicInteger m_errorCount;\n  private final Map<String, Integer> m_errorTypeCounts;\n  \n  public ErrorTracker(StructuredLogger logger) {\n    m_logger = logger;\n    m_errors = new ConcurrentLinkedQueue<>();\n    m_errorCount = new AtomicInteger(0);\n    m_errorTypeCounts = new HashMap<>();\n  }\n  \n  public void logError(String errorType, String message, Exception exception) {\n    ErrorRecord error = new ErrorRecord();\n    error.id = m_errorCount.incrementAndGet();\n    error.type = errorType;\n    error.message = message;\n    error.exception = exception;\n    error.timestamp = Timer.getFPGATimestamp();\n    error.robotState = getCurrentRobotState();\n    \n    m_errors.offer(error);\n    \n    // Update error type counts\n    m_errorTypeCounts.put(errorType, m_errorTypeCounts.getOrDefault(errorType, 0) + 1);\n    \n    // Log the error\n    Map<String, Object> errorData = new HashMap<>();\n    errorData.put(\"ErrorId\", error.id);\n    errorData.put(\"ErrorType\", error.type);\n    errorData.put(\"Message\", error.message);\n    errorData.put(\"ExceptionType\", exception != null ? exception.getClass().getSimpleName() : \"None\");\n    errorData.put(\"RobotState\", error.robotState);\n    \n    m_logger.logEvent(\"ERROR\", \"Error occurred\", errorData);\n  }\n  \n  public void logWarning(String warningType, String message) {\n    Map<String, Object> warningData = new HashMap<>();\n    warningData.put(\"WarningType\", warningType);\n    warningData.put(\"Message\", message);\n    warningData.put(\"RobotState\", getCurrentRobotState());\n    \n    m_logger.logEvent(\"WARNING\", \"Warning occurred\", warningData);\n  }\n  \n  public void logRecovery(String errorType, String recoveryAction) {\n    Map<String, Object> recoveryData = new HashMap<>();\n    recoveryData.put(\"ErrorType\", errorType);\n    recoveryData.put(\"RecoveryAction\", recoveryAction);\n    recoveryData.put(\"Timestamp\", Timer.getFPGATimestamp());\n    \n    m_logger.logEvent(\"RECOVERY\", \"Error recovery attempted\", recoveryData);\n  }\n  \n  public ErrorAnalysis analyzeErrors() {\n    ErrorAnalysis analysis = new ErrorAnalysis();\n    analysis.totalErrors = m_errorCount.get();\n    analysis.errorTypeCounts = new HashMap<>(m_errorTypeCounts);\n    \n    // Analyze error patterns\n    Map<String, Integer> recentErrors = new HashMap<>();\n    double cutoffTime = Timer.getFPGATimestamp() - 60.0; // Last minute\n    \n    for (ErrorRecord error : m_errors) {\n      if (error.timestamp > cutoffTime) {\n        recentErrors.put(error.type, recentErrors.getOrDefault(error.type, 0) + 1);\n      }\n    }\n    \n    analysis.recentErrors = recentErrors;\n    \n    // Identify most common errors\n    analysis.mostCommonError = m_errorTypeCounts.entrySet().stream()\n      .max(Map.Entry.comparingByValue())\n      .map(Map.Entry::getKey)\n      .orElse(\"None\");\n    \n    return analysis;\n  }\n  \n  private String getCurrentRobotState() {\n    // Return current robot state as a string\n    return \"Robot state placeholder\";\n  }\n  \n  public static class ErrorRecord {\n    public int id;\n    public String type;\n    public String message;\n    public Exception exception;\n    public double timestamp;\n    public String robotState;\n  }\n  \n  public static class ErrorAnalysis {\n    public int totalErrors;\n    public Map<String, Integer> errorTypeCounts;\n    public Map<String, Integer> recentErrors;\n    public String mostCommonError;\n  }\n}"
    },
    {
      "type": "text",
      "title": "Data Analysis and Reporting",
      "content": "Advanced data analysis tools help extract meaningful insights from logged data and generate reports for team review."
    },
    {
      "type": "code",
      "title": "Data Analysis System",
      "content": "import java.util.List;\nimport java.util.ArrayList;\nimport java.util.stream.Collectors;\n\npublic class DataAnalyzer {\n  private final StructuredLogger m_logger;\n  \n  public DataAnalyzer(StructuredLogger logger) {\n    m_logger = logger;\n  }\n  \n  public PerformanceReport generatePerformanceReport() {\n    Map<String, Object> logData = m_logger.getLogData();\n    PerformanceReport report = new PerformanceReport();\n    \n    // Analyze performance metrics\n    report.averageLoopTime = calculateAverageLoopTime(logData);\n    report.maxLoopTime = calculateMaxLoopTime(logData);\n    report.memoryUsage = calculateAverageMemoryUsage(logData);\n    report.commandExecutionStats = analyzeCommandExecution(logData);\n    report.errorStats = analyzeErrorPatterns(logData);\n    \n    return report;\n  }\n  \n  public MatchAnalysis analyzeMatch(String matchId) {\n    Map<String, Object> logData = m_logger.getLogData();\n    MatchAnalysis analysis = new MatchAnalysis();\n    \n    analysis.matchId = matchId;\n    analysis.duration = calculateMatchDuration(logData);\n    analysis.autonomousScore = calculateAutonomousScore(logData);\n    analysis.teleopScore = calculateTeleopScore(logData);\n    analysis.performanceIssues = identifyPerformanceIssues(logData);\n    analysis.recommendations = generateRecommendations(logData);\n    \n    return analysis;\n  }\n  \n  public TrendAnalysis analyzeTrends(List<Map<String, Object>> historicalData) {\n    TrendAnalysis trends = new TrendAnalysis();\n    \n    // Analyze performance trends over time\n    trends.performanceTrend = analyzePerformanceTrend(historicalData);\n    trends.errorTrend = analyzeErrorTrend(historicalData);\n    trends.reliabilityTrend = analyzeReliabilityTrend(historicalData);\n    \n    return trends;\n  }\n  \n  private double calculateAverageLoopTime(Map<String, Object> data) {\n    // Calculate average loop time from logged data\n    List<Double> loopTimes = extractValues(data, \"System/LoopTime\");\n    return loopTimes.stream().mapToDouble(Double::doubleValue).average().orElse(0.0);\n  }\n  \n  private double calculateMaxLoopTime(Map<String, Object> data) {\n    List<Double> loopTimes = extractValues(data, \"System/LoopTime\");\n    return loopTimes.stream().mapToDouble(Double::doubleValue).max().orElse(0.0);\n  }\n  \n  private double calculateAverageMemoryUsage(Map<String, Object> data) {\n    List<Double> memoryUsage = extractValues(data, \"System/Memory_UsagePercent\");\n    return memoryUsage.stream().mapToDouble(Double::doubleValue).average().orElse(0.0);\n  }\n  \n  private CommandExecutionStats analyzeCommandExecution(Map<String, Object> data) {\n    CommandExecutionStats stats = new CommandExecutionStats();\n    \n    // Analyze command execution patterns\n    List<String> commandEvents = extractEvents(data, \"COMMAND_START\");\n    stats.totalCommands = commandEvents.size();\n    stats.averageCommandDuration = calculateAverageCommandDuration(data);\n    stats.mostExecutedCommand = findMostExecutedCommand(data);\n    \n    return stats;\n  }\n  \n  private ErrorStats analyzeErrorPatterns(Map<String, Object> data) {\n    ErrorStats stats = new ErrorStats();\n    \n    // Analyze error patterns\n    List<String> errorEvents = extractEvents(data, \"ERROR\");\n    stats.totalErrors = errorEvents.size();\n    stats.errorRate = calculateErrorRate(data);\n    stats.mostCommonError = findMostCommonError(data);\n    \n    return stats;\n  }\n  \n  private List<Double> extractValues(Map<String, Object> data, String keyPattern) {\n    return data.entrySet().stream()\n      .filter(entry -> entry.getKey().contains(keyPattern))\n      .filter(entry -> entry.getValue() instanceof Number)\n      .map(entry -> ((Number) entry.getValue()).doubleValue())\n      .collect(Collectors.toList());\n  }\n  \n  private List<String> extractEvents(Map<String, Object> data, String eventType) {\n    return data.entrySet().stream()\n      .filter(entry -> entry.getKey().contains(\"Events/\" + eventType))\n      .map(entry -> entry.getValue().toString())\n      .collect(Collectors.toList());\n  }\n  \n  // Placeholder methods for analysis calculations\n  private double calculateAverageCommandDuration(Map<String, Object> data) { return 0.0; }\n  private String findMostExecutedCommand(Map<String, Object> data) { return \"Unknown\"; }\n  private double calculateErrorRate(Map<String, Object> data) { return 0.0; }\n  private String findMostCommonError(Map<String, Object> data) { return \"Unknown\"; }\n  private double calculateMatchDuration(Map<String, Object> data) { return 0.0; }\n  private int calculateAutonomousScore(Map<String, Object> data) { return 0; }\n  private int calculateTeleopScore(Map<String, Object> data) { return 0; }\n  private List<String> identifyPerformanceIssues(Map<String, Object> data) { return new ArrayList<>(); }\n  private List<String> generateRecommendations(Map<String, Object> data) { return new ArrayList<>(); }\n  private String analyzePerformanceTrend(List<Map<String, Object>> data) { return \"Stable\"; }\n  private String analyzeErrorTrend(List<Map<String, Object>> data) { return \"Decreasing\"; }\n  private String analyzeReliabilityTrend(List<Map<String, Object>> data) { return \"Improving\"; }\n  \n  public static class PerformanceReport {\n    public double averageLoopTime;\n    public double maxLoopTime;\n    public double memoryUsage;\n    public CommandExecutionStats commandExecutionStats;\n    public ErrorStats errorStats;\n  }\n  \n  public static class CommandExecutionStats {\n    public int totalCommands;\n    public double averageCommandDuration;\n    public String mostExecutedCommand;\n  }\n  \n  public static class ErrorStats {\n    public int totalErrors;\n    public double errorRate;\n    public String mostCommonError;\n  }\n  \n  public static class MatchAnalysis {\n    public String matchId;\n    public double duration;\n    public int autonomousScore;\n    public int teleopScore;\n    public List<String> performanceIssues;\n    public List<String> recommendations;\n  }\n  \n  public static class TrendAnalysis {\n    public String performanceTrend;\n    public String errorTrend;\n    public String reliabilityTrend;\n  }\n}"
    },
    {
      "type": "text",
      "title": "Logging Best Practices",
      "content": "Effective logging requires careful planning and consistent implementation."
    },
    {
      "type": "list",
      "title": "Best Practices",
      "items": [
        "<strong>Define Logging Strategy:</strong> Plan what data to log and why",
        "<strong>Use Consistent Naming:</strong> Follow naming conventions for log entries",
        "<strong>Include Context:</strong> Log relevant context with each entry",
        "<strong>Manage Log Volume:</strong> Balance detail with performance impact",
        "<strong>Secure Sensitive Data:</strong> Avoid logging sensitive information",
        "<strong>Regular Analysis:</strong> Regularly analyze logged data for insights"
      ]
    },
    {
      "type": "rules-box",
      "title": "Implementation Guidelines",
      "items": [
        "Start with a clear logging strategy and objectives",
        "Implement structured logging from the beginning",
        "Use appropriate log levels (DEBUG, INFO, WARNING, ERROR)",
        "Include timestamps and context with all log entries",
        "Regularly review and analyze logged data",
        "Use logging insights to drive robot improvements"
      ],
      "subtitle": "Follow these guidelines for effective advanced logging:"
    },
    {
      "type": "exercise-box",
      "title": "Practice Exercise",
      "description": "Implement a comprehensive logging system with performance monitoring and error tracking.",
      "tasks": [
        "Set up a structured logging framework",
        "Implement performance monitoring for key robot systems",
        "Add command and state transition logging",
        "Create an error tracking and analysis system",
        "Build data analysis tools for generating reports",
        "Test the logging system and analyze the results"
      ],
      "content": "// Complete advanced logging example\npublic class AdvancedLoggingRobot extends TimedRobot {\n  private final StructuredLogger m_logger;\n  private final PerformanceMonitor m_performanceMonitor;\n  private final CommandLogger m_commandLogger;\n  private final ErrorTracker m_errorTracker;\n  private final DataAnalyzer m_dataAnalyzer;\n  \n  public AdvancedLoggingRobot() {\n    m_logger = new StructuredLogger(\"Robot2025\");\n    m_performanceMonitor = new PerformanceMonitor(m_logger);\n    m_commandLogger = new CommandLogger(m_logger);\n    m_errorTracker = new ErrorTracker(m_logger);\n    m_dataAnalyzer = new DataAnalyzer(m_logger);\n  }\n  \n  @Override\n  public void robotInit() {\n    try {\n      m_performanceMonitor.startMetric(\"RobotInit\");\n      \n      // Initialize robot systems\n      initializeSystems();\n      \n      m_performanceMonitor.endMetric(\"RobotInit\");\n      m_logger.logEvent(\"ROBOT_INIT\", \"Robot initialization completed\", null);\n      \n    } catch (Exception e) {\n      m_errorTracker.logError(\"INIT_ERROR\", \"Robot initialization failed\", e);\n    }\n  }\n  \n  @Override\n  public void robotPeriodic() {\n    try {\n      m_performanceMonitor.startMetric(\"RobotPeriodic\");\n      \n      // Track system performance\n      m_performanceMonitor.trackMemoryUsage();\n      m_performanceMonitor.trackLoopTiming();\n      \n      // Log robot state\n      logRobotState();\n      \n      m_performanceMonitor.endMetric(\"RobotPeriodic\");\n      \n    } catch (Exception e) {\n      m_errorTracker.logError(\"PERIODIC_ERROR\", \"Robot periodic execution failed\", e);\n    }\n  }\n  \n  @Override\n  public void disabledInit() {\n    m_logger.logEvent(\"MODE_CHANGE\", \"Robot entered disabled mode\", null);\n  }\n  \n  @Override\n  public void autonomousInit() {\n    m_logger.logEvent(\"MODE_CHANGE\", \"Robot entered autonomous mode\", null);\n  }\n  \n  @Override\n  public void teleopInit() {\n    m_logger.logEvent(\"MODE_CHANGE\", \"Robot entered teleop mode\", null);\n  }\n  \n  private void initializeSystems() {\n    // Initialize robot subsystems\n    // This would include actual robot hardware initialization\n  }\n  \n  private void logRobotState() {\n    // Log current robot state\n    m_logger.log(\"Robot\", \"Enabled\", DriverStation.isEnabled());\n    m_logger.log(\"Robot\", \"Mode\", getCurrentMode());\n    m_logger.log(\"Robot\", \"MatchTime\", DriverStation.getMatchTime());\n  }\n  \n  private String getCurrentMode() {\n    if (DriverStation.isAutonomous()) return \"Autonomous\";\n    if (DriverStation.isTeleop()) return \"Teleop\";\n    if (DriverStation.isTest()) return \"Test\";\n    return \"Disabled\";\n  }\n  \n  public void generateReport() {\n    PerformanceReport report = m_dataAnalyzer.generatePerformanceReport();\n    \n    // Log the report\n    m_logger.log(\"Report/AverageLoopTime\", report.averageLoopTime);\n    m_logger.log(\"Report/MaxLoopTime\", report.maxLoopTime);\n    m_logger.log(\"Report/MemoryUsage\", report.memoryUsage);\n    m_logger.log(\"Report/TotalCommands\", report.commandExecutionStats.totalCommands);\n    m_logger.log(\"Report/TotalErrors\", report.errorStats.totalErrors);\n  }\n}"
    },
    {
      "type": "text",
      "title": "Next Steps",
      "content": "Now that you understand advanced logging, you're ready to learn about robot simulation, which allows you to test and validate your robot code without physical hardware."
    }
  ]
}
