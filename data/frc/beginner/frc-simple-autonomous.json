{
  "title": "Simple Autonomous Programming",
  "sections": [
    {
      "type": "text",
      "title": "Understanding FRC Autonomous",
      "content": "The autonomous period is the first 15 seconds of an FRC match where your robot operates independently. Creating effective autonomous routines is crucial for competitive success."
    },
    {
      "type": "rules-box",
      "title": "Autonomous Period Basics",
      "items": [
        "<strong>Duration:</strong> 15 seconds of independent operation",
        "<strong>Scoring:</strong> Points earned during autonomous count toward final score",
        "<strong>Strategy:</strong> Autonomous performance can determine match outcome",
        "<strong>Reliability:</strong> Autonomous must work consistently every time",
        "<strong>Simplicity:</strong> Start simple and add complexity gradually"
      ],
      "subtitle": "Key aspects of FRC autonomous:"
    },
    {
      "type": "text",
      "title": "Time-Based Autonomous",
      "content": "Time-based autonomous uses the match timer to execute different actions at specific times. This is the simplest approach and good for beginners."
    },
    {
      "type": "code",
      "title": "Basic Time-Based Autonomous",
      "content": "public class Robot extends TimedRobot {\n    // ... existing subsystem declarations ...\n    \n    // Autonomous state\n    private boolean m_autonomousComplete = false;\n    \n    @Override\n    public void autonomousInit() {\n        // Reset autonomous state\n        m_autonomousComplete = false;\n        \n        // Reset sensors\n        m_drivetrain.resetEncoders();\n        m_drivetrain.resetGyro();\n        \n        // Initialize mechanisms\n        m_arm.moveToAngle(0); // Move arm to starting position\n        m_intake.stop();\n        \n        SmartDashboard.putString(\"Autonomous Status\", \"Initialized\");\n    }\n    \n    @Override\n    public void autonomousPeriodic() {\n        if (!m_autonomousComplete) {\n            runTimeBasedAutonomous();\n        }\n    }\n    \n    private void runTimeBasedAutonomous() {\n        double matchTime = DriverStation.getMatchTime();\n        \n        if (matchTime > 13.0) {\n            // Phase 1: Drive forward (0-2 seconds)\n            SmartDashboard.putString(\"Auto Phase\", \"Driving Forward\");\n            m_drivetrain.arcadeDrive(0.5, 0.0);\n            \n        } else if (matchTime > 11.0) {\n            // Phase 2: Turn right (2-4 seconds)\n            SmartDashboard.putString(\"Auto Phase\", \"Turning Right\");\n            m_drivetrain.arcadeDrive(0.0, 0.5);\n            \n        } else if (matchTime > 9.0) {\n            // Phase 3: Drive forward again (4-6 seconds)\n            SmartDashboard.putString(\"Auto Phase\", \"Driving Forward Again\");\n            m_drivetrain.arcadeDrive(0.3, 0.0);\n            \n        } else if (matchTime > 7.0) {\n            // Phase 4: Move arm to scoring position (6-8 seconds)\n            SmartDashboard.putString(\"Auto Phase\", \"Moving Arm\");\n            m_drivetrain.stop();\n            m_arm.moveToAngle(45);\n            \n        } else if (matchTime > 5.0) {\n            // Phase 5: Intake game elements (8-10 seconds)\n            SmartDashboard.putString(\"Auto Phase\", \"Intaking\");\n            m_intake.intake();\n            \n        } else if (matchTime > 3.0) {\n            // Phase 6: Move arm to scoring position (10-12 seconds)\n            SmartDashboard.putString(\"Auto Phase\", \"Moving Arm to Score\");\n            m_intake.stop();\n            m_arm.moveToAngle(90);\n            \n        } else if (matchTime > 1.0) {\n            // Phase 7: Outtake to score (12-14 seconds)\n            SmartDashboard.putString(\"Auto Phase\", \"Scoring\");\n            m_intake.outtake();\n            \n        } else {\n            // Phase 8: Stop everything (14-15 seconds)\n            SmartDashboard.putString(\"Auto Phase\", \"Complete\");\n            m_drivetrain.stop();\n            m_arm.stop();\n            m_intake.stop();\n            m_autonomousComplete = true;\n        }\n        \n        // Update dashboard\n        SmartDashboard.putNumber(\"Auto Time Remaining\", matchTime);\n        SmartDashboard.putNumber(\"Auto Phase Number\", (15 - matchTime) / 2);\n    }\n}"
    },
    {
      "type": "text",
      "title": "State-Based Autonomous",
      "content": "State-based autonomous uses a state machine to transition between different behaviors based on conditions rather than just time. This is more flexible and reliable."
    },
    {
      "type": "code",
      "title": "State-Based Autonomous Implementation",
      "content": "public class Robot extends TimedRobot {\n    // ... existing subsystem declarations ...\n    \n    // Autonomous state machine\n    private enum AutoState {\n        INIT, DRIVE_FORWARD, TURN_RIGHT, DRIVE_TO_TARGET, \n        MOVE_ARM_UP, INTAKE_BALL, MOVE_ARM_SCORE, SCORE_BALL, COMPLETE\n    }\n    \n    private AutoState m_autoState = AutoState.INIT;\n    private double m_stateStartTime = 0.0;\n    private boolean m_autonomousComplete = false;\n    \n    @Override\n    public void autonomousInit() {\n        // Reset state\n        m_autoState = AutoState.INIT;\n        m_stateStartTime = DriverStation.getMatchTime();\n        m_autonomousComplete = false;\n        \n        // Reset sensors\n        m_drivetrain.resetEncoders();\n        m_drivetrain.resetGyro();\n        \n        SmartDashboard.putString(\"Autonomous Status\", \"State Machine Initialized\");\n    }\n    \n    @Override\n    public void autonomousPeriodic() {\n        if (!m_autonomousComplete) {\n            runStateBasedAutonomous();\n        }\n    }\n    \n    private void runStateBasedAutonomous() {\n        double currentTime = DriverStation.getMatchTime();\n        double stateTime = m_stateStartTime - currentTime;\n        \n        switch (m_autoState) {\n            case INIT:\n                // Initialize mechanisms\n                m_arm.moveToAngle(0);\n                m_intake.stop();\n                m_drivetrain.stop();\n                \n                // Wait for initialization\n                if (stateTime > 0.5) {\n                    nextState(AutoState.DRIVE_FORWARD);\n                }\n                break;\n                \n            case DRIVE_FORWARD:\n                // Drive forward for 2 seconds or until target distance\n                m_drivetrain.arcadeDrive(0.5, 0.0);\n                \n                if (stateTime > 2.0 || m_drivetrain.getAverageDistance() > 60) {\n                    nextState(AutoState.TURN_RIGHT);\n                }\n                break;\n                \n            case TURN_RIGHT:\n                // Turn right until facing target direction\n                m_drivetrain.arcadeDrive(0.0, 0.5);\n                \n                if (Math.abs(m_drivetrain.getGyroAngle() - 90) < 5) {\n                    nextState(AutoState.DRIVE_TO_TARGET);\n                }\n                break;\n                \n            case DRIVE_TO_TARGET:\n                // Drive toward target while maintaining heading\n                double gyroError = m_drivetrain.getGyroAngle() - 90;\n                double turnCorrection = gyroError * 0.02;\n                m_drivetrain.arcadeDrive(0.3, turnCorrection);\n                \n                // Check if we're close to target (using ultrasonic)\n                if (m_intake.getDistance() < 12) {\n                    nextState(AutoState.MOVE_ARM_UP);\n                }\n                break;\n                \n            case MOVE_ARM_UP:\n                // Stop driving and move arm to intake position\n                m_drivetrain.stop();\n                m_arm.moveToAngle(45);\n                \n                if (m_arm.isAtAngle(45, 2)) {\n                    nextState(AutoState.INTAKE_BALL);\n                }\n                break;\n                \n            case INTAKE_BALL:\n                // Intake ball\n                m_intake.intake();\n                \n                // Intake for 2 seconds or until ball detected\n                if (stateTime > 2.0 || m_intake.isBallDetected()) {\n                    nextState(AutoState.MOVE_ARM_SCORE);\n                }\n                break;\n                \n            case MOVE_ARM_SCORE:\n                // Stop intake and move arm to scoring position\n                m_intake.stop();\n                m_arm.moveToAngle(90);\n                \n                if (m_arm.isAtAngle(90, 2)) {\n                    nextState(AutoState.SCORE_BALL);\n                }\n                break;\n                \n            case SCORE_BALL:\n                // Score the ball\n                m_intake.outtake();\n                \n                // Score for 1 second\n                if (stateTime > 1.0) {\n                    nextState(AutoState.COMPLETE);\n                }\n                break;\n                \n            case COMPLETE:\n                // Stop everything\n                m_drivetrain.stop();\n                m_arm.stop();\n                m_intake.stop();\n                m_autonomousComplete = true;\n                break;\n        }\n        \n        // Update dashboard\n        SmartDashboard.putString(\"Auto State\", m_autoState.toString());\n        SmartDashboard.putNumber(\"State Time\", stateTime);\n        SmartDashboard.putNumber(\"Auto Time Remaining\", currentTime);\n    }\n    \n    private void nextState(AutoState newState) {\n        m_autoState = newState;\n        m_stateStartTime = DriverStation.getMatchTime();\n        SmartDashboard.putString(\"Auto State Change\", newState.toString());\n    }\n}"
    },
    {
      "type": "text",
      "title": "Autonomous Selection",
      "content": "Many FRC robots need different autonomous routines for different starting positions or strategies. Implementing autonomous selection allows drivers to choose the appropriate routine."
    },
    {
      "type": "code",
      "title": "Autonomous Selection System",
      "content": "public class Robot extends TimedRobot {\n    // ... existing subsystem declarations ...\n    \n    // Autonomous selection\n    private enum AutoRoutine {\n        DO_NOTHING, SIMPLE_DRIVE, SCORE_AND_DRIVE, COMPLEX_ROUTINE\n    }\n    \n    private AutoRoutine m_selectedRoutine = AutoRoutine.SIMPLE_DRIVE;\n    private boolean m_autoRoutineSelected = false;\n    \n    @Override\n    public void robotInit() {\n        // ... existing initialization ...\n        \n        // Set default autonomous routine\n        SmartDashboard.putString(\"Auto Routine\", m_selectedRoutine.toString());\n    }\n    \n    @Override\n    public void robotPeriodic() {\n        // ... existing periodic code ...\n        \n        // Allow autonomous selection during disabled\n        if (DriverStation.isDisabled()) {\n            updateAutonomousSelection();\n        }\n    }\n    \n    private void updateAutonomousSelection() {\n        // Read autonomous selection from SmartDashboard\n        String selectedRoutine = SmartDashboard.getString(\"Auto Routine\", \"SIMPLE_DRIVE\");\n        \n        try {\n            AutoRoutine newRoutine = AutoRoutine.valueOf(selectedRoutine);\n            if (newRoutine != m_selectedRoutine) {\n                m_selectedRoutine = newRoutine;\n                SmartDashboard.putString(\"Auto Status\", \"Routine Selected: \" + m_selectedRoutine);\n            }\n        } catch (IllegalArgumentException e) {\n            SmartDashboard.putString(\"Auto Status\", \"Invalid Routine: \" + selectedRoutine);\n        }\n    }\n    \n    @Override\n    public void autonomousInit() {\n        // Reset autonomous state\n        m_autoRoutineSelected = false;\n        \n        // Initialize based on selected routine\n        switch (m_selectedRoutine) {\n            case DO_NOTHING:\n                SmartDashboard.putString(\"Auto Status\", \"Do Nothing Routine\");\n                break;\n            case SIMPLE_DRIVE:\n                SmartDashboard.putString(\"Auto Status\", \"Simple Drive Routine\");\n                break;\n            case SCORE_AND_DRIVE:\n                SmartDashboard.putString(\"Auto Status\", \"Score and Drive Routine\");\n                break;\n            case COMPLEX_ROUTINE:\n                SmartDashboard.putString(\"Auto Status\", \"Complex Routine\");\n                break;\n        }\n    }\n    \n    @Override\n    public void autonomousPeriodic() {\n        // Run selected autonomous routine\n        switch (m_selectedRoutine) {\n            case DO_NOTHING:\n                runDoNothingAutonomous();\n                break;\n            case SIMPLE_DRIVE:\n                runSimpleDriveAutonomous();\n                break;\n            case SCORE_AND_DRIVE:\n                runScoreAndDriveAutonomous();\n                break;\n            case COMPLEX_ROUTINE:\n                runComplexAutonomous();\n                break;\n        }\n    }\n    \n    private void runDoNothingAutonomous() {\n        // Do nothing - robot stays still\n        m_drivetrain.stop();\n        m_arm.stop();\n        m_intake.stop();\n        \n        SmartDashboard.putString(\"Auto Phase\", \"Doing Nothing\");\n    }\n    \n    private void runSimpleDriveAutonomous() {\n        // Simple time-based autonomous\n        double matchTime = DriverStation.getMatchTime();\n        \n        if (matchTime > 13.0) {\n            m_drivetrain.arcadeDrive(0.5, 0.0);\n        } else {\n            m_drivetrain.stop();\n        }\n        \n        SmartDashboard.putString(\"Auto Phase\", \"Simple Drive\");\n    }\n    \n    private void runScoreAndDriveAutonomous() {\n        // More complex routine with scoring\n        double matchTime = DriverStation.getMatchTime();\n        \n        if (matchTime > 13.0) {\n            // Drive forward\n            m_drivetrain.arcadeDrive(0.5, 0.0);\n        } else if (matchTime > 11.0) {\n            // Turn\n            m_drivetrain.arcadeDrive(0.0, 0.5);\n        } else if (matchTime > 9.0) {\n            // Move arm and score\n            m_drivetrain.stop();\n            m_arm.moveToAngle(45);\n            m_intake.outtake();\n        } else {\n            // Stop\n            m_drivetrain.stop();\n            m_arm.stop();\n            m_intake.stop();\n        }\n        \n        SmartDashboard.putString(\"Auto Phase\", \"Score and Drive\");\n    }\n    \n    private void runComplexAutonomous() {\n        // Use state-based autonomous\n        if (!m_autoRoutineSelected) {\n            // Initialize state machine\n            m_autoRoutineSelected = true;\n        }\n        \n        // Run state-based autonomous (implementation from previous example)\n        runStateBasedAutonomous();\n    }\n}"
    },
    {
      "type": "text",
      "title": "Autonomous Testing and Debugging",
      "content": "Testing autonomous routines is crucial for reliability. Use simulation, practice fields, and systematic testing to ensure your autonomous works consistently."
    },
    {
      "type": "code",
      "title": "Autonomous Testing Framework",
      "content": "public class Robot extends TimedRobot {\n    // ... existing declarations ...\n    \n    // Testing and debugging\n    private boolean m_autoTestingMode = false;\n    private double m_testStartTime = 0.0;\n    \n    @Override\n    public void testInit() {\n        // Enable autonomous testing mode\n        m_autoTestingMode = true;\n        m_testStartTime = Timer.getFPGATimestamp();\n        \n        SmartDashboard.putString(\"Test Status\", \"Autonomous Testing Mode\");\n    }\n    \n    @Override\n    public void testPeriodic() {\n        if (m_autoTestingMode) {\n            runAutonomousTest();\n        }\n    }\n    \n    private void runAutonomousTest() {\n        double testTime = Timer.getFPGATimestamp() - m_testStartTime;\n        \n        // Simulate 15-second autonomous period\n        if (testTime < 15.0) {\n            // Run autonomous routine\n            autonomousPeriodic();\n            \n            // Display test information\n            SmartDashboard.putNumber(\"Test Time\", testTime);\n            SmartDashboard.putNumber(\"Simulated Match Time\", 15.0 - testTime);\n            \n        } else {\n            // Test complete\n            m_drivetrain.stop();\n            m_arm.stop();\n            m_intake.stop();\n            \n            SmartDashboard.putString(\"Test Status\", \"Autonomous Test Complete\");\n        }\n    }\n    \n    // Autonomous validation methods\n    public boolean validateAutonomousSetup() {\n        boolean isValid = true;\n        \n        // Check if all sensors are working\n        if (m_drivetrain.getGyroAngle() == 0 && m_drivetrain.getAverageDistance() == 0) {\n            SmartDashboard.putString(\"Auto Validation\", \"WARNING: Sensors may not be initialized\");\n            isValid = false;\n        }\n        \n        // Check if mechanisms are in safe positions\n        if (m_arm.isAtLowerLimit() || m_arm.isAtUpperLimit()) {\n            SmartDashboard.putString(\"Auto Validation\", \"WARNING: Arm at limit switch\");\n            isValid = false;\n        }\n        \n        // Check battery voltage\n        double batteryVoltage = DriverStation.getBatteryVoltage();\n        if (batteryVoltage < 11.0) {\n            SmartDashboard.putString(\"Auto Validation\", \"WARNING: Low battery voltage\");\n            isValid = false;\n        }\n        \n        if (isValid) {\n            SmartDashboard.putString(\"Auto Validation\", \"PASSED\");\n        }\n        \n        return isValid;\n    }\n    \n    @Override\n    public void autonomousInit() {\n        // ... existing initialization ...\n        \n        // Validate autonomous setup\n        if (!validateAutonomousSetup()) {\n            SmartDashboard.putString(\"Auto Status\", \"WARNING: Validation Failed\");\n        }\n    }\n}"
    },
    {
      "type": "rules-box",
      "title": "Autonomous Best Practices",
      "items": [
        "<strong>Start simple:</strong> Begin with basic movements and add complexity gradually",
        "<strong>Test thoroughly:</strong> Test autonomous routines extensively before competition",
        "<strong>Use sensors:</strong> Incorporate sensor feedback for more reliable behavior",
        "<strong>Handle failures:</strong> Implement fallback behaviors for sensor or mechanism failures",
        "<strong>Document routines:</strong> Keep clear documentation of what each routine does",
        "<strong>Practice deployment:</strong> Practice deploying and selecting autonomous routines"
      ],
      "subtitle": "Follow these guidelines for successful autonomous programming:"
    },
    {
      "type": "exercise-box",
      "title": "Autonomous Practice",
      "description": "Create and test various autonomous routines for your robot.",
      "tasks": [
        "Create a simple time-based autonomous that drives forward",
        "Implement a state-based autonomous with multiple phases",
        "Add sensor feedback to your autonomous routines",
        "Create an autonomous selection system",
        "Implement autonomous testing in test mode",
        "Add validation checks for autonomous setup",
        "Create multiple autonomous routines for different strategies",
        "Test autonomous reliability and consistency",
        "Add error handling and fallback behaviors",
        "Document your autonomous routines for team reference"
      ],
      "code": "// Example autonomous routine template:\n\nprivate void runExampleAutonomous() {\n    double matchTime = DriverStation.getMatchTime();\n    \n    // Phase 1: Initialize (0-1 seconds)\n    if (matchTime > 14.0) {\n        m_drivetrain.resetEncoders();\n        m_drivetrain.resetGyro();\n        m_arm.moveToAngle(0);\n        SmartDashboard.putString(\"Auto Phase\", \"Initializing\");\n        \n    // Phase 2: Drive to target (1-5 seconds)\n    } else if (matchTime > 10.0) {\n        double distance = m_drivetrain.getAverageDistance();\n        if (distance < 120) { // 10 feet\n            m_drivetrain.arcadeDrive(0.5, 0.0);\n        } else {\n            m_drivetrain.stop();\n        }\n        SmartDashboard.putString(\"Auto Phase\", \"Driving to Target\");\n        \n    // Phase 3: Align with target (5-8 seconds)\n    } else if (matchTime > 7.0) {\n        double gyroError = m_drivetrain.getGyroAngle();\n        double turnCorrection = gyroError * 0.02;\n        m_drivetrain.arcadeDrive(0.0, turnCorrection);\n        SmartDashboard.putString(\"Auto Phase\", \"Aligning\");\n        \n    // Phase 4: Score (8-12 seconds)\n    } else if (matchTime > 3.0) {\n        m_drivetrain.stop();\n        m_arm.moveToAngle(45);\n        m_intake.outtake();\n        SmartDashboard.putString(\"Auto Phase\", \"Scoring\");\n        \n    // Phase 5: Complete (12-15 seconds)\n    } else {\n        m_drivetrain.stop();\n        m_arm.stop();\n        m_intake.stop();\n        SmartDashboard.putString(\"Auto Phase\", \"Complete\");\n    }\n    \n    // Update dashboard\n    SmartDashboard.putNumber(\"Auto Time Remaining\", matchTime);\n    SmartDashboard.putNumber(\"Distance Traveled\", m_drivetrain.getAverageDistance());\n    SmartDashboard.putNumber(\"Gyro Angle\", m_drivetrain.getGyroAngle());\n}"
    }
  ]
}