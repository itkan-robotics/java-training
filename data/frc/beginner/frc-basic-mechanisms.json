{
  "title": "Basic Mechanisms and Actuators",
  "sections": [
    {
      "type": "text",
      "title": "Understanding FRC Mechanisms",
      "content": "FRC robots use various mechanisms to interact with game elements and perform specific tasks. Understanding how to program these mechanisms is essential for creating effective robots."
    },
    {
      "type": "rules-box",
      "title": "Common FRC Mechanisms",
      "items": [
        "<strong>Arms:</strong> Rotating mechanisms for lifting and positioning",
        "<strong>Elevators:</strong> Linear mechanisms for vertical movement",
        "<strong>Intakes:</strong> Mechanisms for collecting game elements",
        "<strong>Shooters:</strong> Mechanisms for launching game elements",
        "<strong>Pneumatics:</strong> Air-powered actuators for gripping and positioning",
        "<strong>Conveyors:</strong> Transport mechanisms for moving game elements"
      ],
      "subtitle": "Typical FRC robot mechanisms include:"
    },
    {
      "type": "text",
      "title": "Arm Mechanisms",
      "content": "Arms are rotating mechanisms that can lift and position game elements. They typically use motors with encoders or potentiometers for position feedback."
    },
    {
      "type": "code",
      "title": "Basic Arm Implementation",
      "content": "package frc.robot.subsystems;\n\nimport com.revrobotics.CANSparkMax;\nimport com.revrobotics.CANSparkMaxLowLevel.MotorType;\nimport edu.wpi.first.wpilibj.DigitalInput;\nimport edu.wpi.first.wpilibj.AnalogInput;\nimport edu.wpi.first.wpilibj.smartdashboard.SmartDashboard;\n\npublic class Arm {\n    // Motor controller\n    private final CANSparkMax m_armMotor = new CANSparkMax(3, MotorType.kBrushless);\n    \n    // Sensors\n    private final DigitalInput m_lowerLimitSwitch = new DigitalInput(4);\n    private final DigitalInput m_upperLimitSwitch = new DigitalInput(5);\n    private final AnalogInput m_potentiometer = new AnalogInput(0);\n    \n    // Configuration\n    private static final double ARM_SPEED = 0.5;\n    private static final double POSITION_TOLERANCE = 2.0; // degrees\n    private static final double POT_VOLTAGE_AT_0_DEGREES = 0.0;\n    private static final double POT_VOLTAGE_AT_90_DEGREES = 5.0;\n    \n    // Arm state\n    private boolean m_atLowerLimit = false;\n    private boolean m_atUpperLimit = false;\n    private double m_targetAngle = 0.0;\n    \n    public Arm() {\n        // Configure motor\n        m_armMotor.setInverted(false);\n        m_armMotor.setSmartCurrentLimit(30);\n        m_armMotor.setOpenLoopRampRate(0.5); // Smooth acceleration\n        \n        SmartDashboard.putString(\"Arm Status\", \"Initialized\");\n    }\n    \n    // Manual control methods\n    public void moveUp() {\n        if (!m_atUpperLimit) {\n            m_armMotor.set(ARM_SPEED);\n        } else {\n            m_armMotor.set(0);\n        }\n    }\n    \n    public void moveDown() {\n        if (!m_atLowerLimit) {\n            m_armMotor.set(-ARM_SPEED);\n        } else {\n            m_armMotor.set(0);\n        }\n    }\n    \n    public void stop() {\n        m_armMotor.set(0);\n    }\n    \n    // Position control methods\n    public void moveToAngle(double targetAngle) {\n        m_targetAngle = targetAngle;\n        \n        double currentAngle = getArmAngle();\n        double error = targetAngle - currentAngle;\n        \n        // Simple proportional control\n        double speed = error * 0.02;\n        \n        // Limit speed\n        speed = Math.max(-ARM_SPEED, Math.min(ARM_SPEED, speed));\n        \n        // Apply minimum speed to overcome friction\n        if (Math.abs(speed) > 0 && Math.abs(speed) < 0.1) {\n            speed = Math.signum(speed) * 0.1;\n        }\n        \n        // Check limit switches\n        if (speed > 0 && m_atUpperLimit) {\n            speed = 0;\n        }\n        if (speed < 0 && m_atLowerLimit) {\n            speed = 0;\n        }\n        \n        m_armMotor.set(speed);\n    }\n    \n    public boolean isAtAngle(double targetAngle, double tolerance) {\n        return Math.abs(getArmAngle() - targetAngle) < tolerance;\n    }\n    \n    public boolean isAtTargetAngle() {\n        return isAtAngle(m_targetAngle, POSITION_TOLERANCE);\n    }\n    \n    // Sensor methods\n    public double getArmAngle() {\n        double voltage = m_potentiometer.getAverageVoltage();\n        double angle = ((voltage - POT_VOLTAGE_AT_0_DEGREES) / \n                       (POT_VOLTAGE_AT_90_DEGREES - POT_VOLTAGE_AT_0_DEGREES)) * 90.0;\n        return angle;\n    }\n    \n    public boolean isAtLowerLimit() {\n        return m_lowerLimitSwitch.get();\n    }\n    \n    public boolean isAtUpperLimit() {\n        return m_upperLimitSwitch.get();\n    }\n    \n    // Preset positions\n    public void moveToGround() {\n        moveToAngle(0);\n    }\n    \n    public void moveToLowScore() {\n        moveToAngle(45);\n    }\n    \n    public void moveToHighScore() {\n        moveToAngle(90);\n    }\n    \n    public void update() {\n        // Update limit switch states\n        m_atLowerLimit = isAtLowerLimit();\n        m_atUpperLimit = isAtUpperLimit();\n        \n        // Stop motor if at limits\n        if (m_atLowerLimit && m_armMotor.get() < 0) {\n            m_armMotor.set(0);\n        }\n        if (m_atUpperLimit && m_armMotor.get() > 0) {\n            m_armMotor.set(0);\n        }\n    }\n    \n    public void updateDashboard() {\n        SmartDashboard.putNumber(\"Arm Angle\", getArmAngle());\n        SmartDashboard.putNumber(\"Target Angle\", m_targetAngle);\n        SmartDashboard.putBoolean(\"At Target\", isAtTargetAngle());\n        SmartDashboard.putBoolean(\"Lower Limit\", m_atLowerLimit);\n        SmartDashboard.putBoolean(\"Upper Limit\", m_atUpperLimit);\n        SmartDashboard.putNumber(\"Arm Motor Speed\", m_armMotor.get());\n        SmartDashboard.putNumber(\"Arm Current\", m_armMotor.getOutputCurrent());\n    }\n}"
    },
    {
      "type": "text",
      "title": "Elevator Mechanisms",
      "content": "Elevators provide vertical movement and are commonly used for lifting game elements to different heights. They typically use linear actuators or motor-driven lead screws."
    },
    {
      "type": "code",
      "title": "Elevator Implementation",
      "content": "package frc.robot.subsystems;\n\nimport com.revrobotics.CANSparkMax;\nimport com.revrobotics.CANSparkMaxLowLevel.MotorType;\nimport edu.wpi.first.wpilibj.DigitalInput;\nimport edu.wpi.first.wpilibj.Encoder;\nimport edu.wpi.first.wpilibj.smartdashboard.SmartDashboard;\n\npublic class Elevator {\n    // Motor controller\n    private final CANSparkMax m_elevatorMotor = new CANSparkMax(4, MotorType.kBrushless);\n    \n    // Sensors\n    private final DigitalInput m_bottomLimitSwitch = new DigitalInput(6);\n    private final DigitalInput m_topLimitSwitch = new DigitalInput(7);\n    private final Encoder m_elevatorEncoder = new Encoder(8, 9);\n    \n    // Configuration\n    private static final double ELEVATOR_SPEED = 0.6;\n    private static final double POSITION_TOLERANCE = 0.5; // inches\n    private static final double ENCODER_DISTANCE_PER_PULSE = 0.01; // inches per pulse\n    private static final double MAX_HEIGHT = 60.0; // inches\n    \n    // Elevator state\n    private boolean m_atBottom = false;\n    private boolean m_atTop = false;\n    private double m_targetHeight = 0.0;\n    \n    public Elevator() {\n        // Configure motor\n        m_elevatorMotor.setInverted(false);\n        m_elevatorMotor.setSmartCurrentLimit(40);\n        m_elevatorMotor.setOpenLoopRampRate(0.3);\n        \n        // Configure encoder\n        m_elevatorEncoder.setDistancePerPulse(ENCODER_DISTANCE_PER_PULSE);\n        m_elevatorEncoder.setReverseDirection(false);\n        \n        SmartDashboard.putString(\"Elevator Status\", \"Initialized\");\n    }\n    \n    // Manual control methods\n    public void moveUp() {\n        if (!m_atTop) {\n            m_elevatorMotor.set(ELEVATOR_SPEED);\n        } else {\n            m_elevatorMotor.set(0);\n        }\n    }\n    \n    public void moveDown() {\n        if (!m_atBottom) {\n            m_elevatorMotor.set(-ELEVATOR_SPEED);\n        } else {\n            m_elevatorMotor.set(0);\n        }\n    }\n    \n    public void stop() {\n        m_elevatorMotor.set(0);\n    }\n    \n    // Position control methods\n    public void moveToHeight(double targetHeight) {\n        m_targetHeight = Math.max(0, Math.min(MAX_HEIGHT, targetHeight));\n        \n        double currentHeight = getElevatorHeight();\n        double error = m_targetHeight - currentHeight;\n        \n        // Proportional control\n        double speed = error * 0.05;\n        \n        // Limit speed\n        speed = Math.max(-ELEVATOR_SPEED, Math.min(ELEVATOR_SPEED, speed));\n        \n        // Apply minimum speed\n        if (Math.abs(speed) > 0 && Math.abs(speed) < 0.1) {\n            speed = Math.signum(speed) * 0.1;\n        }\n        \n        // Check limit switches\n        if (speed > 0 && m_atTop) {\n            speed = 0;\n        }\n        if (speed < 0 && m_atBottom) {\n            speed = 0;\n        }\n        \n        m_elevatorMotor.set(speed);\n    }\n    \n    public boolean isAtHeight(double targetHeight, double tolerance) {\n        return Math.abs(getElevatorHeight() - targetHeight) < tolerance;\n    }\n    \n    public boolean isAtTargetHeight() {\n        return isAtHeight(m_targetHeight, POSITION_TOLERANCE);\n    }\n    \n    // Sensor methods\n    public double getElevatorHeight() {\n        return m_elevatorEncoder.getDistance();\n    }\n    \n    public double getElevatorSpeed() {\n        return m_elevatorEncoder.getRate();\n    }\n    \n    public boolean isAtBottom() {\n        return m_bottomLimitSwitch.get();\n    }\n    \n    public boolean isAtTop() {\n        return m_topLimitSwitch.get();\n    }\n    \n    // Preset heights\n    public void moveToBottom() {\n        moveToHeight(0);\n    }\n    \n    public void moveToLowScore() {\n        moveToHeight(20);\n    }\n    \n    public void moveToMidScore() {\n        moveToHeight(40);\n    }\n    \n    public void moveToHighScore() {\n        moveToHeight(60);\n    }\n    \n    public void update() {\n        // Update limit switch states\n        m_atBottom = isAtBottom();\n        m_atTop = isAtTop();\n        \n        // Stop motor if at limits\n        if (m_atBottom && m_elevatorMotor.get() < 0) {\n            m_elevatorMotor.set(0);\n        }\n        if (m_atTop && m_elevatorMotor.get() > 0) {\n            m_elevatorMotor.set(0);\n        }\n    }\n    \n    public void updateDashboard() {\n        SmartDashboard.putNumber(\"Elevator Height\", getElevatorHeight());\n        SmartDashboard.putNumber(\"Target Height\", m_targetHeight);\n        SmartDashboard.putBoolean(\"At Target\", isAtTargetHeight());\n        SmartDashboard.putBoolean(\"At Bottom\", m_atBottom);\n        SmartDashboard.putBoolean(\"At Top\", m_atTop);\n        SmartDashboard.putNumber(\"Elevator Speed\", getElevatorSpeed());\n        SmartDashboard.putNumber(\"Elevator Motor Speed\", m_elevatorMotor.get());\n    }\n}"
    },
    {
      "type": "text",
      "title": "Intake Mechanisms",
      "content": "Intakes collect game elements from the field. They can use various methods including rollers, belts, or pneumatic grippers."
    },
    {
      "type": "code",
      "title": "Intake Implementation",
      "content": "package frc.robot.subsystems;\n\nimport com.revrobotics.CANSparkMax;\nimport com.revrobotics.CANSparkMaxLowLevel.MotorType;\nimport edu.wpi.first.wpilibj.Ultrasonic;\nimport edu.wpi.first.wpilibj.smartdashboard.SmartDashboard;\n\npublic class Intake {\n    // Motor controllers\n    private final CANSparkMax m_leftRoller = new CANSparkMax(5, MotorType.kBrushless);\n    private final CANSparkMax m_rightRoller = new CANSparkMax(6, MotorType.kBrushless);\n    \n    // Sensors\n    private final Ultrasonic m_ballSensor = new Ultrasonic(10, 11);\n    \n    // Configuration\n    private static final double INTAKE_SPEED = 0.7;\n    private static final double OUTTAKE_SPEED = -0.5;\n    private static final double BALL_DETECTION_DISTANCE = 3.0; // inches\n    \n    // Intake state\n    private boolean m_ballDetected = false;\n    private boolean m_isIntaking = false;\n    \n    public Intake() {\n        // Configure motors\n        m_leftRoller.setInverted(false);\n        m_rightRoller.setInverted(true); // Opposite direction for proper intake\n        \n        m_leftRoller.setSmartCurrentLimit(20);\n        m_rightRoller.setSmartCurrentLimit(20);\n        \n        // Configure ultrasonic sensor\n        m_ballSensor.setAutomaticMode(true);\n        \n        SmartDashboard.putString(\"Intake Status\", \"Initialized\");\n    }\n    \n    // Control methods\n    public void intake() {\n        m_leftRoller.set(INTAKE_SPEED);\n        m_rightRoller.set(INTAKE_SPEED);\n        m_isIntaking = true;\n    }\n    \n    public void outtake() {\n        m_leftRoller.set(OUTTAKE_SPEED);\n        m_rightRoller.set(OUTTAKE_SPEED);\n        m_isIntaking = false;\n    }\n    \n    public void stop() {\n        m_leftRoller.set(0);\n        m_rightRoller.set(0);\n        m_isIntaking = false;\n    }\n    \n    // Sensor methods\n    public double getBallDistance() {\n        return m_ballSensor.getRangeInches();\n    }\n    \n    public boolean isBallDetected() {\n        return getBallDistance() < BALL_DETECTION_DISTANCE;\n    }\n    \n    // Advanced control methods\n    public void intakeUntilBall() {\n        if (!isBallDetected()) {\n            intake();\n        } else {\n            stop();\n        }\n    }\n    \n    public void outtakeForTime(double timeSeconds) {\n        outtake();\n        // Note: You would need a timer to implement this properly\n        // This is a simplified version\n    }\n    \n    public void update() {\n        // Update ball detection\n        m_ballDetected = isBallDetected();\n        \n        // Auto-stop if ball detected during intake\n        if (m_isIntaking && m_ballDetected) {\n            stop();\n        }\n    }\n    \n    public void updateDashboard() {\n        SmartDashboard.putNumber(\"Ball Distance\", getBallDistance());\n        SmartDashboard.putBoolean(\"Ball Detected\", m_ballDetected);\n        SmartDashboard.putBoolean(\"Is Intaking\", m_isIntaking);\n        SmartDashboard.putNumber(\"Left Roller Speed\", m_leftRoller.get());\n        SmartDashboard.putNumber(\"Right Roller Speed\", m_rightRoller.get());\n        SmartDashboard.putNumber(\"Left Roller Current\", m_leftRoller.getOutputCurrent());\n        SmartDashboard.putNumber(\"Right Roller Current\", m_rightRoller.getOutputCurrent());\n    }\n}"
    },
    {
      "type": "text",
      "title": "Pneumatic Systems",
      "content": "Pneumatics use compressed air to power actuators. They're commonly used for grippers, lifters, and other mechanisms that need quick, powerful movements."
    },
    {
      "type": "code",
      "title": "Pneumatic Implementation",
      "content": "package frc.robot.subsystems;\n\nimport edu.wpi.first.wpilibj.DoubleSolenoid;\nimport edu.wpi.first.wpilibj.Compressor;\nimport edu.wpi.first.wpilibj.PneumaticsModuleType;\nimport edu.wpi.first.wpilibj.smartdashboard.SmartDashboard;\n\npublic class Pneumatics {\n    // Pneumatic components\n    private final Compressor m_compressor = new Compressor(PneumaticsModuleType.REVPH);\n    private final DoubleSolenoid m_gripperSolenoid = new DoubleSolenoid(\n        PneumaticsModuleType.REVPH, 0, 1);\n    private final DoubleSolenoid m_lifterSolenoid = new DoubleSolenoid(\n        PneumaticsModuleType.REVPH, 2, 3);\n    \n    // Gripper state\n    private boolean m_gripperOpen = true;\n    private boolean m_lifterUp = false;\n    \n    public Pneumatics() {\n        // Configure compressor\n        m_compressor.enableDigital();\n        \n        // Initialize solenoids\n        m_gripperSolenoid.set(DoubleSolenoid.Value.kOff);\n        m_lifterSolenoid.set(DoubleSolenoid.Value.kOff);\n        \n        SmartDashboard.putString(\"Pneumatics Status\", \"Initialized\");\n    }\n    \n    // Gripper control methods\n    public void openGripper() {\n        m_gripperSolenoid.set(DoubleSolenoid.Value.kForward);\n        m_gripperOpen = true;\n    }\n    \n    public void closeGripper() {\n        m_gripperSolenoid.set(DoubleSolenoid.Value.kReverse);\n        m_gripperOpen = false;\n    }\n    \n    public void toggleGripper() {\n        if (m_gripperOpen) {\n            closeGripper();\n        } else {\n            openGripper();\n        }\n    }\n    \n    // Lifter control methods\n    public void raiseLifter() {\n        m_lifterSolenoid.set(DoubleSolenoid.Value.kForward);\n        m_lifterUp = true;\n    }\n    \n    public void lowerLifter() {\n        m_lifterSolenoid.set(DoubleSolenoid.Value.kReverse);\n        m_lifterUp = false;\n    }\n    \n    public void toggleLifter() {\n        if (m_lifterUp) {\n            lowerLifter();\n        } else {\n            raiseLifter();\n        }\n    }\n    \n    // Compressor control\n    public void enableCompressor() {\n        m_compressor.enableDigital();\n    }\n    \n    public void disableCompressor() {\n        m_compressor.disable();\n    }\n    \n    // Status methods\n    public boolean isCompressorEnabled() {\n        return m_compressor.enabled();\n    }\n    \n    public double getPressure() {\n        return m_compressor.getPressure();\n    }\n    \n    public boolean isGripperOpen() {\n        return m_gripperOpen;\n    }\n    \n    public boolean isLifterUp() {\n        return m_lifterUp;\n    }\n    \n    public void updateDashboard() {\n        SmartDashboard.putBoolean(\"Compressor Enabled\", isCompressorEnabled());\n        SmartDashboard.putNumber(\"Pressure (PSI)\", getPressure());\n        SmartDashboard.putBoolean(\"Gripper Open\", m_gripperOpen);\n        SmartDashboard.putBoolean(\"Lifter Up\", m_lifterUp);\n        SmartDashboard.putString(\"Gripper State\", m_gripperOpen ? \"Open\" : \"Closed\");\n        SmartDashboard.putString(\"Lifter State\", m_lifterUp ? \"Up\" : \"Down\");\n    }\n}"
    },
    {
      "type": "text",
      "title": "Shooter Mechanisms",
      "content": "Shooters launch game elements at targets. They typically use flywheels or other mechanisms to achieve consistent velocity and accuracy."
    },
    {
      "type": "code",
      "title": "Shooter Implementation",
      "content": "package frc.robot.subsystems;\n\nimport com.revrobotics.CANSparkMax;\nimport com.revrobotics.CANSparkMaxLowLevel.MotorType;\nimport com.revrobotics.RelativeEncoder;\nimport edu.wpi.first.wpilibj.smartdashboard.SmartDashboard;\n\npublic class Shooter {\n    // Motor controllers\n    private final CANSparkMax m_leftFlywheel = new CANSparkMax(7, MotorType.kBrushless);\n    private final CANSparkMax m_rightFlywheel = new CANSparkMax(8, MotorType.kBrushless);\n    \n    // Encoders\n    private final RelativeEncoder m_leftEncoder = m_leftFlywheel.getEncoder();\n    private final RelativeEncoder m_rightEncoder = m_rightFlywheel.getEncoder();\n    \n    // Configuration\n    private static final double LOW_SPEED_RPM = 2000;\n    private static final double HIGH_SPEED_RPM = 4000;\n    private static final double SPEED_TOLERANCE = 100; // RPM\n    \n    // Shooter state\n    private double m_targetSpeed = 0.0;\n    private boolean m_atSpeed = false;\n    \n    public Shooter() {\n        // Configure motors\n        m_leftFlywheel.setInverted(false);\n        m_rightFlywheel.setInverted(true); // Opposite direction for stability\n        \n        m_leftFlywheel.setSmartCurrentLimit(40);\n        m_rightFlywheel.setSmartCurrentLimit(40);\n        \n        // Configure PID controllers (simplified - you'd use SparkMax PID in practice)\n        m_leftFlywheel.setOpenLoopRampRate(0.5);\n        m_rightFlywheel.setOpenLoopRampRate(0.5);\n        \n        SmartDashboard.putString(\"Shooter Status\", \"Initialized\");\n    }\n    \n    // Control methods\n    public void setSpeed(double targetRPM) {\n        m_targetSpeed = targetRPM;\n        \n        // Simple proportional control (use PID in practice)\n        double leftSpeed = (targetRPM - getLeftSpeed()) * 0.001;\n        double rightSpeed = (targetRPM - getRightSpeed()) * 0.001;\n        \n        // Limit speed\n        leftSpeed = Math.max(-1.0, Math.min(1.0, leftSpeed));\n        rightSpeed = Math.max(-1.0, Math.min(1.0, rightSpeed));\n        \n        m_leftFlywheel.set(leftSpeed);\n        m_rightFlywheel.set(rightSpeed);\n    }\n    \n    public void setLowSpeed() {\n        setSpeed(LOW_SPEED_RPM);\n    }\n    \n    public void setHighSpeed() {\n        setSpeed(HIGH_SPEED_RPM);\n    }\n    \n    public void stop() {\n        m_targetSpeed = 0.0;\n        m_leftFlywheel.set(0);\n        m_rightFlywheel.set(0);\n    }\n    \n    // Status methods\n    public double getLeftSpeed() {\n        return m_leftEncoder.getVelocity();\n    }\n    \n    public double getRightSpeed() {\n        return m_rightEncoder.getVelocity();\n    }\n    \n    public double getAverageSpeed() {\n        return (getLeftSpeed() + getRightSpeed()) / 2.0;\n    }\n    \n    public boolean isAtSpeed() {\n        return Math.abs(getAverageSpeed() - m_targetSpeed) < SPEED_TOLERANCE;\n    }\n    \n    public boolean isAtTargetSpeed() {\n        return isAtSpeed() && m_targetSpeed > 0;\n    }\n    \n    // Shooter control\n    public void shoot() {\n        if (isAtTargetSpeed()) {\n            // Activate feeder or other mechanism to release ball\n            // This would interface with your intake or feeder mechanism\n        }\n    }\n    \n    public void update() {\n        // Update at-speed status\n        m_atSpeed = isAtSpeed();\n    }\n    \n    public void updateDashboard() {\n        SmartDashboard.putNumber(\"Target Speed (RPM)\", m_targetSpeed);\n        SmartDashboard.putNumber(\"Left Speed (RPM)\", getLeftSpeed());\n        SmartDashboard.putNumber(\"Right Speed (RPM)\", getRightSpeed());\n        SmartDashboard.putNumber(\"Average Speed (RPM)\", getAverageSpeed());\n        SmartDashboard.putBoolean(\"At Speed\", m_atSpeed);\n        SmartDashboard.putBoolean(\"Ready to Shoot\", isAtTargetSpeed());\n        SmartDashboard.putNumber(\"Left Current\", m_leftFlywheel.getOutputCurrent());\n        SmartDashboard.putNumber(\"Right Current\", m_rightFlywheel.getOutputCurrent());\n    }\n}"
    },
    {
      "type": "text",
      "title": "Mechanism Coordination",
      "content": "Coordinating multiple mechanisms is essential for complex robot behaviors. This involves sequencing operations and ensuring mechanisms don't interfere with each other."
    },
    {
      "type": "code",
      "title": "Mechanism Coordinator",
      "content": "public class MechanismCoordinator {\n    // Subsystems\n    private final Arm m_arm;\n    private final Elevator m_elevator;\n    private final Intake m_intake;\n    private final Pneumatics m_pneumatics;\n    private final Shooter m_shooter;\n    \n    // Coordination state\n    private enum CoordinatedAction {\n        IDLE, PICKUP_BALL, SCORE_LOW, SCORE_HIGH, DEFENSE\n    }\n    \n    private CoordinatedAction m_currentAction = CoordinatedAction.IDLE;\n    private boolean m_actionComplete = true;\n    \n    public MechanismCoordinator(Arm arm, Elevator elevator, Intake intake, \n                               Pneumatics pneumatics, Shooter shooter) {\n        m_arm = arm;\n        m_elevator = elevator;\n        m_intake = intake;\n        m_pneumatics = pneumatics;\n        m_shooter = shooter;\n    }\n    \n    // Coordinated actions\n    public void pickupBall() {\n        if (m_actionComplete) {\n            m_currentAction = CoordinatedAction.PICKUP_BALL;\n            m_actionComplete = false;\n        }\n    }\n    \n    public void scoreLow() {\n        if (m_actionComplete) {\n            m_currentAction = CoordinatedAction.SCORE_LOW;\n            m_actionComplete = false;\n        }\n    }\n    \n    public void scoreHigh() {\n        if (m_actionComplete) {\n            m_currentAction = CoordinatedAction.SCORE_HIGH;\n            m_actionComplete = false;\n        }\n    }\n    \n    public void update() {\n        switch (m_currentAction) {\n            case IDLE:\n                // Do nothing\n                break;\n                \n            case PICKUP_BALL:\n                executePickupBall();\n                break;\n                \n            case SCORE_LOW:\n                executeScoreLow();\n                break;\n                \n            case SCORE_HIGH:\n                executeScoreHigh();\n                break;\n                \n            case DEFENSE:\n                executeDefense();\n                break;\n        }\n    }\n    \n    private void executePickupBall() {\n        // Sequence: Lower arm -> Open gripper -> Move to ground -> Intake -> Close gripper\n        if (m_arm.isAtAngle(0, 2)) {\n            if (!m_pneumatics.isGripperOpen()) {\n                m_pneumatics.openGripper();\n            } else if (m_intake.isBallDetected()) {\n                m_intake.stop();\n                m_pneumatics.closeGripper();\n                m_currentAction = CoordinatedAction.IDLE;\n                m_actionComplete = true;\n            } else {\n                m_intake.intake();\n            }\n        } else {\n            m_arm.moveToGround();\n        }\n    }\n    \n    private void executeScoreLow() {\n        // Sequence: Move arm to low position -> Open gripper\n        if (m_arm.isAtAngle(45, 2)) {\n            m_pneumatics.openGripper();\n            m_currentAction = CoordinatedAction.IDLE;\n            m_actionComplete = true;\n        } else {\n            m_arm.moveToLowScore();\n        }\n    }\n    \n    private void executeScoreHigh() {\n        // Sequence: Move arm and elevator to high position -> Open gripper\n        if (m_arm.isAtAngle(90, 2) && m_elevator.isAtHeight(60, 1)) {\n            m_pneumatics.openGripper();\n            m_currentAction = CoordinatedAction.IDLE;\n            m_actionComplete = true;\n        } else {\n            m_arm.moveToHighScore();\n            m_elevator.moveToHighScore();\n        }\n    }\n    \n    private void executeDefense() {\n        // Sequence: Move to defensive position\n        m_arm.moveToGround();\n        m_elevator.moveToBottom();\n        m_pneumatics.closeGripper();\n        m_currentAction = CoordinatedAction.IDLE;\n        m_actionComplete = true;\n    }\n    \n    public void updateDashboard() {\n        SmartDashboard.putString(\"Coordinated Action\", m_currentAction.toString());\n        SmartDashboard.putBoolean(\"Action Complete\", m_actionComplete);\n    }\n}"
    },
    {
      "type": "rules-box",
      "title": "Mechanism Best Practices",
      "items": [
        "<strong>Use sensors:</strong> Incorporate position feedback for precise control",
        "<strong>Implement safety:</strong> Add limit switches and current limits",
        "<strong>Test individually:</strong> Test each mechanism separately before integration",
        "<strong>Coordinate actions:</strong> Sequence multiple mechanisms properly",
        "<strong>Handle failures:</strong> Implement fallback behaviors for mechanism failures",
        "<strong>Document operation:</strong> Keep clear documentation of mechanism behavior"
      ],
      "subtitle": "Follow these guidelines for effective mechanism programming:"
    },
    {
      "type": "exercise-box",
      "title": "Mechanism Practice",
      "description": "Implement and test various mechanisms on your robot.",
      "tasks": [
        "Create an arm mechanism with position control",
        "Implement an elevator with height control",
        "Build an intake system with ball detection",
        "Add pneumatic controls for grippers or lifters",
        "Create a shooter mechanism with speed control",
        "Implement mechanism coordination for complex actions",
        "Add safety features and error handling",
        "Test mechanism reliability and consistency",
        "Create mechanism testing routines",
        "Document mechanism operation and maintenance"
      ],
      "content": "// Example mechanism integration in Robot class:\n\npublic class Robot extends TimedRobot {\n    // Subsystems\n    private final Arm m_arm = new Arm();\n    private final Elevator m_elevator = new Elevator();\n    private final Intake m_intake = new Intake();\n    private final Pneumatics m_pneumatics = new Pneumatics();\n    private final Shooter m_shooter = new Shooter();\n    private final MechanismCoordinator m_coordinator;\n    \n    public Robot() {\n        m_coordinator = new MechanismCoordinator(\n            m_arm, m_elevator, m_intake, m_pneumatics, m_shooter);\n    }\n    \n    @Override\n    public void teleopPeriodic() {\n        // Handle operator controls\n        if (m_oi.getPickupBall()) {\n            m_coordinator.pickupBall();\n        } else if (m_oi.getScoreLow()) {\n            m_coordinator.scoreLow();\n        } else if (m_oi.getScoreHigh()) {\n            m_coordinator.scoreHigh();\n        }\n        \n        // Update all mechanisms\n        m_arm.update();\n        m_elevator.update();\n        m_intake.update();\n        m_shooter.update();\n        m_coordinator.update();\n        \n        // Update dashboards\n        m_arm.updateDashboard();\n        m_elevator.updateDashboard();\n        m_intake.updateDashboard();\n        m_pneumatics.updateDashboard();\n        m_shooter.updateDashboard();\n        m_coordinator.updateDashboard();\n    }\n}"
    }
  ]
}
