These are examples of how to control mechanisms in FRC using PID Controllers and Trapezoidal motion,
but are currently being stored here because they are subpar.

{
    "type": "text",
    "title": "PID in FRC: Controlling a Mechanism",
    "content": "In FRC, PID control is essential for precise and consistent control of various mechanisms, such as arm position, shooter speed, and drivetrain movement. Let's illustrate this with an example of controlling the position of a robot arm using a PID controller.\n\nImagine you have a robot arm that needs to move to a specific target angle. Here's how PID would be applied:\n\n1.  **Subsystem (Arm):**  This subsystem manages the physical arm mechanism, including the motor, an encoder (to measure the arm's angle), and any other necessary components. It provides methods to set the motor power and get the current arm angle.\n2.  **Command (MoveArmToPosition):** This command utilizes a PID controller to smoothly move the arm to a target position.  It will:\n    *   Obtain the current arm angle from the subsystem (process variable).\n    *   Calculate the error (difference between the target angle and current angle).\n    *   Use the PID controller to compute the necessary motor power.\n    *   Set the motor power via the subsystem.\n    *   Repeat the above steps until the arm reaches the target angle within a small tolerance."
  },
  {
    "type": "code",
    "title": "PID Control Example (Robot Arm)",
    "content": "// ArmSubsystem.java\nimport edu.wpi.first.wpilibj.motorcontrol.PWMVictorSPX;\nimport edu.wpi.first.wpilibj.Encoder;\nimport edu.wpi.first.wpilibj2.command.SubsystemBase;\n\npublic class ArmSubsystem extends SubsystemBase {\n    private final PWMVictorSPX m_motor = new PWMVictorSPX(0);  // Replace with your motor port\n    private final Encoder m_encoder = new Encoder(0, 1);     // Replace with your encoder ports\n\n    public ArmSubsystem() {\n        // Configure the encoder (pulses per revolution, etc.)\n        m_encoder.setDistancePerPulse(360.0 / 2048.0); // Example: 2048 CPR, degrees per pulse\n    }\n\n    public void setMotorPower(double power) {\n        m_motor.set(power);\n    }\n\n    public double getArmAngle() {\n        return m_encoder.getDistance();\n    }\n}\n\n// MoveArmToPosition.java\nimport edu.wpi.first.math.controller.PIDController;\nimport edu.wpi.first.wpilibj2.command.Command;\nimport edu.wpi.first.wpilibj2.command.PIDCommand;\n\npublic class MoveArmToPosition extends PIDCommand {\n    public MoveArmToPosition(double targetAngle, ArmSubsystem arm) {\n        super(\n            new PIDController(0.1, 0.01, 0.005),  // Tune these gains!\n            arm::getArmAngle,                        // Current measurement\n            targetAngle,                              // Target position\n            arm::setMotorPower,                       // Output to actuator\n            arm                                       // Require the subsystem\n        );\n        getController().setTolerance(2);              // Degrees of tolerance\n        addRequirements(arm);\n        //TODO: Make sure PID loop is continuous so it doesn't do weird stuff going over the 0 to 360 boundary\n    }\n\n    @Override\n    public boolean isFinished() {\n        return getController().atSetpoint();\n    }\n}\n\n"
  },
  {
    "type": "text",
    "title": "Trapezoidal Motion Profiling",
    "content": "While PID control excels at reaching and maintaining a setpoint, it doesn't inherently manage the motion profile (velocity and acceleration) during the movement. This is where **trapezoidal motion profiling** becomes valuable.  It's a technique for generating a smooth, controlled path for a mechanism to follow, limiting acceleration and velocity to prevent jerky movements or excessive forces. A trapezoidal profile is characterized by three phases:\n\n1.  **Acceleration Phase:** The mechanism smoothly accelerates from rest to a maximum velocity.\n2.  **Cruise Phase:** The mechanism maintains a constant maximum velocity for a period.\n3.  **Deceleration Phase:** The mechanism smoothly decelerates to a stop at the target position.\n\nThis profile helps ensure smooth, controlled motion, minimizing overshoot and reducing stress on the mechanism and robot structure. It's especially important for tasks like moving an arm or elevator where precise control over velocity and acceleration is desired."
  },
  {
    "type": "code",
    "title": "Trapezoidal Motion Profile Example (WPILib)",
    "content": "import edu.wpi.first.math.trajectory.TrapezoidProfile;\nimport edu.wpi.first.wpilibj.Timer;\n\npublic class TrapezoidalMotion {\n    private TrapezoidProfile.Constraints m_constraints;\n    private TrapezoidProfile.State m_goal;\n    private TrapezoidProfile.State m_currentState;\n    private TrapezoidProfile m_profile;\n    private Timer m_timer = new Timer();\n    \n    public TrapezoidalMotion(double maxVelocity, double maxAcceleration, double targetPosition) {\n      // Define constraints (max velocity, max acceleration)\n      m_constraints = new TrapezoidProfile.Constraints(maxVelocity, maxAcceleration);\n      // Define the goal (target position and velocity)\n      m_goal = new TrapezoidProfile.State(targetPosition, 0.0);\n      // Initial state (start at position 0 with 0 velocity)\n      m_currentState = new TrapezoidProfile.State(0.0, 0.0);\n    }\n\n    public void startMotion() {\n        // Create a new profile from the start to the goal\n        m_profile = new TrapezoidProfile(m_constraints, m_goal, m_currentState);\n        m_timer.restart();\n    }\n\n    public TrapezoidProfile.State calculateNextState() {\n        double elapsedTime = m_timer.get();\n        // Calculate the desired state at the current elapsed time\n        return m_profile.calculate(elapsedTime);\n    }\n\n    public boolean isFinished() {\n        // Check if the current state is close to the goal state\n        return m_profile.isFinished(m_currentState);\n    }\n}\n\n"
  },
  {
    "type": "text",
    "title": "CTRE Motion Magic",
    "content": "CTRE Motion Magic is a sophisticated motion profiling solution built into CTRE Talon FX motor controllers. It simplifies the process of creating smooth, trapezoidal motion profiles for mechanisms like arms, elevators, and drivetrains. By setting parameters like target position, velocity, and acceleration, Motion Magic handles the low-level details of trajectory generation and motor control, ensuring smooth and precise movements."
  },
  {
    "type": "code",
    "title": "Talon FX Motion Magic Example (Arm Control)",
    "content": "import com.ctre.phoenix6.hardware.TalonFX;\nimport com.ctre.phoenix6.configs.TalonFXConfiguration;\nimport com.ctre.phoenix6.controls.MotionMagicVoltage;\nimport com.ctre.phoenix6.signals.NeutralModeValue;\nimport com.ctre.phoenix6.signals.GravityTypeValue;\n\npublic class ArmWithMotionMagic {\n    private TalonFX m_armMotor;\n    private MotionMagicVoltage m_motionMagicControl;\n\n    public ArmWithMotionMagic(int canID, double gearRatio) {\n        // Initialize Talon FX\n        m_armMotor = new TalonFX(canID);\n\n        // Configure Talon FX\n        TalonFXConfiguration config = new TalonFXConfiguration();\n\n        // Configure feedback sensor (integrated encoder)\n        config.MotionMagic.MotionMagicCruiseVelocity = 30;          // Set a reasonable cruise velocity (rotations per second)\n        config.MotionMagic.MotionMagicAcceleration = 60;              // Set a reasonable acceleration (rotations per second squared)\n        config.MotionMagic.MotionMagicJerk = 300;                     // Set a reasonable jerk (rotations per second cubed)\n\n        // Invert motor direction if needed\n        config.MotorOutput.Inverted = InvertedValue.Clockwise_Positive; // Or CounterClockwise_Positive\n\n        // Set neutral mode to brake (hold position when stopped)\n        config.MotorOutput.NeutralMode = NeutralModeValue.Brake;\n\n        // Configure soft limits (optional, prevents over-extension)\n        config.SoftwareLimitSwitch.ForwardSoftLimitEnable = true;\n        config.SoftwareLimitSwitch.ReverseSoftLimitEnable = true;\n        config.SoftwareLimitSwitch.ForwardSoftLimitThreshold = 150; // Example limit\n        config.SoftwareLimitSwitch.ReverseSoftLimitThreshold = 0;   // Example limit\n\n        // Apply configuration\n        m_armMotor.getConfigurator().apply(config);\n\n        // Create Motion Magic control object\n        m_motionMagicControl = new MotionMagicVoltage(0); // Starting position (degrees)\n    }\n\n    /**\n     * Moves the arm to a target position using Motion Magic.\n     *\n     * @param targetPosition The target angle in degrees.\n     */\n    public void moveToPosition(double targetPosition) {\n        // Use Motion Magic to move to the target position\n        m_motionMagicControl.Position = targetPosition * gearRatio;  //Apply gear ratio\n        m_armMotor.setControl(m_motionMagicControl);\n\n        System.out.println(\"Moving arm to position: \" + targetPosition + \" degrees\");\n    }\n\n    /**\n     * Stops the arm movement.\n     */\n    public void stop() {\n        m_armMotor.setControl(new NeutralOut()); // Use neutral output to stop motor movement \n    }\n\n    /**\n     * Gets the current arm position in degrees.\n     *\n     * @return The current arm angle.\n     */\n    public double getPosition() {\n        return m_armMotor.getPosition().getValueAsDouble() / gearRatio;  // Divide by gear ratio\n    }\n}\n"
  },
  {
    "type": "text",
    "title": "Motion Magic and Gravity Compensation",
    "content": "For mechanisms like robot arms that work against gravity, you often need to compensate for the gravitational force to achieve precise position control.  With Phoenix 6, you can use `MotionMagicVoltage` and configure it to counteract gravity's effects. There are two settings for this:\n\n*   **`GravityTypeValue.Elevator`:** Compensates for gravity in a linear motion (like an elevator).\n*   **`GravityTypeValue.Arm`:** Compensates for gravity in a rotational motion (like an arm, where the effect of gravity changes depending on the arm's angle).\n\n To use gravity compensation, you'll need to:\n\n1.  Set the `MotionMagicVoltage.GravityType` property to `GravityTypeValue.Arm` (for a rotating arm) after getting the config\n2.  Tune the `kS` gain (static friction) so it's high enough to overcome gravity's pull without adding excessive force."
  },
  {
    "type": "code",
    "title": "Arm with Motion Magic and Gravity Compensation",
    "content": "import com.ctre.phoenix6.hardware.TalonFX;\nimport com.ctre.phoenix6.configs.TalonFXConfiguration;\nimport com.ctre.phoenix6.controls.MotionMagicVoltage;\nimport com.ctre.phoenix6.signals.NeutralModeValue;\nimport com.ctre.phoenix6.signals.GravityTypeValue;\n\npublic class ArmWithMotionMagicAndGravity {\n    private TalonFX m_armMotor;\n    private MotionMagicVoltage m_motionMagicControl;\n    private double gearRatio;  // Added gear ratio\n\n    public ArmWithMotionMagicAndGravity(int canID, double gearRatio) {\n        this.gearRatio = gearRatio; //Store gear ratio\n        // Initialize Talon FX\n        m_armMotor = new TalonFX(canID);\n\n        // Configure Talon FX\n        TalonFXConfiguration config = new TalonFXConfiguration();\n\n        // Configure feedback sensor (integrated encoder)\n        config.MotionMagic.MotionMagicCruiseVelocity = 30; // Set a reasonable cruise velocity (rotations per second)\n        config.MotionMagic.MotionMagicAcceleration = 60;     // Set a reasonable acceleration (rotations per second squared)\n        config.MotionMagic.MotionMagicJerk = 300;            // Set a reasonable jerk (rotations per second cubed)\n\n        // Invert motor direction if needed\n        config.MotorOutput.Inverted = InvertedValue.Clockwise_Positive; // Or CounterClockwise_Positive\n\n        // Set neutral mode to brake (hold position when stopped)\n        config.MotorOutput.NeutralMode = NeutralModeValue.Brake;\n\n        // Configure soft limits (optional, prevents over-extension)\n        config.SoftwareLimitSwitch.ForwardSoftLimitEnable = true;\n        config.SoftwareLimitSwitch.ReverseSoftLimitEnable = true;\n        config.SoftwareLimitSwitch.ForwardSoftLimitThreshold = 150; // Example limit\n        config.SoftwareLimitSwitch.ReverseSoftLimitThreshold = 0;   // Example limit\n\n        // NEW: Configure gravity compensation for an arm\n        config.MotionMagic.GravityType = GravityTypeValue.Arm;        \n        config.MotionMagic.kS = 0.1;                        // IMPORTANT: Tune this gain (static friction)\n        \n        // Apply configuration\n        m_armMotor.getConfigurator().apply(config);\n\n        // Create Motion Magic control object\n        m_motionMagicControl = new MotionMagicVoltage(0);\n        m_motionMagicControl.UseSupplyVoltage = true;  // Use supply voltage compensation\n    }\n\n    /**\n     * Moves the arm to a target position using Motion Magic.\n     *\n     * @param targetPosition The target angle in degrees.\n     */\n    public void moveToPosition(double targetPosition) {\n        // Use Motion Magic to move to the target position\n        m_motionMagicControl.Position = targetPosition * gearRatio; // Apply gear ratio\n        m_armMotor.setControl(m_motionMagicControl);\n\n        System.out.println(\"Moving arm to position: \" + targetPosition + \" degrees\");\n    }\n\n    /**\n     * Stops the arm movement.\n     */\n    public void stop() {\n        m_armMotor.setControl(new NeutralOut());  // Use neutral output\n    }\n\n    /**\n     * Gets the current arm position in degrees.\n     *\n     * @return The current arm angle.\n     */\n    public double getPosition() {\n        return m_armMotor.getPosition().getValueAsDouble() / gearRatio; // Divide by gear ratio"
  }