{
    "id": "frccommands",
    "title": "All About Commands in FRC",
    "sections": [
      {
        "type": "text",
        "title": "Introduction to Commands",
        "content": "In FRC robotics, especially when using the command-based programming framework, commands are the core building blocks of robot behavior. They represent specific actions the robot can perform, such as driving, shooting, or manipulating game pieces. Understanding the different types of commands and when to use them is crucial for effective robot programming."
      },
      {
        "type": "text",
        "title": "Command Types Overview",
        "content": "WPILib provides several fundamental command types that cater to different programming needs. These can be broadly categorized as:\n<ul>\n  <li><strong>Instant Commands:</strong> Commands that execute once and finish immediately.</li>\n  <li><strong>Sequential Commands:</strong> Commands that run a sequence of other commands.</li>\n  <li><strong>Parallel Commands:</strong> Commands that run multiple commands concurrently.</li>\n  <li><strong>Functional Commands:</strong> Commands created using lambda expressions for simple, concise actions.</li>\n  <li><strong>Proxy Commands:</strong> Commands that defer to another command.</li>\n <li><strong>Run Commands:</strong> Commands that run repeatedly until interrupted or explicitly stopped.</li>\n <li><strong>Deferred Commands:</strong> Commands that are initialized as they are called.\n</li></ul>Let's explore each of these in detail."
      },
      {
        "type": "text",
        "title": "1. Instant Commands",
        "content": "Instant commands are the simplest type. They are designed for actions that should happen exactly once and complete immediately, such as setting a motor speed or activating a solenoid. They do not have an `execute()` method, and their `isFinished()` method always returns true."
      },
      {
        "type": "code",
        "title": "Instant Command Example (Java)",
        "content": "// Example: SetMotor Command\nimport edu.wpi.first.wpilibj2.command.InstantCommand;\nimport edu.wpi.first.wpilibj2.command.Subsystem;\n\npublic class SetMotor extends InstantCommand {\n  private final Drivetrain m_drivetrain;\n  private final double m_speed;\n\n  public SetMotor(Drivetrain drivetrain, double speed) {\n    m_drivetrain = drivetrain;\n    m_speed = speed;\n    addRequirements(m_drivetrain); // Command requires the drivetrain subsystem\n  }\n\n  @Override\n  public void initialize() {\n    m_drivetrain.setSpeed(m_speed, m_speed);  // Set both sides to same speed\n  }\n}"
      },
      {
        "type": "text",
        "content": "Instant commands are also useful for creating commands on-the-fly in your button bindings when the commmand is very simple. For instance, rather than creating an entirely new command file for setting the intake to full speed, you can instead do the following:"

      },
      {
        "type": "code",
        "content": "package edu.wpi.first.wpilibj.templates.commandbased;\nimport edu.wpi.first.wpilibj2.command.Command;...\n\npublic class RobotContainer {\n  //Initialize subsystem(s)...\n\n  /**\n   * Use this method to define your trigger->command mappings.\n   */\n  private void configureBindings() {\n    // Use an InstantCommand to set the intake speed to 1 when right bumper (R1) held\n\n    m_driverController.R1().whileTrue(new InstantCommand(() -> m_intakeSubsystem.setIntakeSpeed(1.0)));\n\n    //Other button bindings...\n  }\n\n  //Rest of RobotContainer...\n}"
      },
      {
        "type": "text",
        "title": "2. Sequential Commands",
        "content": "Sequential commands allow you to chain together multiple commands, ensuring they execute one after another in a specific order. This is useful for automating multi-step processes, like an entire shooting sequence or a complex autonomous routine."
      },
      {
        "type": "code",
        "title": "Sequential Command Example (Java)",
        "content": "// Example: Autonomous Routine\nimport edu.wpi.first.wpilibj2.command.SequentialCommandGroup;\n\npublic class AutonomousRoutine extends SequentialCommandGroup {\n\n  public AutonomousRoutine(Drivetrain drivetrain, Shooter shooter, Intake intake) {\n    addCommands(\n        // Drive forward for 2 seconds\n        new DriveForward(drivetrain, 0.5, 2.0),\n        \n        // Stop the drivetrain\n        new StopDrive(drivetrain),\n        \n        // Spin up the shooter\n        new SpinUpShooter(shooter, 0.8),\n        \n        // Intake a game piece (runs concurrently with shooter spin-up)\n        new IntakeGamePiece(intake),\n        \n        // Shoot for 3 seconds\n        new Shoot(shooter, 3.0)\n    );\n  }\n}"
      },
      {
        "type": "text",
        "title": "3. Parallel Commands",
        "content": "Parallel commands let you run multiple commands simultaneously. This is ideal for tasks where you want multiple subsystems to operate at the same time, like intaking while driving or aiming while shooting. There are two main types of parallel command groups:\n\n<ul>\n<li><strong>ParallelCommandGroup:</strong> All commands start and run concurrently until all of them finish.</li>\n<li><strong>ParallelRaceGroup:</strong> All commands start together, but the group finishes as soon as the first command finishes, interrupting any remaining commands.</li>\n<li><strong>ParallelDeadlineGroup:</strong> All commands start together and continue running in parallel until a \"deadline\" command completes, at which point the other commands are interrupted.</li>\n</ul>"
      },
      {
        "type": "code",
        "title": "Parallel Command Example (Java)",
        "content": "// Example: Intake and Drive Simultaneously\nimport edu.wpi.first.wpilibj2.command.ParallelCommandGroup;\n\npublic class IntakeAndDrive extends ParallelCommandGroup {\n  public IntakeAndDrive(Drivetrain drivetrain, Intake intake) {\n    addCommands(\n        // Start the intake\n        new RunIntake(intake, 1.0),\n        \n        // Drive forward slowly at the same time\n        new DriveForward(drivetrain, 0.3, 3.0)  // Drive for 3 seconds\n    );\n  }\n}\n\n//Example: Parallel Race\nimport edu.wpi.first.wpilibj2.command.ParallelRaceGroup;\nimport edu.wpi.first.wpilibj2.command.WaitCommand;\nimport java.time.Duration;\n\npublic class ShootUntilAligned extends ParallelRaceGroup {\n  public ShootUntilAligned(Shooter shooter, Aligner aligner) {\n    addCommands(\n      // Run the shooter continuously\n      new RunShooter(shooter), \n\n      // Stop shooting once aligned\n      new AlignWithTarget(aligner)\n    );\n  }\n}\n\n// Example: Parallel Deadline\nimport edu.wpi.first.wpilibj2.command.ParallelDeadlineGroup;\nimport edu.wpi.first.wpilibj2.command.WaitCommand;\nimport java.time.Duration;\n\npublic class TimedShoot extends ParallelDeadlineGroup {\n  public TimedShoot(Shooter shooter, Intake intake) {\n    super(\n      //Set the deadline to be a 3 second wait.\n      new WaitCommand(Duration.ofSeconds(3)),\n\n      //Run the intake\n      new RunIntake(intake), \n\n      //Also run the shooter.\n      new RunShooter(shooter)\n    );\n  }\n}"
      },
      {
        "type": "text",
        "title": "4. Functional Commands",
        "content": "Functional commands provide a concise way to create simple commands using lambda expressions (anonymous functions). This reduces boilerplate code and makes it easier to define short, single-purpose actions directly within your command bindings."
      },
      {
        "type": "code",
        "title": "Functional Command Examples (Java)",
        "content": "import edu.wpi.first.wpilibj2.command.Commands;\n\npublic class FunctionalCommandExamples {\n  public static Command setSpeedInstant(Drivetrain drivetrain, double speed) {\n    return Commands.instant(() -> drivetrain.setSpeed(speed, speed), drivetrain);\n  }\n\n  public static Command driveTimed(Drivetrain drivetrain, double speed, double duration) {\n    return Commands.run(() -> drivetrain.setSpeed(speed, speed), drivetrain)\n        .withTimeout(duration)\n        .andThen(() -> drivetrain.stop());\n  }\n}\n\n//Usage within RobotContainer (or similar):\nm_controller.aButton().onTrue(FunctionalCommandExamples.setSpeedInstant(m_drivetrain, 0.5));\nm_controller.bButton().onTrue(FunctionalCommandExamples.driveTimed(m_drivetrain, 0.7, 2.0));"
      },
      {
        "type": "text",
        "title": "5. Proxy Commands",
        "content": "A Proxy command is a command that will defer all of its scheduling to another command. It acts as a stand in for a different command, running that other command when it itself is scheduled."
      },
      {
        "type": "code",
        "title": "Proxy Command Example (Java)",
        "content": "import edu.wpi.first.wpilibj2.command.ProxyCommand;\nimport edu.wpi.first.wpilibj2.command.SequentialCommandGroup;\n\npublic class ComplexAutonomous extends SequentialCommandGroup {\n  public ComplexAutonomous(Drivetrain drivetrain) {\n    addCommands(\n      //Do some initial setup\n      new InitializeCommand(),\n\n      //Drive to a location.\n      new ProxyCommand(() -> chooseDriveCommand(drivetrain)),\n\n      // Do some final tasks\n      new FinishCommand()\n    );\n  }\n\n  //This function will choose what command to run for the proxy command.\n  private Command chooseDriveCommand(Drivetrain drivetrain) {\n    if (shouldDoComplexPath()) {\n      return new ComplexPathCommand(drivetrain);\n    } else {\n      return new SimpleDriveCommand(drivetrain);\n    }\n  }\n\n  // This function checks the current conditions of the game and returns a boolean.\n  private boolean shouldDoComplexPath() {\n    //Implementation hidden.\n    return true;\n  }\n}"
      }, 
      {
        "type": "text",
        "title": "6. Run Commands",
        "content": "Run commands are designed for actions that need to run continuously until interrupted or explicitly stopped. Unlike InstantCommand which finishes immediately, or commands with a defined duration, RunCommand will keep executing its execute() method repeatedly as long as it is scheduled. This is particularly useful for default commands of subsystems, or for actions that need to persist until a new command takes over."
      },
      {
        "type": "code",
        "title": "Run Command Example (Java)",
        "content": "// Example: Default Drive Command\nimport edu.wpi.first.wpilibj2.command.RunCommand;\nimport edu.wpi.first.wpilibj2.command.Subsystem;\n\npublic class DefaultDrive extends RunCommand {\n  private final Drivetrain m_drivetrain;\n  private final double m_forwardSpeed;\n  private final double m_turnSpeed;\n\n  public DefaultDrive(Drivetrain drivetrain, double forwardSpeed, double turnSpeed) {\n    super(\n        // This lambda will be executed repeatedly in the command's execute() method\n        () -> drivetrain.arcadeDrive(forwardSpeed, turnSpeed),\n        drivetrain // Specify the subsystem requirement\n    );\n    m_drivetrain = drivetrain;\n    m_forwardSpeed = forwardSpeed;\n    m_turnSpeed = turnSpeed;\n  }\n\n  // No need to override initialize() or isFinished() for a simple RunCommand\n  // The command will run until interrupted or a new command takes the drivetrain\n\n  @Override\n  public void end(boolean interrupted) {\n    m_drivetrain.stop(); // Stop the motors when the command ends\n    if (interrupted) {\n      System.out.println(\"DefaultDrive command interrupted!\");\n    } else {\n      System.out.println(\"DefaultDrive command finished normally.\");\n    }\n  }\n}\n\n// Usage in RobotContainer (as a default command):\n// m_drivetrain.setDefaultCommand(new DefaultDrive(m_drivetrain, () -> m_driverController.getLeftY(), () -> m_driverController.getRightX()));"
      },
      {
        "type": "text",
        "title": "7. Deferred Commands",
        "content": "Deferred commands are a special type of command that allows you to specify the command to be run at the time of execution, rather than at the time of creation. This is particularly useful when the exact command to be run depends on runtime conditions or user input that isn't available when the command is initially defined. It ensures that the command's requirements are correctly registered with the scheduler, even if the actual command object is created later."
      },
      {
        "type": "code",
        "title": "Deferred Command Example (Java)",
        "content": "import edu.wpi.first.wpilibj2.command.DeferredCommand;\nimport edu.wpi.first.wpilibj2.command.InstantCommand;\nimport edu.wpi.first.wpilibj2.command.Command;\nimport edu.wpi.first.wpilibj2.command.SubsystemBase;\nimport java.util.Set;\n\n// Assume these are your subsystems\nclass Drivetrain extends SubsystemBase {\n    public void drive(double speed) { System.out.println(\"Driving at \" + speed); }\n    public void stop() { System.out.println(\"Drivetrain stopped.\"); }\n}\n\nclass Shooter extends SubsystemBase {\n    public void shoot() { System.out.println(\"Shooting!\"); }\n    public void stop() { System.out.println(\"Shooter stopped.\"); }\n}\n\npublic class DeferredCommandExample {\n    private final Drivetrain m_drivetrain = new Drivetrain();\n    private final Shooter m_shooter = new Shooter();\n    private boolean m_isAutonomous = true; // Simulate a runtime condition\n\n    public Command getActionCommand() {\n        // This DeferredCommand will decide which action to take when it's scheduled\n        return new DeferredCommand(\n            () -> {\n                if (m_isAutonomous) {\n                    // In autonomous, drive forward\n                    return new InstantCommand(() -> m_drivetrain.drive(0.5), m_drivetrain);\n                } else {\n                    // In teleop, shoot\n                    return new InstantCommand(() -> m_shooter.shoot(), m_shooter); \n                }\n            }\n        );\n    }"
      },{
        "type": "exercise-box",
        "title": "Putting it All Together",
        "subtitle": "Explain the following code to a peer:",
        "tasks": ["Code Snippet From Team 9128, Itkan Robotics"],
        "code": "operatorCommand.L2().whileTrue(\n        new RepeatCommand(\n            new DeferredCommand(\n                () -> {\n                    storedState.setOperatorReefAngle(\n                        () -> -operatorCommand.getRightY(),\n                        () -> operatorCommand.getRightX());\n                }, Set.of())\n        )\n    );",
        "answers": [
          {"task": "This line of code sets up a command-based trigger so that while the operator holds the L2 button, the robot continuously executes a nested command structure: a RepeatCommand wraps a DeferredCommand, which on each initialization dynamically supplies a new command defined by the lambda. That deferred command calls storedState.setOperatorReefAngle(...), providing two suppliers that read the controller’s right stick Y and X positions at runtime. In effect, this continuously updates the subsystem’s target reef angle using live controller input, handling button-held behavior smoothly.",
          "code": "operatorCommand.L2().whileTrue(  // While the L2 button is held down...\n    new RepeatCommand(            // ...continuously repeat this command:\n        new DeferredCommand(      // ...deferred until execution, so controller inputs are current\n            () -> {\n                storedState.setOperatorReefAngle(\n                    () -> -operatorCommand.getRightY(),  // supply current right Y\n                    () -> operatorCommand.getRightX()); // supply current right X\n              }, Set.of()   // no subsystem requirements\n        )\n    )\n);"
          }]
      },
      {
        "type": "text",
        "title": "Choosing the Right Command Type",
        "content": "The key to effective command-based programming is selecting the appropriate command type for each task. Consider the following guidelines:"
      },
      {
        "type": "rules-box",
        "items": [
        "Use <strong>InstantCommand</strong> for single, immediate actions without duration (e.g., setting initial states).",
        "Use <strong>SequentialCommandGroup</strong> for ordered, multi-step processes that must happen one after another.",
        "Use <strong>ParallelCommandGroup</strong> when you want all commands to run to completion simultaneously.",
        "Use <strong>ParallelRaceGroup</strong> to run commands concurrently, stopping all when the first one completes.  Good for tasks like \"run until a sensor triggers.\"",
        "Use <strong>ParallelDeadlineGroup</strong> to run commands concurrently, stopping all when a specific \"deadline\" command completes.  Good for timed operations with other actions happening in the background.",
        "Use <strong>Functional Commands</strong> for simple, short commands that can be expressed concisely with lambda expressions.",
        "Use <strong>Proxy Commands</strong> when you need to decide on the fly which command should be running in the current circumstance."
      ]
      }
    ]
  }
  