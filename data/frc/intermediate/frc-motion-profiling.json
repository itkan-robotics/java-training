{
  "title": "Motion Profiling and Advanced Motion Control",
  "sections": [
    {
      "type": "text",
      "title": "Understanding Motion Profiling",
      "content": "Motion profiling generates smooth, controlled motion paths that specify position, velocity, and acceleration over time. This creates more precise and efficient robot movement compared to simple position control."
    },
    {
      "type": "rules-box",
      "title": "Motion Profile Benefits",
      "items": [
        "<strong>Smooth Motion:</strong> Eliminates jerky movements and reduces wear",
        "<strong>Predictable Timing:</strong> Consistent motion duration regardless of distance",
        "<strong>Better Control:</strong> Specifies velocity and acceleration limits",
        "<strong>Efficient Operation:</strong> Optimizes motor usage and reduces current spikes",
        "<strong>Precise Positioning:</strong> More accurate end positioning"
      ],
      "subtitle": "Motion profiling provides several advantages:"
    },
    {
      "type": "text",
      "title": "Trapezoidal Motion Profiles",
      "content": "A trapezoidal motion profile consists of three phases: acceleration, constant velocity, and deceleration. This creates a smooth, efficient motion path."
    },
    {
      "type": "code",
      "title": "Trapezoidal Motion Profile Implementation",
      "content": "package frc.robot.utils;\n\nimport edu.wpi.first.wpilibj.Timer;\nimport edu.wpi.first.wpilibj.smartdashboard.SmartDashboard;\n\npublic class TrapezoidalMotionProfile {\n    // Profile parameters\n    private final double m_maxVelocity;      // Maximum velocity (units/second)\n    private final double m_maxAcceleration;  // Maximum acceleration (units/second^2)\n    private final double m_distance;         // Total distance to travel\n    \n    // Calculated profile parameters\n    private final double m_accelTime;        // Time to accelerate\n    private final double m_constantTime;     // Time at constant velocity\n    private final double m_decelTime;        // Time to decelerate\n    private final double m_totalTime;        // Total profile time\n    \n    // Profile state\n    private double m_startTime;\n    private boolean m_isFinished = false;\n    \n    public TrapezoidalMotionProfile(double maxVelocity, double maxAcceleration, double distance) {\n        m_maxVelocity = maxVelocity;\n        m_maxAcceleration = maxAcceleration;\n        m_distance = Math.abs(distance);\n        \n        // Calculate profile parameters\n        double accelDistance = (m_maxVelocity * m_maxVelocity) / (2.0 * m_maxAcceleration);\n        \n        if (2.0 * accelDistance <= m_distance) {\n            // Full trapezoid (accel, constant, decel)\n            m_accelTime = m_maxVelocity / m_maxAcceleration;\n            double constantDistance = m_distance - 2.0 * accelDistance;\n            m_constantTime = constantDistance / m_maxVelocity;\n            m_decelTime = m_accelTime;\n        } else {\n            // Triangle (accel, decel only)\n            m_accelTime = Math.sqrt(m_distance / m_maxAcceleration);\n            m_constantTime = 0.0;\n            m_decelTime = m_accelTime;\n        }\n        \n        m_totalTime = m_accelTime + m_constantTime + m_decelTime;\n    }\n    \n    public void start() {\n        m_startTime = Timer.getFPGATimestamp();\n        m_isFinished = false;\n    }\n    \n    public MotionProfileState calculate() {\n        double currentTime = Timer.getFPGATimestamp() - m_startTime;\n        \n        if (currentTime >= m_totalTime) {\n            m_isFinished = true;\n            return new MotionProfileState(m_distance, 0.0, 0.0);\n        }\n        \n        double position, velocity, acceleration;\n        \n        if (currentTime < m_accelTime) {\n            // Acceleration phase\n            acceleration = m_maxAcceleration;\n            velocity = m_maxAcceleration * currentTime;\n            position = 0.5 * m_maxAcceleration * currentTime * currentTime;\n            \n        } else if (currentTime < m_accelTime + m_constantTime) {\n            // Constant velocity phase\n            acceleration = 0.0;\n            velocity = m_maxVelocity;\n            position = 0.5 * m_maxAcceleration * m_accelTime * m_accelTime + \n                      m_maxVelocity * (currentTime - m_accelTime);\n            \n        } else {\n            // Deceleration phase\n            double decelTime = currentTime - m_accelTime - m_constantTime;\n            acceleration = -m_maxAcceleration;\n            velocity = m_maxVelocity - m_maxAcceleration * decelTime;\n            position = m_distance - 0.5 * m_maxAcceleration * (m_decelTime - decelTime) * (m_decelTime - decelTime);\n        }\n        \n        return new MotionProfileState(position, velocity, acceleration);\n    }\n    \n    public boolean isFinished() {\n        return m_isFinished;\n    }\n    \n    public double getTotalTime() {\n        return m_totalTime;\n    }\n    \n    // Motion profile state class\n    public static class MotionProfileState {\n        public final double position;\n        public final double velocity;\n        public final double acceleration;\n        \n        public MotionProfileState(double position, double velocity, double acceleration) {\n            this.position = position;\n            this.velocity = velocity;\n            this.acceleration = acceleration;\n        }\n    }\n}"
    },
    {
      "type": "text",
      "title": "REV Spark MAX Motion Profiling",
      "content": "The REV Spark MAX supports Smart Motion, which provides built-in motion profiling with automatic trajectory generation."
    },
    {
      "type": "code",
      "title": "REV Spark MAX Motion Profiling",
      "content": "package frc.robot.subsystems;\n\nimport com.revrobotics.CANSparkMax;\nimport com.revrobotics.CANSparkMaxLowLevel.MotorType;\nimport com.revrobotics.RelativeEncoder;\nimport com.revrobotics.SparkMaxPIDController;\nimport edu.wpi.first.wpilibj.smartdashboard.SmartDashboard;\nimport edu.wpi.first.wpilibj2.command.SubsystemBase;\n\npublic class Arm extends SubsystemBase {\n    // Motor controller\n    private final CANSparkMax m_armMotor = new CANSparkMax(3, MotorType.kBrushless);\n    private final RelativeEncoder m_encoder = m_armMotor.getEncoder();\n    private final SparkMaxPIDController m_pidController = m_armMotor.getPIDController();\n    \n    // Motion profile parameters\n    private static final double MAX_VELOCITY = 30.0;        // degrees/second\n    private static final double MAX_ACCELERATION = 60.0;    // degrees/second^2\n    private static final double ALLOWED_ERROR = 1.0;        // degrees\n    private static final double MIN_VELOCITY = 0.0;         // degrees/second\n    \n    // PID constants for motion profiling\n    private static final double MOTION_KP = 0.2;\n    private static final double MOTION_KI = 0.0;\n    private static final double MOTION_KD = 0.02;\n    private static final double MOTION_KF = 0.0;\n    \n    public Arm() {\n        // Configure motor\n        m_armMotor.setInverted(false);\n        m_armMotor.setSmartCurrentLimit(30);\n        \n        // Configure encoder\n        m_encoder.setPositionConversionFactor(1.0); // 1 unit = 1 degree\n        m_encoder.setVelocityConversionFactor(1.0); // 1 unit = 1 degree/second\n        \n        // Configure PID for motion profiling\n        m_pidController.setP(MOTION_KP);\n        m_pidController.setI(MOTION_KI);\n        m_pidController.setD(MOTION_KD);\n        m_pidController.setFF(MOTION_KF);\n        \n        // Configure Smart Motion parameters\n        m_pidController.setSmartMotionMaxVelocity(MAX_VELOCITY, 0);\n        m_pidController.setSmartMotionMaxAccel(MAX_ACCELERATION, 0);\n        m_pidController.setSmartMotionAllowedClosedLoopError(ALLOWED_ERROR, 0);\n        m_pidController.setSmartMotionMinOutputVelocity(MIN_VELOCITY, 0);\n        \n        // Set output range\n        m_pidController.setOutputRange(-0.5, 0.5);\n        \n        SmartDashboard.putString(\"Arm Status\", \"Motion Profiling Initialized\");\n    }\n    \n    // Motion profile control methods\n    public void moveToPosition(double position) {\n        // Use Smart Motion for smooth motion profiling\n        m_pidController.setReference(position, CANSparkMax.ControlType.kSmartMotion);\n        \n        SmartDashboard.putString(\"Arm Action\", \"Moving to \" + position + \" degrees\");\n    }\n    \n    public void moveToPositionWithProfile(double position) {\n        // Alternative: Use position control with custom profile\n        m_pidController.setReference(position, CANSparkMax.ControlType.kPosition);\n    }\n    \n    public boolean isAtPosition(double position, double tolerance) {\n        return Math.abs(getPosition() - position) < tolerance;\n    }\n    \n    public boolean isMotionComplete() {\n        // Check if Smart Motion has completed\n        return m_pidController.getSmartMotionAllowedClosedLoopError(0) >= \n               Math.abs(m_pidController.getSetpoint() - getPosition());\n    }\n    \n    // Sensor methods\n    public double getPosition() {\n        return m_encoder.getPosition();\n    }\n    \n    public double getVelocity() {\n        return m_encoder.getVelocity();\n    }\n    \n    // Preset positions with motion profiling\n    public void moveToGround() {\n        moveToPosition(0);\n    }\n    \n    public void moveToLowScore() {\n        moveToPosition(45);\n    }\n    \n    public void moveToHighScore() {\n        moveToPosition(90);\n    }\n    \n    // Motion profile tuning methods\n    public void setMotionProfileParameters(double maxVelocity, double maxAcceleration) {\n        m_pidController.setSmartMotionMaxVelocity(maxVelocity, 0);\n        m_pidController.setSmartMotionMaxAccel(maxAcceleration, 0);\n        \n        SmartDashboard.putNumber(\"Max Velocity\", maxVelocity);\n        SmartDashboard.putNumber(\"Max Acceleration\", maxAcceleration);\n    }\n    \n    @Override\n    public void periodic() {\n        // Update SmartDashboard\n        SmartDashboard.putNumber(\"Arm Position\", getPosition());\n        SmartDashboard.putNumber(\"Arm Velocity\", getVelocity());\n        SmartDashboard.putBoolean(\"Motion Complete\", isMotionComplete());\n        SmartDashboard.putNumber(\"Arm Current\", m_armMotor.getOutputCurrent());\n        \n        // Display motion profile parameters\n        SmartDashboard.putNumber(\"Max Velocity\", MAX_VELOCITY);\n        SmartDashboard.putNumber(\"Max Acceleration\", MAX_ACCELERATION);\n        SmartDashboard.putNumber(\"Allowed Error\", ALLOWED_ERROR);\n    }\n}"
    },
    {
      "type": "text",
      "title": "CTRE Talon FX Motion Profiling",
      "content": "CTRE Talon FX controllers support advanced motion profiling with Motion Magic and trajectory following capabilities."
    },
    {
      "type": "code",
      "title": "CTRE Talon FX Motion Profiling",
      "content": "package frc.robot.subsystems;\n\nimport com.ctre.phoenix.motorcontrol.can.WPI_TalonFX;\nimport com.ctre.phoenix.motorcontrol.NeutralMode;\nimport com.ctre.phoenix.motorcontrol.FeedbackDevice;\nimport com.ctre.phoenix.motorcontrol.StatusFrame;\nimport edu.wpi.first.wpilibj.smartdashboard.SmartDashboard;\nimport edu.wpi.first.wpilibj2.command.SubsystemBase;\n\npublic class Elevator extends SubsystemBase {\n    // Motor controller\n    private final WPI_TalonFX m_elevatorMotor = new WPI_TalonFX(4);\n    \n    // Motion profile parameters\n    private static final double MAX_VELOCITY = 2000;        // encoder units per 100ms\n    private static final double MAX_ACCELERATION = 4000;    // encoder units per 100ms per 100ms\n    private static final double ALLOWED_ERROR = 50;         // encoder units\n    \n    // PID constants for motion profiling\n    private static final double MOTION_KP = 0.2;\n    private static final double MOTION_KI = 0.0;\n    private static final double MOTION_KD = 0.02;\n    private static final double MOTION_KF = 0.0;\n    \n    // Conversion factors\n    private static final double ENCODER_UNITS_PER_INCH = 2048.0 / (Math.PI * 1.5); // 1.5 inch drum\n    \n    public Elevator() {\n        // Configure motor\n        m_elevatorMotor.setNeutralMode(NeutralMode.Brake);\n        m_elevatorMotor.configSupplyCurrentLimit(new SupplyCurrentLimitConfiguration(true, 40, 40, 0.1));\n        \n        // Configure encoder\n        m_elevatorMotor.configSelectedFeedbackSensor(FeedbackDevice.IntegratedSensor, 0, 10);\n        m_elevatorMotor.setSelectedSensorPosition(0, 0, 10);\n        \n        // Configure PID for motion profiling (Slot 0)\n        m_elevatorMotor.config_kP(0, MOTION_KP, 10);\n        m_elevatorMotor.config_kI(0, MOTION_KI, 10);\n        m_elevatorMotor.config_kD(0, MOTION_KD, 10);\n        m_elevatorMotor.config_kF(0, MOTION_KF, 10);\n        \n        // Configure Motion Magic parameters\n        m_elevatorMotor.configMotionCruiseVelocity(MAX_VELOCITY, 10);\n        m_elevatorMotor.configMotionAcceleration(MAX_ACCELERATION, 10);\n        m_elevatorMotor.configMotionSCurveStrength(0, 10); // 0 = trapezoidal, higher = S-curve\n        \n        // Configure output limits\n        m_elevatorMotor.configPeakOutputForward(0.5, 10);\n        m_elevatorMotor.configPeakOutputReverse(-0.5, 10);\n        \n        // Set status frame periods for faster updates\n        m_elevatorMotor.setStatusFramePeriod(StatusFrame.Status_10_MotionMagic, 10, 10);\n        \n        SmartDashboard.putString(\"Elevator Status\", \"Motion Profiling Initialized\");\n    }\n    \n    // Motion profile control methods\n    public void moveToHeight(double height) {\n        // Convert height to encoder units\n        double encoderUnits = height * ENCODER_UNITS_PER_INCH;\n        \n        // Use Motion Magic for smooth motion profiling\n        m_elevatorMotor.set(ControlMode.MotionMagic, encoderUnits);\n        \n        SmartDashboard.putString(\"Elevator Action\", \"Moving to \" + height + \" inches\");\n    }\n    \n    public boolean isAtHeight(double height, double tolerance) {\n        double currentHeight = getHeight();\n        return Math.abs(currentHeight - height) < tolerance;\n    }\n    \n    public boolean isMotionComplete() {\n        // Check if Motion Magic has completed\n        return m_elevatorMotor.getClosedLoopError(0) < ALLOWED_ERROR && \n               Math.abs(m_elevatorMotor.getSelectedSensorVelocity(0)) < 100; // Low velocity\n    }\n    \n    // Sensor methods\n    public double getHeight() {\n        double encoderUnits = m_elevatorMotor.getSelectedSensorPosition(0);\n        return encoderUnits / ENCODER_UNITS_PER_INCH;\n    }\n    \n    public double getVelocity() {\n        double encoderUnitsPer100ms = m_elevatorMotor.getSelectedSensorVelocity(0);\n        return encoderUnitsPer100ms * 10.0 / ENCODER_UNITS_PER_INCH; // Convert to inches/second\n    }\n    \n    // Preset heights with motion profiling\n    public void moveToBottom() {\n        moveToHeight(0);\n    }\n    \n    public void moveToLowScore() {\n        moveToHeight(20);\n    }\n    \n    public void moveToMidScore() {\n        moveToHeight(40);\n    }\n    \n    public void moveToHighScore() {\n        moveToHeight(60);\n    }\n    \n    // Motion profile tuning methods\n    public void setMotionProfileParameters(double maxVelocity, double maxAcceleration) {\n        m_elevatorMotor.configMotionCruiseVelocity(maxVelocity, 10);\n        m_elevatorMotor.configMotionAcceleration(maxAcceleration, 10);\n        \n        SmartDashboard.putNumber(\"Max Velocity\", maxVelocity);\n        SmartDashboard.putNumber(\"Max Acceleration\", maxAcceleration);\n    }\n    \n    @Override\n    public void periodic() {\n        // Update SmartDashboard\n        SmartDashboard.putNumber(\"Elevator Height\", getHeight());\n        SmartDashboard.putNumber(\"Elevator Velocity\", getVelocity());\n        SmartDashboard.putBoolean(\"Motion Complete\", isMotionComplete());\n        SmartDashboard.putNumber(\"Elevator Current\", m_elevatorMotor.getStatorCurrent());\n        \n        // Display motion profile parameters\n        SmartDashboard.putNumber(\"Max Velocity (units/100ms)\", MAX_VELOCITY);\n        SmartDashboard.putNumber(\"Max Acceleration (units/100ms^2)\", MAX_ACCELERATION);\n        SmartDashboard.putNumber(\"Allowed Error (units)\", ALLOWED_ERROR);\n    }\n}"
    },
    {
      "type": "text",
      "title": "Custom Motion Profile Commands",
      "content": "You can create custom commands that use motion profiles for precise control over robot movement."
    },
    {
      "type": "code",
      "title": "Custom Motion Profile Commands",
      "content": "package frc.robot.commands;\n\nimport edu.wpi.first.wpilibj2.command.CommandBase;\nimport frc.robot.subsystems.Arm;\nimport frc.robot.utils.TrapezoidalMotionProfile;\nimport edu.wpi.first.wpilibj.smartdashboard.SmartDashboard;\n\npublic class ArmMotionProfileCommand extends CommandBase {\n    private final Arm m_arm;\n    private final TrapezoidalMotionProfile m_profile;\n    private final double m_targetPosition;\n    private final double m_startPosition;\n    \n    // PID controller for following the profile\n    private final PIDController m_pidController;\n    \n    public ArmMotionProfileCommand(Arm arm, double targetPosition) {\n        m_arm = arm;\n        m_targetPosition = targetPosition;\n        m_startPosition = arm.getPosition();\n        \n        // Create motion profile\n        double distance = targetPosition - m_startPosition;\n        m_profile = new TrapezoidalMotionProfile(30.0, 60.0, distance);\n        \n        // Create PID controller for following the profile\n        m_pidController = new PIDController(0.1, 0.0, 0.01);\n        \n        addRequirements(m_arm);\n    }\n    \n    @Override\n    public void initialize() {\n        // Start the motion profile\n        m_profile.start();\n        m_pidController.reset();\n        \n        SmartDashboard.putString(\"Motion Profile Status\", \"Started\");\n    }\n    \n    @Override\n    public void execute() {\n        // Get the desired state from the motion profile\n        TrapezoidalMotionProfile.MotionProfileState desiredState = m_profile.calculate();\n        \n        // Calculate the target position (add to start position)\n        double targetPosition = m_startPosition + desiredState.position;\n        \n        // Use PID to follow the profile\n        double currentPosition = m_arm.getPosition();\n        double output = m_pidController.calculate(currentPosition, targetPosition);\n        \n        // Apply feed forward for velocity\n        double feedForward = desiredState.velocity * 0.01; // Feed forward gain\n        output += feedForward;\n        \n        // Set motor output\n        m_arm.setMotorOutput(output);\n        \n        // Update SmartDashboard\n        SmartDashboard.putNumber(\"Desired Position\", targetPosition);\n        SmartDashboard.putNumber(\"Current Position\", currentPosition);\n        SmartDashboard.putNumber(\"Desired Velocity\", desiredState.velocity);\n        SmartDashboard.putNumber(\"Profile Output\", output);\n    }\n    \n    @Override\n    public void end(boolean interrupted) {\n        // Stop the arm\n        m_arm.stop();\n        \n        if (interrupted) {\n            SmartDashboard.putString(\"Motion Profile Status\", \"Interrupted\");\n        } else {\n            SmartDashboard.putString(\"Motion Profile Status\", \"Complete\");\n        }\n    }\n    \n    @Override\n    public boolean isFinished() {\n        return m_profile.isFinished();\n    }\n}\n\n// Command for coordinated motion (multiple mechanisms)\npublic class CoordinatedMotionCommand extends CommandBase {\n    private final Arm m_arm;\n    private final Elevator m_elevator;\n    private final TrapezoidalMotionProfile m_armProfile;\n    private final TrapezoidalMotionProfile m_elevatorProfile;\n    \n    public CoordinatedMotionCommand(Arm arm, Elevator elevator, \n                                   double armTarget, double elevatorTarget) {\n        m_arm = arm;\n        m_elevator = elevator;\n        \n        // Create profiles for both mechanisms\n        double armDistance = armTarget - arm.getPosition();\n        double elevatorDistance = elevatorTarget - elevator.getHeight();\n        \n        m_armProfile = new TrapezoidalMotionProfile(30.0, 60.0, armDistance);\n        m_elevatorProfile = new TrapezoidalMotionProfile(20.0, 40.0, elevatorDistance);\n        \n        addRequirements(m_arm, m_elevator);\n    }\n    \n    @Override\n    public void initialize() {\n        m_armProfile.start();\n        m_elevatorProfile.start();\n    }\n    \n    @Override\n    public void execute() {\n        // Execute both profiles simultaneously\n        TrapezoidalMotionProfile.MotionProfileState armState = m_armProfile.calculate();\n        TrapezoidalMotionProfile.MotionProfileState elevatorState = m_elevatorProfile.calculate();\n        \n        // Apply motion to both mechanisms\n        m_arm.setPosition(armState.position);\n        m_elevator.moveToHeight(elevatorState.position);\n    }\n    \n    @Override\n    public void end(boolean interrupted) {\n        m_arm.stop();\n        m_elevator.stop();\n    }\n    \n    @Override\n    public boolean isFinished() {\n        return m_armProfile.isFinished() && m_elevatorProfile.isFinished();\n    }\n}"
    },
    {
      "type": "text",
      "title": "Advanced Motion Control Features",
      "content": "Advanced motion control includes features like S-curves, adaptive profiles, and trajectory optimization."
    },
    {
      "type": "code",
      "title": "Advanced Motion Control",
      "content": "// 1. S-Curve Motion Profile\n// S-curves provide smoother acceleration and deceleration\n\npublic class SCurveMotionProfile {\n    private final double m_maxVelocity;\n    private final double m_maxAcceleration;\n    private final double m_jerk; // Rate of change of acceleration\n    private final double m_distance;\n    \n    public SCurveMotionProfile(double maxVelocity, double maxAcceleration, \n                              double jerk, double distance) {\n        m_maxVelocity = maxVelocity;\n        m_maxAcceleration = maxAcceleration;\n        m_jerk = jerk;\n        m_distance = distance;\n    }\n    \n    public MotionProfileState calculate(double time) {\n        // S-curve calculation (simplified)\n        // In practice, you'd use more complex math for true S-curves\n        \n        double position, velocity, acceleration;\n        \n        // Calculate jerk-limited motion\n        if (time < m_maxAcceleration / m_jerk) {\n            // Jerk phase\n            acceleration = m_jerk * time;\n            velocity = 0.5 * m_jerk * time * time;\n            position = (1.0/6.0) * m_jerk * time * time * time;\n        } else if (time < m_maxVelocity / m_maxAcceleration) {\n            // Constant acceleration phase\n            acceleration = m_maxAcceleration;\n            velocity = m_maxAcceleration * time - 0.5 * m_maxAcceleration * m_maxAcceleration / m_jerk;\n            position = 0.5 * m_maxAcceleration * time * time - \n                      (1.0/6.0) * m_maxAcceleration * m_maxAcceleration * m_maxAcceleration / (m_jerk * m_jerk);\n        } else {\n            // Constant velocity phase\n            acceleration = 0.0;\n            velocity = m_maxVelocity;\n            position = m_maxVelocity * time - 0.5 * m_maxVelocity * m_maxVelocity / m_maxAcceleration;\n        }\n        \n        return new MotionProfileState(position, velocity, acceleration);\n    }\n}\n\n// 2. Adaptive Motion Profile\n// Adjusts profile parameters based on conditions\n\npublic class AdaptiveMotionProfile {\n    private double m_maxVelocity;\n    private double m_maxAcceleration;\n    private final double m_baseMaxVelocity;\n    private final double m_baseMaxAcceleration;\n    \n    public AdaptiveMotionProfile(double baseMaxVelocity, double baseMaxAcceleration) {\n        m_baseMaxVelocity = baseMaxVelocity;\n        m_baseMaxAcceleration = baseMaxAcceleration;\n        m_maxVelocity = baseMaxVelocity;\n        m_maxAcceleration = baseMaxAcceleration;\n    }\n    \n    public void adaptToLoad(double loadFactor) {\n        // Reduce speed and acceleration for heavy loads\n        m_maxVelocity = m_baseMaxVelocity * (1.0 - loadFactor * 0.3);\n        m_maxAcceleration = m_baseMaxAcceleration * (1.0 - loadFactor * 0.5);\n    }\n    \n    public void adaptToBattery(double batteryVoltage) {\n        // Reduce performance for low battery\n        if (batteryVoltage < 11.0) {\n            m_maxVelocity *= 0.8;\n            m_maxAcceleration *= 0.7;\n        } else {\n            m_maxVelocity = m_baseMaxVelocity;\n            m_maxAcceleration = m_baseMaxAcceleration;\n        }\n    }\n    \n    public void adaptToTemperature(double motorTemperature) {\n        // Reduce performance for high temperatures\n        if (motorTemperature > 80.0) {\n            m_maxVelocity *= 0.9;\n            m_maxAcceleration *= 0.8;\n        }\n    }\n}\n\n// 3. Trajectory Optimization\n// Optimizes motion profiles for efficiency\n\npublic class TrajectoryOptimizer {\n    public TrapezoidalMotionProfile optimizeProfile(double distance, \n                                                   double maxVelocity, \n                                                   double maxAcceleration) {\n        // Calculate optimal profile parameters\n        double optimalVelocity = Math.min(maxVelocity, \n            Math.sqrt(2.0 * maxAcceleration * distance / 3.0));\n        \n        double optimalAcceleration = Math.min(maxAcceleration, \n            optimalVelocity * optimalVelocity / distance);\n        \n        return new TrapezoidalMotionProfile(optimalVelocity, optimalAcceleration, distance);\n    }\n    \n    public double calculateOptimalTime(double distance, double maxVelocity, double maxAcceleration) {\n        // Calculate minimum time for given constraints\n        double accelTime = maxVelocity / maxAcceleration;\n        double accelDistance = 0.5 * maxAcceleration * accelTime * accelTime;\n        \n        if (2.0 * accelDistance <= distance) {\n            // Full trapezoid\n            double constantDistance = distance - 2.0 * accelDistance;\n            double constantTime = constantDistance / maxVelocity;\n            return 2.0 * accelTime + constantTime;\n        } else {\n            // Triangle\n            return 2.0 * Math.sqrt(distance / maxAcceleration);\n        }\n    }\n}"
    },
    {
      "type": "rules-box",
      "title": "Motion Profiling Best Practices",
      "items": [
        "<strong>Start conservative:</strong> Use lower velocities and accelerations initially",
        "<strong>Tune systematically:</strong> Adjust parameters one at a time",
        "<strong>Consider mechanical limits:</strong> Account for backlash, friction, and inertia",
        "<strong>Test thoroughly:</strong> Test under various loads and conditions",
        "<strong>Monitor performance:</strong> Use SmartDashboard to track motion quality",
        "<strong>Plan for failures:</strong> Implement fallback behaviors for profile failures"
      ],
      "subtitle": "Follow these guidelines for effective motion profiling:"
    },
    {
      "type": "exercise-box",
      "title": "Motion Profiling Practice",
      "description": "Implement and test motion profiling for various mechanisms.",
      "tasks": [
        "Create a trapezoidal motion profile class",
        "Implement motion profiling with REV Spark MAX Smart Motion",
        "Implement motion profiling with CTRE Talon FX Motion Magic",
        "Create custom motion profile commands",
        "Implement coordinated motion for multiple mechanisms",
        "Add S-curve motion profiles for smoother motion",
        "Create adaptive motion profiles based on conditions",
        "Implement trajectory optimization",
        "Test motion profiles under various loads",
        "Tune motion profile parameters for optimal performance"
      ],
      "content": "// Example motion profiling workflow:\n\n// 1. Create a basic motion profile\nTrapezoidalMotionProfile profile = new TrapezoidalMotionProfile(\n    30.0,  // max velocity (degrees/second)\n    60.0,  // max acceleration (degrees/second^2)\n    45.0   // distance (degrees)\n);\n\n// 2. Use in a command\npublic class MotionProfileCommand extends CommandBase {\n    private final TrapezoidalMotionProfile m_profile;\n    private final Arm m_arm;\n    \n    public MotionProfileCommand(Arm arm, double targetPosition) {\n        m_arm = arm;\n        double distance = targetPosition - arm.getPosition();\n        m_profile = new TrapezoidalMotionProfile(30.0, 60.0, distance);\n        addRequirements(arm);\n    }\n    \n    @Override\n    public void initialize() {\n        m_profile.start();\n    }\n    \n    @Override\n    public void execute() {\n        TrapezoidalMotionProfile.MotionProfileState state = m_profile.calculate();\n        m_arm.setPosition(state.position);\n    }\n    \n    @Override\n    public boolean isFinished() {\n        return m_profile.isFinished();\n    }\n}\n\n// 3. Use built-in motion profiling\n// For REV Spark MAX:\nm_arm.moveToPosition(45.0); // Uses Smart Motion\n\n// For CTRE Talon FX:\nm_elevator.moveToHeight(20.0); // Uses Motion Magic\n\n// 4. Create coordinated motion\nSequentialCommandGroup coordinatedMotion = new SequentialCommandGroup(\n    new ParallelCommandGroup(\n        new ArmMotionProfileCommand(m_arm, 45.0),\n        new ElevatorMotionProfileCommand(m_elevator, 20.0)\n    ),\n    new WaitCommand(0.5),\n    new IntakeCommand(m_intake)\n);"
    }
  ]
}
