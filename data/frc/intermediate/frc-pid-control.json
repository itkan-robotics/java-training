{
  "title": "PID Control Systems",
  "sections": [
    {
      "type": "text",
      "title": "Understanding PID Control",
      "content": "PID (Proportional-Integral-Derivative) control is a feedback control system that helps mechanisms reach and maintain desired positions or speeds. It's essential for precise robot control in FRC."
    },
    {
      "type": "rules-box",
      "title": "PID Control Components",
      "items": [
        "<strong>Proportional (P):</strong> Responds to current error - larger error = larger correction",
        "<strong>Integral (I):</strong> Accumulates past errors to eliminate steady-state error",
        "<strong>Derivative (D):</strong> Responds to rate of change to reduce overshoot and oscillation",
        "<strong>Setpoint:</strong> The desired position or value",
        "<strong>Feedback:</strong> The current position or value from sensors"
      ],
      "subtitle": "PID control consists of three components:"
    },
    {
      "type": "text",
      "title": "PID Control Theory",
      "content": "The PID controller calculates an output based on the error between the desired setpoint and the current feedback value. Understanding this relationship is crucial for effective tuning."
    },
    {
      "type": "code",
      "title": "PID Control Formula",
      "content": "// PID Control Formula:\n// output = Kp * error + Ki * integral + Kd * derivative\n\n// Where:\n// error = setpoint - feedback\n// integral = sum of all past errors\n// derivative = rate of change of error\n\n// Example implementation:\npublic class PIDController {\n    private double m_kp, m_ki, m_kd;\n    private double m_setpoint;\n    private double m_previousError;\n    private double m_integral;\n    private double m_outputMin, m_outputMax;\n    \n    public PIDController(double kp, double ki, double kd) {\n        m_kp = kp;\n        m_ki = ki;\n        m_kd = kd;\n        m_setpoint = 0.0;\n        m_previousError = 0.0;\n        m_integral = 0.0;\n        m_outputMin = -1.0;\n        m_outputMax = 1.0;\n    }\n    \n    public double calculate(double feedback) {\n        // Calculate error\n        double error = m_setpoint - feedback;\n        \n        // Proportional term\n        double proportional = m_kp * error;\n        \n        // Integral term\n        m_integral += error;\n        double integral = m_ki * m_integral;\n        \n        // Derivative term\n        double derivative = m_kd * (error - m_previousError);\n        \n        // Calculate output\n        double output = proportional + integral + derivative;\n        \n        // Clamp output\n        output = Math.max(m_outputMin, Math.min(m_outputMax, output));\n        \n        // Update previous error\n        m_previousError = error;\n        \n        return output;\n    }\n    \n    public void setSetpoint(double setpoint) {\n        m_setpoint = setpoint;\n    }\n    \n    public void reset() {\n        m_previousError = 0.0;\n        m_integral = 0.0;\n    }\n}"
    },
    {
      "type": "text",
      "title": "REV Spark MAX PID",
      "content": "The REV Spark MAX motor controller has built-in PID control that can be configured and used directly. This provides excellent performance and reduces the need for external PID controllers."
    },
    {
      "type": "code",
      "title": "REV Spark MAX PID Implementation",
      "content": "package frc.robot.subsystems;\n\nimport com.revrobotics.CANSparkMax;\nimport com.revrobotics.CANSparkMaxLowLevel.MotorType;\nimport com.revrobotics.RelativeEncoder;\nimport com.revrobotics.SparkMaxPIDController;\nimport edu.wpi.first.wpilibj.smartdashboard.SmartDashboard;\nimport edu.wpi.first.wpilibj2.command.SubsystemBase;\n\npublic class Arm extends SubsystemBase {\n    // Motor controller\n    private final CANSparkMax m_armMotor = new CANSparkMax(3, MotorType.kBrushless);\n    private final RelativeEncoder m_encoder = m_armMotor.getEncoder();\n    private final SparkMaxPIDController m_pidController = m_armMotor.getPIDController();\n    \n    // PID constants\n    private static final double ARM_KP = 0.1;\n    private static final double ARM_KI = 0.0;\n    private static final double ARM_KD = 0.01;\n    private static final double ARM_KF = 0.0; // Feed forward\n    \n    // Position limits\n    private static final double MIN_POSITION = 0.0;\n    private static final double MAX_POSITION = 90.0;\n    \n    // Control state\n    private double m_targetPosition = 0.0;\n    private boolean m_pidEnabled = false;\n    \n    public Arm() {\n        // Configure motor\n        m_armMotor.setInverted(false);\n        m_armMotor.setSmartCurrentLimit(30);\n        \n        // Configure encoder\n        m_encoder.setPositionConversionFactor(1.0); // 1 unit = 1 degree\n        m_encoder.setVelocityConversionFactor(1.0); // 1 unit = 1 degree/second\n        \n        // Configure PID controller\n        m_pidController.setP(ARM_KP);\n        m_pidController.setI(ARM_KI);\n        m_pidController.setD(ARM_KD);\n        m_pidController.setFF(ARM_KF);\n        \n        // Set output range\n        m_pidController.setOutputRange(-0.5, 0.5);\n        \n        // Set position tolerance\n        m_pidController.setSmartMotionMaxVelocity(30, 0); // 30 degrees/second\n        m_pidController.setSmartMotionMaxAccel(60, 0);    // 60 degrees/second^2\n        m_pidController.setSmartMotionAllowedClosedLoopError(1, 0); // 1 degree tolerance\n        \n        SmartDashboard.putString(\"Arm Status\", \"PID Controller Initialized\");\n    }\n    \n    // Manual control methods\n    public void moveUp() {\n        m_pidEnabled = false;\n        m_armMotor.set(0.3);\n    }\n    \n    public void moveDown() {\n        m_pidEnabled = false;\n        m_armMotor.set(-0.3);\n    }\n    \n    public void stop() {\n        m_armMotor.set(0);\n    }\n    \n    // PID position control\n    public void setPosition(double position) {\n        // Clamp position to limits\n        position = Math.max(MIN_POSITION, Math.min(MAX_POSITION, position));\n        \n        m_targetPosition = position;\n        m_pidEnabled = true;\n        \n        // Set the setpoint for the PID controller\n        m_pidController.setReference(position, CANSparkMax.ControlType.kPosition);\n    }\n    \n    public boolean isAtPosition(double position, double tolerance) {\n        return Math.abs(getPosition() - position) < tolerance;\n    }\n    \n    public boolean isAtTargetPosition() {\n        return isAtPosition(m_targetPosition, 1.0);\n    }\n    \n    // Sensor methods\n    public double getPosition() {\n        return m_encoder.getPosition();\n    }\n    \n    public double getVelocity() {\n        return m_encoder.getVelocity();\n    }\n    \n    // PID tuning methods\n    public void setPIDConstants(double kp, double ki, double kd) {\n        m_pidController.setP(kp);\n        m_pidController.setI(ki);\n        m_pidController.setD(kd);\n    }\n    \n    public void resetEncoder() {\n        m_encoder.setPosition(0);\n    }\n    \n    // Preset positions\n    public void moveToGround() {\n        setPosition(0);\n    }\n    \n    public void moveToLowScore() {\n        setPosition(45);\n    }\n    \n    public void moveToHighScore() {\n        setPosition(90);\n    }\n    \n    @Override\n    public void periodic() {\n        // Update SmartDashboard\n        SmartDashboard.putNumber(\"Arm Position\", getPosition());\n        SmartDashboard.putNumber(\"Arm Velocity\", getVelocity());\n        SmartDashboard.putNumber(\"Target Position\", m_targetPosition);\n        SmartDashboard.putBoolean(\"At Target\", isAtTargetPosition());\n        SmartDashboard.putBoolean(\"PID Enabled\", m_pidEnabled);\n        SmartDashboard.putNumber(\"Arm Current\", m_armMotor.getOutputCurrent());\n        \n        // Display PID constants for tuning\n        SmartDashboard.putNumber(\"Arm KP\", ARM_KP);\n        SmartDashboard.putNumber(\"Arm KI\", ARM_KI);\n        SmartDashboard.putNumber(\"Arm KD\", ARM_KD);\n    }\n}"
    },
    {
      "type": "text",
      "title": "CTRE Talon FX PID",
      "content": "CTRE Talon FX controllers also have built-in PID control with advanced features like motion profiling and multiple PID slots."
    },
    {
      "type": "code",
      "title": "CTRE Talon FX PID Implementation",
      "content": "package frc.robot.subsystems;\n\nimport com.ctre.phoenix.motorcontrol.can.WPI_TalonFX;\nimport com.ctre.phoenix.motorcontrol.NeutralMode;\nimport com.ctre.phoenix.motorcontrol.FeedbackDevice;\nimport com.ctre.phoenix.motorcontrol.StatusFrame;\nimport edu.wpi.first.wpilibj.smartdashboard.SmartDashboard;\nimport edu.wpi.first.wpilibj2.command.SubsystemBase;\n\npublic class Elevator extends SubsystemBase {\n    // Motor controller\n    private final WPI_TalonFX m_elevatorMotor = new WPI_TalonFX(4);\n    \n    // PID constants\n    private static final double ELEVATOR_KP = 0.1;\n    private static final double ELEVATOR_KI = 0.0;\n    private static final double ELEVATOR_KD = 0.01;\n    private static final double ELEVATOR_KF = 0.0;\n    \n    // Position limits\n    private static final double MIN_HEIGHT = 0.0;\n    private static final double MAX_HEIGHT = 60.0;\n    \n    // Control state\n    private double m_targetHeight = 0.0;\n    private boolean m_pidEnabled = false;\n    \n    public Elevator() {\n        // Configure motor\n        m_elevatorMotor.setNeutralMode(NeutralMode.Brake);\n        m_elevatorMotor.configSupplyCurrentLimit(new SupplyCurrentLimitConfiguration(true, 40, 40, 0.1));\n        \n        // Configure encoder\n        m_elevatorMotor.configSelectedFeedbackSensor(FeedbackDevice.IntegratedSensor, 0, 10);\n        m_elevatorMotor.setSelectedSensorPosition(0, 0, 10);\n        \n        // Configure PID controller (Slot 0)\n        m_elevatorMotor.config_kP(0, ELEVATOR_KP, 10);\n        m_elevatorMotor.config_kI(0, ELEVATOR_KI, 10);\n        m_elevatorMotor.config_kD(0, ELEVATOR_KD, 10);\n        m_elevatorMotor.config_kF(0, ELEVATOR_KF, 10);\n        \n        // Configure output limits\n        m_elevatorMotor.configPeakOutputForward(0.5, 10);\n        m_elevatorMotor.configPeakOutputReverse(-0.5, 10);\n        \n        // Configure closed loop settings\n        m_elevatorMotor.configAllowableClosedloopError(0, 50, 10); // 50 encoder units tolerance\n        m_elevatorMotor.configClosedLoopPeakOutput(0, 0.5, 10);\n        \n        // Set status frame periods for faster updates\n        m_elevatorMotor.setStatusFramePeriod(StatusFrame.Status_13_Base_PIDF0, 10, 10);\n        m_elevatorMotor.setStatusFramePeriod(StatusFrame.Status_10_MotionMagic, 10, 10);\n        \n        SmartDashboard.putString(\"Elevator Status\", \"PID Controller Initialized\");\n    }\n    \n    // Manual control methods\n    public void moveUp() {\n        m_pidEnabled = false;\n        m_elevatorMotor.set(0.3);\n    }\n    \n    public void moveDown() {\n        m_pidEnabled = false;\n        m_elevatorMotor.set(-0.3);\n    }\n    \n    public void stop() {\n        m_elevatorMotor.set(0);\n    }\n    \n    // PID position control\n    public void setHeight(double height) {\n        // Clamp height to limits\n        height = Math.max(MIN_HEIGHT, Math.min(MAX_HEIGHT, height));\n        \n        m_targetHeight = height;\n        m_pidEnabled = true;\n        \n        // Convert height to encoder units (assuming 2048 units per revolution)\n        double encoderUnits = height * 2048.0 / (Math.PI * 1.5); // 1.5 inch diameter drum\n        \n        // Set the setpoint for the PID controller\n        m_elevatorMotor.set(ControlMode.Position, encoderUnits);\n    }\n    \n    public boolean isAtHeight(double height, double tolerance) {\n        return Math.abs(getHeight() - height) < tolerance;\n    }\n    \n    public boolean isAtTargetHeight() {\n        return isAtHeight(m_targetHeight, 0.5);\n    }\n    \n    // Sensor methods\n    public double getHeight() {\n        // Convert encoder units to height\n        double encoderUnits = m_elevatorMotor.getSelectedSensorPosition(0);\n        return encoderUnits * (Math.PI * 1.5) / 2048.0; // 1.5 inch diameter drum\n    }\n    \n    public double getVelocity() {\n        // Convert encoder units per 100ms to inches per second\n        double encoderUnitsPer100ms = m_elevatorMotor.getSelectedSensorVelocity(0);\n        return encoderUnitsPer100ms * 10.0 * (Math.PI * 1.5) / 2048.0;\n    }\n    \n    // PID tuning methods\n    public void setPIDConstants(double kp, double ki, double kd) {\n        m_elevatorMotor.config_kP(0, kp, 10);\n        m_elevatorMotor.config_kI(0, ki, 10);\n        m_elevatorMotor.config_kD(0, kd, 10);\n    }\n    \n    public void resetEncoder() {\n        m_elevatorMotor.setSelectedSensorPosition(0, 0, 10);\n    }\n    \n    // Preset heights\n    public void moveToBottom() {\n        setHeight(0);\n    }\n    \n    public void moveToLowScore() {\n        setHeight(20);\n    }\n    \n    public void moveToMidScore() {\n        setHeight(40);\n    }\n    \n    public void moveToHighScore() {\n        setHeight(60);\n    }\n    \n    @Override\n    public void periodic() {\n        // Update SmartDashboard\n        SmartDashboard.putNumber(\"Elevator Height\", getHeight());\n        SmartDashboard.putNumber(\"Elevator Velocity\", getVelocity());\n        SmartDashboard.putNumber(\"Target Height\", m_targetHeight);\n        SmartDashboard.putBoolean(\"At Target\", isAtTargetHeight());\n        SmartDashboard.putBoolean(\"PID Enabled\", m_pidEnabled);\n        SmartDashboard.putNumber(\"Elevator Current\", m_elevatorMotor.getStatorCurrent());\n        \n        // Display PID constants for tuning\n        SmartDashboard.putNumber(\"Elevator KP\", ELEVATOR_KP);\n        SmartDashboard.putNumber(\"Elevator KI\", ELEVATOR_KI);\n        SmartDashboard.putNumber(\"Elevator KD\", ELEVATOR_KD);\n    }\n}"
    },
    {
      "type": "text",
      "title": "PID Tuning Process",
      "content": "Tuning PID controllers is both an art and a science. Following a systematic approach helps achieve optimal performance."
    },
    {
      "type": "code",
      "title": "PID Tuning Implementation",
      "content": "package frc.robot.commands;\n\nimport edu.wpi.first.wpilibj2.command.CommandBase;\nimport frc.robot.subsystems.Arm;\nimport edu.wpi.first.wpilibj.smartdashboard.SmartDashboard;\nimport edu.wpi.first.wpilibj.Timer;\n\npublic class PIDTuningCommand extends CommandBase {\n    private final Arm m_arm;\n    private final Timer m_timer = new Timer();\n    \n    // Tuning parameters\n    private double m_kp = 0.0;\n    private double m_ki = 0.0;\n    private double m_kd = 0.0;\n    private double m_setpoint = 45.0;\n    private double m_tolerance = 1.0;\n    \n    // Tuning state\n    private enum TuningState {\n        SETTLING, MEASURING, COMPLETE\n    }\n    \n    private TuningState m_state = TuningState.SETTLING;\n    private double m_settleStartTime = 0.0;\n    private double m_measureStartTime = 0.0;\n    private double m_maxOvershoot = 0.0;\n    private double m_settleTime = 0.0;\n    private double m_steadyStateError = 0.0;\n    \n    public PIDTuningCommand(Arm arm) {\n        m_arm = arm;\n        addRequirements(m_arm);\n    }\n    \n    @Override\n    public void initialize() {\n        m_timer.start();\n        m_timer.reset();\n        \n        // Get tuning parameters from SmartDashboard\n        m_kp = SmartDashboard.getNumber(\"Tuning KP\", 0.1);\n        m_ki = SmartDashboard.getNumber(\"Tuning KI\", 0.0);\n        m_kd = SmartDashboard.getNumber(\"Tuning KD\", 0.01);\n        m_setpoint = SmartDashboard.getNumber(\"Tuning Setpoint\", 45.0);\n        m_tolerance = SmartDashboard.getNumber(\"Tuning Tolerance\", 1.0);\n        \n        // Set PID constants\n        m_arm.setPIDConstants(m_kp, m_ki, m_kd);\n        \n        // Reset to starting position\n        m_arm.setPosition(0);\n        \n        m_state = TuningState.SETTLING;\n        m_settleStartTime = 0.0;\n        m_maxOvershoot = 0.0;\n        \n        SmartDashboard.putString(\"Tuning Status\", \"Starting Tuning\");\n    }\n    \n    @Override\n    public void execute() {\n        double currentTime = m_timer.get();\n        double currentPosition = m_arm.getPosition();\n        double error = Math.abs(m_setpoint - currentPosition);\n        \n        switch (m_state) {\n            case SETTLING:\n                // Wait for initial settling\n                if (currentTime > 1.0) {\n                    // Move to setpoint\n                    m_arm.setPosition(m_setpoint);\n                    m_settleStartTime = currentTime;\n                    m_state = TuningState.MEASURING;\n                    SmartDashboard.putString(\"Tuning Status\", \"Moving to Setpoint\");\n                }\n                break;\n                \n            case MEASURING:\n                // Track overshoot\n                if (currentPosition > m_setpoint) {\n                    double overshoot = currentPosition - m_setpoint;\n                    m_maxOvershoot = Math.max(m_maxOvershoot, overshoot);\n                }\n                \n                // Check if settled\n                if (error < m_tolerance) {\n                    if (m_measureStartTime == 0.0) {\n                        m_measureStartTime = currentTime;\n                    } else if (currentTime - m_measureStartTime > 0.5) {\n                        // Settled for 0.5 seconds\n                        m_settleTime = currentTime - m_settleStartTime;\n                        m_steadyStateError = error;\n                        m_state = TuningState.COMPLETE;\n                        SmartDashboard.putString(\"Tuning Status\", \"Complete\");\n                    }\n                } else {\n                    m_measureStartTime = 0.0;\n                }\n                break;\n                \n            case COMPLETE:\n                // Display results\n                SmartDashboard.putNumber(\"Max Overshoot\", m_maxOvershoot);\n                SmartDashboard.putNumber(\"Settle Time\", m_settleTime);\n                SmartDashboard.putNumber(\"Steady State Error\", m_steadyStateError);\n                break;\n        }\n        \n        // Update real-time data\n        SmartDashboard.putNumber(\"Current Position\", currentPosition);\n        SmartDashboard.putNumber(\"Current Error\", error);\n        SmartDashboard.putNumber(\"Current Time\", currentTime);\n    }\n    \n    @Override\n    public void end(boolean interrupted) {\n        m_arm.stop();\n        m_timer.stop();\n        \n        if (interrupted) {\n            SmartDashboard.putString(\"Tuning Status\", \"Interrupted\");\n        }\n    }\n    \n    @Override\n    public boolean isFinished() {\n        return m_state == TuningState.COMPLETE;\n    }\n}\n\n// PID Tuning Guidelines:\n// 1. Start with P only (I=0, D=0)\n// 2. Increase P until you get oscillation\n// 3. Add D to reduce oscillation\n// 4. Add I to eliminate steady-state error\n// 5. Fine-tune all parameters\n\n// Common Tuning Values:\n// P: 0.01 to 1.0 (start low)\n// I: 0.0 to 0.1 (usually small)\n// D: 0.001 to 0.1 (start small)\n\n// Tuning Tips:\n// - Test in small increments\n// - Watch for oscillation\n// - Consider mechanical issues (backlash, friction)\n// - Use SmartDashboard for real-time tuning\n// - Document successful values"
    },
    {
      "type": "text",
      "title": "Advanced PID Features",
      "content": "Modern motor controllers offer advanced PID features that can improve performance and simplify implementation."
    },
    {
      "type": "code",
      "title": "Advanced PID Features",
      "content": "// 1. Feed Forward Control\n// Feed forward provides additional output based on the desired velocity\n// This helps overcome friction and gravity\n\npublic class AdvancedPIDController {\n    private double m_kf = 0.0; // Feed forward gain\n    \n    public double calculate(double setpoint, double feedback, double velocitySetpoint) {\n        double error = setpoint - feedback;\n        \n        // Standard PID terms\n        double proportional = m_kp * error;\n        double integral = m_ki * m_integral;\n        double derivative = m_kd * (error - m_previousError);\n        \n        // Feed forward term\n        double feedForward = m_kf * velocitySetpoint;\n        \n        return proportional + integral + derivative + feedForward;\n    }\n}\n\n// 2. Multiple PID Slots (CTRE)\n// Different PID constants for different operating conditions\n\npublic class MultiSlotPID {\n    private final WPI_TalonFX m_motor;\n    \n    public void configurePIDSlots() {\n        // Slot 0: Position control\n        m_motor.config_kP(0, 0.1, 10);\n        m_motor.config_kI(0, 0.0, 10);\n        m_motor.config_kD(0, 0.01, 10);\n        \n        // Slot 1: Velocity control\n        m_motor.config_kP(1, 0.05, 10);\n        m_motor.config_kI(1, 0.001, 10);\n        m_motor.config_kD(1, 0.0, 10);\n        \n        // Slot 2: Motion profiling\n        m_motor.config_kP(2, 0.2, 10);\n        m_motor.config_kI(2, 0.0, 10);\n        m_motor.config_kD(2, 0.02, 10);\n    }\n    \n    public void setPosition(double position) {\n        m_motor.selectProfileSlot(0, 0); // Use slot 0 for position\n        m_motor.set(ControlMode.Position, position);\n    }\n    \n    public void setVelocity(double velocity) {\n        m_motor.selectProfileSlot(1, 0); // Use slot 1 for velocity\n        m_motor.set(ControlMode.Velocity, velocity);\n    }\n}\n\n// 3. Smart Motion (REV)\n// Automatic motion profiling with acceleration and velocity limits\n\npublic class SmartMotionPID {\n    private final CANSparkMax m_motor;\n    private final SparkMaxPIDController m_pidController;\n    \n    public void configureSmartMotion() {\n        // Set Smart Motion parameters\n        m_pidController.setSmartMotionMaxVelocity(30, 0); // 30 units/second\n        m_pidController.setSmartMotionMaxAccel(60, 0);    // 60 units/second^2\n        m_pidController.setSmartMotionAllowedClosedLoopError(1, 0); // 1 unit tolerance\n        m_pidController.setSmartMotionMinOutputVelocity(0, 0); // 0 units/second minimum\n        \n        // Use Smart Motion for position control\n        m_pidController.setReference(setpoint, CANSparkMax.ControlType.kSmartMotion);\n    }\n}\n\n// 4. Adaptive PID\n// PID that adjusts its parameters based on conditions\n\npublic class AdaptivePIDController {\n    private double m_kp, m_ki, m_kd;\n    private double m_baseKp, m_baseKi, m_baseKd;\n    \n    public void updatePIDForLoad(double loadFactor) {\n        // Adjust PID based on load\n        m_kp = m_baseKp * loadFactor;\n        m_ki = m_baseKi * loadFactor;\n        m_kd = m_baseKd * loadFactor;\n    }\n    \n    public void updatePIDForSpeed(double speed) {\n        // Adjust PID based on speed\n        if (speed > 0.5) {\n            m_kp *= 1.2; // Increase P for high speed\n            m_kd *= 1.1; // Increase D for stability\n        } else {\n            m_kp = m_baseKp;\n            m_kd = m_baseKd;\n        }\n    }\n}"
    },
    {
      "type": "rules-box",
      "title": "PID Best Practices",
      "items": [
        "<strong>Start simple:</strong> Begin with P control only, then add I and D",
        "<strong>Tune systematically:</strong> Follow a consistent tuning process",
        "<strong>Test thoroughly:</strong> Test under various conditions and loads",
        "<strong>Use appropriate gains:</strong> Different mechanisms need different PID values",
        "<strong>Monitor performance:</strong> Use SmartDashboard to track PID behavior",
        "<strong>Consider mechanical issues:</strong> Address backlash, friction, and other mechanical problems"
      ],
      "subtitle": "Follow these guidelines for effective PID control:"
    },
    {
      "type": "exercise-box",
      "title": "PID Practice",
      "description": "Implement and tune PID controllers for various mechanisms.",
      "tasks": [
        "Implement PID control for an arm mechanism",
        "Create a PID tuning command with SmartDashboard integration",
        "Tune PID constants using the systematic approach",
        "Implement PID control for an elevator or linear mechanism",
        "Add feed forward control to improve performance",
        "Create multiple PID slots for different control modes",
        "Implement Smart Motion or motion profiling",
        "Add adaptive PID based on load or conditions",
        "Test PID performance under various conditions",
        "Document successful PID values for your mechanisms"
      ],
      "content": "// Example PID implementation workflow:\n\n// 1. Create a basic PID controller\npublic class BasicPIDController {\n    private double m_kp = 0.1;\n    private double m_ki = 0.0;\n    private double m_kd = 0.01;\n    private double m_setpoint = 0.0;\n    private double m_integral = 0.0;\n    private double m_previousError = 0.0;\n    \n    public double calculate(double feedback) {\n        double error = m_setpoint - feedback;\n        \n        // Proportional\n        double p = m_kp * error;\n        \n        // Integral\n        m_integral += error;\n        double i = m_ki * m_integral;\n        \n        // Derivative\n        double d = m_kd * (error - m_previousError);\n        \n        m_previousError = error;\n        \n        return p + i + d;\n    }\n    \n    public void setSetpoint(double setpoint) {\n        m_setpoint = setpoint;\n    }\n    \n    public void reset() {\n        m_integral = 0.0;\n        m_previousError = 0.0;\n    }\n}\n\n// 2. Use in a subsystem\npublic class PIDArm extends SubsystemBase {\n    private final CANSparkMax m_motor;\n    private final BasicPIDController m_pidController;\n    \n    public PIDArm() {\n        m_motor = new CANSparkMax(3, MotorType.kBrushless);\n        m_pidController = new BasicPIDController();\n    }\n    \n    public void setPosition(double position) {\n        m_pidController.setSetpoint(position);\n    }\n    \n    @Override\n    public void periodic() {\n        double currentPosition = m_motor.getEncoder().getPosition();\n        double output = m_pidController.calculate(currentPosition);\n        m_motor.set(output);\n        \n        SmartDashboard.putNumber(\"Arm Position\", currentPosition);\n        SmartDashboard.putNumber(\"PID Output\", output);\n    }\n}\n\n// 3. Create tuning interface\npublic class PIDTuningInterface {\n    public static void setupTuningDashboard() {\n        SmartDashboard.putNumber(\"PID KP\", 0.1);\n        SmartDashboard.putNumber(\"PID KI\", 0.0);\n        SmartDashboard.putNumber(\"PID KD\", 0.01);\n        SmartDashboard.putNumber(\"PID Setpoint\", 45.0);\n        SmartDashboard.putBoolean(\"Enable PID\", false);\n    }\n    \n    public static void updatePIDFromDashboard(BasicPIDController controller) {\n        double kp = SmartDashboard.getNumber(\"PID KP\", 0.1);\n        double ki = SmartDashboard.getNumber(\"PID KI\", 0.0);\n        double kd = SmartDashboard.getNumber(\"PID KD\", 0.01);\n        \n        // Update controller constants\n        // (You'd need to add setter methods to BasicPIDController)\n    }\n}"
    }
  ]
}
