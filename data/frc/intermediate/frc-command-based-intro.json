{
  "title": "Introduction to Command-Based Programming",
  "sections": [
    {
      "type": "text",
      "title": "Understanding Command-Based Programming",
      "content": "Command-based programming is a design pattern that organizes robot code into commands and subsystems. It provides better structure, reusability, and maintainability compared to the basic TimedRobot approach."
    },
    {
      "type": "rules-box",
      "title": "Command-Based Architecture",
      "items": [
        "<strong>Subsystems:</strong> Organized components that control specific robot mechanisms",
        "<strong>Commands:</strong> Actions that subsystems can perform",
        "<strong>Command Scheduler:</strong> Manages command execution and scheduling",
        "<strong>OI (Operator Interface):</strong> Maps controller input to commands",
        "<strong>Robot Container:</strong> Central configuration and initialization"
      ],
      "subtitle": "Command-based programming consists of:"
    },
    {
      "type": "text",
      "title": "Subsystems",
      "content": "Subsystems are the foundation of command-based programming. They encapsulate the functionality of specific robot mechanisms and provide a clean interface for commands to use."
    },
    {
      "type": "code",
      "title": "Basic Subsystem Structure",
      "content": "package frc.robot.subsystems;\n\nimport edu.wpi.first.wpilibj2.command.SubsystemBase;\nimport com.revrobotics.CANSparkMax;\nimport com.revrobotics.CANSparkMaxLowLevel.MotorType;\nimport edu.wpi.first.wpilibj.smartdashboard.SmartDashboard;\n\npublic class Drivetrain extends SubsystemBase {\n    // Motor controllers\n    private final CANSparkMax m_leftMotor = new CANSparkMax(1, MotorType.kBrushless);\n    private final CANSparkMax m_rightMotor = new CANSparkMax(2, MotorType.kBrushless);\n    \n    // Configuration\n    private static final double MAX_SPEED = 1.0;\n    private static final double DEADBAND = 0.1;\n    \n    public Drivetrain() {\n        // Configure motor controllers\n        m_rightMotor.setInverted(true);\n        \n        // Set current limits\n        m_leftMotor.setSmartCurrentLimit(40);\n        m_rightMotor.setSmartCurrentLimit(40);\n        \n        // Set default command (runs when no other command is using this subsystem)\n        setDefaultCommand(new DriveCommand(this));\n    }\n    \n    // Public methods that commands can call\n    public void arcadeDrive(double forward, double turn) {\n        // Apply deadband\n        forward = applyDeadband(forward);\n        turn = applyDeadband(turn);\n        \n        // Limit speed\n        forward = Math.max(-MAX_SPEED, Math.min(MAX_SPEED, forward));\n        turn = Math.max(-MAX_SPEED, Math.min(MAX_SPEED, turn));\n        \n        // Calculate motor powers\n        double leftPower = forward + turn;\n        double rightPower = forward - turn;\n        \n        // Normalize powers\n        double maxPower = Math.max(Math.abs(leftPower), Math.abs(rightPower));\n        if (maxPower > 1.0) {\n            leftPower /= maxPower;\n            rightPower /= maxPower;\n        }\n        \n        // Set motor powers\n        m_leftMotor.set(leftPower);\n        m_rightMotor.set(rightPower);\n    }\n    \n    public void tankDrive(double left, double right) {\n        // Apply deadband\n        left = applyDeadband(left);\n        right = applyDeadband(right);\n        \n        // Limit speed\n        left = Math.max(-MAX_SPEED, Math.min(MAX_SPEED, left));\n        right = Math.max(-MAX_SPEED, Math.min(MAX_SPEED, right));\n        \n        // Set motor powers\n        m_leftMotor.set(left);\n        m_rightMotor.set(right);\n    }\n    \n    public void stop() {\n        m_leftMotor.set(0);\n        m_rightMotor.set(0);\n    }\n    \n    // Helper methods\n    private double applyDeadband(double value) {\n        if (Math.abs(value) < DEADBAND) {\n            return 0.0;\n        }\n        return value;\n    }\n    \n    @Override\n    public void periodic() {\n        // This method will be called once per scheduler run\n        // Update SmartDashboard\n        SmartDashboard.putNumber(\"Left Motor Speed\", m_leftMotor.get());\n        SmartDashboard.putNumber(\"Right Motor Speed\", m_rightMotor.get());\n        SmartDashboard.putNumber(\"Left Current\", m_leftMotor.getOutputCurrent());\n        SmartDashboard.putNumber(\"Right Current\", m_rightMotor.getOutputCurrent());\n    }\n}"
    },
    {
      "type": "text",
      "title": "Commands",
      "content": "Commands represent actions that the robot can perform. They use subsystems to accomplish their goals and can be scheduled, interrupted, and reused."
    },
    {
      "type": "code",
      "title": "Basic Command Structure",
      "content": "package frc.robot.commands;\n\nimport edu.wpi.first.wpilibj2.command.CommandBase;\nimport frc.robot.subsystems.Drivetrain;\nimport frc.robot.OI;\n\npublic class DriveCommand extends CommandBase {\n    private final Drivetrain m_drivetrain;\n    private final OI m_oi;\n    \n    public DriveCommand(Drivetrain drivetrain) {\n        m_drivetrain = drivetrain;\n        m_oi = new OI();\n        \n        // Add this command's requirements\n        addRequirements(m_drivetrain);\n    }\n    \n    @Override\n    public void initialize() {\n        // Called once when the command is scheduled\n        System.out.println(\"DriveCommand initialized\");\n    }\n    \n    @Override\n    public void execute() {\n        // Called repeatedly while the command is scheduled\n        double forward = m_oi.getDriverLeftY();\n        double turn = m_oi.getDriverRightX();\n        \n        m_drivetrain.arcadeDrive(forward, turn);\n    }\n    \n    @Override\n    public void end(boolean interrupted) {\n        // Called once when the command ends or is interrupted\n        if (interrupted) {\n            m_drivetrain.stop();\n        }\n        System.out.println(\"DriveCommand ended\");\n    }\n    \n    @Override\n    public boolean isFinished() {\n        // Return true when the command should end\n        // For a default command, this should always return false\n        return false;\n    }\n}"
    },
    {
      "type": "text",
      "title": "Command Types",
      "content": "There are several types of commands in WPILib, each serving different purposes. Understanding these types helps you choose the right command for each situation."
    },
    {
      "type": "code",
      "title": "Different Command Types",
      "content": "package frc.robot.commands;\n\nimport edu.wpi.first.wpilibj2.command.CommandBase;\nimport edu.wpi.first.wpilibj2.command.InstantCommand;\nimport edu.wpi.first.wpilibj2.command.WaitCommand;\nimport edu.wpi.first.wpilibj2.command.SequentialCommandGroup;\nimport edu.wpi.first.wpilibj2.command.ParallelCommandGroup;\nimport frc.robot.subsystems.Arm;\nimport frc.robot.subsystems.Intake;\n\n// 1. Instant Command - executes once and finishes immediately\npublic class OpenGripperCommand extends InstantCommand {\n    public OpenGripperCommand() {\n        // No requirements needed for instant commands\n        super(() -> {\n            // Action to perform\n            System.out.println(\"Gripper opened\");\n        });\n    }\n}\n\n// 2. Wait Command - does nothing for a specified time\npublic class WaitForBallCommand extends WaitCommand {\n    public WaitForBallCommand() {\n        super(2.0); // Wait for 2 seconds\n    }\n}\n\n// 3. Sequential Command Group - runs commands one after another\npublic class PickupBallSequence extends SequentialCommandGroup {\n    public PickupBallSequence(Arm arm, Intake intake) {\n        addCommands(\n            new MoveArmToGroundCommand(arm),\n            new OpenGripperCommand(),\n            new IntakeBallCommand(intake),\n            new WaitForBallCommand(),\n            new CloseGripperCommand()\n        );\n    }\n}\n\n// 4. Parallel Command Group - runs commands simultaneously\npublic class DriveAndIntakeCommand extends ParallelCommandGroup {\n    public DriveAndIntakeCommand(Drivetrain drivetrain, Intake intake) {\n        addCommands(\n            new DriveCommand(drivetrain),\n            new IntakeBallCommand(intake)\n        );\n    }\n}\n\n// 5. Conditional Command - chooses between commands based on a condition\npublic class ConditionalIntakeCommand extends ConditionalCommand {\n    public ConditionalIntakeCommand(Intake intake) {\n        super(\n            new IntakeBallCommand(intake),     // Command to run if condition is true\n            new StopIntakeCommand(intake),     // Command to run if condition is false\n            () -> intake.isBallDetected()      // Condition\n        );\n    }\n}\n\n// 6. Custom Command with conditions\npublic class MoveArmToPositionCommand extends CommandBase {\n    private final Arm m_arm;\n    private final double m_targetAngle;\n    private final double m_tolerance;\n    \n    public MoveArmToPositionCommand(Arm arm, double targetAngle, double tolerance) {\n        m_arm = arm;\n        m_targetAngle = targetAngle;\n        m_tolerance = tolerance;\n        \n        addRequirements(m_arm);\n    }\n    \n    @Override\n    public void initialize() {\n        System.out.println(\"Moving arm to \" + m_targetAngle + \" degrees\");\n    }\n    \n    @Override\n    public void execute() {\n        m_arm.moveToAngle(m_targetAngle);\n    }\n    \n    @Override\n    public void end(boolean interrupted) {\n        if (interrupted) {\n            m_arm.stop();\n        }\n    }\n    \n    @Override\n    public boolean isFinished() {\n        return m_arm.isAtAngle(m_targetAngle, m_tolerance);\n    }\n}"
    },
    {
      "type": "text",
      "title": "Robot Container",
      "content": "The RobotContainer class is the central configuration point for command-based robots. It initializes subsystems, configures commands, and sets up the operator interface."
    },
    {
      "type": "code",
      "title": "Robot Container Implementation",
      "content": "package frc.robot;\n\nimport edu.wpi.first.wpilibj2.command.Command;\nimport edu.wpi.first.wpilibj2.command.button.JoystickButton;\nimport edu.wpi.first.wpilibj.XboxController;\nimport frc.robot.subsystems.*;\nimport frc.robot.commands.*;\nimport frc.robot.Constants;\n\npublic class RobotContainer {\n    // Subsystems\n    private final Drivetrain m_drivetrain = new Drivetrain();\n    private final Arm m_arm = new Arm();\n    private final Intake m_intake = new Intake();\n    private final Elevator m_elevator = new Elevator();\n    private final Pneumatics m_pneumatics = new Pneumatics();\n    \n    // Controllers\n    private final XboxController m_driverController = new XboxController(Constants.DRIVER_CONTROLLER_PORT);\n    private final XboxController m_operatorController = new XboxController(Constants.OPERATOR_CONTROLLER_PORT);\n    \n    // Commands\n    private final DriveCommand m_driveCommand;\n    private final PickupBallSequence m_pickupBallSequence;\n    private final ScoreLowCommand m_scoreLowCommand;\n    private final ScoreHighCommand m_scoreHighCommand;\n    \n    public RobotContainer() {\n        // Initialize commands\n        m_driveCommand = new DriveCommand(m_drivetrain, m_driverController);\n        m_pickupBallSequence = new PickupBallSequence(m_arm, m_intake, m_pneumatics);\n        m_scoreLowCommand = new ScoreLowCommand(m_arm, m_pneumatics);\n        m_scoreHighCommand = new ScoreHighCommand(m_arm, m_elevator, m_pneumatics);\n        \n        // Configure default commands\n        configureDefaultCommands();\n        \n        // Configure button bindings\n        configureButtonBindings();\n        \n        // Configure autonomous\n        configureAutonomous();\n    }\n    \n    private void configureDefaultCommands() {\n        // Set default commands for subsystems\n        m_drivetrain.setDefaultCommand(m_driveCommand);\n        m_arm.setDefaultCommand(new ArmHoldPositionCommand(m_arm));\n    }\n    \n    private void configureButtonBindings() {\n        // Driver controls\n        new JoystickButton(m_driverController, XboxController.Button.kA.value)\n            .whenPressed(new ToggleDriveModeCommand(m_drivetrain));\n        \n        new JoystickButton(m_driverController, XboxController.Button.kB.value)\n            .whenPressed(new ToggleSpeedModeCommand(m_drivetrain));\n        \n        // Operator controls\n        new JoystickButton(m_operatorController, XboxController.Button.kA.value)\n            .whenPressed(m_pickupBallSequence);\n        \n        new JoystickButton(m_operatorController, XboxController.Button.kB.value)\n            .whenPressed(m_scoreLowCommand);\n        \n        new JoystickButton(m_operatorController, XboxController.Button.kX.value)\n            .whenPressed(m_scoreHighCommand);\n        \n        // Trigger controls\n        m_operatorController.rightTrigger(0.5)\n            .whileActiveContinuous(new IntakeBallCommand(m_intake));\n        \n        m_operatorController.leftTrigger(0.5)\n            .whileActiveContinuous(new OuttakeBallCommand(m_intake));\n        \n        // Bumper controls\n        m_operatorController.rightBumper()\n            .whileActiveContinuous(new MoveArmUpCommand(m_arm));\n        \n        m_operatorController.leftBumper()\n            .whileActiveContinuous(new MoveArmDownCommand(m_arm));\n    }\n    \n    private void configureAutonomous() {\n        // Configure autonomous chooser\n        // This will be covered in more detail in the autonomous lesson\n    }\n    \n    // Getter methods for subsystems\n    public Drivetrain getDrivetrain() {\n        return m_drivetrain;\n    }\n    \n    public Arm getArm() {\n        return m_arm;\n    }\n    \n    public Intake getIntake() {\n        return m_intake;\n    }\n    \n    public Elevator getElevator() {\n        return m_elevator;\n    }\n    \n    public Pneumatics getPneumatics() {\n        return m_pneumatics;\n    }\n    \n    // Get autonomous command\n    public Command getAutonomousCommand() {\n        // Return the selected autonomous command\n        return new SimpleAutonomousCommand(this);\n    }\n}"
    },
    {
      "type": "text",
      "title": "Main Robot Class",
      "content": "The main Robot class in command-based programming is much simpler than in TimedRobot. It primarily handles robot mode transitions and delegates most work to the RobotContainer."
    },
    {
      "type": "code",
      "title": "Command-Based Robot Class",
      "content": "package frc.robot;\n\nimport edu.wpi.first.wpilibj.TimedRobot;\nimport edu.wpi.first.wpilibj2.command.Command;\nimport edu.wpi.first.wpilibj2.command.CommandScheduler;\nimport edu.wpi.first.wpilibj.smartdashboard.SmartDashboard;\n\npublic class Robot extends TimedRobot {\n    private Command m_autonomousCommand;\n    private RobotContainer m_robotContainer;\n    \n    @Override\n    public void robotInit() {\n        // Instantiate our RobotContainer\n        m_robotContainer = new RobotContainer();\n        \n        SmartDashboard.putString(\"Robot Status\", \"Command-Based Robot Initialized\");\n    }\n    \n    @Override\n    public void robotPeriodic() {\n        // Runs the CommandScheduler\n        // This is essential for command-based programming\n        CommandScheduler.getInstance().run();\n        \n        // Update SmartDashboard\n        SmartDashboard.putNumber(\"Match Time\", DriverStation.getMatchTime());\n        SmartDashboard.putBoolean(\"Robot Enabled\", DriverStation.isEnabled());\n    }\n    \n    @Override\n    public void disabledInit() {\n        // Cancel all running commands when disabled\n        CommandScheduler.getInstance().cancelAll();\n        \n        SmartDashboard.putString(\"Robot Status\", \"Disabled\");\n    }\n    \n    @Override\n    public void disabledPeriodic() {\n        // Nothing to do in disabled periodic\n    }\n    \n    @Override\n    public void autonomousInit() {\n        // Get the autonomous command from RobotContainer\n        m_autonomousCommand = m_robotContainer.getAutonomousCommand();\n        \n        // Schedule the autonomous command\n        if (m_autonomousCommand != null) {\n            m_autonomousCommand.schedule();\n        }\n        \n        SmartDashboard.putString(\"Robot Status\", \"Autonomous Started\");\n    }\n    \n    @Override\n    public void autonomousPeriodic() {\n        // Nothing to do here - commands handle autonomous behavior\n    }\n    \n    @Override\n    public void teleopInit() {\n        // Cancel the autonomous command if it's still running\n        if (m_autonomousCommand != null) {\n            m_autonomousCommand.cancel();\n        }\n        \n        SmartDashboard.putString(\"Robot Status\", \"Teleop Started\");\n    }\n    \n    @Override\n    public void teleopPeriodic() {\n        // Nothing to do here - commands handle teleop behavior\n    }\n    \n    @Override\n    public void testInit() {\n        // Cancel all running commands\n        CommandScheduler.getInstance().cancelAll();\n        \n        SmartDashboard.putString(\"Robot Status\", \"Test Mode Started\");\n    }\n    \n    @Override\n    public void testPeriodic() {\n        // Test mode behavior\n        // You can add test commands here if needed\n    }\n}"
    },
    {
      "type": "text",
      "title": "Command Scheduler",
      "content": "The Command Scheduler is the heart of command-based programming. It manages command execution, handles command requirements, and ensures proper subsystem access."
    },
    {
      "type": "code",
      "title": "Understanding Command Scheduling",
      "content": "// The Command Scheduler automatically:\n// 1. Runs scheduled commands\n// 2. Checks command requirements\n// 3. Interrupts conflicting commands\n// 4. Manages command lifecycle\n\n// Example of how the scheduler works:\n\n// When you schedule a command:\nCommand myCommand = new MoveArmCommand(m_arm, 45);\nmyCommand.schedule(); // Scheduler adds this to its queue\n\n// The scheduler checks requirements:\n// - If no other command requires the arm subsystem, myCommand runs\n// - If another command requires the arm, the scheduler interrupts it\n\n// During robotPeriodic():\nCommandScheduler.getInstance().run();\n// This calls:\n// 1. myCommand.execute() if it's running\n// 2. myCommand.isFinished() to check if it should end\n// 3. myCommand.end() if it's finished\n\n// Command requirements prevent conflicts:\npublic class MoveArmCommand extends CommandBase {\n    public MoveArmCommand(Arm arm) {\n        addRequirements(arm); // Only one command can use the arm at a time\n    }\n}\n\npublic class IntakeCommand extends CommandBase {\n    public IntakeCommand(Intake intake) {\n        addRequirements(intake); // Only one command can use the intake at a time\n    }\n}\n\n// These commands can run simultaneously because they use different subsystems\n// But if two commands both require the same subsystem, the scheduler will\n// interrupt the first command when the second is scheduled"
    },
    {
      "type": "text",
      "title": "Advanced Command Features",
      "content": "WPILib provides several advanced features for commands that make complex robot behaviors easier to implement."
    },
    {
      "type": "code",
      "title": "Advanced Command Examples",
      "content": "package frc.robot.commands;\n\nimport edu.wpi.first.wpilibj2.command.*;\nimport frc.robot.subsystems.*;\nimport java.util.function.BooleanSupplier;\nimport java.util.function.DoubleSupplier;\n\n// 1. Functional Commands - quick commands using lambda expressions\npublic class FunctionalCommandExample {\n    public static Command createIntakeCommand(Intake intake, DoubleSupplier speed) {\n        return new FunctionalCommand(\n            () -> {}, // initialize\n            () -> intake.setSpeed(speed.getAsDouble()), // execute\n            interrupted -> intake.stop(), // end\n            () -> false, // isFinished\n            intake // requirements\n        );\n    }\n}\n\n// 2. Conditional Commands - choose between commands based on conditions\npublic class SmartIntakeCommand extends ConditionalCommand {\n    public SmartIntakeCommand(Intake intake) {\n        super(\n            new IntakeBallCommand(intake),     // if ball detected\n            new StopIntakeCommand(intake),     // if no ball\n            () -> intake.isBallDetected()      // condition\n        );\n    }\n}\n\n// 3. Command Groups with Conditions\npublic class AdaptivePickupSequence extends SequentialCommandGroup {\n    public AdaptivePickupSequence(Arm arm, Intake intake) {\n        addCommands(\n            new MoveArmToGroundCommand(arm),\n            new ConditionalCommand(\n                new IntakeBallCommand(intake),\n                new WaitCommand(1.0),\n                () -> intake.isBallDetected()\n            ),\n            new MoveArmToStowCommand(arm)\n        );\n    }\n}\n\n// 4. Repeat Commands\npublic class RepeatIntakeCommand extends RepeatCommand {\n    public RepeatIntakeCommand(Intake intake) {\n        super(new IntakeBallCommand(intake));\n    }\n}\n\n// 5. Timeout Commands\npublic class TimedIntakeCommand extends TimeoutCommand {\n    public TimedIntakeCommand(Intake intake, double timeout) {\n        super(new IntakeBallCommand(intake), timeout);\n    }\n}\n\n// 6. Command Decorators\npublic class SafeArmCommand extends CommandBase {\n    private final Command m_decoratedCommand;\n    private final Arm m_arm;\n    \n    public SafeArmCommand(Command command, Arm arm) {\n        m_decoratedCommand = command;\n        m_arm = arm;\n        \n        // Add all requirements from the decorated command\n        addRequirements(command.getRequirements().toArray(new Subsystem[0]));\n    }\n    \n    @Override\n    public void initialize() {\n        // Check safety conditions before starting\n        if (m_arm.isAtLowerLimit() || m_arm.isAtUpperLimit()) {\n            System.out.println(\"Safety check failed - not starting command\");\n            return;\n        }\n        \n        m_decoratedCommand.initialize();\n    }\n    \n    @Override\n    public void execute() {\n        m_decoratedCommand.execute();\n    }\n    \n    @Override\n    public void end(boolean interrupted) {\n        m_decoratedCommand.end(interrupted);\n    }\n    \n    @Override\n    public boolean isFinished() {\n        return m_decoratedCommand.isFinished();\n    }\n}"
    },
    {
      "type": "rules-box",
      "title": "Command-Based Best Practices",
      "items": [
        "<strong>Keep commands simple:</strong> Each command should do one thing well",
        "<strong>Use requirements properly:</strong> Add requirements to prevent conflicts",
        "<strong>Test commands individually:</strong> Test each command before integration",
        "<strong>Use command groups:</strong> Combine simple commands for complex behaviors",
        "<strong>Handle interruptions:</strong> Always clean up in the end() method",
        "<strong>Document command behavior:</strong> Keep clear documentation of what each command does"
      ],
      "subtitle": "Follow these guidelines for effective command-based programming:"
    },
    {
      "type": "exercise-box",
      "title": "Command-Based Practice",
      "description": "Convert your robot to command-based programming and create various commands.",
      "tasks": [
        "Convert your existing subsystems to extend SubsystemBase",
        "Create basic commands for each subsystem operation",
        "Implement the RobotContainer class with button bindings",
        "Convert your main Robot class to command-based structure",
        "Create command groups for complex sequences",
        "Add conditional commands based on sensor feedback",
        "Implement default commands for subsystems",
        "Test command scheduling and interruption",
        "Create autonomous commands using the command-based structure",
        "Add safety features and error handling to commands"
      ],
      "content": "// Example conversion from TimedRobot to Command-Based:\n\n// Before (TimedRobot):\n@Override\npublic void teleopPeriodic() {\n    double forward = m_oi.getLeftY();\n    double turn = m_oi.getRightX();\n    m_drivetrain.arcadeDrive(forward, turn);\n    \n    if (m_oi.getArmUp()) {\n        m_arm.moveUp();\n    } else if (m_oi.getArmDown()) {\n        m_arm.moveDown();\n    } else {\n        m_arm.stop();\n    }\n}\n\n// After (Command-Based):\n// In RobotContainer.configureButtonBindings():\nm_operatorController.rightBumper()\n    .whileActiveContinuous(new MoveArmUpCommand(m_arm));\n\nm_operatorController.leftBumper()\n    .whileActiveContinuous(new MoveArmDownCommand(m_arm));\n\n// In Drivetrain.setDefaultCommand():\nsetDefaultCommand(new DriveCommand(m_drivetrain, m_driverController));\n\n// The Robot class teleopPeriodic() becomes:\n@Override\npublic void teleopPeriodic() {\n    // Nothing needed here - commands handle everything\n    CommandScheduler.getInstance().run();\n}"
    }
  ]
}
