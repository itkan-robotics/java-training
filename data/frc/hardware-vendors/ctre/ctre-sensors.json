{
  "title": "CTRE Sensors",
  "sections": [
    {
      "type": "text",
      "title": "Introduction to CTRE Sensors",
      "content": "CTRE manufactures several sensors for FRC robots that provide critical feedback for robot control, navigation, and mechanism positioning. The two main CTRE sensors covered in this lesson are:<br><br><strong>CANcoder:</strong> Absolute encoder that provides precise position tracking and remembers its position even after power loss. Ideal for swerve modules, arms, and mechanisms that need to know their position immediately on startup.<br><br><strong>Pigeon 2:</strong> Gyroscope and inertial measurement unit (IMU) that provides robot orientation and heading information. Essential for field-relative driving, odometry, and autonomous navigation.<br><br>Both sensors communicate over CAN bus and integrate seamlessly with CTRE motor controllers and WPILib."
    },
    {
      "type": "rules-box",
      "title": "CTRE Sensor Overview",
      "subtitle": "Available CTRE sensors:",
      "items": [
        "<strong>CANcoder:</strong> Absolute encoder for position tracking (4096 counts per revolution, magnet-based)",
        "<strong>Pigeon 2:</strong> Gyroscope and IMU for robot orientation and heading",
        "Both use CAN bus communication (no extra wiring for data)",
        "Both integrate with Phoenix Tuner X for configuration",
        "Both provide high-resolution, accurate measurements"
      ]
    },
    {
      "type": "text",
      "title": "CANcoder Overview",
      "content": "The CANcoder is CTRE's absolute encoder that provides precise position tracking over CAN bus. Unlike relative encoders (like those built into motors), absolute encoders remember their position even after power loss, making them ideal for mechanisms that need to know their position immediately on startup.<br><br><strong>Absolute vs Relative Encoders:</strong><br>- <strong>Absolute:</strong> Position is always known, no reset needed, remembers position after power loss<br>- <strong>Relative:</strong> Position resets to 0 on power-up, must be reset/homed, loses position on power loss<br><br>The CANcoder is commonly used for swerve module angle measurement, arm position tracking, and other mechanisms where absolute position is important.<br><br>Learn more: <a href='https://v6.docs.ctr-electronics.com/en/latest/docs/hardware-reference/cancoder/index.html' target='_blank'>CANcoder Documentation</a>"
    },
    {
      "type": "rules-box",
      "title": "CANcoder Features",
      "subtitle": "Key capabilities:",
      "items": [
        "Absolute position tracking (remembers position after power loss)",
        "High resolution (4096 counts per revolution)",
        "CAN bus communication (no extra data wiring)",
        "Magnet-based sensing (no mechanical contact)",
        "Configurable direction and offset",
        "Provides both absolute and relative position readings"
      ]
    },
    {
      "type": "text",
      "title": "CANcoder Hardware Setup",
      "content": "Before programming, you need to physically set up your CANcoder on the mechanism.<br><br><strong>Mounting CANcoder:</strong><br>1. Mount CANcoder securely to your mechanism (stationary part)<br>2. Mount the magnet on the rotating part of the mechanism<br>3. Ensure the magnet is properly aligned with the CANcoder<br>4. Magnet should be centered and at correct distance (3-5mm typical)<br>5. Secure all mounting hardware<br><br><strong>Wiring:</strong><br>1. <strong>CAN Bus:</strong> Connect CAN High and CAN Low to the CAN bus network<br>2. <strong>Power:</strong> CANcoder is powered from the CAN bus (no separate power needed)<br>3. <strong>Ground:</strong> Ensure proper CAN bus grounding<br><br>Learn more: <a href='https://v6.docs.ctr-electronics.com/en/latest/docs/hardware-reference/cancoder/quickstart-cancoder.html' target='_blank'>CANcoder Quickstart</a>"
    },
    {
      "type": "code",
      "title": "Creating CANcoder Instance",
      "content": "package frc.robot.subsystems;\n\nimport com.ctre.phoenix6.hardware.CANcoder;\nimport com.ctre.phoenix6.configs.CANcoderConfiguration;\nimport com.ctre.phoenix6.signals.SensorDirectionValue;\n\npublic class SwerveModule {\n    // CANcoder for measuring module angle\n    private final CANcoder m_angleEncoder = new CANcoder(10);  // CAN ID 10\n    \n    public SwerveModule() {\n        // Basic configuration\n        CANcoderConfiguration config = new CANcoderConfiguration();\n        config.MagnetSensor.SensorDirection = SensorDirectionValue.CounterClockwise_Positive;\n        config.MagnetSensor.MagnetOffset = 0.0;  // Calibrate this value\n        \n        m_angleEncoder.getConfigurator().apply(config);\n    }\n    \n    public double getAngleDegrees() {\n        // Returns position in rotations (0.0 to 1.0), convert to degrees\n        return m_angleEncoder.getAbsolutePosition().getValueAsDouble() * 360.0;\n    }\n}"
    },
    {
      "type": "text",
      "title": "Reading CANcoder Position",
      "content": "The CANcoder's primary function is providing absolute position. Position is returned in rotations (0.0 to 1.0 for one full revolution).<br><br><strong>Position Methods:</strong><br>- <code>getAbsolutePosition()</code>: Returns raw absolute position (0.0 to 1.0 rotations)<br>- <code>getPosition()</code>: Returns position with magnet offset applied<br><br><strong>Position Characteristics:</strong><br>- Range: 0.0 to 1.0 rotations (one full revolution)<br>- Can be converted to degrees: position × 360.0<br>- Position wraps around (1.0 becomes 0.0)<br>- Always accurate, no drift over time<br>- Available immediately on power-up (no calibration needed)"
    },
    {
      "type": "code",
      "title": "Reading CANcoder Position",
      "content": "import com.ctre.phoenix6.hardware.CANcoder;\nimport com.ctre.phoenix6.StatusSignal;\nimport edu.wpi.first.wpilibj.smartdashboard.SmartDashboard;\nimport edu.wpi.first.math.geometry.Rotation2d;\nimport edu.wpi.first.units.measure.Angle;\n\npublic class CANcoderReading {\n    private final CANcoder m_encoder = new CANcoder(10);\n    \n    // Status signals for efficient reading\n    private final StatusSignal<Angle> m_absolutePosition = m_encoder.getAbsolutePosition();\n    private final StatusSignal<Angle> m_position = m_encoder.getPosition();\n    \n    public void updatePosition() {\n        // Refresh signals\n        m_absolutePosition.refresh();\n        m_position.refresh();\n        \n        // Read absolute position (0.0 to 1.0 rotations)\n        double rawPosition = m_absolutePosition.getValueAsDouble();\n        \n        // Convert to degrees (0-360)\n        double degrees = rawPosition * 360.0;\n        \n        // Read position with offset applied\n        double positionWithOffset = m_position.getValueAsDouble();\n        \n        SmartDashboard.putNumber(\"CANcoder Raw (rot)\", rawPosition);\n        SmartDashboard.putNumber(\"CANcoder Degrees\", degrees);\n        SmartDashboard.putNumber(\"CANcoder With Offset (rot)\", positionWithOffset);\n    }\n    \n    public Rotation2d getRotation() {\n        return Rotation2d.fromRotations(m_absolutePosition.refresh().getValueAsDouble());\n    }\n}"
    },
    {
      "type": "text",
      "title": "Magnet Offset Calibration",
      "content": "Magnet offset accounts for the physical mounting position of the magnet relative to the mechanism's zero position. Calibrating the magnet offset allows you to define what position corresponds to \"zero\" for your mechanism.<br><br><strong>Calibration Process:</strong><br>1. Move mechanism to desired zero position<br>2. Read current absolute position<br>3. Calculate offset: offset = desired_zero - current_position (in rotations)<br>4. Configure offset in code or Phoenix Tuner X<br>5. Verify: <code>getPosition().getValueAsDouble()</code> should now show zero at mechanism zero<br><br><strong>Using Offset:</strong> Once configured, <code>getPosition().getValueAsDouble()</code> returns position with offset applied, while <code>getAbsolutePosition().getValueAsDouble()</code> returns raw position."
    },
    {
      "type": "code",
      "title": "CANcoder Magnet Offset Calibration",
      "content": "import com.ctre.phoenix6.hardware.CANcoder;\nimport com.ctre.phoenix6.configs.CANcoderConfiguration;\nimport com.ctre.phoenix6.signals.SensorDirectionValue;\n\npublic class CANcoderCalibration {\n    private final CANcoder m_encoder = new CANcoder(10);\n    \n    public void calibrateForSwerveModule() {\n        // Step 1: Manually align swerve module to 0 degrees (straight forward)\n        \n        // Step 2: Read current absolute position\n        double currentPosition = m_encoder.getAbsolutePosition().refresh().getValueAsDouble();\n        \n        // Step 3: Calculate offset to make current position equal zero\n        double offset = -currentPosition;\n        \n        // Step 4: Configure CANcoder with offset\n        CANcoderConfiguration config = new CANcoderConfiguration();\n        config.MagnetSensor.MagnetOffset = offset;  // In rotations\n        config.MagnetSensor.SensorDirection = SensorDirectionValue.CounterClockwise_Positive;\n        \n        m_encoder.getConfigurator().apply(config);\n        \n        // Step 5: Verify - getPosition() should now read ~0.0 at zero position\n        double verifyPosition = m_encoder.getPosition().refresh().getValueAsDouble();\n        System.out.println(\"CANcoder offset: \" + offset + \", new position: \" + verifyPosition);\n    }\n}"
    },
    {
      "type": "text",
      "title": "Pigeon 2 Overview",
      "content": "The Pigeon 2 is CTRE's gyroscope and inertial measurement unit (IMU) that provides robot orientation and heading information. It's essential for field-relative driving, odometry, and autonomous navigation.<br><br><strong>Pigeon 2 Capabilities:</strong><br>- Measure robot heading (yaw angle)<br>- Measure pitch and roll angles<br>- Provide angular velocity<br>- Accelerometer data<br>- CAN bus communication<br>- Automatic calibration on startup<br><br><strong>Common Uses:</strong><br>- Field-relative driving (drive relative to field, not robot)<br>- Odometry (robot position estimation)<br>- Autonomous navigation and path following<br>- Balancing mechanisms<br>- Tilt detection<br><br>Learn more: <a href='https://v6.docs.ctr-electronics.com/en/latest/docs/hardware-reference/pigeon2/index.html' target='_blank'>Pigeon 2 Documentation</a>"
    },
    {
      "type": "text",
      "title": "Pigeon 2 Hardware Setup",
      "content": "Before programming, you need to physically set up your Pigeon 2 on the robot.<br><br><strong>Mounting Pigeon 2:</strong><br>1. Mount Pigeon 2 securely to robot chassis<br>2. Ensure Pigeon 2 is level (for accurate pitch/roll)<br>3. Mount away from sources of vibration if possible<br>4. Secure all mounting hardware<br>5. Note the mounting orientation for configuration<br><br><strong>Wiring:</strong><br>1. <strong>CAN Bus:</strong> Connect CAN High and CAN Low to CAN bus network<br>2. <strong>Power:</strong> Pigeon 2 is powered from CAN bus (no separate power needed)<br>3. <strong>Ground:</strong> Ensure proper CAN bus grounding<br><br><strong>Orientation:</strong> Pigeon 2 has a specific orientation marking. Note how it's mounted for proper configuration if needed."
    },
    {
      "type": "code",
      "title": "Creating Pigeon 2 Instance",
      "content": "package frc.robot.subsystems;\n\nimport com.ctre.phoenix6.hardware.Pigeon2;\nimport com.ctre.phoenix6.StatusSignal;\nimport edu.wpi.first.math.geometry.Rotation2d;\nimport edu.wpi.first.math.geometry.Rotation2d;\nimport edu.wpi.first.units.measure.Angle;\n\npublic class DrivetrainWithPigeon {\n    // Pigeon 2 IMU for heading\n    private final Pigeon2 m_pigeon = new Pigeon2(0);  // CAN ID 0\n    \n    // Status signal for efficient reading\n    private final StatusSignal<Angle> m_yaw = m_pigeon.getYaw();\n    \n    public DrivetrainWithPigeon() {\n        // Pigeon 2 calibrates automatically on first boot\n        // Reset heading to zero\n        m_pigeon.setYaw(0);\n    }\n    \n    public double getHeadingDegrees() {\n        return m_yaw.refresh().getValueAsDouble();\n    }\n    \n    public Rotation2d getHeading() {\n        return Rotation2d.fromDegrees(getHeadingDegrees());\n    }\n    \n    public void resetHeading() {\n        m_pigeon.setYaw(0);\n    }\n}"
    },
    {
      "type": "text",
      "title": "Reading Heading (Yaw)",
      "content": "The most common use of Pigeon 2 is reading the robot's heading (yaw angle) - the rotation of the robot around the vertical axis. This is essential for field-relative driving and odometry.<br><br><strong>Heading Characteristics:</strong><br>- Range: Continuous (can exceed ±180 degrees without wrapping by default)<br>- Increases when rotating clockwise (default, configurable)<br>- Can be reset to zero at any time<br>- Updates continuously at high frequency<br><br><strong>Reading Heading:</strong> Use <code>getYaw()</code> to get the status signal, then <code>refresh().getValueAsDouble()</code> to read the current heading. The heading is relative to when Pigeon 2 was last reset.<br><br><strong>Resetting Heading:</strong> Use <code>setYaw(0)</code> to reset heading to zero. This is typically done at the start of autonomous or when robot is at a known orientation."
    },
    {
      "type": "code",
      "title": "Reading Pigeon 2 Heading",
      "content": "package frc.robot.subsystems;\n\nimport com.ctre.phoenix6.hardware.Pigeon2;\nimport com.ctre.phoenix6.StatusSignal;\nimport com.ctre.phoenix6.BaseStatusSignal;\nimport edu.wpi.first.wpilibj.smartdashboard.SmartDashboard;\nimport edu.wpi.first.wpilibj2.command.SubsystemBase;\nimport edu.wpi.first.math.geometry.Rotation2d;\nimport edu.wpi.first.math.geometry.Rotation2d;\nimport edu.wpi.first.units.measure.Angle;\n\npublic class Drivetrain extends SubsystemBase {\n    private final Pigeon2 m_pigeon = new Pigeon2(0);\n    \n    // Status signal for efficient reading\n    private final StatusSignal<Angle> m_yaw = m_pigeon.getYaw();\n    \n    public Drivetrain() {\n        // Pigeon 2 calibrates automatically on first boot\n        // Wait briefly for initialization, then reset\n        m_pigeon.setYaw(0);\n    }\n    \n    public double getHeadingDegrees() {\n        return m_yaw.refresh().getValueAsDouble();\n    }\n    \n    public Rotation2d getHeading() {\n        return Rotation2d.fromDegrees(getHeadingDegrees());\n    }\n    \n    public void resetHeading() {\n        m_pigeon.setYaw(0);\n    }\n    \n    @Override\n    public void periodic() {\n        SmartDashboard.putNumber(\"Robot Heading (degrees)\", getHeadingDegrees());\n    }\n}"
    },
    {
      "type": "text",
      "title": "Reading Pitch and Roll",
      "content": "Pigeon 2 can also measure pitch (rotation around lateral axis) and roll (rotation around longitudinal axis). These are useful for detecting robot tilt, balancing, and specialized applications.<br><br><strong>Pitch:</strong><br>- Rotation around side-to-side axis<br>- Positive = nose up, negative = nose down<br>- Useful for detecting robot tilt forward/backward<br><br><strong>Roll:</strong><br>- Rotation around front-to-back axis<br>- Positive = roll right, negative = roll left<br>- Useful for detecting robot tilt left/right<br><br><strong>Use Cases:</strong><br>- Detecting if robot is tipped over<br>- Balancing mechanisms<br>- Climbing applications<br>- Tilt compensation"
    },
    {
      "type": "code",
      "title": "Reading Pitch and Roll",
      "content": "import com.ctre.phoenix6.hardware.Pigeon2;\nimport com.ctre.phoenix6.StatusSignal;\nimport com.ctre.phoenix6.BaseStatusSignal;\nimport edu.wpi.first.wpilibj.smartdashboard.SmartDashboard;\nimport edu.wpi.first.math.geometry.Rotation2d;\nimport edu.wpi.first.units.measure.Angle;\n\npublic class PigeonPitchRoll {\n    private final Pigeon2 m_pigeon = new Pigeon2(0);\n    \n    // Status signals for efficient reading\n    private final StatusSignal<Angle> m_yaw = m_pigeon.getYaw();\n    private final StatusSignal<Angle> m_pitch = m_pigeon.getPitch();\n    private final StatusSignal<Angle> m_roll = m_pigeon.getRoll();\n    \n    public void updateAngles() {\n        // Refresh all signals efficiently\n        BaseStatusSignal.waitForAll(0.02, m_yaw, m_pitch, m_roll);\n        \n        double yaw = m_yaw.getValueAsDouble();      // Heading\n        double pitch = m_pitch.getValueAsDouble();  // Pitch angle\n        double roll = m_roll.getValueAsDouble();    // Roll angle\n        \n        SmartDashboard.putNumber(\"Yaw\", yaw);\n        SmartDashboard.putNumber(\"Pitch\", pitch);\n        SmartDashboard.putNumber(\"Roll\", roll);\n        \n        // Check if robot is tilted\n        boolean isTilted = Math.abs(pitch) > 10 || Math.abs(roll) > 10;\n        SmartDashboard.putBoolean(\"Robot Tilted\", isTilted);\n    }\n}"
    },
    {
      "type": "text",
      "title": "Field-Relative Driving with Pigeon 2",
      "content": "One of the most common uses of Pigeon 2 is enabling field-relative driving, where the robot moves relative to the field orientation rather than its own orientation. This makes the robot easier to drive and more predictable during matches.<br><br><strong>Field-Relative vs Robot-Relative:</strong><br>- <strong>Robot-Relative:</strong> Forward on joystick always moves robot forward (relative to robot front)<br>- <strong>Field-Relative:</strong> Forward on joystick always moves robot toward same field direction (relative to field)<br><br>Field-relative driving requires the Pigeon 2 heading to rotate driver inputs based on robot orientation. WPILib's <code>ChassisSpeeds</code> class makes this transformation easy."
    },
    {
      "type": "code",
      "title": "Field-Relative Driving Example",
      "content": "package frc.robot.subsystems;\n\nimport com.ctre.phoenix6.hardware.Pigeon2;\nimport com.ctre.phoenix6.StatusSignal;\nimport edu.wpi.first.math.geometry.Rotation2d;\nimport edu.wpi.first.math.kinematics.ChassisSpeeds;\nimport edu.wpi.first.wpilibj2.command.SubsystemBase;\nimport edu.wpi.first.math.geometry.Rotation2d;\nimport edu.wpi.first.units.measure.Angle;\n\npublic class FieldRelativeDrivetrain extends SubsystemBase {\n    private final Pigeon2 m_pigeon = new Pigeon2(0);\n    private final StatusSignal<Angle> m_yaw = m_pigeon.getYaw();\n    \n    public Rotation2d getHeading() {\n        return Rotation2d.fromDegrees(m_yaw.refresh().getValueAsDouble());\n    }\n    \n    public void driveFieldRelative(double xSpeed, double ySpeed, double rotSpeed) {\n        // Convert field-relative speeds to robot-relative\n        ChassisSpeeds robotSpeeds = ChassisSpeeds.fromFieldRelativeSpeeds(\n            xSpeed, ySpeed, rotSpeed, getHeading()\n        );\n        \n        // Apply robot-relative speeds to drivetrain\n        // (Implementation depends on drivetrain type)\n    }\n}"
    },
    {
      "type": "text",
      "title": "Sensor Integration for Odometry",
      "content": "Both CANcoder and Pigeon 2 are commonly used together with wheel encoders for accurate robot pose estimation (odometry).<br><br><strong>Typical Integration:</strong><br>- <strong>Pigeon 2:</strong> Provides robot heading for odometry calculations<br>- <strong>CANcoder:</strong> Provides swerve module angles for swerve odometry<br>- <strong>Together:</strong> Enable accurate field positioning and autonomous navigation<br><br>For detailed information on implementing odometry with these sensors, see the <a href='#odometry-basics' target='_blank'>Odometry</a> and <a href='#swerve-odometry' target='_blank'>Swerve Odometry</a> lessons."
    },
    {
      "type": "code",
      "title": "Swerve Module with CANcoder and Pigeon 2",
      "content": "package frc.robot.subsystems.swerve;\n\nimport com.ctre.phoenix6.hardware.CANcoder;\nimport com.ctre.phoenix6.hardware.TalonFX;\nimport com.ctre.phoenix6.configs.CANcoderConfiguration;\nimport com.ctre.phoenix6.signals.SensorDirectionValue;\nimport com.ctre.phoenix6.BaseStatusSignal;\nimport com.ctre.phoenix6.StatusSignal;\nimport edu.wpi.first.math.geometry.Rotation2d;\nimport edu.wpi.first.math.kinematics.SwerveModulePosition;\nimport edu.wpi.first.math.kinematics.SwerveModuleState;\nimport edu.wpi.first.math.geometry.Rotation2d;\nimport edu.wpi.first.units.measure.Angle;\n\npublic class SwerveModule {\n    private final TalonFX m_driveMotor;\n    private final TalonFX m_steerMotor;\n    private final CANcoder m_angleEncoder;\n    \n    // Status signals\n    private final StatusSignal<Angle> m_drivePosition;\n    private final StatusSignal<Angle> m_anglePosition;\n    \n    public SwerveModule(int driveID, int steerID, int encoderID, double encoderOffset) {\n        m_driveMotor = new TalonFX(driveID);\n        m_steerMotor = new TalonFX(steerID);\n        m_angleEncoder = new CANcoder(encoderID);\n        \n        // Configure CANcoder with offset\n        CANcoderConfiguration config = new CANcoderConfiguration();\n        config.MagnetSensor.MagnetOffset = encoderOffset;\n        config.MagnetSensor.SensorDirection = SensorDirectionValue.CounterClockwise_Positive;\n        m_angleEncoder.getConfigurator().apply(config);\n        \n        // Get status signals for efficient reading\n        m_drivePosition = m_driveMotor.getPosition();\n        m_anglePosition = m_angleEncoder.getPosition();\n    }\n    \n    public SwerveModulePosition getPosition() {\n        // Refresh and read both signals\n        BaseStatusSignal.waitForAll(0.02, m_drivePosition, m_anglePosition);\n        \n        double driveDistance = m_drivePosition.getValueAsDouble();  // meters\n        Rotation2d angle = Rotation2d.fromRotations(m_anglePosition.getValueAsDouble());\n        \n        return new SwerveModulePosition(driveDistance, angle);\n    }\n}"
    },
    {
      "type": "text",
      "title": "Pigeon 2 Configuration",
      "content": "Pigeon 2 requires minimal configuration in most cases, as it calibrates automatically on startup. However, you can configure mounting orientation and other parameters if needed.<br><br><strong>Configuration Options:</strong><br>- Mounting orientation (if Pigeon 2 is mounted at an angle)<br>- Yaw trim for calibration adjustments<br>- Disable temperature compensation (if needed)<br><br><strong>Automatic Calibration:</strong> Pigeon 2 automatically calibrates when powered on. Keep the robot stationary for the first few seconds after power-up for best results."
    },
    {
      "type": "code",
      "title": "Pigeon 2 Configuration",
      "content": "import com.ctre.phoenix6.hardware.Pigeon2;\nimport com.ctre.phoenix6.configs.Pigeon2Configuration;\nimport com.ctre.phoenix6.configs.MountPoseConfigs;\n\npublic class PigeonConfiguration {\n    private final Pigeon2 m_pigeon = new Pigeon2(0);\n    \n    public PigeonConfiguration() {\n        Pigeon2Configuration config = new Pigeon2Configuration();\n        \n        // Configure mounting orientation if Pigeon is mounted at an angle\n        // Most common: Pigeon mounted flat (default configuration works)\n        MountPoseConfigs mountPose = config.MountPose;\n        mountPose.MountPoseYaw = 0;\n        mountPose.MountPosePitch = 0;\n        mountPose.MountPoseRoll = 0;\n        \n        m_pigeon.getConfigurator().apply(config);\n        \n        // Reset heading to zero\n        m_pigeon.setYaw(0);\n    }\n}"
    },
    {
      "type": "link-grid",
      "title": "Related Topics and Documentation",
      "links": [
        {
          "label": "Odometry Basics",
          "id": "odometry-basics"
        },
        {
          "label": "Swerve Odometry",
          "id": "swerve-odometry"
        },
        {
          "label": "CANcoder API Documentation",
          "url": "https://api.ctr-electronics.com/phoenix6/release/java/com/ctre/phoenix6/hardware/CANcoder.html"
        },
        {
          "label": "Pigeon 2 API Documentation",
          "url": "https://api.ctr-electronics.com/phoenix6/release/java/com/ctre/phoenix6/hardware/Pigeon2.html"
        }
      ]
    }
  ]
}