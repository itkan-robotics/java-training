{
  "title": "CTRE Sensors",
  "sections": [
    {
      "type": "text",
      "title": "Introduction to CTRE Sensors",
      "content": "CTRE manufactures several sensors for FRC robots beyond motor controllers. These sensors provide critical feedback for robot control, navigation, and mechanism positioning. Understanding CTRE sensors helps you build more capable and reliable robots.<br><br>The main CTRE sensors used in FRC are:<br>- <strong>Pigeon IMU:</strong> Gyroscope and inertial measurement unit for robot orientation<br>- <strong>CANcoder:</strong> Absolute encoder (covered in separate lessons)<br>- Other specialized sensors for specific applications<br><br>This lesson focuses on the Pigeon IMU, which is one of the most commonly used CTRE sensors."
    },
    {
      "type": "rules-box",
      "title": "CTRE Sensor Overview",
      "subtitle": "Available CTRE sensors:",
      "items": [
        "<strong>Pigeon IMU:</strong> Gyroscope and IMU for robot orientation and heading",
        "<strong>CANcoder:</strong> Absolute encoder for position tracking (covered separately)",
        "<strong>Pigeon 2.0:</strong> Updated version of Pigeon with improved features",
        "Other specialized sensors for specific applications"
      ]
    },
    {
      "type": "text",
      "title": "Pigeon IMU Overview",
      "content": "The Pigeon IMU (Inertial Measurement Unit) is a gyroscope and accelerometer that provides robot orientation and heading information. It's essential for field-relative driving, odometry, and autonomous navigation.<br><br><strong>Pigeon Capabilities:</strong><br>- Measure robot heading (yaw angle)<br>- Measure pitch and roll angles<br>- Provide angular velocity<br>- Accelerometer data<br>- Compass heading (magnetometer)<br>- CAN bus communication<br><br><strong>Common Uses:</strong><br>- Field-relative driving (drive relative to field, not robot)<br>- Odometry (robot position estimation)<br>- Autonomous navigation<br>- Balancing mechanisms<br>- Tilt detection"
    },
    {
      "type": "text",
      "title": "Pigeon Hardware Setup",
      "content": "Before programming, you need to physically set up your Pigeon IMU on the robot.<br><br><strong>Mounting Pigeon:</strong><br>1. Mount Pigeon securely to robot chassis<br>2. Ensure Pigeon is level (for accurate pitch/roll)<br>3. Mount away from sources of vibration<br>4. Secure all mounting hardware<br><br><strong>Wiring:</strong><br>1. <strong>CAN Bus:</strong> Connect CAN High and CAN Low to CAN bus network<br>2. <strong>Power:</strong> Pigeon is powered from CAN bus (no separate power needed)<br>3. <strong>Ground:</strong> Ensure proper CAN bus grounding<br><br><strong>Orientation:</strong> Pigeon has a specific orientation. Mount it according to CTRE documentation to ensure axes align correctly with your robot."
    },
    {
      "type": "text",
      "title": "CAN ID Configuration",
      "content": "The Pigeon IMU needs a unique CAN ID (0-62) to communicate on the CAN bus. You can set the CAN ID using Phoenix Tuner or programmatically in code.<br><br><strong>Using Phoenix Tuner:</strong><br>1. Open Phoenix Tuner and connect to robot<br>2. Select the Pigeon device<br>3. Set the CAN ID in configuration<br>4. Apply and save configuration<br><br><strong>In Code:</strong> When you create a Pigeon instance, you specify the CAN ID in the constructor. The CAN ID must match what's configured in Phoenix Tuner.<br><br><strong>Best Practice:</strong> Use a consistent CAN ID for Pigeon (commonly 0 or a high number like 60) and document it."
    },
    {
      "type": "code",
      "title": "Creating Pigeon IMU Instance",
      "content": "package frc.robot.subsystems;\n\nimport com.ctre.phoenix6.hardware.Pigeon2;\nimport com.ctre.phoenix6.BaseStatusSignal;\n\npublic class DrivetrainWithPigeon {\n    // Pigeon2 IMU for heading\n    private final Pigeon2 m_pigeon = new Pigeon2(0);  // CAN ID 0\n    \n    // Status signals for efficient reading\n    private final BaseStatusSignal[] m_signals = {\n        m_pigeon.getYaw()\n    };\n    \n    public DrivetrainWithPigeon() {\n        // Configure Pigeon (see configuration section)\n    }\n    \n    public double getHeading() {\n        // Refresh signal and read heading (yaw angle)\n        BaseStatusSignal.refreshAll(m_signals);\n        return m_pigeon.getYaw().getValue();\n    }\n}\n\n// Alternative: Pigeon mounted on Talon FX\npublic class DrivetrainWithPigeonOnTalon {\n    private final com.ctre.phoenix6.hardware.TalonFX m_motor = \n        new com.ctre.phoenix6.hardware.TalonFX(1);\n    \n    // Pigeon can be mounted on some Talon FX controllers\n    private final Pigeon2 m_pigeon = new Pigeon2(m_motor);\n}"
    },
    {
      "type": "text",
      "title": "Reading Heading (Yaw)",
      "content": "The most common use of Pigeon is reading the robot's heading (yaw angle) - the rotation of the robot around the vertical axis. This is essential for field-relative driving and odometry.<br><br><strong>Heading Characteristics:</strong><br>- Range: -180 to +180 degrees (or 0-360, configurable)<br>- Increases when rotating clockwise (typically)<br>- Can be reset to zero<br>- Wraps around at Â±180 degrees<br><br><strong>Reading Heading:</strong> Use <code>getYaw().getValue()</code> to read the current heading. The value is returned as a <code>StatusSignal</code> which must be read using <code>getValue()</code>. The heading is relative to when Pigeon was last calibrated or reset.<br><br><strong>Resetting Heading:</strong> Use <code>setYaw(0)</code> to reset heading to zero. This is typically done at the start of autonomous or when robot is at a known orientation."
    },
    {
      "type": "code",
      "title": "Reading Pigeon Heading",
      "content": "package frc.robot.subsystems;\n\nimport com.ctre.phoenix6.hardware.Pigeon2;\nimport com.ctre.phoenix6.BaseStatusSignal;\nimport edu.wpi.first.wpilibj.smartdashboard.SmartDashboard;\nimport edu.wpi.first.wpilibj2.command.SubsystemBase;\n\npublic class Drivetrain extends SubsystemBase {\n    private final Pigeon2 m_pigeon = new Pigeon2(0);\n    \n    // Status signals for efficient reading\n    private final BaseStatusSignal[] m_signals = {\n        m_pigeon.getYaw()\n    };\n    \n    public Drivetrain() {\n        // Calibrate Pigeon (takes a few seconds)\n        // In Phoenix 6, calibration happens automatically on first boot\n        // You can manually trigger calibration if needed\n    }\n    \n    public double getHeading() {\n        // Refresh signal and read yaw (heading) angle\n        BaseStatusSignal.refreshAll(m_signals);\n        return m_pigeon.getYaw().getValue();\n    }\n    \n    public void resetHeading() {\n        m_pigeon.setYaw(0);\n    }\n    \n    public double getHeadingRadians() {\n        // Convert degrees to radians\n        return Math.toRadians(getHeading());\n    }\n    \n    @Override\n    public void periodic() {\n        SmartDashboard.putNumber(\"Robot Heading (degrees)\", getHeading());\n        SmartDashboard.putNumber(\"Robot Heading (radians)\", getHeadingRadians());\n    }\n}"
    },
    {
      "type": "text",
      "title": "Reading Pitch and Roll",
      "content": "Pigeon can also measure pitch (rotation around lateral axis) and roll (rotation around longitudinal axis). These are useful for detecting robot tilt, balancing, and specialized applications.<br><br><strong>Pitch:</strong><br>- Rotation around side-to-side axis<br>- Positive = nose up, negative = nose down<br>- Useful for detecting robot tilt forward/backward<br><br><strong>Roll:</strong><br>- Rotation around front-to-back axis<br>- Positive = roll right, negative = roll left<br>- Useful for detecting robot tilt left/right<br><br><strong>Use Cases:</strong><br>- Detecting if robot is tipped over<br>- Balancing mechanisms<br>- Climbing applications<br>- Tilt compensation"
    },
    {
      "type": "code",
      "title": "Reading Pitch and Roll",
      "content": "import com.ctre.phoenix6.hardware.Pigeon2;\nimport com.ctre.phoenix6.BaseStatusSignal;\nimport edu.wpi.first.wpilibj.smartdashboard.SmartDashboard;\n\npublic class PigeonPitchRoll {\n    private final Pigeon2 m_pigeon = new Pigeon2(0);\n    \n    // Status signals for efficient reading\n    private final BaseStatusSignal[] m_signals = {\n        m_pigeon.getYaw(),\n        m_pigeon.getPitch(),\n        m_pigeon.getRoll()\n    };\n    \n    public void updateAngles() {\n        // Refresh all signals at once (efficient)\n        BaseStatusSignal.refreshAll(m_signals);\n        \n        double yaw = m_pigeon.getYaw().getValue();    // Heading\n        double pitch = m_pigeon.getPitch().getValue();  // Pitch angle\n        double roll = m_pigeon.getRoll().getValue();    // Roll angle\n        \n        SmartDashboard.putNumber(\"Yaw\", yaw);\n        SmartDashboard.putNumber(\"Pitch\", pitch);\n        SmartDashboard.putNumber(\"Roll\", roll);\n        \n        // Check if robot is tilted\n        boolean isTilted = Math.abs(pitch) > 10 || Math.abs(roll) > 10;\n        SmartDashboard.putBoolean(\"Robot Tilted\", isTilted);\n    }\n}"
    },
    {
      "type": "text",
      "title": "Pigeon Calibration",
      "content": "Pigeon2 IMU requires calibration before first use. In Phoenix 6, calibration typically happens automatically on first boot, but you can manually trigger calibration if needed.<br><br><strong>Calibration Process:</strong><br>1. Keep robot stationary during calibration<br>2. Calibration happens automatically on first boot<br>3. Wait for calibration to complete (typically 2-4 seconds)<br>4. Don't move robot during calibration<br>5. Calibration is stored in Pigeon's memory<br><br><strong>When to Calibrate:</strong><br>- First time using Pigeon<br>- After firmware update<br>- If readings seem incorrect<br>- Typically done automatically, but can be triggered manually<br><br><strong>Configuration:</strong> Use <code>Pigeon2Configuration</code> object to configure Pigeon settings, including mounting orientation and other parameters."
    },
    {
      "type": "code",
      "title": "Pigeon Calibration",
      "content": "package frc.robot;\n\nimport com.ctre.phoenix6.hardware.Pigeon2;\nimport com.ctre.phoenix6.configs.Pigeon2Configuration;\nimport edu.wpi.first.wpilibj.TimedRobot;\n\npublic class Robot extends TimedRobot {\n    private Pigeon2 m_pigeon = new Pigeon2(0);\n    \n    @Override\n    public void robotInit() {\n        // Configure Pigeon\n        Pigeon2Configuration config = new Pigeon2Configuration();\n        // Configure mounting orientation and other settings as needed\n        m_pigeon.getConfigurator().apply(config);\n        \n        // In Phoenix 6, calibration typically happens automatically on first boot\n        // If you need to manually trigger calibration, you can do so here\n        // IMPORTANT: Keep robot stationary during calibration\n        System.out.println(\"Pigeon IMU initialized\");\n        \n        // Wait a moment for Pigeon to initialize\n        try {\n            Thread.sleep(1000);\n        } catch (InterruptedException e) {\n            e.printStackTrace();\n        }\n        \n        m_pigeon.setYaw(0);\n        \n        System.out.println(\"Pigeon ready\");\n    }\n}"
    },
    {
      "type": "text",
      "title": "Sensor Integration",
      "content": "Pigeon data is typically integrated with other sensors and control systems for advanced robot functionality:<br><br><strong>Field-Relative Driving:</strong><br>- Use heading to drive relative to field orientation<br>- Compensate for robot rotation<br>- Essential for precise autonomous<br><br><strong>Odometry:</strong><br>- Combine Pigeon heading with encoder data<br>- Estimate robot position on field<br>- More accurate than encoders alone<br><br><strong>Sensor Fusion:</strong><br>- Combine Pigeon with other sensors<br>- Use multiple data sources for better accuracy<br>- Filter and process sensor data<br><br><strong>Control Applications:</strong><br>- Use pitch/roll for balancing<br>- Use heading for rotation control<br>- Compensate for robot tilt"
    },
    {
      "type": "code",
      "title": "Field-Relative Driving with Pigeon",
      "content": "package frc.robot.subsystems;\n\nimport com.ctre.phoenix6.hardware.Pigeon2;\nimport com.ctre.phoenix6.BaseStatusSignal;\nimport edu.wpi.first.math.geometry.Rotation2d;\nimport edu.wpi.first.wpilibj2.command.SubsystemBase;\n\npublic class FieldRelativeDrivetrain extends SubsystemBase {\n    private final Pigeon2 m_pigeon = new Pigeon2(0);\n    // ... motor controllers ...\n    \n    // Status signal for efficient reading\n    private final BaseStatusSignal[] m_signals = {\n        m_pigeon.getYaw()\n    };\n    \n    public Rotation2d getHeading() {\n        // Refresh signal and get heading, convert to Rotation2d\n        BaseStatusSignal.refreshAll(m_signals);\n        double yaw = m_pigeon.getYaw().getValue();\n        return Rotation2d.fromDegrees(yaw);\n    }\n    \n    public void driveFieldRelative(double xSpeed, double ySpeed, double rotSpeed) {\n        Rotation2d heading = getHeading();\n        \n        // Rotate field-relative speeds to robot-relative\n        // (Implementation would use WPILib's ChassisSpeeds or similar)\n        \n        double cos = heading.getCos();\n        double sin = heading.getSin();\n        \n        double robotX = xSpeed * cos - ySpeed * sin;\n        double robotY = xSpeed * sin + ySpeed * cos;\n        \n        drive(robotX, robotY, rotSpeed);\n    }\n}"
    },
    {
      "type": "text",
      "title": "Calibration and Configuration",
      "content": "Proper calibration and configuration ensure accurate Pigeon readings:<br><br><strong>Calibration:</strong><br>- Always calibrate before first use<br>- Keep robot stationary during calibration<br>- Calibration is stored in Pigeon memory<br><br><strong>Configuration Options:</strong><br>- Heading range: -180 to +180 or 0-360 degrees<br>- Mounting orientation (if Pigeon is mounted at angle)<br>- Compass calibration (if using magnetometer)<br>- Status frame periods (update rates)<br><br><strong>Best Practices:</strong><br>- Calibrate in robot initialization<br>- Reset heading at start of autonomous<br>- Document Pigeon CAN ID and mounting orientation<br>- Test calibration by rotating robot and verifying readings"
    },
    {
      "type": "code",
      "title": "Pigeon Configuration",
      "content": "import com.ctre.phoenix6.hardware.Pigeon2;\nimport com.ctre.phoenix6.configs.Pigeon2Configuration;\nimport com.ctre.phoenix6.signals.MountPoseYawValue;\n\npublic class PigeonConfiguration {\n    private final Pigeon2 m_pigeon = new Pigeon2(0);\n    \n    public PigeonConfiguration() {\n        Pigeon2Configuration config = new Pigeon2Configuration();\n        \n        // Configure mounting orientation (if Pigeon is mounted at angle)\n        // Options: Top, Bottom, Front, Back, Left, Right, etc.\n        config.MountPose.MountPoseYaw = MountPoseYawValue.Top;\n        \n        m_pigeon.getConfigurator().apply(config);\n        \n        // In Phoenix 6, calibration typically happens automatically\n        m_pigeon.setYaw(0);\n    }\n}"
    },
    {
      "type": "link-grid",
      "title": "Related Topics and Documentation",
      "links": [
        {
          "label": "Odometry Basics",
          "id": "odometry-basics"
        },
        {
          "label": "Field-Relative Driving",
          "id": "odometry-basics"
        },
        {
          "label": "CTRE Introduction",
          "id": "ctre-intro"
        }
      ]
    }
  ]
}