{
  "title": "CANcoder Absolute Encoders",
  "sections": [
    {
      "type": "text",
      "title": "Understanding Absolute Encoders",
      "content": "Absolute encoders provide position information that is always known, even after power loss. Unlike relative encoders (like those built into motors), absolute encoders don't need to be reset or homed - they always know their position.<br><br><strong>Absolute vs Relative Encoders:</strong><br>- <strong>Absolute:</strong> Position is always known, no reset needed, remembers position after power loss<br>- <strong>Relative:</strong> Position resets to 0 on power-up, must be reset/homed, loses position on power loss<br><br><strong>Advantages of Absolute Encoders:</strong><br>- No need to home mechanism on startup<br>- Always know position immediately<br>- Better for mechanisms that move when powered off<br>- Ideal for swerve modules, arms, and other mechanisms<br><br>The CANcoder is an absolute encoder, making it perfect for applications where absolute position is important."
    },
    {
      "type": "text",
      "title": "CANcoder Absolute Position",
      "content": "The CANcoder provides absolute position in rotations (0.0 to 1.0 for one full revolution). This position is always available, even immediately after power-up, without any calibration or homing sequence.<br><br><strong>Position Characteristics:</strong><br>- Range: 0.0 to 1.0 rotations (one full revolution)<br>- Wraps around: 1.0 + small increment = 0.0<br>- Can be converted to degrees: position * 360.0<br>- Always accurate, no drift over time<br><br><strong>Reading Absolute Position:</strong> Use <code>getAbsolutePosition().getValue()</code> to read the raw absolute position. This value is returned as a <code>StatusSignal</code> which must be read using <code>getValue()</code>. The value represents the physical position of the mechanism relative to the magnet's position."
    },
    {
      "type": "code",
      "title": "Reading Absolute Position",
      "content": "import com.ctre.phoenix6.hardware.CANcoder;\nimport com.ctre.phoenix6.BaseStatusSignal;\nimport edu.wpi.first.wpilibj.smartdashboard.SmartDashboard;\n\npublic class AbsolutePosition {\n    private final CANcoder m_encoder = new CANcoder(10);\n    \n    // Status signals for efficient reading\n    private final BaseStatusSignal[] m_signals = {\n        m_encoder.getAbsolutePosition(),\n        m_encoder.getPosition()\n    };\n    \n    public void updatePosition() {\n        // Refresh all signals at once (efficient)\n        BaseStatusSignal.refreshAll(m_signals);\n        \n        // Read absolute position (0.0-1.0 rotations)\n        double absolutePosition = m_encoder.getAbsolutePosition().getValue();\n        \n        // Convert to degrees (0-360)\n        double degrees = absolutePosition * 360.0;\n        \n        // Alternative: getPosition() includes magnet offset\n        double positionWithOffset = m_encoder.getPosition().getValue();\n        \n        // Update dashboard\n        SmartDashboard.putNumber(\"Absolute Position (rotations)\", absolutePosition);\n        SmartDashboard.putNumber(\"Absolute Position (degrees)\", degrees);\n        SmartDashboard.putNumber(\"Position with Offset\", positionWithOffset);\n    }\n}"
    },
    {
      "type": "text",
      "title": "Magnet Offset Calibration",
      "content": "Magnet offset accounts for the physical mounting position of the magnet relative to the mechanism's zero position. Calibrating the magnet offset allows you to define what position corresponds to \"zero\" for your mechanism.<br><br><strong>Why Calibration is Needed:</strong><br>- Magnet can be mounted at any position on the mechanism<br>- You want a specific mechanism position to be \"zero\"<br>- Offset allows you to align encoder zero with mechanism zero<br><br><strong>Calibration Process:</strong><br>1. Move mechanism to desired zero position<br>2. Read current absolute position<br>3. Calculate offset: offset = desired_zero - current_position (in rotations)<br>4. Configure offset in code or Phoenix Tuner<br>5. Verify: reading should now show zero at mechanism zero<br><br><strong>Using Offset:</strong> Once configured, <code>getPosition().getValue()</code> returns position with offset applied, while <code>getAbsolutePosition().getValue()</code> returns raw position."
    },
    {
      "type": "code",
      "title": "Calibrating Magnet Offset",
      "content": "import com.ctre.phoenix6.hardware.CANcoder;\nimport com.ctre.phoenix6.configs.CANcoderConfiguration;\nimport com.ctre.phoenix6.BaseStatusSignal;\nimport edu.wpi.first.wpilibj.smartdashboard.SmartDashboard;\n\npublic class MagnetOffsetCalibration {\n    private final CANcoder m_encoder = new CANcoder(10);\n    \n    // Status signals\n    private final BaseStatusSignal[] m_signals = {\n        m_encoder.getAbsolutePosition(),\n        m_encoder.getPosition()\n    };\n    \n    public void calibrateOffset() {\n        // Step 1: Move mechanism to desired zero position\n        // (This would be done manually or with code)\n        \n        // Step 2: Read current absolute position\n        BaseStatusSignal.refreshAll(m_signals);\n        double currentAbsolutePosition = m_encoder.getAbsolutePosition().getValue();\n        \n        // Step 3: Calculate offset (in rotations)\n        // If you want current position to be zero:\n        double offset = -currentAbsolutePosition;\n        \n        // Or if you want a specific position to be zero:\n        double desiredZeroPosition = 0.0;  // degrees\n        double desiredZeroRotations = desiredZeroPosition / 360.0;\n        offset = desiredZeroRotations - currentAbsolutePosition;\n        \n        // Step 4: Configure offset\n        CANcoderConfiguration config = new CANcoderConfiguration();\n        config.MagnetSensor.MagnetOffset = offset;\n        m_encoder.getConfigurator().apply(config);\n        \n        // Step 5: Verify\n        BaseStatusSignal.refreshAll(m_signals);\n        double positionWithOffset = m_encoder.getPosition().getValue();\n        System.out.println(\"Offset configured: \" + offset);\n        System.out.println(\"Position with offset: \" + positionWithOffset);\n        \n        // Update dashboard\n        SmartDashboard.putNumber(\"Magnet Offset\", offset);\n        SmartDashboard.putNumber(\"Position After Calibration\", positionWithOffset);\n    }\n    \n    public void displayCalibrationInfo() {\n        BaseStatusSignal.refreshAll(m_signals);\n        double absolutePos = m_encoder.getAbsolutePosition().getValue();\n        double positionWithOffset = m_encoder.getPosition().getValue();\n        \n        SmartDashboard.putNumber(\"Raw Absolute Position\", absolutePos);\n        SmartDashboard.putNumber(\"Position with Offset\", positionWithOffset);\n    }\n}"
    },
    {
      "type": "text",
      "title": "Direction Configuration",
      "content": "CANcoder direction determines whether increasing position corresponds to clockwise or counterclockwise rotation. You may need to invert the direction to match your mechanism's rotation.<br><br><strong>When to Invert:</strong><br>- Encoder reads backwards relative to mechanism rotation<br>- Mechanism rotates opposite to expected direction<br>- Need to match convention with other encoders<br><br><strong>Configuration:</strong> Configure direction in the <code>CANcoderConfiguration</code> object using <code>SensorDirectionValue</code>. This affects both position and velocity readings.<br><br><strong>Testing Direction:</strong> Rotate mechanism manually and verify encoder position changes in the expected direction. If it's backwards, change the direction configuration."
    },
    {
      "type": "code",
      "title": "Configuring Direction",
      "content": "import com.ctre.phoenix6.hardware.CANcoder;\nimport com.ctre.phoenix6.configs.CANcoderConfiguration;\nimport com.ctre.phoenix6.signals.SensorDirectionValue;\n\npublic class DirectionConfig {\n    private final CANcoder m_encoder = new CANcoder(10);\n    \n    public DirectionConfig() {\n        CANcoderConfiguration config = new CANcoderConfiguration();\n        \n        // Normal direction (default)\n        config.MagnetSensor.SensorDirection = SensorDirectionValue.CounterClockwise_Positive;\n        \n        // Inverted direction (if encoder reads backwards)\n        // config.MagnetSensor.SensorDirection = SensorDirectionValue.Clockwise_Positive;\n        \n        // Apply configuration\n        m_encoder.getConfigurator().apply(config);\n        \n        // Test: Rotate mechanism and verify position changes correctly\n    }\n}"
    },
    {
      "type": "text",
      "title": "Using CANcoder with Mechanisms",
      "content": "CANcoder is commonly used with various mechanisms that require absolute position tracking. Here are common applications:<br><br><strong>Swerve Module Angle:</strong><br>- Measure wheel angle for swerve drive<br>- Absolute position ensures correct angle on startup<br>- No need to home modules<br>- Critical for field-relative driving<br><br><strong>Arm Position:</strong><br>- Track arm angle for precise positioning<br>- Know arm position immediately on startup<br>- Useful for autonomous routines<br><br><strong>Elevator Position:</strong><br>- Track elevator height<br>- Absolute position prevents errors<br>- Safety: know position even after power loss<br><br><strong>Turret Rotation:</strong><br>- Measure turret angle<br>- Absolute position for targeting<br>- No homing required"
    },
    {
      "type": "code",
      "title": "Swerve Module with CANcoder",
      "content": "package frc.robot.subsystems.swerve;\n\nimport com.ctre.phoenix6.hardware.CANcoder;\nimport com.ctre.phoenix6.hardware.TalonFX;\nimport com.ctre.phoenix6.configs.CANcoderConfiguration;\nimport com.ctre.phoenix6.signals.SensorDirectionValue;\nimport com.ctre.phoenix6.BaseStatusSignal;\nimport edu.wpi.first.math.geometry.Rotation2d;\n\npublic class SwerveModule {\n    private final TalonFX m_driveMotor;\n    private final TalonFX m_steerMotor;\n    private final CANcoder m_angleEncoder;\n    \n    // Status signal for efficient reading\n    private final BaseStatusSignal[] m_signals = {\n        m_angleEncoder.getPosition()\n    };\n    \n    // Conversion: rotations to radians\n    private static final double ROTATIONS_TO_RADIANS = 2.0 * Math.PI;\n    \n    public SwerveModule(int driveMotorID, int steerMotorID, int encoderID, double encoderOffset) {\n        m_driveMotor = new TalonFX(driveMotorID);\n        m_steerMotor = new TalonFX(steerMotorID);\n        m_angleEncoder = new CANcoder(encoderID);\n        \n        // Configure encoder offset and direction\n        CANcoderConfiguration config = new CANcoderConfiguration();\n        config.MagnetSensor.MagnetOffset = encoderOffset;  // Offset in rotations\n        config.MagnetSensor.SensorDirection = SensorDirectionValue.CounterClockwise_Positive;\n        m_angleEncoder.getConfigurator().apply(config);\n    }\n    \n    public Rotation2d getAngle() {\n        // Refresh signal\n        BaseStatusSignal.refreshAll(m_signals);\n        \n        // Read absolute position (includes offset) and convert to Rotation2d\n        double position = m_angleEncoder.getPosition().getValue();  // In rotations\n        double radians = position * ROTATIONS_TO_RADIANS;\n        return Rotation2d.fromRadians(radians);\n    }\n    \n    public void setDesiredAngle(Rotation2d angle) {\n        // Use angle for steering control\n        // (Steering control implementation would go here)\n    }\n}"
    },
    {
      "type": "code",
      "title": "Arm with CANcoder",
      "content": "package frc.robot.subsystems;\n\nimport com.ctre.phoenix6.hardware.CANcoder;\nimport com.ctre.phoenix6.hardware.TalonFX;\nimport com.ctre.phoenix6.controls.PositionVoltage;\nimport com.ctre.phoenix6.configs.CANcoderConfiguration;\nimport com.ctre.phoenix6.configs.TalonFXConfiguration;\nimport com.ctre.phoenix6.signals.FeedbackSensorSourceValue;\nimport com.ctre.phoenix6.signals.SensorDirectionValue;\nimport com.ctre.phoenix6.BaseStatusSignal;\nimport edu.wpi.first.wpilibj.smartdashboard.SmartDashboard;\nimport edu.wpi.first.wpilibj2.command.SubsystemBase;\n\npublic class ArmWithCANcoder extends SubsystemBase {\n    private final TalonFX m_armMotor = new TalonFX(3);\n    private final CANcoder m_angleEncoder = new CANcoder(11);\n    \n    // Control request (reusable)\n    private final PositionVoltage m_positionRequest = new PositionVoltage(0);\n    \n    // Status signal for efficient reading\n    private final BaseStatusSignal[] m_signals = {\n        m_angleEncoder.getPosition()\n    };\n    \n    // Conversion: rotations to degrees\n    private static final double ROTATIONS_TO_DEGREES = 360.0;\n    \n    // Preset angles (in degrees)\n    public static final double STOWED = 0.0;\n    public static final double INTAKE = 45.0;\n    public static final double SCORE_LOW = 90.0;\n    public static final double SCORE_HIGH = 135.0;\n    \n    public ArmWithCANcoder() {\n        // Configure CANcoder offset and direction\n        CANcoderConfiguration encoderConfig = new CANcoderConfiguration();\n        double encoderOffset = 0.0;  // Calibrate this\n        encoderConfig.MagnetSensor.MagnetOffset = encoderOffset;\n        encoderConfig.MagnetSensor.SensorDirection = SensorDirectionValue.CounterClockwise_Positive;\n        m_angleEncoder.getConfigurator().apply(encoderConfig);\n        \n        // Configure Talon FX to use CANcoder as feedback\n        TalonFXConfiguration motorConfig = new TalonFXConfiguration();\n        motorConfig.Feedback.FeedbackRemoteSensorID = m_angleEncoder.getDeviceID();\n        motorConfig.Feedback.FeedbackSensorSource = FeedbackSensorSourceValue.RemoteCANcoder;\n        motorConfig.Feedback.RotorToSensorRatio = 1.0;  // 1:1 if no gearing\n        \n        // Configure PID\n        motorConfig.Slot0.kP = 0.1;\n        motorConfig.Slot0.kI = 0.0;\n        motorConfig.Slot0.kD = 0.01;\n        motorConfig.Slot0.kV = 0.0;\n        \n        m_armMotor.getConfigurator().apply(motorConfig);\n    }\n    \n    public double getAngle() {\n        // Refresh signal\n        BaseStatusSignal.refreshAll(m_signals);\n        \n        // Read absolute position with offset (in rotations)\n        double position = m_angleEncoder.getPosition().getValue();\n        return position * ROTATIONS_TO_DEGREES;\n    }\n    \n    public void setAngle(double degrees) {\n        // Convert degrees to rotations\n        double targetRotations = degrees / ROTATIONS_TO_DEGREES;\n        \n        // Use PositionVoltage control request with CANcoder feedback\n        m_armMotor.setControl(m_positionRequest.withPosition(targetRotations));\n    }\n    \n    @Override\n    public void periodic() {\n        SmartDashboard.putNumber(\"Arm Angle\", getAngle());\n    }\n}"
    },
    {
      "type": "text",
      "title": "Position Conversion",
      "content": "CANcoder position is returned in rotations (0.0 to 1.0). You'll often need to convert this to real-world units like degrees, inches, or radians depending on your mechanism.<br><br><strong>Common Conversions:</strong><br>- <strong>Degrees:</strong> position * 360.0<br>- <strong>Radians:</strong> position * (2Ï€)<br>- <strong>Inches (for linear mechanisms):</strong> position * circumference<br><br><strong>Wrapping:</strong> Since CANcoder wraps around (1.0 + small increment = 0.0), you may need to handle wrapping when calculating differences or when converting to continuous units like radians.<br><br><strong>Best Practice:</strong> Create conversion constants and helper methods to make conversions clear and consistent throughout your code."
    },
    {
      "type": "code",
      "title": "Position Conversion Examples",
      "content": "import com.ctre.phoenix6.hardware.CANcoder;\nimport com.ctre.phoenix6.BaseStatusSignal;\n\npublic class PositionConversion {\n    private final CANcoder m_encoder = new CANcoder(10);\n    \n    // Status signal for efficient reading\n    private final BaseStatusSignal[] m_signals = {\n        m_encoder.getPosition()\n    };\n    \n    // Conversion constants (rotations to other units)\n    private static final double ROTATIONS_TO_DEGREES = 360.0;\n    private static final double ROTATIONS_TO_RADIANS = 2.0 * Math.PI;\n    \n    // For linear mechanism (example: 4 inch diameter spool)\n    private static final double SPOOL_CIRCUMFERENCE = 4.0 * Math.PI;  // inches\n    \n    public double getAngleDegrees() {\n        BaseStatusSignal.refreshAll(m_signals);\n        double position = m_encoder.getPosition().getValue();  // In rotations\n        return position * ROTATIONS_TO_DEGREES;\n    }\n    \n    public double getAngleRadians() {\n        BaseStatusSignal.refreshAll(m_signals);\n        double position = m_encoder.getPosition().getValue();  // In rotations\n        return position * ROTATIONS_TO_RADIANS;\n    }\n    \n    public double getLinearPosition() {\n        BaseStatusSignal.refreshAll(m_signals);\n        double position = m_encoder.getPosition().getValue();  // In rotations\n        return position * SPOOL_CIRCUMFERENCE;\n    }\n    \n    // Handle wrapping when calculating difference\n    public double angleDifference(double target, double current) {\n        double diff = target - current;\n        \n        // Normalize to -180 to 180 degrees\n        while (diff > 180) diff -= 360;\n        while (diff < -180) diff += 360;\n        \n        return diff;\n    }\n}"
    },
    {
      "type": "text",
      "title": "Calibration Process",
      "content": "Calibrating CANcoder for your mechanism involves setting the magnet offset so that the encoder zero matches your mechanism's zero position. Here's a step-by-step process:<br><br><strong>Step 1: Mount CANcoder and Magnet</strong><br>- Mount CANcoder securely on mechanism<br>- Mount magnet on rotating part<br>- Ensure proper alignment and distance<br><br><strong>Step 2: Move to Zero Position</strong><br>- Manually move mechanism to desired zero position<br>- This is the position you want to read as \"zero\"<br><br><strong>Step 3: Read Current Position</strong><br>- Read absolute position using <code>getAbsolutePosition()</code><br>- Note this value<br><br><strong>Step 4: Calculate Offset</strong><br>- Offset = desired_zero - current_absolute_position<br>- If you want current position to be zero: offset = -current_position<br><br><strong>Step 5: Configure Offset</strong><br>- Set offset using <code>configMagnetOffset()</code><br>- Or configure in Phoenix Tuner<br><br><strong>Step 6: Verify</strong><br>- Read position using <code>getPosition()</code><br>- Should now read zero (or desired zero value)<br>- Test at multiple positions to verify accuracy"
    },
    {
      "type": "text",
      "title": "Advanced Usage",
      "content": "CANcoder can be used in advanced ways for more complex applications:<br><br><strong>Multiple CANcoders:</strong><br>- Use multiple CANcoders for multi-axis mechanisms<br>- Each CANcoder needs unique CAN ID<br>- Example: Shoulder and elbow encoders on arm<br><br><strong>Synchronizing with Talon FX:</strong><br>- Use CANcoder as feedback for Talon FX PID<br>- Configure Talon FX to use CANcoder as remote sensor<br>- Provides absolute position feedback for closed-loop control<br><br><strong>Using as Feedback for PID:</strong><br>- Configure Talon FX to use CANcoder as feedback sensor<br>- Enables absolute position control<br>- No need to reset encoder on startup<br>- Better than integrated encoder for mechanisms that move when powered off"
    },
    {
      "type": "code",
      "title": "Using CANcoder with Talon FX PID",
      "content": "package frc.robot.subsystems;\n\nimport com.ctre.phoenix6.hardware.CANcoder;\nimport com.ctre.phoenix6.hardware.TalonFX;\nimport com.ctre.phoenix6.controls.PositionVoltage;\nimport com.ctre.phoenix6.configs.CANcoderConfiguration;\nimport com.ctre.phoenix6.configs.TalonFXConfiguration;\nimport com.ctre.phoenix6.signals.FeedbackSensorSourceValue;\n\npublic class TalonFXWithCANcoder {\n    private final TalonFX m_motor = new TalonFX(3);\n    private final CANcoder m_encoder = new CANcoder(11);\n    \n    // Control request (reusable)\n    private final PositionVoltage m_positionRequest = new PositionVoltage(0);\n    \n    public TalonFXWithCANcoder() {\n        // Configure CANcoder\n        CANcoderConfiguration encoderConfig = new CANcoderConfiguration();\n        encoderConfig.MagnetSensor.MagnetOffset = 0.0;\n        m_encoder.getConfigurator().apply(encoderConfig);\n        \n        // Configure Talon FX to use CANcoder as feedback\n        TalonFXConfiguration motorConfig = new TalonFXConfiguration();\n        motorConfig.Feedback.FeedbackRemoteSensorID = m_encoder.getDeviceID();\n        motorConfig.Feedback.FeedbackSensorSource = FeedbackSensorSourceValue.RemoteCANcoder;\n        motorConfig.Feedback.RotorToSensorRatio = 1.0;  // 1:1 if no gearing\n        \n        // Configure PID\n        motorConfig.Slot0.kP = 0.1;\n        motorConfig.Slot0.kI = 0.0;\n        motorConfig.Slot0.kD = 0.01;\n        motorConfig.Slot0.kV = 0.0;\n        \n        m_motor.getConfigurator().apply(motorConfig);\n    }\n    \n    public void setPosition(double rotations) {\n        // Use PositionVoltage control request with CANcoder feedback\n        m_motor.setControl(m_positionRequest.withPosition(rotations));\n    }\n    \n    public double getPosition() {\n        // Read position from Talon FX (which reads from CANcoder)\n        // Position is in rotations\n        return m_motor.getPosition().getValue();\n    }\n}"
    },
    {
      "type": "rules-box",
      "title": "Absolute Encoder Best Practices",
      "subtitle": "Tips for effective CANcoder usage:",
      "items": [
        "Calibrate magnet offset for each mechanism",
        "Test calibration at multiple positions",
        "Use consistent conversion factors",
        "Handle position wrapping when calculating differences",
        "Verify magnet strength is adequate",
        "Document CAN ID assignments and offsets",
        "Use CANcoder as feedback for Talon FX when appropriate",
        "Test mechanism immediately after power-up to verify absolute position"
      ]
    },
    {
      "type": "text",
      "title": "Troubleshooting Absolute Encoder Issues",
      "content": "Common issues with CANcoder absolute encoders and solutions:<br><br><strong>Position is Wrong:</strong><br>- Check magnet offset calibration<br>- Verify magnet is mounted correctly<br>- Check sensor direction configuration<br><br><strong>Position Jumps or is Unstable:</strong><br>- Check magnet strength (should be > 50)<br>- Verify magnet distance is correct<br>- Check for electrical interference<br>- Ensure magnet is properly aligned<br><br><strong>Doesn't Remember Position:</strong><br>- Verify you're using <code>getAbsolutePosition()</code> or <code>getPosition()</code><br>- Check that CANcoder is actually an absolute encoder (it is)<br>- Verify configuration is correct<br><br><strong>Offset Not Working:</strong><br>- Verify offset is configured correctly<br>- Check that you're using <code>getPosition()</code> (not <code>getAbsolutePosition()</code>)<br>- Re-calibrate offset if needed"
    },
    {
      "type": "link-grid",
      "title": "Related Topics",
      "links": [
        { "label": "CANcoder Setup", "id": "cancoder-setup" },
        { "label": "Talon FX PID Control", "id": "talon-fx-pid-control" },
        { "label": "Swerve Odometry", "id": "swerve-odometry" }
      ]
    }
  ]
}

