{
  "title": "SPARK MAX Smart Motion",
  "sections": [
    {
      "type": "text",
      "title": "Introduction to Smart Motion",
      "content": "Smart Motion (also called MAXMotion) is REV's motion profiling feature that provides smooth, controlled motion to target positions. Unlike basic PID position control, Smart Motion automatically generates a motion profile (acceleration, cruise velocity, deceleration) that results in smooth, predictable motion.<br><br>Smart Motion is ideal for mechanisms that need to move quickly and smoothly to positions, such as arms, elevators, and turrets. It combines motion profiling with PID control to achieve both speed and precision."
    },
    {
      "type": "rules-box",
      "title": "Smart Motion Advantages",
      "subtitle": "Why use Smart Motion:",
      "items": [
        "Smooth, controlled motion (no jerky movements)",
        "Automatic acceleration and deceleration",
        "Faster than basic PID (can use higher speeds)",
        "Predictable motion profiles",
        "Reduces mechanical stress on mechanisms",
        "Better for mechanisms with significant inertia",
        "Configurable cruise velocity and acceleration"
      ]
    },
    {
      "type": "text",
      "title": "Smart Motion vs Basic PID",
      "content": "Understanding the difference between Smart Motion and basic PID helps you choose the right control method:<br><br><strong>Basic PID Position Control:</strong><br>- Moves directly toward target<br>- Constant output until target reached<br>- Can be jerky, especially with high kP<br>- May overshoot or oscillate<br>- Simpler configuration<br><br><strong>Smart Motion:</strong><br>- Generates smooth motion profile<br>- Accelerates, cruises, then decelerates<br>- Smooth, predictable motion<br>- Less mechanical stress<br>- More configuration required<br><br><strong>When to Use Each:</strong><br>- <strong>Basic PID:</strong> Simple mechanisms, slow movements, tight spaces<br>- <strong>Smart Motion:</strong> Mechanisms with inertia, fast movements, smooth motion required"
    },
    {
      "type": "text",
      "title": "Smart Motion Parameters",
      "content": "Smart Motion requires several parameters to be configured. These control the shape and speed of the motion profile:<br><br><strong>Max Velocity:</strong><br>- Maximum speed during motion (encoder counts per second)<br>- Higher = faster motion, but may cause overshoot<br>- Typical values depend on encoder and mechanism<br><br><strong>Max Acceleration:</strong><br>- How quickly to reach max velocity (encoder counts per second squared)<br>- Higher = faster acceleration, but more mechanical stress<br>- Typical values depend on mechanism capabilities<br><br><strong>Min Velocity:</strong><br>- Minimum velocity during motion (encoder counts per second)<br>- Prevents stalling at low speeds<br>- Typically small value (e.g., 0)<br><br><strong>Allowed Closed Loop Error:</strong><br>- Maximum error considered \"at target\" (encoder counts)<br>- Determines when motion is complete<br>- Typical values: 1-10 encoder counts<br><br><strong>Note:</strong> Smart Motion uses encoder counts for units, so conversion factors may be needed depending on your encoder setup."
    },
    {
      "type": "code",
      "title": "Configuring Smart Motion Parameters",
      "content": "import com.revrobotics.CANSparkMax;\nimport com.revrobotics.CANSparkLowLevel.MotorType;\nimport com.revrobotics.SparkPIDController;\n\npublic class SmartMotionConfig {\n    private final CANSparkMax m_motor = new CANSparkMax(1, MotorType.kBrushless);\n    private final SparkPIDController m_pidController = m_motor.getPIDController();\n    \n    // Smart Motion parameters (encoder counts per second)\n    // NEO encoder: 42 counts per revolution\n    private static final double MAX_VELOCITY = 2000.0;  // encoder counts per second\n    private static final double MAX_ACCELERATION = 1500.0;  // encoder counts per second squared\n    private static final double MIN_VELOCITY = 0.0;  // encoder counts per second\n    private static final double ALLOWED_ERROR = 5.0;  // encoder counts\n    \n    public SmartMotionConfig() {\n        // Configure PID for Smart Motion (Slot 0)\n        m_pidController.setP(0.1, 0);\n        m_pidController.setI(0.0, 0);\n        m_pidController.setD(0.01, 0);\n        m_pidController.setFF(0.0, 0);\n        \n        // Configure Smart Motion parameters\n        m_pidController.setSmartMotionMaxVelocity(MAX_VELOCITY, 0);\n        m_pidController.setSmartMotionMaxAccel(MAX_ACCELERATION, 0);\n        m_pidController.setSmartMotionMinOutputVelocity(MIN_VELOCITY, 0);\n        m_pidController.setSmartMotionAllowedClosedLoopError(ALLOWED_ERROR, 0);\n    }\n}"
    },
    {
      "type": "text",
      "title": "Using Smart Motion",
      "content": "Using Smart Motion is similar to position control - you set a target position, and the SPARK MAX automatically generates and follows a motion profile to reach that position smoothly.<br><br><strong>Control Type:</strong> Use <code>ControlType.kSmartMotion</code> when setting the target position. The SPARK MAX will:<br>1. Calculate motion profile based on current position and target<br>2. Accelerate to max velocity<br>3. Maintain max velocity<br>4. Decelerate to target<br>5. Use PID to hold at target<br><br><strong>Target Setting:</strong> Set the target position in encoder counts, just like position control. Smart Motion handles the rest automatically."
    },
    {
      "type": "code",
      "title": "Basic Smart Motion Usage",
      "content": "package frc.robot.subsystems;\n\nimport com.revrobotics.CANSparkMax;\nimport com.revrobotics.CANSparkLowLevel.MotorType;\nimport com.revrobotics.SparkPIDController;\nimport com.revrobotics.CANSparkBase.ControlType;\nimport com.revrobotics.RelativeEncoder;\nimport edu.wpi.first.wpilibj2.command.SubsystemBase;\n\npublic class ArmWithSmartMotion extends SubsystemBase {\n    private final CANSparkMax m_armMotor = new CANSparkMax(3, MotorType.kBrushless);\n    private final SparkPIDController m_pidController = m_armMotor.getPIDController();\n    private final RelativeEncoder m_encoder = m_armMotor.getEncoder();\n    \n    // Conversion: encoder counts to degrees\n    // NEO encoder: 42 counts per revolution\n    private static final double COUNTS_PER_DEGREE = 42.0 / 360.0;\n    \n    // Smart Motion parameters (encoder counts per second)\n    private static final double MAX_VELOCITY = 2000.0;\n    private static final double MAX_ACCELERATION = 1500.0;\n    private static final double MIN_VELOCITY = 0.0;\n    private static final double ALLOWED_ERROR = 5.0;\n    \n    public ArmWithSmartMotion() {\n        // Configure PID\n        m_pidController.setP(0.1, 0);\n        m_pidController.setI(0.0, 0);\n        m_pidController.setD(0.01, 0);\n        m_pidController.setFF(0.0, 0);\n        \n        // Configure Smart Motion\n        m_pidController.setSmartMotionMaxVelocity(MAX_VELOCITY, 0);\n        m_pidController.setSmartMotionMaxAccel(MAX_ACCELERATION, 0);\n        m_pidController.setSmartMotionMinOutputVelocity(MIN_VELOCITY, 0);\n        m_pidController.setSmartMotionAllowedClosedLoopError(ALLOWED_ERROR, 0);\n        \n        // Reset encoder position to zero\n        m_encoder.setPosition(0);\n    }\n    \n    public void setAngle(double degrees) {\n        // Convert degrees to encoder counts\n        double targetCounts = degrees * COUNTS_PER_DEGREE;\n        \n        // Use Smart Motion control type\n        m_pidController.setReference(targetCounts, ControlType.kSmartMotion, 0);\n    }\n    \n    public double getAngle() {\n        double position = m_encoder.getPosition();\n        return position / COUNTS_PER_DEGREE;\n    }\n}"
    },
    {
      "type": "text",
      "title": "Monitoring Motion Status",
      "content": "You can monitor Smart Motion status to determine when motion is complete or to display telemetry. The SPARK MAX provides status information about the motion profile.<br><br><strong>Available Status Information:</strong><br>- <strong>Position:</strong> Current encoder position<br>- <strong>Velocity:</strong> Current velocity<br>- <strong>Output:</strong> Current motor output<br>- <strong>Setpoint:</strong> Current target position<br><br><strong>Motion Completion:</strong> Motion is typically considered complete when the position error is within the allowed closed loop error and velocity is near zero. Calculate error by comparing the target position with the current position."
    },
    {
      "type": "code",
      "title": "Monitoring Smart Motion Status",
      "content": "import com.revrobotics.CANSparkMax;\nimport com.revrobotics.CANSparkLowLevel.MotorType;\nimport com.revrobotics.SparkPIDController;\nimport com.revrobotics.CANSparkBase.ControlType;\nimport com.revrobotics.RelativeEncoder;\nimport edu.wpi.first.wpilibj.smartdashboard.SmartDashboard;\n\npublic class SmartMotionStatus {\n    private final CANSparkMax m_motor = new CANSparkMax(1, MotorType.kBrushless);\n    private final SparkPIDController m_pidController = m_motor.getPIDController();\n    private final RelativeEncoder m_encoder = m_motor.getEncoder();\n    \n    private double m_targetPosition = 0.0;\n    \n    public void setPosition(double position) {\n        m_targetPosition = position;\n        m_pidController.setReference(position, ControlType.kSmartMotion, 0);\n    }\n    \n    public void updateStatus() {\n        // Current position and velocity\n        double position = m_encoder.getPosition();\n        double velocity = m_encoder.getVelocity();\n        \n        // Motor output\n        double output = m_motor.get();\n        \n        // Calculate error (target - current)\n        double error = m_targetPosition - position;\n        \n        // Update dashboard\n        SmartDashboard.putNumber(\"Position\", position);\n        SmartDashboard.putNumber(\"Velocity\", velocity);\n        SmartDashboard.putNumber(\"Target Position\", m_targetPosition);\n        SmartDashboard.putNumber(\"Error\", error);\n        SmartDashboard.putNumber(\"Output\", output);\n        \n        // Check if motion is complete (tolerance in encoder counts)\n        boolean isComplete = Math.abs(error) < 5.0 && Math.abs(velocity) < 10.0;\n        SmartDashboard.putBoolean(\"Motion Complete\", isComplete);\n    }\n}"
    },
    {
      "type": "text",
      "title": "Smart Motion Tuning",
      "content": "Tuning Smart Motion involves adjusting both the motion profile parameters and the underlying PID parameters. Follow this process:<br><br><strong>Step 1: Tune PID First</strong><br>- Start with basic PID position control<br>- Tune kP, kI, kD until position control works well<br>- This ensures Smart Motion has good PID to follow the profile<br><br><strong>Step 2: Set Max Velocity</strong><br>- Start with a moderate max velocity<br>- Increase until motion is fast but still smooth<br>- Too high = overshoot or instability<br><br><strong>Step 3: Set Max Acceleration</strong><br>- Start with acceleration = max velocity<br>- Increase for faster acceleration, decrease for smoother<br>- Too high = mechanical stress, too low = slow motion<br><br><strong>Step 4: Adjust Allowed Error</strong><br>- Start with moderate allowed error (e.g., 5 encoder counts)<br>- Smaller = more precise but may take longer<br>- Larger = faster completion but less precise<br><br><strong>Step 5: Test and Refine</strong><br>- Test with different distances<br>- Test with different loads<br>- Adjust parameters based on results"
    },
    {
      "type": "code",
      "title": "Smart Motion Tuning Helper",
      "content": "package frc.robot.subsystems;\n\nimport com.revrobotics.CANSparkMax;\nimport com.revrobotics.SparkPIDController;\nimport edu.wpi.first.wpilibj.smartdashboard.SmartDashboard;\n\npublic class SmartMotionTuning {\n    private final CANSparkMax m_motor;\n    private final SparkPIDController m_pidController;\n    \n    public SmartMotionTuning(CANSparkMax motor) {\n        m_motor = motor;\n        m_pidController = motor.getPIDController();\n    }\n    \n    public void updateFromDashboard() {\n        // Read parameters from dashboard\n        double maxVel = SmartDashboard.getNumber(\"SM Max Velocity\", 2000.0);\n        double maxAccel = SmartDashboard.getNumber(\"SM Max Acceleration\", 1500.0);\n        double minVel = SmartDashboard.getNumber(\"SM Min Velocity\", 0.0);\n        double allowedError = SmartDashboard.getNumber(\"SM Allowed Error\", 5.0);\n        \n        // Update Smart Motion parameters\n        m_pidController.setSmartMotionMaxVelocity(maxVel, 0);\n        m_pidController.setSmartMotionMaxAccel(maxAccel, 0);\n        m_pidController.setSmartMotionMinOutputVelocity(minVel, 0);\n        m_pidController.setSmartMotionAllowedClosedLoopError(allowedError, 0);\n        \n        // Update PID from dashboard\n        double kP = SmartDashboard.getNumber(\"PID kP\", 0.1);\n        double kI = SmartDashboard.getNumber(\"PID kI\", 0.0);\n        double kD = SmartDashboard.getNumber(\"PID kD\", 0.01);\n        \n        m_pidController.setP(kP, 0);\n        m_pidController.setI(kI, 0);\n        m_pidController.setD(kD, 0);\n    }\n    \n    public void displayStatus() {\n        SmartDashboard.putNumber(\"SM Position\", m_motor.getEncoder().getPosition());\n        SmartDashboard.putNumber(\"SM Velocity\", m_motor.getEncoder().getVelocity());\n        SmartDashboard.putNumber(\"SM Output\", m_motor.get());\n    }\n}"
    },
    {
      "type": "text",
      "title": "S-Curve Profiles",
      "content": "Smart Motion uses acceleration control to create smooth motion profiles. The acceleration and deceleration phases create smooth motion without sudden changes.<br><br><strong>Motion Profile Shape:</strong><br>- Acceleration phase: Gradually increase speed<br>- Cruise phase: Maintain max velocity<br>- Deceleration phase: Gradually decrease speed<br>- Hold phase: PID holds at target<br><br><strong>Profile Characteristics:</strong><br>- Smooth acceleration and deceleration<br>- No sudden changes in velocity<br>- Predictable motion path<br>- Reduces mechanical stress<br><br><strong>Parameter Effects:</strong><br>- Higher max velocity = faster motion but may overshoot<br>- Higher max acceleration = faster start but more stress<br>- Lower allowed error = more precise but slower completion<br><br><strong>Choosing Parameters:</strong> Start with moderate values, then adjust based on your mechanism's needs. Balance speed vs smoothness based on application."
    },
    {
      "type": "code",
      "title": "Complete Smart Motion Example",
      "content": "package frc.robot.subsystems;\n\nimport com.revrobotics.CANSparkMax;\nimport com.revrobotics.CANSparkLowLevel.MotorType;\nimport com.revrobotics.SparkPIDController;\nimport com.revrobotics.CANSparkBase.ControlType;\nimport com.revrobotics.RelativeEncoder;\nimport com.revrobotics.SparkBase.IdleMode;\nimport edu.wpi.first.wpilibj.smartdashboard.SmartDashboard;\nimport edu.wpi.first.wpilibj2.command.SubsystemBase;\n\npublic class Elevator extends SubsystemBase {\n    private final CANSparkMax m_elevatorMotor = new CANSparkMax(4, MotorType.kBrushless);\n    private final SparkPIDController m_pidController = m_elevatorMotor.getPIDController();\n    private final RelativeEncoder m_encoder = m_elevatorMotor.getEncoder();\n    \n    // Conversion: encoder counts to inches (assuming 4\" diameter spool, 42 counts/rev)\n    private static final double COUNTS_PER_REVOLUTION = 42.0;\n    private static final double SPOOL_CIRCUMFERENCE = 4.0 * Math.PI;  // inches\n    private static final double COUNTS_PER_INCH = COUNTS_PER_REVOLUTION / SPOOL_CIRCUMFERENCE;\n    \n    // Smart Motion parameters (encoder counts per second)\n    private static final double MAX_VELOCITY = 3000.0;\n    private static final double MAX_ACCELERATION = 2000.0;\n    private static final double MIN_VELOCITY = 0.0;\n    private static final double ALLOWED_ERROR = 5.0;\n    \n    // Preset positions (in inches)\n    public static final double BOTTOM = 0.0;\n    public static final double MID = 24.0;\n    public static final double TOP = 48.0;\n    \n    public Elevator() {\n        // Basic configuration\n        m_elevatorMotor.setIdleMode(IdleMode.kBrake);\n        \n        // Configure PID\n        m_pidController.setP(0.15, 0);\n        m_pidController.setI(0.0, 0);\n        m_pidController.setD(0.02, 0);\n        m_pidController.setFF(0.0, 0);\n        \n        // Configure Smart Motion\n        m_pidController.setSmartMotionMaxVelocity(MAX_VELOCITY, 0);\n        m_pidController.setSmartMotionMaxAccel(MAX_ACCELERATION, 0);\n        m_pidController.setSmartMotionMinOutputVelocity(MIN_VELOCITY, 0);\n        m_pidController.setSmartMotionAllowedClosedLoopError(ALLOWED_ERROR, 0);\n        \n        // Configure soft limits (in encoder counts)\n        m_encoder.setPosition(0);\n        m_elevatorMotor.setSoftLimit(CANSparkMax.SoftLimitDirection.kForward, (float)(TOP * COUNTS_PER_INCH));\n        m_elevatorMotor.setSoftLimit(CANSparkMax.SoftLimitDirection.kReverse, (float)(BOTTOM * COUNTS_PER_INCH));\n        m_elevatorMotor.enableSoftLimit(CANSparkMax.SoftLimitDirection.kForward, true);\n        m_elevatorMotor.enableSoftLimit(CANSparkMax.SoftLimitDirection.kReverse, true);\n    }\n    \n    public void setHeight(double inches) {\n        double targetCounts = inches * COUNTS_PER_INCH;\n        m_pidController.setReference(targetCounts, ControlType.kSmartMotion, 0);\n    }\n    \n    public double getHeight() {\n        double position = m_encoder.getPosition();\n        return position / COUNTS_PER_INCH;\n    }\n    \n    public boolean isAtHeight(double targetHeight, double tolerance) {\n        double currentHeight = getHeight();\n        return Math.abs(currentHeight - targetHeight) < tolerance;\n    }\n    \n    public boolean isMotionComplete() {\n        // Check if within allowed error and velocity is low\n        double currentPos = m_encoder.getPosition();\n        double velocity = Math.abs(m_encoder.getVelocity());\n        // Note: You need to track target position yourself\n        return velocity < 10.0;  // Simplified check\n    }\n    \n    @Override\n    public void periodic() {\n        SmartDashboard.putNumber(\"Elevator Height\", getHeight());\n        SmartDashboard.putBoolean(\"Motion Complete\", isMotionComplete());\n    }\n}"
    },
    {
      "type": "link-grid",
      "title": "Related Topics",
      "links": [
        {
		  "label": "SPARK MAX PID Control", 
		  "url": "spark-max-pid-control"},
        {
		  "label": "SPARK MAX Configuration", 
		  "url": "spark-max-configuration"},
        {
		  "label": "Motion Profiling Basics", 
		  "url": "motion-profiling-basics"}
      ]
    }
  ]
}

