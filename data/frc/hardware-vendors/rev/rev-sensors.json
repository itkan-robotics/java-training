{
  "title": "REV Sensors",
  "sections": [
    {
      "type": "text",
      "title": "Introduction to REV Sensors",
      "content": "REV Robotics manufactures several sensors for FRC robots that provide critical feedback for robot control, navigation, and mechanism positioning. These sensors integrate with SPARK MAX controllers via the data port, making them easy to use and configure.<br><br>Understanding REV sensors helps you build more capable and reliable robots. The main REV sensors used in FRC are the Color Sensor V3 and the 2m Distance Sensor, along with support for analog and digital sensors via the data port."
    },
    {
      "type": "rules-box",
      "title": "REV Sensor Overview",
      "subtitle": "Available REV sensors:",
      "items": [
        "<strong>REV Color Sensor V3:</strong> Advanced color detection sensor with proximity sensing capabilities",
        "<strong>REV 2m Distance Sensor:</strong> Ultrasonic distance sensor for object detection and ranging up to 2 meters",
        "<strong>Analog Sensors:</strong> Support for potentiometers and other analog sensors via data port",
        "<strong>Digital Sensors:</strong> Support for limit switches and other digital sensors via data port"
      ]
    },
    {
      "type": "text",
      "title": "REV Color Sensor V3",
      "content": "The REV Color Sensor V3 is an advanced color detection sensor that can detect colors and measure proximity. It's useful for game piece detection, line following, and other color-based applications.<br><br><strong>Color Sensor Capabilities:</strong><br>- Color detection (RGB values)<br>- Color matching (match detected color to known colors)<br>- Proximity sensing (detect objects nearby)<br>- IR LED control<br><br><strong>Common Uses:</strong><br>- Game piece detection (detect game piece color)<br>- Line following (detect field lines)<br>- Mechanism state detection (detect mechanism position by color)<br>- Object detection (using proximity mode)<br><br><strong>Wiring:</strong> The Color Sensor V3 connects to the SPARK MAX data port using a data port breakout board. Follow REV documentation for proper wiring connections."
    },
    {
      "type": "code",
      "title": "REV Color Sensor V3 Usage",
      "content": "package frc.robot.subsystems;\n\nimport com.revrobotics.ColorSensorV3;\nimport com.revrobotics.ColorMatch;\nimport edu.wpi.first.wpilibj.I2C;\nimport edu.wpi.first.wpilibj.util.Color;\nimport edu.wpi.first.wpilibj.smartdashboard.SmartDashboard;\nimport edu.wpi.first.wpilibj2.command.SubsystemBase;\n\npublic class ColorSensorExample extends SubsystemBase {\n    // Color Sensor V3 uses I2C port on roboRIO\n    // Port depends on your wiring (typically I2C.Port.kOnboard)\n    private final ColorSensorV3 m_colorSensor = new ColorSensorV3(I2C.Port.kOnboard);\n    \n    // Color matcher for matching detected colors\n    private final ColorMatch m_colorMatcher = new ColorMatch();\n    \n    // Define target colors (example: game piece colors)\n    private final Color kBlueTarget = new Color(0.143, 0.427, 0.429);\n    private final Color kRedTarget = new Color(0.561, 0.232, 0.114);\n    \n    public ColorSensorExample() {\n        // Add target colors to matcher\n        m_colorMatcher.addColorMatch(kBlueTarget);\n        m_colorMatcher.addColorMatch(kRedTarget);\n    }\n    \n    @Override\n    public void periodic() {\n        Color detectedColor = m_colorSensor.getColor();\n        \n        int proximity = m_colorSensor.getProximity();\n        \n        // Match detected color to known colors\n        var match = m_colorMatcher.matchClosestColor(detectedColor);\n        \n        SmartDashboard.putNumber(\"Color R\", detectedColor.red);\n        SmartDashboard.putNumber(\"Color G\", detectedColor.green);\n        SmartDashboard.putNumber(\"Color B\", detectedColor.blue);\n        SmartDashboard.putNumber(\"Proximity\", proximity);\n        SmartDashboard.putBoolean(\"Object Detected\", proximity > 150);\n    }\n    \n    public boolean isBlueDetected() {\n        Color detectedColor = m_colorSensor.getColor();\n        var match = m_colorMatcher.matchClosestColor(detectedColor);\n        return match.color == kBlueTarget;\n    }\n}"
    },
    {
      "type": "text",
      "title": "REV 2m Distance Sensor",
      "content": "The REV 2m Distance Sensor is an ultrasonic distance sensor that can measure distances up to 2 meters. It's useful for object detection, obstacle avoidance, and mechanism positioning.<br><br><strong>Distance Sensor Capabilities:</strong><br>- Distance measurement (0-2 meters)<br>- High accuracy and resolution<br>- Fast update rate<br>- Reliable performance<br><br><strong>Common Uses:</strong><br>- Object detection (detect game pieces, obstacles)<br>- Mechanism positioning (detect when mechanism reaches position)<br>- Autonomous navigation (obstacle avoidance)<br>- Intake detection (detect when game piece is in intake)<br><br><strong>Wiring:</strong> The Distance Sensor connects to the SPARK MAX data port using a data port breakout board. Follow REV documentation for proper wiring connections."
    },
    {
      "type": "code",
      "title": "REV 2m Distance Sensor Usage",
      "content": "package frc.robot.subsystems;\n\nimport com.revrobotics.TimeOfFlight;\nimport edu.wpi.first.wpilibj.smartdashboard.SmartDashboard;\nimport edu.wpi.first.wpilibj2.command.SubsystemBase;\n\npublic class DistanceSensorExample extends SubsystemBase {\n    // TimeOfFlight sensor (REV 2m Distance Sensor)\n    private final TimeOfFlight m_distanceSensor = new TimeOfFlight(0);  // I2C port 0\n    \n    // Distance threshold for object detection (in meters)\n    private static final double DETECTION_THRESHOLD = 0.3;  // 30 cm\n    \n    public DistanceSensorExample() {\n        // Configure sensor range (0-2 meters)\n        m_distanceSensor.setRangingMode(TimeOfFlight.RangingMode.kShort, 24);\n    }\n    \n    @Override\n    public void periodic() {\n        double distance = m_distanceSensor.getRange();\n        \n        // Check if object is detected\n        boolean objectDetected = distance < DETECTION_THRESHOLD && distance > 0.0;\n        \n        SmartDashboard.putNumber(\"Distance (m)\", distance);\n        SmartDashboard.putNumber(\"Distance (cm)\", distance * 100.0);\n        SmartDashboard.putBoolean(\"Object Detected\", objectDetected);\n    }\n    \n    public boolean isObjectDetected() {\n        double distance = m_distanceSensor.getRange();\n        return distance < DETECTION_THRESHOLD && distance > 0.0;\n    }\n    \n    public double getDistance() {\n        return m_distanceSensor.getRange();\n    }\n}"
    },
    {
      "type": "text",
      "title": "Analog Sensors",
      "content": "SPARK MAX supports analog sensors via the data port. Analog sensors provide continuous position or value readings, making them useful for position feedback and measurement.<br><br><strong>Analog Sensor Types:</strong><br>- <strong>Potentiometers:</strong> Position sensors that provide voltage proportional to position<br>- <strong>Other Analog Sensors:</strong> Any sensor that outputs analog voltage<br><br><strong>Wiring:</strong> Analog sensors connect to the SPARK MAX data port using a data port breakout board. Follow REV documentation for proper wiring connections.<br><br><strong>Reading Values:</strong> Analog sensors are read using the SPARK MAX analog input methods. Values are typically in volts (0-5V) or can be converted to position units."
    },
    {
      "type": "code",
      "title": "Analog Sensor Reading",
      "content": "import com.revrobotics.CANSparkMax;\nimport com.revrobotics.CANSparkLowLevel.MotorType;\nimport edu.wpi.first.wpilibj.smartdashboard.SmartDashboard;\n\npublic class AnalogSensorReading {\n    private final CANSparkMax m_motor = new CANSparkMax(1, MotorType.kBrushless);\n    \n    public void readAnalogSensor() {\n        // Note: SPARK MAX analog input reading depends on specific API\n        \n        // Analog sensors typically provide voltage proportional to position\n        // You may need to convert voltage to position units\n        \n        // Example: Potentiometer reading\n        // double voltage = m_motor.getAnalogVoltage();\n        // double position = voltage * CONVERSION_FACTOR;\n    }\n}"
    },
    {
      "type": "text",
      "title": "Digital Sensors",
      "content": "SPARK MAX supports digital sensors via the data port. Digital sensors provide on/off (boolean) readings, making them useful for limit switches, hall effect sensors, and other binary sensors.<br><br><strong>Digital Sensor Types:</strong><br>- <strong>Limit Switches:</strong> Mechanical switches that detect when mechanism reaches limit<br>- <strong>Hall Effect Sensors:</strong> Magnetic sensors that detect presence of magnet<br>- <strong>Other Digital Sensors:</strong> Any sensor that outputs digital (high/low) signal<br><br><strong>Wiring:</strong> Digital sensors connect to the SPARK MAX data port using a data port breakout board. Follow REV documentation for proper wiring connections.<br><br><strong>Reading Values:</strong> Digital sensors are read using the SPARK MAX digital input methods. Values are boolean (true/false)."
    },
    {
      "type": "code",
      "title": "Digital Limit Switch Usage",
      "content": "package frc.robot.subsystems;\n\nimport com.revrobotics.CANSparkMax;\nimport com.revrobotics.CANSparkLowLevel.MotorType;\nimport edu.wpi.first.wpilibj.DigitalInput;\nimport edu.wpi.first.wpilibj.smartdashboard.SmartDashboard;\nimport edu.wpi.first.wpilibj2.command.SubsystemBase;\n\npublic class LimitSwitchExample extends SubsystemBase {\n    private final CANSparkMax m_motor = new CANSparkMax(1, MotorType.kBrushless);\n    \n    // Limit switch connected to DIO port on roboRIO\n    // (Digital sensors can also connect via SPARK MAX data port)\n    private final DigitalInput m_limitSwitch = new DigitalInput(0);\n    \n    @Override\n    public void periodic() {\n        // Note: get() returns true when switch is NOT pressed (normally open)\n        boolean isPressed = !m_limitSwitch.get();\n        \n        SmartDashboard.putBoolean(\"Limit Switch Pressed\", isPressed);\n        \n        // Safety: Stop motor if limit switch is pressed\n        if (isPressed) {\n            m_motor.set(0.0);\n        }\n    }\n    \n    public boolean isAtLimit() {\n        return !m_limitSwitch.get();\n    }\n}"
    },
    {
      "type": "text",
      "title": "Sensor Integration",
      "content": "REV sensors are typically integrated with motor control and other robot systems for advanced functionality:<br><br><strong>Sensor-Based Control:</strong><br>- Use sensors to trigger motor actions<br>- Detect game pieces and activate mechanisms<br>- Use limit switches for safety<br><br><strong>State Machines:</strong><br>- Use sensors to determine mechanism state<br>- Transition between states based on sensor readings<br>- Implement complex mechanism behaviors<br><br><strong>Safety Interlocks:</strong><br>- Use sensors to prevent unsafe operations<br>- Stop motors when limits are reached<br>- Prevent mechanism damage<br><br><strong>Autonomous Integration:</strong><br>- Use sensors for autonomous routines<br>- Detect game pieces for scoring<br>- Navigate using sensor feedback"
    },
    {
      "type": "code",
      "title": "Sensor-Based Control Example",
      "content": "package frc.robot.subsystems;\n\nimport com.revrobotics.CANSparkMax;\nimport com.revrobotics.CANSparkLowLevel.MotorType;\nimport com.revrobotics.TimeOfFlight;\nimport edu.wpi.first.wpilibj.DigitalInput;\nimport edu.wpi.first.wpilibj2.command.SubsystemBase;\n\npublic class IntakeWithSensors extends SubsystemBase {\n    private final CANSparkMax m_intakeMotor = new CANSparkMax(5, MotorType.kBrushless);\n    private final TimeOfFlight m_distanceSensor = new TimeOfFlight(0);\n    private final DigitalInput m_limitSwitch = new DigitalInput(0);\n    \n    private static final double DETECTION_DISTANCE = 0.15;  // 15 cm\n    \n    public void runIntake() {\n        // Check if game piece is detected\n        double distance = m_distanceSensor.getRange();\n        boolean gamePieceDetected = distance < DETECTION_DISTANCE && distance > 0.0;\n        \n        // Check if limit switch is pressed (intake full)\n        boolean isFull = !m_limitSwitch.get();\n        \n        if (gamePieceDetected && !isFull) {\n            m_intakeMotor.set(0.5);\n        } else if (isFull) {\n            m_intakeMotor.set(0.0);\n        } else {\n            m_intakeMotor.set(0.3);  // Slow intake when no game piece\n        }\n    }\n    \n    public void stopIntake() {\n        m_intakeMotor.set(0.0);\n    }\n    \n    public boolean hasGamePiece() {\n        double distance = m_distanceSensor.getRange();\n        return distance < DETECTION_DISTANCE && distance > 0.0;\n    }\n}"
    },
    {
      "type": "link-grid",
      "title": "Related Topics and Documentation",
      "links": [
        {
          "label": "Motor Controller Configuration",
          "id": "motor-controller-configuration"
        },
        {
          "label": "SPARK MAX Setup",
          "id": "spark-max-setup"
        },
        {
          "label": "REV Introduction",
          "id": "rev-intro"
        }
      ]
    }
  ]
}