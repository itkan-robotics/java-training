{
  "title": "REV Sensors and Encoders",
  "sections": [
    {
      "type": "text",
      "title": "Introduction to REV Sensors and Encoders",
      "content": "REV Robotics manufactures several sensors and encoders for FRC robots that provide critical feedback for robot control, navigation, and mechanism positioning. This lesson covers both encoder hardware (for position/velocity tracking) and other REV sensors (Color Sensor V3, Distance Sensor) that integrate with SPARK MAX controllers.<br><br>Understanding REV sensors and encoders helps you build more capable and reliable robots with accurate feedback for control systems."
    },
    {
      "type": "rules-box",
      "title": "REV Sensor and Encoder Overview",
      "subtitle": "Available REV sensors and encoders:",
      "items": [
        "<strong>NEO Built-in Encoder:</strong> Integrated encoder on NEO brushless motors (42 counts per revolution)",
        "<strong>External Encoders:</strong> Quadrature encoders via SPARK MAX data port for higher resolution or brushed motors",
        "<strong>REV Color Sensor V3:</strong> Advanced color detection sensor with proximity sensing capabilities",
        "<strong>REV 2m Distance Sensor:</strong> Time-of-flight distance sensor for object detection and ranging up to 2 meters",
        "<strong>Analog Sensors:</strong> Potentiometers and other analog sensors via data port",
        "<strong>Digital Sensors:</strong> Limit switches and other digital sensors via data port or DIO"
      ]
    },
    {
      "type": "text",
      "title": "NEO Motor Encoders",
      "content": "NEO brushless motors have built-in encoders that provide position and velocity feedback. These encoders are automatically available when using NEO motors with SPARK MAX controllers.<br><br><strong>Built-in Encoder Features:</strong><br>- 42 counts per revolution<br>- Position and velocity measurement<br>- No additional wiring required<br>- Automatic configuration<br><br><strong>Reading NEO Encoder Values:</strong> Use the <code>getEncoder()</code> method on your SPARK MAX to get the encoder object. Then use <code>getPosition()</code> and <code>getVelocity()</code> to read values.<br><br><strong>Encoder Units:</strong> Position is in revolutions by default. Velocity is in RPM (revolutions per minute) by default. You can configure conversion factors to work in your mechanism's units."
    },
    {
      "type": "code",
      "title": "Reading NEO Encoder Values",
      "content": "import com.revrobotics.spark.SparkMax;\nimport com.revrobotics.spark.SparkLowLevel.MotorType;\nimport com.revrobotics.RelativeEncoder;\nimport edu.wpi.first.wpilibj.smartdashboard.SmartDashboard;\n\npublic class NEOEncoderReading {\n    private final SparkMax m_motor = new SparkMax(1, MotorType.kBrushless);\n    private final RelativeEncoder m_encoder = m_motor.getEncoder();\n    \n    public void updateEncoder() {\n        // Read position (revolutions by default)\n        double position = m_encoder.getPosition();\n        \n        // Read velocity (RPM by default)\n        double velocity = m_encoder.getVelocity();\n        \n        // Convert to degrees\n        double positionDegrees = position * 360.0;\n        \n        SmartDashboard.putNumber(\"Encoder Position (rev)\", position);\n        SmartDashboard.putNumber(\"Encoder Position (deg)\", positionDegrees);\n        SmartDashboard.putNumber(\"Encoder Velocity (RPM)\", velocity);\n    }\n}"
    },
    {
      "type": "text",
      "title": "Encoder Configuration and Unit Conversion",
      "content": "Encoders can be configured with conversion factors to automatically convert encoder values to your mechanism's units (degrees, inches, meters, etc.).<br><br><strong>Position Conversion Factor:</strong><br>- Converts revolutions to your mechanism's position units<br>- Accounts for gear ratios and mechanism geometry<br>- Example: For a 10:1 gear ratio, use 1.0/10.0 to get mechanism rotations<br><br><strong>Velocity Conversion Factor:</strong><br>- Converts RPM to your mechanism's velocity units<br>- Typically matches position conversion factor<br>- Results in units per minute by default<br><br><strong>Resetting Position:</strong> Use <code>setPosition(0)</code> to reset the encoder position to zero. This sets the current position as the new zero reference point."
    },
    {
      "type": "code",
      "title": "Encoder Configuration Example",
      "content": "import com.revrobotics.spark.SparkMax;\nimport com.revrobotics.spark.SparkBase.PersistMode;\nimport com.revrobotics.spark.SparkBase.ResetMode;\nimport com.revrobotics.spark.config.SparkMaxConfig;\nimport com.revrobotics.spark.SparkLowLevel.MotorType;\nimport com.revrobotics.RelativeEncoder;\n\npublic class EncoderConfiguration {\n    private final SparkMax m_motor = new SparkMax(1, MotorType.kBrushless);\n    private final RelativeEncoder m_encoder = m_motor.getEncoder();\n    \n    // Example: 10:1 gear ratio (10 motor rotations = 1 mechanism rotation)\n    private static final double GEAR_RATIO = 10.0;\n    \n    public EncoderConfiguration() {\n        // Configure conversion factors\n        SparkMaxConfig config = new SparkMaxConfig();\n        \n        // Position will now be in mechanism rotations instead of motor rotations\n        config.encoder.positionConversionFactor(1.0 / GEAR_RATIO);\n        \n        // Velocity will now be in mechanism RPM\n        config.encoder.velocityConversionFactor(1.0 / GEAR_RATIO);\n        \n        m_motor.configure(config,\n            ResetMode.kResetSafeParameters,\n            PersistMode.kPersistParameters);\n        \n        // Reset encoder position to zero\n        m_encoder.setPosition(0);\n    }\n    \n    public double getPosition() {\n        return m_encoder.getPosition();  // In mechanism rotations\n    }\n    \n    public double getVelocity() {\n        return m_encoder.getVelocity();  // In mechanism RPM\n    }\n}"
    },
    {
      "type": "text",
      "title": "REV Color Sensor V3",
      "content": "The REV Color Sensor V3 is an advanced color detection sensor that can detect colors, measure proximity, and detect objects. It's useful for game piece detection, line following, and other color-based applications.<br><br><strong>Color Sensor Capabilities:</strong><br>- Color detection (RGB values and color matching)<br>- Proximity sensing (detect objects nearby, 0-2047 range)<br>- IR LED control<br>- I2C communication with roboRIO<br><br><strong>Common Uses:</strong><br>- Game piece detection (identify game piece color)<br>- Object detection (using proximity mode)<br>- Mechanism state detection (detect position by color markers)<br><br>Learn more: <a href='https://docs.revrobotics.com/color-sensor/overview' target='_blank'>Color Sensor V3 Documentation</a>"
    },
    {
      "type": "code",
      "title": "REV Color Sensor V3 Usage",
      "content": "package frc.robot.subsystems;\n\nimport com.revrobotics.ColorSensorV3;\nimport com.revrobotics.ColorMatch;\nimport edu.wpi.first.wpilibj.I2C;\nimport edu.wpi.first.wpilibj.util.Color;\nimport edu.wpi.first.wpilibj.smartdashboard.SmartDashboard;\nimport edu.wpi.first.wpilibj2.command.SubsystemBase;\n\npublic class ColorSensorExample extends SubsystemBase {\n    // Color Sensor V3 uses I2C port on roboRIO\n    private final ColorSensorV3 m_colorSensor = new ColorSensorV3(I2C.Port.kOnboard);\n    \n    // Color matcher for matching detected colors\n    private final ColorMatch m_colorMatcher = new ColorMatch();\n    \n    // Define target colors (example: game piece colors)\n    private final Color kBlueTarget = new Color(0.143, 0.427, 0.429);\n    private final Color kRedTarget = new Color(0.561, 0.232, 0.114);\n    \n    public ColorSensorExample() {\n        // Add target colors to matcher\n        m_colorMatcher.addColorMatch(kBlueTarget);\n        m_colorMatcher.addColorMatch(kRedTarget);\n    }\n    \n    @Override\n    public void periodic() {\n        // Read color values\n        Color detectedColor = m_colorSensor.getColor();\n        \n        // Read proximity (0-2047, higher = closer)\n        int proximity = m_colorSensor.getProximity();\n        \n        // Match detected color to known colors\n        var match = m_colorMatcher.matchClosestColor(detectedColor);\n        \n        SmartDashboard.putNumber(\"Color R\", detectedColor.red);\n        SmartDashboard.putNumber(\"Color G\", detectedColor.green);\n        SmartDashboard.putNumber(\"Color B\", detectedColor.blue);\n        SmartDashboard.putNumber(\"Proximity\", proximity);\n        SmartDashboard.putBoolean(\"Object Detected\", proximity > 150);\n    }\n    \n    public boolean hasGamePiece() {\n        return m_colorSensor.getProximity() > 150;\n    }\n}"
    },
    {
      "type": "text",
      "title": "REV 2m Distance Sensor",
      "content": "The REV 2m Distance Sensor (TimeOfFlight sensor) measures distances up to 2 meters using ultrasonic time-of-flight technology. It's useful for object detection, obstacle avoidance, and mechanism positioning.<br><br><strong>Distance Sensor Capabilities:</strong><br>- Distance measurement (0-2000 mm)<br>- Fast update rate<br>- Reliable performance<br>- I2C communication<br><br><strong>Common Uses:</strong><br>- Object detection (detect game pieces, obstacles)<br>- Mechanism positioning (detect when mechanism reaches position)<br>- Autonomous navigation (obstacle avoidance)<br>- Intake detection (detect when game piece is in intake)<br><br>Learn more: <a href='https://docs.revrobotics.com/sensors/2m-distance-sensor' target='_blank'>Distance Sensor Documentation</a><br><br>I could not for the life of me understand how to code for this sensor, as the REV documentation was difficult to understand and I could not find any examples of how to code for it. Please let me know if you have any examples!"
    },
    {
      "type": "text",
      "title": "Unit Conversions for Encoders",
      "content": "Encoder values are typically in revolutions (NEO) or counts (external encoders), but you often need real-world units like degrees, inches, or meters. Understanding unit conversions is essential for working with encoders.<br><br><strong>Common Conversions:</strong><br>- <strong>Revolutions to Degrees:</strong> revolutions × 360.0<br>- <strong>Revolutions to Radians:</strong> revolutions × 2π<br>- <strong>Revolutions to Linear Distance:</strong> revolutions × circumference<br>- <strong>RPM to Linear Velocity:</strong> (RPM × circumference) / 60.0 = distance per second<br><br><strong>Conversion Factors:</strong> Configure position and velocity conversion factors on the encoder to automatically work in your mechanism's units. This is cleaner than manual conversion in every method."
    },
    {
      "type": "code",
      "title": "Unit Conversion Examples",
      "content": "import com.revrobotics.spark.SparkMax;\nimport com.revrobotics.spark.SparkBase.PersistMode;\nimport com.revrobotics.spark.SparkBase.ResetMode;\nimport com.revrobotics.spark.config.SparkMaxConfig;\nimport com.revrobotics.spark.SparkLowLevel.MotorType;\nimport com.revrobotics.RelativeEncoder;\n\npublic class UnitConversions {\n    private final SparkMax m_motor = new SparkMax(1, MotorType.kBrushless);\n    private final RelativeEncoder m_encoder = m_motor.getEncoder();\n    \n    // Example: Elevator with 4\" diameter spool\n    private static final double SPOOL_DIAMETER_INCHES = 4.0;\n    private static final double SPOOL_CIRCUMFERENCE = SPOOL_DIAMETER_INCHES * Math.PI;\n    private static final double GEAR_RATIO = 10.0;  // 10:1 reduction\n    \n    public UnitConversions() {\n        SparkMaxConfig config = new SparkMaxConfig();\n        \n        // Configure for linear distance in inches\n        // 1 motor rotation = (1/gear_ratio) mechanism rotation = (circumference/gear_ratio) inches\n        double inchesPerMotorRotation = SPOOL_CIRCUMFERENCE / GEAR_RATIO;\n        config.encoder.positionConversionFactor(inchesPerMotorRotation);\n        \n        // Velocity: inches per minute by default with this factor\n        config.encoder.velocityConversionFactor(inchesPerMotorRotation);\n        \n        m_motor.configure(config,\n            ResetMode.kResetSafeParameters,\n            PersistMode.kPersistParameters);\n    }\n    \n    public double getHeightInches() {\n        return m_encoder.getPosition();  // Already in inches\n    }\n    \n    public double getVelocityInchesPerSecond() {\n        return m_encoder.getVelocity() / 60.0;  // Convert inches/min to inches/sec\n    }\n}"
    },
    {
      "type": "text",
      "title": "Sensor-Based Control Integration",
      "content": "REV sensors are typically integrated with motor control and other robot systems for advanced functionality:<br><br><strong>Sensor-Based Control:</strong><br>- Use sensors to trigger motor actions<br>- Detect game pieces and activate mechanisms<br>- Use limit switches for safety<br><br><strong>State Machines:</strong><br>- Use sensors to determine mechanism state<br>- Transition between states based on sensor readings<br>- Implement complex mechanism behaviors<br><br><strong>Example Use Case:</strong> An intake that uses a distance sensor to detect when a game piece enters, then uses a color sensor to identify the piece color, and finally uses a limit switch to detect when the intake is full."
    },
    {
      "type": "code",
      "title": "Sensor-Based Intake Control",
      "content": "package frc.robot.subsystems;\n\nimport com.revrobotics.spark.SparkMax;\nimport com.revrobotics.spark.SparkLowLevel.MotorType;\nimport com.revrobotics.ColorSensorV3;\nimport edu.wpi.first.wpilibj.DigitalInput;\nimport edu.wpi.first.wpilibj.I2C.Port;\nimport edu.wpi.first.wpilibj2.command.SubsystemBase;\n\npublic class IntakeWithSensors extends SubsystemBase {\n    private final SparkMax m_intakeMotor = new SparkMax(5, MotorType.kBrushless);\n    private final ColorSensorV3 m_distanceSensor = new ColorSensorV3(Port.kMXP);\n    private final DigitalInput m_limitSwitch = new DigitalInput(0);\n    \n    private static final double DETECTION_DISTANCE = 150.0;  // Unknown units\n    \n    public void runIntake() {\n        // Check if game piece is detected by distance sensor\n        double distance = m_distanceSensor.getProximity();\n        boolean gamePieceDetected = distance != 0 && \n                                    distance < DETECTION_DISTANCE;\n        \n        // Check if limit switch is pressed (intake full)\n        boolean isFull = !m_limitSwitch.get();  // Inverted: false when pressed\n        \n        if (isFull) {\n            // Stop intake when full\n            m_intakeMotor.set(0.0);\n        } else if (gamePieceDetected) {\n            // Run intake at full speed when game piece detected\n            m_intakeMotor.set(0.75);\n        } else {\n            // Slow intake when searching for game piece\n            m_intakeMotor.set(0.3);\n        }\n    }\n    \n    public void stopIntake() {\n        m_intakeMotor.set(0.0);\n    }\n    \n    public boolean hasGamePiece() {\n        double distance = m_distanceSensor.getProximity();\n        return distance != 0 && distance < DETECTION_DISTANCE;    \n    }\n}"
    },
    {
      "type": "link-grid",
      "title": "Related Topics and Documentation",
      "links": [
        {
          "label": "Motor Controller Configuration",
          "id": "motor-controller-configuration"
        },
        {
          "label": "Motor PID Control",
          "id": "motor-pid-control"
        },
        {
          "label": "SPARK MAX Setup",
          "id": "rev-hardware-setup"
        },
        {
          "label": "Color Sensor API",
          "url": "https://codedocs.revrobotics.com/java/com/revrobotics/colorsensorv3"
        }
      ]
    }
  ]
}