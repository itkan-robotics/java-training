{
  "title": "REV Encoders",
  "sections": [
    {
      "type": "text",
      "title": "Introduction to Encoders",
      "content": "Encoders are sensors that measure position and velocity of rotating mechanisms. They provide feedback for closed-loop control (PID, Smart Motion) and are essential for precise mechanism control. REV hardware supports multiple encoder types, including built-in encoders on NEO motors and external encoders via the SPARK MAX data port.<br><br>Understanding how to use encoders with REV hardware is critical for building mechanisms that require precise positioning or velocity control."
    },
    {
      "type": "text",
      "title": "Encoder Types",
      "content": "REV hardware supports several encoder types, each with different characteristics and use cases:<br><br><strong>NEO Built-in Encoder:</strong><br>- Integrated encoder on NEO brushless motors<br>- 42 counts per revolution<br>- No additional wiring required<br>- Most common choice for NEO motors<br><br><strong>External Encoders via Data Port:</strong><br>- Analog encoders (potentiometers)<br>- Digital encoders (quadrature encoders)<br>- Connected via SPARK MAX data port<br>- Useful when using brushed motors or when higher resolution is needed<br><br><strong>Alternate Encoder:</strong><br>- External encoder via alternate encoder port<br>- Higher resolution options<br>- More advanced configuration"
    },
    {
      "type": "text",
      "title": "NEO Motor Encoders",
      "content": "NEO brushless motors have built-in encoders that provide position and velocity feedback. These encoders are automatically available when using NEO motors with SPARK MAX controllers.<br><br><strong>Built-in Encoder Features:</strong><br>- 42 counts per revolution<br>- Position and velocity measurement<br>- No additional wiring required<br>- Automatic configuration<br><br><strong>Reading NEO Encoder Values:</strong> Use the <code>getEncoder()</code> method on your SPARK MAX to get the encoder object. Then use <code>getPosition()</code> and <code>getVelocity()</code> to read values.<br><br><strong>Encoder Units:</strong> Position is in encoder counts (0 = starting position). Velocity is in encoder counts per second. You may need to convert these to real-world units (degrees, inches, etc.) depending on your mechanism."
    },
    {
      "type": "code",
      "title": "Reading NEO Encoder Values",
      "content": "import com.revrobotics.CANSparkMax;\nimport com.revrobotics.CANSparkLowLevel.MotorType;\nimport com.revrobotics.RelativeEncoder;\nimport edu.wpi.first.wpilibj.smartdashboard.SmartDashboard;\n\npublic class NEOEncoderReading {\n    private final CANSparkMax m_motor = new CANSparkMax(1, MotorType.kBrushless);\n    private final RelativeEncoder m_encoder = m_motor.getEncoder();\n    \n    // Conversion: encoder counts to degrees\n    // NEO encoder: 42 counts per revolution\n    private static final double COUNTS_PER_DEGREE = 42.0 / 360.0;\n    \n    public void updateEncoder() {\n        // Read encoder position (in encoder counts)\n        double position = m_encoder.getPosition();\n        \n        // Read encoder velocity (in encoder counts per second)\n        double velocity = m_encoder.getVelocity();\n        \n        // Convert to degrees\n        double positionDegrees = position / COUNTS_PER_DEGREE;\n        double velocityDegreesPerSecond = velocity / COUNTS_PER_DEGREE;\n        \n        // Update dashboard\n        SmartDashboard.putNumber(\"Encoder Position (counts)\", position);\n        SmartDashboard.putNumber(\"Encoder Position (degrees)\", positionDegrees);\n        SmartDashboard.putNumber(\"Encoder Velocity (counts/s)\", velocity);\n        SmartDashboard.putNumber(\"Encoder Velocity (deg/s)\", velocityDegreesPerSecond);\n    }\n}"
    },
    {
      "type": "text",
      "title": "Resetting Encoder Position",
      "content": "You can reset the encoder position to zero at any time. This is useful when you want to define a new zero position for your mechanism.<br><br><strong>When to Reset:</strong><br>- At robot initialization<br>- When mechanism reaches a known position (e.g., limit switch)<br>- After calibration<br>- When changing mechanism configuration<br><br><strong>Resetting Position:</strong> Use <code>setPosition(0)</code> to reset the encoder position to zero. This sets the current position as the new zero reference point."
    },
    {
      "type": "code",
      "title": "Encoder Reset Code Example",
      "content": "import com.revrobotics.CANSparkMax;\nimport com.revrobotics.CANSparkLowLevel.MotorType;\nimport com.revrobotics.RelativeEncoder;\n\npublic class EncoderReset {\n    private final CANSparkMax m_motor = new CANSparkMax(1, MotorType.kBrushless);\n    private final RelativeEncoder m_encoder = m_motor.getEncoder();\n    \n    public void resetEncoder() {\n        // Reset encoder position to zero\n        m_encoder.setPosition(0);\n        \n        // Now current position is considered zero\n        // All future position readings will be relative to this point\n    }\n    \n    public void resetToValue(double value) {\n        // Reset encoder to a specific value\n        // Useful if you want zero to be at a different position\n        m_encoder.setPosition(value);\n    }\n}"
    },
    {
      "type": "text",
      "title": "External Encoders",
      "content": "SPARK MAX supports external encoders connected via the data port. External encoders are useful when using brushed motors or when you need higher resolution than the NEO built-in encoder.<br><br><strong>External Encoder Types:</strong><br>- <strong>Analog Encoders:</strong> Potentiometers or analog position sensors<br>- <strong>Digital Encoders:</strong> Quadrature encoders (incremental encoders)<br>- <strong>Alternate Encoders:</strong> Higher resolution encoders via alternate encoder port<br><br><strong>Wiring:</strong> External encoders connect to the SPARK MAX data port using a data port breakout board. Follow REV documentation for proper wiring connections.<br><br><strong>Configuration:</strong> External encoders must be configured in code to specify encoder type and parameters."
    },
    {
      "type": "code",
      "title": "External Encoder Configuration",
      "content": "import com.revrobotics.CANSparkMax;\nimport com.revrobotics.CANSparkLowLevel.MotorType;\nimport com.revrobotics.SparkMaxAlternateEncoder;\nimport com.revrobotics.RelativeEncoder;\n\npublic class ExternalEncoderConfig {\n    private final CANSparkMax m_motor = new CANSparkMax(1, MotorType.kBrushed);\n    \n    // Configure alternate encoder (external encoder via data port)\n    // Type: kQuadrature for quadrature encoder\n    // Counts per revolution depends on encoder\n    private final SparkMaxAlternateEncoder.Type m_encoderType = SparkMaxAlternateEncoder.Type.kQuadrature;\n    private final int m_countsPerRevolution = 4096;  // Example: 4096 counts per revolution\n    \n    // Get alternate encoder\n    private final RelativeEncoder m_alternateEncoder = m_motor.getAlternateEncoder(m_encoderType, m_countsPerRevolution);\n    \n    public ExternalEncoderConfig() {\n        // Configure encoder conversion factors (if needed)\n        // For example, if gear ratio is 10:1\n        m_alternateEncoder.setPositionConversionFactor(1.0 / 10.0);\n        m_alternateEncoder.setVelocityConversionFactor(1.0 / 10.0);\n        \n        // Reset encoder position\n        m_alternateEncoder.setPosition(0);\n    }\n    \n    public double getPosition() {\n        return m_alternateEncoder.getPosition();\n    }\n    \n    public double getVelocity() {\n        return m_alternateEncoder.getVelocity();\n    }\n}"
    },
    {
      "type": "text",
      "title": "Reading Encoder Values",
      "content": "Reading encoder values is straightforward once the encoder is configured. You can read position and velocity at any time in your code.<br><br><strong>Position Reading:</strong><br>- Returns current position in encoder counts<br>- Value is relative to last reset position<br>- Can be converted to real-world units (degrees, inches, etc.)<br><br><strong>Velocity Reading:</strong><br>- Returns current velocity in encoder counts per second<br>- Positive = forward, negative = reverse<br>- Can be converted to real-world units (degrees per second, RPM, etc.)<br><br><strong>Reading Frequency:</strong> You can read encoder values as frequently as needed. The encoder updates continuously, so reading in <code>periodic()</code> methods is typical."
    },
    {
      "type": "code",
      "title": "Reading Encoder Position and Velocity",
      "content": "import com.revrobotics.CANSparkMax;\nimport com.revrobotics.CANSparkLowLevel.MotorType;\nimport com.revrobotics.RelativeEncoder;\nimport edu.wpi.first.wpilibj.smartdashboard.SmartDashboard;\nimport edu.wpi.first.wpilibj2.command.SubsystemBase;\n\npublic class EncoderReading extends SubsystemBase {\n    private final CANSparkMax m_motor = new CANSparkMax(1, MotorType.kBrushless);\n    private final RelativeEncoder m_encoder = m_motor.getEncoder();\n    \n    // Conversion factors\n    private static final double COUNTS_PER_REVOLUTION = 42.0;  // NEO encoder\n    private static final double COUNTS_PER_DEGREE = COUNTS_PER_REVOLUTION / 360.0;\n    \n    @Override\n    public void periodic() {\n        // Read position (encoder counts)\n        double positionCounts = m_encoder.getPosition();\n        \n        // Read velocity (encoder counts per second)\n        double velocityCountsPerSecond = m_encoder.getVelocity();\n        \n        // Convert to degrees\n        double positionDegrees = positionCounts / COUNTS_PER_DEGREE;\n        double velocityDegreesPerSecond = velocityCountsPerSecond / COUNTS_PER_DEGREE;\n        \n        // Convert velocity to RPM\n        double velocityRPM = (velocityCountsPerSecond / COUNTS_PER_REVOLUTION) * 60.0;\n        \n        // Update dashboard\n        SmartDashboard.putNumber(\"Position (counts)\", positionCounts);\n        SmartDashboard.putNumber(\"Position (degrees)\", positionDegrees);\n        SmartDashboard.putNumber(\"Velocity (counts/s)\", velocityCountsPerSecond);\n        SmartDashboard.putNumber(\"Velocity (deg/s)\", velocityDegreesPerSecond);\n        SmartDashboard.putNumber(\"Velocity (RPM)\", velocityRPM);\n    }\n}"
    },
    {
      "type": "text",
      "title": "Unit Conversions",
      "content": "Encoder values are typically in encoder counts, but you often need real-world units like degrees, inches, or rotations. Understanding unit conversions is essential for working with encoders.<br><br><strong>Common Conversions:</strong><br>- <strong>Counts to Degrees:</strong> counts / (counts_per_revolution / 360.0)<br>- <strong>Counts to Rotations:</strong> counts / counts_per_revolution<br>- <strong>Counts to Inches:</strong> (counts / counts_per_revolution) * circumference<br>- <strong>Velocity to RPM:</strong> (counts_per_second / counts_per_revolution) * 60.0<br><br><strong>Conversion Factors:</strong> You can set conversion factors on the encoder to automatically convert values. This is useful when you want encoder readings in real-world units directly.<br><br><strong>Best Practice:</strong> Create conversion constants and helper methods to make conversions clear and consistent throughout your code."
    },
    {
      "type": "code",
      "title": "Unit Conversion Examples",
      "content": "import com.revrobotics.CANSparkMax;\nimport com.revrobotics.CANSparkLowLevel.MotorType;\nimport com.revrobotics.RelativeEncoder;\n\npublic class UnitConversions {\n    private final CANSparkMax m_motor = new CANSparkMax(1, MotorType.kBrushless);\n    private final RelativeEncoder m_encoder = m_motor.getEncoder();\n    \n    // Conversion constants (NEO encoder: 42 counts per revolution)\n    private static final double COUNTS_PER_REVOLUTION = 42.0;\n    private static final double COUNTS_PER_DEGREE = COUNTS_PER_REVOLUTION / 360.0;\n    \n    // For linear mechanism (example: 4 inch diameter spool)\n    private static final double SPOOL_CIRCUMFERENCE = 4.0 * Math.PI;  // inches\n    private static final double COUNTS_PER_INCH = COUNTS_PER_REVOLUTION / SPOOL_CIRCUMFERENCE;\n    \n    public double getAngleDegrees() {\n        double position = m_encoder.getPosition();  // In encoder counts\n        return position / COUNTS_PER_DEGREE;\n    }\n    \n    public double getAngleRadians() {\n        double position = m_encoder.getPosition();  // In encoder counts\n        double rotations = position / COUNTS_PER_REVOLUTION;\n        return rotations * 2.0 * Math.PI;\n    }\n    \n    public double getLinearPosition() {\n        double position = m_encoder.getPosition();  // In encoder counts\n        return position / COUNTS_PER_INCH;\n    }\n    \n    public double getVelocityRPM() {\n        double velocity = m_encoder.getVelocity();  // In encoder counts per second\n        return (velocity / COUNTS_PER_REVOLUTION) * 60.0;\n    }\n}"
    },
    {
      "type": "text",
      "title": "Encoder Configuration",
      "content": "Encoders can be configured with various settings to match your mechanism's needs:<br><br><strong>Position Conversion Factor:</strong><br>- Converts encoder counts to real-world units<br>- Set based on gear ratio and mechanism geometry<br>- Example: If gear ratio is 10:1, set factor to 1.0/10.0<br><br><strong>Velocity Conversion Factor:</strong><br>- Converts encoder velocity to real-world units<br>- Typically matches position conversion factor<br>- Example: Same as position factor for consistency<br><br><strong>Sensor Phase:</strong><br>- Inverts encoder direction if needed<br>- Set to match motor direction<br>- Useful if encoder reads backwards<br><br><strong>Average Depth:</strong><br>- Number of samples to average for velocity<br>- Higher = smoother but slower response<br>- Lower = faster but noisier<br><br><strong>Measurement Period:</strong><br>- Time period for velocity measurement<br>- Affects velocity update rate<br>- Default is usually fine"
    },
    {
      "type": "code",
      "title": "Encoder Configuration Example",
      "content": "import com.revrobotics.CANSparkMax;\nimport com.revrobotics.CANSparkLowLevel.MotorType;\nimport com.revrobotics.RelativeEncoder;\n\npublic class EncoderConfiguration {\n    private final CANSparkMax m_motor = new CANSparkMax(1, MotorType.kBrushless);\n    private final RelativeEncoder m_encoder = m_motor.getEncoder();\n    \n    // Gear ratio: 10:1 (motor rotates 10 times for 1 mechanism rotation)\n    private static final double GEAR_RATIO = 10.0;\n    \n    public EncoderConfiguration() {\n        // Set position conversion factor\n        // Position will now be in mechanism rotations instead of motor rotations\n        m_encoder.setPositionConversionFactor(1.0 / GEAR_RATIO);\n        \n        // Set velocity conversion factor\n        // Velocity will now be in mechanism rotations per second\n        m_encoder.setVelocityConversionFactor(1.0 / GEAR_RATIO);\n        \n        // Set average depth for velocity (number of samples to average)\n        // Higher = smoother but slower response\n        m_encoder.setAverageDepth(4);\n        \n        // Set measurement period for velocity (milliseconds)\n        // Lower = faster updates but may be noisier\n        m_encoder.setMeasurementPeriod(10);\n        \n        // Reset encoder position\n        m_encoder.setPosition(0);\n    }\n}"
    },
    {
      "type": "link-grid",
      "title": "Related Topics",
      "links": [
        {
		  "label": "SPARK MAX PID Control", 
		  "url": "spark-max-pid-control"},
        {
		  "label": "SPARK MAX Configuration", 
		  "url": "spark-max-configuration"},
        {
		  "label": "SPARK MAX Setup", 
		  "url": "spark-max-setup"}
      ]
    }
  ]
}

