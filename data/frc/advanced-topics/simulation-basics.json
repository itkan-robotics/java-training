{
  "title": "Simulation Basics for FRC Robots",
  "sections": [
    {
      "type": "text",
      "title": "What is Robot Simulation?",
      "content": "Robot simulation allows you to test and run your robot code in a virtual environment without physical hardware. WPILib provides a simulation framework that models robot behavior, enabling you to develop, test, and debug code without access to the actual robot. Simulation is an essential tool for FRC teams, especially when hardware isn't available or when you want to test code changes quickly.<br><br>Simulation models robot components including motors, sensors, and mechanisms. You can run your actual robot code in simulation, seeing how it behaves with simulated hardware. This enables rapid iteration, testing autonomous routines, and debugging issues without the constraints of physical hardware availability.<br><br>While simulation can't perfectly replicate real hardware behavior, good simulations are valuable for development and testing. They catch many issues early and allow you to validate code logic before deploying to hardware. Simulation is particularly useful for testing autonomous routines, validating control systems, and training drivers.<br><br>Learn more: <a href='https://docs.wpilib.org/en/stable/docs/software/wpilib-tools/robot-simulation/introduction.html' target='_blank'>WPILib: Introduction to Robot Simulation</a>"
    },
    {
      "type": "text",
      "title": "Why Use Simulation?",
      "content": "Simulation offers several benefits for FRC teams:<br><br><strong>Hardware Availability:</strong> Test code when physical hardware isn't available. This is especially valuable during off-season development, when robots are being built, or when hardware is at competition. Simulation enables continuous development regardless of hardware access.<br><br><strong>Rapid Iteration:</strong> Test code changes quickly without deploying to hardware. Simulation runs faster than physical testing and doesn't require robot setup. This enables rapid development cycles and quick validation of changes.<br><br><strong>Safe Testing:</strong> Test potentially dangerous code safely. Try new autonomous routines, test edge cases, or experiment with control systems without risk to hardware. Simulation provides a safe environment for exploration and learning.<br><br><strong>Autonomous Development:</strong> Develop and test autonomous routines extensively. Run autonomous code repeatedly, test different scenarios, and validate path following without physical constraints. Simulation is invaluable for autonomous development.<br><br><strong>Debugging:</strong> Debug code issues in a controlled environment. Simulation provides consistent, repeatable conditions that make debugging easier. You can pause, step through code, and inspect state more easily than with physical hardware.<br><br><strong>Training:</strong> Train drivers and operators using simulation. Practice driving, test operator interfaces, and familiarize team members with robot behavior without hardware wear or risk."
    },
    {
      "type": "text",
      "title": "WPILib Simulation Framework Overview",
      "content": "WPILib provides a comprehensive simulation framework built into the standard WPILib installation:<br><br><strong>Simulation Classes:</strong> WPILib includes simulation classes for common robot components. These include motor simulators (<code>DCMotorSim</code>, <code>FlywheelSim</code>), mechanism simulators (<code>SingleJointedArmSim</code>, <code>ElevatorSim</code>), and sensor simulators. These classes model physical behavior realistically.<br><br><strong>Physics Engine:</strong> WPILib's simulation uses physics-based modeling. Motors are modeled with realistic dynamics, mechanisms follow physics laws, and sensors provide simulated readings based on physical models. This provides more accurate simulation than simple mathematical models.<br><br><strong>Integration:</strong> Simulation integrates seamlessly with standard WPILib code. You can run the same robot code in simulation and on hardware with minimal changes. Simulation classes provide the same interfaces as real hardware, making integration straightforward.<br><br><strong>Visualization:</strong> WPILib provides basic visualization through Field2d, which shows robot position on a 2D field representation. More advanced visualization is available through third-party tools or custom implementations.<br><br>WPILib's simulation framework is powerful and sufficient for many teams' needs. It provides a solid foundation for robot simulation without requiring external tools or complex setup."
    },
    {
      "type": "text",
      "title": "Setting Up Basic Simulation",
      "content": "Setting up simulation in your WPILib project involves several steps:<br><br><strong>Project Configuration:</strong> WPILib projects are configured for simulation by default. No special project setup is required - simulation capabilities are built into standard WPILib projects. Ensure your project uses a recent WPILib version with simulation support.<br><br><strong>Simulation Classes:</strong> Create simulation classes for your robot's components. For each motor, sensor, or mechanism, create a corresponding simulation class. Use WPILib's simulation classes (like <code>DCMotorSim</code> for motors) or create custom simulations for complex mechanisms.<br><br><strong>Robot Code Structure:</strong> Structure your robot code to support both simulation and real hardware. Use conditional logic to create simulated components when in simulation mode and real hardware when on the robot. WPILib provides <code>RobotBase.isSimulation()</code> to detect simulation mode.<br><br><strong>Simulation Updates:</strong> Update simulation models in <code>simulationPeriodic()</code> method. This method is called every simulation cycle (typically matching the robot loop rate of 20ms). Update physics models, sensor readings, and mechanism states in this method.<br><br>Refer to WPILib simulation documentation for detailed setup instructions. The setup process is straightforward but requires understanding your robot's components and how to model them.<br><br>Learn more: <a href='https://docs.wpilib.org/en/stable/docs/software/wpilib-tools/robot-simulation/introduction.html' target='_blank'>WPILib Simulation Setup</a>"
    },
    {
      "type": "code",
      "title": "Basic Simulation Setup Example",
      "content": "package frc.robot;\n\nimport edu.wpi.first.wpilibj.TimedRobot;\nimport edu.wpi.first.wpilibj.simulation.DifferentialDrivetrainSim;\nimport edu.wpi.first.math.system.plant.LinearSystemId;\nimport edu.wpi.first.math.system.plant.DCMotor;\nimport frc.robot.subsystems.Drivetrain;\n\npublic class Robot extends TimedRobot {\n    private Drivetrain m_drivetrain;\n    private DifferentialDrivetrainSim m_drivetrainSim;\n    \n    @Override\n    public void robotInit() {\n        m_drivetrain = new Drivetrain();\n        \n        if (RobotBase.isSimulation()) {\n            m_drivetrainSim = new DifferentialDrivetrainSim(\n                LinearSystemId.identifyDrivetrainSystem(\n                    1.98,  // kv (volts per meter per second)\n                    0.2,   // ka (volts per meter per second squared)\n                    1.5,   // kvAngular\n                    0.3    // kaAngular\n                ),\n                DCMotor.getFalcon500(2),  // 2 motors per side\n                10.71,  // gear ratio\n                0.0762,  // wheel radius in meters\n                0.546,   // track width in meters\n                null     // noise (optional)\n            );\n        }\n    }\n    \n    @Override\n    public void simulationPeriodic() {\n        if (m_drivetrainSim != null) {\n            m_drivetrainSim.setInputs(\n                m_drivetrain.getLeftVoltage(),\n                m_drivetrain.getRightVoltage()\n            );\n            \n            m_drivetrainSim.update(0.02);\n            \n            m_drivetrain.setSimulatedEncoderPositions(\n                m_drivetrainSim.getLeftPositionMeters(),\n                m_drivetrainSim.getRightPositionMeters()\n            );\n            \n            m_drivetrain.setSimulatedGyroAngle(\n                m_drivetrainSim.getHeading().getDegrees()\n            );\n        }\n    }\n}"
    },
    {
      "type": "text",
      "title": "Simulating Motors",
      "content": "Motor simulation is fundamental to robot simulation. WPILib provides several motor simulation classes:<br><br><strong>DCMotorSim:</strong> Simulates DC motors with realistic dynamics. Models motor characteristics including voltage, current, and torque. Use for simple motor applications or as building blocks for more complex simulations.<br><br><strong>DifferentialDrivetrainSim:</strong> Simulates differential (tank) drivetrains. Models left and right motor groups, wheel dynamics, and drivetrain physics. Provides realistic drivetrain behavior including acceleration, turning, and wheel slip.<br><br><strong>FlywheelSim:</strong> Simulates flywheel mechanisms. Models rotational inertia and motor dynamics. Useful for simulating shooter flywheels, intake rollers, or other rotating mechanisms.<br><br><strong>Motor Parameters:</strong> Configure simulation with realistic motor parameters. These include motor characteristics (like Falcon 500 or NEO), gear ratios, wheel sizes, and mechanism properties. Accurate parameters produce more realistic simulation behavior.<br><br><strong>Integration:</strong> Connect simulated motors to your robot code. Simulated motors should provide the same interface as real motors (encoder readings, current measurements, etc.) so your robot code works unchanged. Update simulation models based on actual motor commands from your code."
    },
    {
      "type": "code",
      "title": "Motor Simulation Example",
      "content": "package frc.robot.subsystems;\n\nimport edu.wpi.first.wpilibj.motorcontrol.PWMSparkMax;\nimport edu.wpi.first.wpilibj.Encoder;\nimport edu.wpi.first.wpilibj.simulation.FlywheelSim;\nimport edu.wpi.first.math.system.plant.LinearSystemId;\nimport edu.wpi.first.math.system.plant.DCMotor;\nimport edu.wpi.first.wpilibj.RobotBase;\n\npublic class Shooter extends SubsystemBase {\n    private final PWMSparkMax m_motor = new PWMSparkMax(5);\n    private final Encoder m_encoder = new Encoder(0, 1);\n    \n    // Simulation\n    private FlywheelSim m_flywheelSim;\n    \n    public Shooter() {\n        if (RobotBase.isSimulation()) {\n            // Parameters: moment of inertia, motor type, gear ratio\n            m_flywheelSim = new FlywheelSim(\n                LinearSystemId.createFlywheelSystem(\n                    DCMotor.getNEO(1),  // 1 NEO motor\n                    0.003,  // moment of inertia (kg*m^2)\n                    1.0     // gear ratio\n                )\n            );\n        }\n    }\n    \n    public void setSpeed(double speed) {\n        m_motor.set(speed);\n    }\n    \n    public double getVelocity() {\n        return m_encoder.getRate();\n    }\n    \n    @Override\n    public void simulationPeriodic() {\n        if (m_flywheelSim != null) {\n            m_flywheelSim.setInput(m_motor.get() * 12.0);  // Convert to volts\n            m_flywheelSim.update(0.02);  // 20ms update\n            \n            m_encoder.setRate(m_flywheelSim.getAngularVelocityRadPerSec());\n        }\n    }\n}"
    },
    {
      "type": "text",
      "title": "Simulating Sensors",
      "content": "Sensor simulation provides realistic sensor readings based on simulated robot state:<br><br><strong>Encoder Simulation:</strong> Simulate encoders by reading positions and velocities from simulation models. Motor simulations provide position and velocity data that can be used to simulate encoder readings. Convert simulation units (meters, radians) to encoder units (counts, rotations) as needed.<br><br><strong>Gyro Simulation:</strong> Simulate gyroscopes using heading information from drivetrain simulations. Differential drivetrain simulations provide heading that can be used for gyro simulation. For more complex drivetrains, calculate heading from simulated robot pose.<br><br><strong>Limit Switch Simulation:</strong> Simulate limit switches based on mechanism positions. Check if simulated mechanism positions exceed limits and set switch states accordingly. This enables testing limit switch logic in simulation.<br><br><strong>Vision Simulation:</strong> Simulating vision is more complex but possible. Use field geometry and robot pose to simulate camera observations. This is advanced and may require custom implementation or third-party tools.<br><br><strong>Sensor Integration:</strong> Connect simulated sensors to your robot code. Simulated sensors should provide the same interface as real sensors so code works unchanged. Update sensor readings in <code>simulationPeriodic()</code> based on simulation state."
    },
    {
      "type": "text",
      "title": "Running Simulation",
      "content": "Running simulation in WPILib is straightforward:<br><br><strong>Simulation Mode:</strong> WPILib automatically detects simulation mode when running in the development environment (not on robot hardware). No special configuration is needed - just run your robot code normally, and WPILib will use simulation if appropriate.<br><br><strong>Deploying to Simulation:</strong> Deploy code to simulation the same way you deploy to hardware. Use the WPILib deploy button or command, and WPILib will detect simulation mode and run accordingly. Simulation runs on your development computer, not on robot hardware.<br><br><strong>Driver Station:</strong> Use Driver Station with simulation just like with real hardware. Driver Station connects to the simulated robot and provides the same interface. You can control the robot, view telemetry, and operate it normally.<br><br><strong>Visualization:</strong> View simulation through WPILib's Field2d visualization or custom visualizations. Field2d shows robot position on a 2D field representation. More advanced visualization may require additional setup or tools.<br><br><strong>Debugging:</strong> Debug simulation code like any other code. Set breakpoints, inspect variables, and step through code. Simulation provides a controlled environment that makes debugging easier than with physical hardware."
    },
    {
      "type": "text",
      "title": "Basic Visualization",
      "content": "Visualization helps you understand what's happening in simulation:<br><br><strong>Field2d:</strong> WPILib's Field2d class provides 2D field visualization. Display robot pose, trajectories, and field elements on a 2D representation. Field2d is simple to use and provides basic visualization needs.<br><br><strong>Robot Representation:</strong> Show robot position and orientation on the field. Update robot pose in Field2d based on simulation state. This helps visualize robot movement and validate autonomous routines.<br><br><strong>Trajectory Visualization:</strong> Display planned paths and trajectories on the field. Show where the robot should go and compare with actual movement. This is valuable for autonomous development and debugging.<br><br><strong>Custom Visualization:</strong> Create custom visualizations for specific needs. Display mechanism states, sensor readings, or other information visually. Custom visualization requires more work but provides tailored views.<br><br><strong>SmartDashboard Integration:</strong> Display simulation data in SmartDashboard or Shuffleboard. Show robot pose, sensor readings, and simulation state. This provides real-time feedback during simulation."
    },
    {
      "type": "code",
      "title": "Basic Field Visualization",
      "content": "package frc.robot.subsystems;\n\nimport edu.wpi.first.math.geometry.Pose2d;\nimport edu.wpi.first.wpilibj.smartdashboard.Field2d;\nimport edu.wpi.first.wpilibj.smartdashboard.SmartDashboard;\nimport edu.wpi.first.wpilibj2.command.SubsystemBase;\n\npublic class Drivetrain extends SubsystemBase {\n    private final Field2d m_field = new Field2d();\n    private Pose2d m_robotPose = new Pose2d();\n    \n    public Drivetrain() {\n        // Add field to SmartDashboard\n        SmartDashboard.putData(\"Field\", m_field);\n    }\n    \n    public void setPose(Pose2d pose) {\n        m_robotPose = pose;\n        m_field.setRobotPose(pose);\n    }\n    \n    public Pose2d getPose() {\n        return m_robotPose;\n    }\n    \n    @Override\n    public void periodic() {\n        m_field.setRobotPose(m_robotPose);\n    }\n    \n    public void addTrajectory(String name, Trajectory trajectory) {\n        m_field.getObject(name).setTrajectory(trajectory);\n    }\n}\n\n// In simulation, update pose from simulation:\n@Override\npublic void simulationPeriodic() {\n    if (m_drivetrainSim != null) {\n        Pose2d simPose = m_drivetrainSim.getPose();\n        \n        m_drivetrain.setPose(simPose);\n    }\n}"
    },
    {
      "type": "text",
      "title": "Testing Autonomous Routines",
      "content": "Simulation is particularly valuable for testing autonomous routines:<br><br><strong>Repeated Testing:</strong> Run autonomous routines repeatedly without physical constraints. Test different scenarios, validate path following, and verify mechanism operations. Simulation enables extensive autonomous testing that would be time-consuming with hardware.<br><br><strong>Path Validation:</strong> Validate path following in simulation. See how well the robot follows planned paths, identify issues with path generation or following, and tune path following parameters. Simulation provides immediate feedback on path following performance.<br><br><strong>Scenario Testing:</strong> Test autonomous routines in different scenarios. Try different starting positions, test edge cases, and validate behavior under various conditions. Simulation makes it easy to test scenarios that might be difficult to set up with hardware.<br><br><strong>Mechanism Coordination:</strong> Test how mechanisms coordinate during autonomous routines. Verify that mechanisms operate correctly together, that timing is appropriate, and that sequences execute as expected. Simulation helps identify coordination issues.<br><br><strong>Performance Analysis:</strong> Analyze autonomous routine performance in simulation. Measure execution times, validate that routines complete within time limits, and identify optimization opportunities. Simulation provides detailed performance data."
    },
    {
      "type": "text",
      "title": "Common Simulation Patterns",
      "content": "Several common patterns emerge when using simulation:<br><br><strong>Conditional Component Creation:</strong> Create simulated components only in simulation mode. Use <code>RobotBase.isSimulation()</code> to conditionally create simulation objects. This keeps simulation code separate from production code.<br><br><strong>Simulation Update Method:</strong> Update all simulation models in <code>simulationPeriodic()</code>. This centralizes simulation updates and ensures consistent timing. Update physics models, sensor readings, and visualization in this method.<br><br><strong>Parameter Configuration:</strong> Store simulation parameters (motor characteristics, gear ratios, etc.) in constants or configuration. This makes it easy to tune simulation to match real hardware. Consider making parameters easily adjustable for tuning.<br><br><strong>Realistic Modeling:</strong> Model robot components realistically. Use accurate motor characteristics, gear ratios, and mechanism properties. Realistic models produce more useful simulation results. Tune simulation parameters to match real hardware behavior.<br><br>These patterns help create effective simulations that provide value for development and testing."
    },
    {
      "type": "text",
      "title": "Limitations and Considerations",
      "content": "Understanding simulation limitations is important for effective use:<br><br><strong>Model Accuracy:</strong> Simulations are models and may not perfectly match real hardware. Motor characteristics, friction, and other factors may differ between simulation and reality. Always validate simulation results with real hardware testing.<br><br><strong>Simplified Physics:</strong> Simulation physics may be simplified compared to real-world complexity. Some effects (like wheel slip, mechanism flex, or environmental factors) may not be fully modeled. Be aware of these limitations when interpreting results.<br><br><strong>Sensor Limitations:</strong> Simulated sensors may not capture all real sensor behaviors. Noise, latency, and other sensor characteristics may differ. Consider these differences when testing sensor-dependent code.<br><br><strong>Hardware-Specific Behavior:</strong> Some hardware-specific behaviors may not be simulated. Vendor-specific features, CAN bus timing, or other hardware details may differ. Test hardware-specific code on real hardware.<br><br><strong>Use Appropriately:</strong> Use simulation for development and testing, but always validate with real hardware. Simulation is a tool, not a replacement for hardware testing. Balance simulation and hardware testing appropriately."
    },
    {
      "type": "text",
      "title": "Next Steps",
      "content": "After mastering basic simulation, you can explore advanced topics:<br><br><strong>Advanced Simulation:</strong> Learn about advanced simulation features including complex mechanism modeling, physics-based simulation, and integration with external tools. The Advanced Simulation lesson covers these topics in detail.<br><br><strong>Simulation Tuning:</strong> Tune simulation parameters to better match real hardware. Measure real hardware behavior and adjust simulation models accordingly. Accurate simulation provides more value.<br><br><strong>Custom Models:</strong> Create custom simulation models for complex mechanisms. Learn to model mechanisms that don't have built-in simulation classes. Custom models enable simulation of any robot component.<br><br><strong>Integration:</strong> Integrate simulation with other tools like AdvantageKit, PathPlanner, or custom visualization. Integration enhances simulation capabilities and provides more comprehensive development tools."
    },
    {
      "type": "rules-box",
      "title": "Best Practices",
      "subtitle": "Tips for effective simulation usage:",
      "items": [
        "Model robot components realistically",
        "Update simulation in simulationPeriodic()",
        "Use conditional logic for simulation code",
        "Test autonomous routines extensively",
        "Validate simulation results with hardware",
        "Keep simulation parameters configurable",
        "Use visualization to understand behavior",
        "Refer to WPILib documentation for latest features"
      ]
    },
    {
      "type": "link-grid",
      "title": "Related Topics and Documentation",
      "links": [
        {
          "label": "WPILib Simulation Introduction",
          "url": "https://docs.wpilib.org/en/stable/docs/software/wpilib-tools/robot-simulation/introduction.html"
        },
        {
          "label": "Command-Based Programming",
          "id": "command-based-intro"
        },
        {
          "label": "Pose Estimation",
          "id": "pose-estimation-intro"
        }
      ]
    }
  ]
}