{
  "title": "Professional Code Organization",
  "sections": [
    {
      "type": "text",
      "title": "Structuring a Command-Based Project",
      "content": "A well-organized FRC project is easier to maintain, debug, and teach to new members. The standard structure for a Command-Based robot separates concerns into Subsystems, Commands, and the Robot container.<br><br><strong>Subsystems:</strong> Represent physical parts of the robot (Drivetrain, Arm, Intake). They handle low-level hardware control (motors, sensors) and expose high-level methods (\"setVoltage\", \"moveToAngle\").<br><br><strong>Commands:</strong> Represent actions or behaviors (\"DriveWithJoystick\", \"ScoreGamePiece\"). They use subsystem methods to perform tasks over time.<br><br><strong>RobotContainer:</strong> The \"glue\" class. It initializes subsystems, defines button bindings, and sets up autonomous routines. It replaces the logic typically found in \"Robot.java\".<br><br>Learn more: <a href='https://docs.wpilib.org/en/stable/docs/software/commandbased/structuring-command-based-project.html' target='_blank'>WPILib: Structuring a Command-Based Project</a>"
    },
    {
      "type": "text",
      "title": "Recommended Directory Structure",
      "content": "Follow this standard directory layout for clarity:"
    },
    {
      "type": "code",
      "title": "Project Structure",
      "content": "src/main/java/frc/robot/\n├── Main.java                // Entry point (do not edit)\n├── Robot.java               // Lifecycle management (periodic, init)\n├── RobotContainer.java      // Dependency injection, button bindings, auto chooser\n├── Constants.java           // Robot-wide constants (CAN IDs, PID gains)\n├── subsystems/              // Folder for Subsystems\n│   ├── Drivetrain.java\n│   ├── Intake.java\n│   └── Arm.java\n├── commands/                // Folder for Commands\n│   ├── autos/               // Autonomous command groups\n│   │   ├── TwoPieceAuto.java\n│   │   └── BalanceAuto.java\n│   ├── DriveCommand.java    // Teleop drive command\n│   └── IntakeCommand.java\n└── util/                    // Utilities, math helpers, drivers"
    },
    {
      "type": "text",
      "title": "Constants Management",
      "content": "Avoid \"magic numbers\" in your code. Use a \"Constants\" class to store all configuration values. This makes tuning easier (change in one place) and improves readability.<br><br>Organize \"Constants\" using nested classes for each subsystem."
    },
    {
      "type": "code",
      "title": "Organized Constants Class",
      "content": "public final class Constants {\n    public static final class OperatorConstants {\n        public static final int kDriverControllerPort = 0;\n    }\n\n    public static final class DrivetrainConstants {\n        public static final int kLeftMotorID = 1;\n        public static final int kRightMotorID = 2;\n        public static final double kMaxSpeedMetersPerSecond = 4.5;\n    }\n\n    public static final class ArmConstants {\n        public static final int kMotorID = 5;\n        public static final double kP = 0.1;\n        public static final double kI = 0.0;\n        public static final double kD = 0.0;\n    }\n}"
    },
    {
      "type": "text",
      "title": "RobotContainer Best Practices",
      "content": "The \"RobotContainer\" is where you wire everything together. It should:<br><br>1. Instantiate all subsystems as \"private final\" fields.<br>2. Define \"Command\" objects for default behaviors (e.g., default drive).<br>3. Configure button bindings using \"Trigger\" and \"JoystickButton\".<br>4. Setup the \"SendableChooser\" for selecting autonomous routines.<br><br>It should <strong>NOT</strong> contain loop logic or hardware initialization details (that belongs in subsystems)."
    },
    {
      "type": "code",
      "title": "RobotContainer Example",
      "content": "public class RobotContainer {\n    private final Drivetrain m_drivetrain = new Drivetrain();\n    private final Intake m_intake = new Intake();\n    private final CommandXboxController m_driver = new CommandXboxController(0);\n\n    public RobotContainer() {\n        configureBindings();\n        \n        // Set default command for driving\n        m_drivetrain.setDefaultCommand(\n            new RunCommand(\n                () -> m_drivetrain.arcadeDrive(m_driver.getLeftY(), m_driver.getRightX()),\n                m_drivetrain\n            )\n        );\n    }\n\n    private void configureBindings() {\n        // Simple bindings using Triggers (2023+ style)\n        m_driver.a().whileTrue(new RunIntake(m_intake));\n        m_driver.b().onTrue(Commands.runOnce(m_intake::stop, m_intake));\n    }\n\n    public Command getAutonomousCommand() {\n        return new Autos.ExampleAuto(m_drivetrain);\n    }\n}"
    },
    {
      "type": "rules-box",
      "title": "Code Organization Rules",
      "subtitle": "Keep your code clean:",
      "items": [
        "One class per file.",
        "Subsystems handle 'how' (hardware), Commands handle 'when' (logic).",
        "Use dependency injection: pass subsystems into commands via constructors.",
        "Avoid static subsystem instances (Singleton pattern is okay, but DI is better for testing).",
        "Group related commands into subfolders (e.g., 'commands/auto', 'commands/teleop').",
        "Name variables descriptively (e.g., 'm_frontLeftMotor' instead of 'motor1')."
      ]
    },
    {
      "type": "link-grid",
      "title": "Related Topics",
      "links": [
        {
          "label": "Command-Based Programming",
          "id": "command-based-intro"
        },
        {
          "label": "Unit Testing",
          "id": "unit-testing"
        },
        {
          "label": "WPILib Style Guide",
          "url": "https://docs.wpilib.org/en/stable/docs/software/basic-programming/java-style-guide.html"
        }
      ]
    }
  ]
}

