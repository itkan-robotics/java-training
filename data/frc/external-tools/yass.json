{
  "title": "YASS: Yet Another Software Suite",
  "sections": [
    {
      "type": "text",
      "title": "What is YASS?",
      "content": "YASS (Yet Another Software Suite) is a collection of libraries designed to make FRC robot programming significantly easier. YASS promotes a community with common code, allowing for easy debugging and development both with and without a robot. The suite's philosophy is that programming robots should not take years to masterâ€”teams should be able to master programming robots in days, not years.<br><br>YASS consists of four main libraries, each addressing different aspects of FRC robot development:<br><br><strong>YAGSL (Yet Another Generic Swerve Library):</strong> A powerful swerve library that allows for as complicated or simple programming experience as you'd like. YAGSL provides comprehensive swerve drive functionality with extensive customization options.<br><br><strong>YAMG (Yet Another Mechanism Generator):</strong> An extremely useful tool for teams who want to jump start their development. YAMG provides an evolving template with an interactive web simulator, allowing teams to generate command-based Java code for elevator, arm, and pivot subsystems.<br><br><strong>YAMS (Yet Another Mechanism System):</strong> An easy-to-use mechanism library for FRC that allows teams to rapidly prototype and develop seamlessly in simulation and on the robot with the same code. YAMS provides a high-level abstraction layer for building subsystems.<br><br><strong>YALL (Yet Another Limelight Library):</strong> An improved version of LimelightHelpers that provides enhanced functionality and additional features for easier integration and control of Limelight vision systems on your robot.<br><br>Learn more: <a href='https://yetanothersoftwaresuite.com/' target='_blank'>YASS Official Website</a>"
    },
    {
      "type": "text",
      "title": "Why Use YASS?",
      "content": "YASS offers several powerful benefits for FRC teams:<br><br><strong>Accelerated Development:</strong> YASS libraries are designed to reduce development time significantly. With YAMS, simulation and real robot code are nearly identical. YAMG generates code automatically, and YAGSL provides comprehensive swerve functionality out of the box. This allows teams to focus on robot functionality rather than infrastructure.<br><br><strong>Community and Common Code:</strong> YASS promotes a community with common code, making debugging and development easier. When teams use the same libraries, they can share solutions, learn from each other, and collaborate more effectively. Common code patterns make it easier for team members to understand and contribute.<br><br><strong>Simulation Integration:</strong> YASS libraries, particularly YAMS, are designed so that simulation and real robot code are nearly 1:1 identical. This enables teams to test robot code without physical hardware, develop and iterate rapidly, and validate code before deploying to hardware.<br><br><strong>Ease of Use:</strong> YASS libraries are designed to be intuitive and easy to learn. The goal is to master robot programming in days, not years. Well-designed APIs, comprehensive documentation, and helpful examples make YASS libraries accessible to teams of all experience levels.<br><br><strong>Comprehensive Coverage:</strong> YASS covers major aspects of FRC robot development: swerve drive (YAGSL), mechanism generation (YAMG), mechanism control (YAMS), and vision processing (YALL). Teams can use individual libraries or the entire suite based on their needs."
    },
    {
      "type": "text",
      "title": "YAGSL: Yet Another Generic Swerve Library",
      "content": "YAGSL is a powerful swerve library for FRC teams that provides comprehensive swerve drive functionality:<br><br><strong>Flexible Programming Experience:</strong> YAGSL allows for as complicated or simple programming experience as you'd like. Teams can use YAGSL for basic swerve drive or leverage advanced features for complex swerve configurations.<br><br><strong>Comprehensive Swerve Support:</strong> YAGSL provides full support for swerve drive systems, including module control, kinematics, and odometry. The library handles the complexities of swerve drive, allowing teams to focus on robot behavior rather than low-level swerve mechanics.<br><br><strong>Easy Integration:</strong> YAGSL integrates seamlessly with WPILib's command-based programming framework and other YASS libraries. Teams can use YAGSL alongside YAMS mechanisms and YALL vision processing for comprehensive robot control.<br><br>YAGSL is particularly valuable for teams using swerve drive, as it provides a proven, well-tested foundation for swerve systems. The library reduces the complexity of swerve drive implementation and provides consistent patterns that teams can learn and apply.<br><br>Learn more: <a href='https://yagsl.gitbook.io/yagsl/' target='_blank'>YAGSL Documentation</a>"
    },
    {
      "type": "text",
      "title": "YAMG: Yet Another Mechanism Generator",
      "content": "YAMG is an extremely useful tool for teams who want to jump start their mechanism development:<br><br><strong>Code Generation:</strong> YAMG generates command-based Java code for elevator, arm, and pivot subsystems. Teams can configure mechanisms through a web interface, and YAMG generates the corresponding Java code automatically. This eliminates boilerplate code and ensures consistent structure.<br><br><strong>Interactive Web Simulator:</strong> YAMG includes an interactive web simulator that allows teams to visualize and test mechanisms before deploying to hardware. The simulator helps teams understand mechanism behavior and validate configurations.<br><br><strong>Evolving Template:</strong> YAMG provides an evolving template that stays current with best practices and WPILib updates. Teams benefit from improvements and new features as YAMG evolves.<br><br><strong>Easy Configuration:</strong> YAMG's web interface makes it easy to configure motor controllers, gear ratios, control parameters, and telemetry settings. Non-programmers can help configure mechanisms, making the tool accessible to the entire team.<br><br>YAMG is particularly valuable for teams starting new mechanisms or wanting to quickly prototype mechanism designs. The generated code follows best practices and integrates well with YAMS and other YASS libraries.<br><br>Try it now: <a href='https://www.yamgen.com/' target='_blank'>YAMG Web Generator</a>"
    },
    {
      "type": "text",
      "title": "YAMS: Yet Another Mechanism System",
      "content": "YAMS is an easy-to-use mechanism library for FRC that allows teams to rapidly prototype and develop seamlessly in simulation and on the robot:<br><br><strong>High-Level Abstraction:</strong> YAMS provides a high-level abstraction layer for building subsystems. It supports several mechanism types: <strong>Arm</strong>, <strong>Elevator</strong>, <strong>Pivot</strong> (for turrets and wrists), <strong>Shooter</strong>, <strong>SwerveModule</strong>, <strong>SwerveDrive</strong>, <strong>DoubleJointedArm</strong>, and <strong>DifferentialMechanism</strong>.<br><br><strong>Unified Motor Controller Interface:</strong> YAMS provides a unified <code>SmartMotorController</code> interface that abstracts away vendor-specific differences. It supports SparkMax, TalonFX, TalonFXS, ThriftyNova, SparkFlex, and ReduxNitrate motor controllers, allowing you to write mechanism code once and use it with different motor controllers.<br><br><strong>Simulation and Real Code Are Nearly Identical:</strong> The most significant advantage of YAMS is that simulation and real robot code are nearly 1:1 identical. The only difference is calling <code>.simIterate()</code> in <code>simulationPeriodic()</code>. This enables full-fidelity simulation, testing without hardware, and accelerated development.<br><br><strong>Built-In Features:</strong> YAMS includes many features out of the box: SysId integration, fully customizable telemetry, seamless simulation integration, AdvantageKit integration, and live-tuning capabilities through NetworkTables (<code>NT:/Tuning</code>).<br><br>YAMS is particularly valuable for teams developing complex mechanisms, as it reduces boilerplate code and provides consistent patterns that make mechanism development faster and more reliable.<br><br>Learn more: <a href='https://yagsl.gitbook.io/yams/documentation/' target='_blank'>YAMS Documentation</a>"
    },
    {
      "type": "code",
      "title": "YAMS Example: Creating an Arm",
      "content": "package frc.robot.subsystems;\n\nimport yams.mechanisms.arm.Arm;\nimport yams.mechanisms.arm.ArmConfig;\nimport yams.motors.SmartMotorController;\nimport yams.motors.SmartMotorControllerConfig;\nimport yams.motors.wrappers.TalonFXSWrapper;\nimport com.ctre.phoenix6.hardware.TalonFX;\nimport edu.wpi.first.math.system.plant.DCMotor;\nimport edu.wpi.first.units.angle.Degrees;\nimport edu.wpi.first.units.angularvelocity.DegreesPerSecond;\nimport edu.wpi.first.units.angularacceleration.DegreesPerSecondPerSecond;\nimport edu.wpi.first.units.length.Meters;\nimport edu.wpi.first.units.mass.Pounds;\nimport edu.wpi.first.units.time.Seconds;\nimport edu.wpi.first.units.current.Amps;\nimport edu.wpi.first.wpilibj2.command.SubsystemBase;\n\npublic class ArmSubsystem extends SubsystemBase {\n    private final Arm m_arm;\n    \n    public ArmSubsystem() {\n        TalonFX armMotor = new TalonFX(1);\n        \n        SmartMotorControllerConfig motorConfig = new SmartMotorControllerConfig(this)\n            .withClosedLoopController(4.0, 0.0, 0.0, DegreesPerSecond.of(180), DegreesPerSecondPerSecond.of(90))\n            .withSoftLimit(Degrees.of(-30), Degrees.of(100))\n            .withGearing(10.71)  // Example gear ratio\n            .withIdleMode(yams.motors.MotorMode.BRAKE)\n            .withTelemetry(\"ArmMotor\", yams.motors.TelemetryVerbosity.HIGH)\n            .withStatorCurrentLimit(Amps.of(40))\n            .withMotorInverted(false)\n            .withClosedLoopRampRate(Seconds.of(0.25))\n            .withOpenLoopRampRate(Seconds.of(0.25));\n        \n        SmartMotorController motor = new TalonFXSWrapper(armMotor, DCMotor.getFalcon500(1), motorConfig);\n        \n        ArmConfig config = new ArmConfig(motor)\n            .withLength(Meters.of(0.135))\n            .withHardLimit(Degrees.of(-100), Degrees.of(200))\n            .withTelemetry(\"ArmExample\", yams.motors.TelemetryVerbosity.HIGH)\n            .withMass(Pounds.of(1))\n            .withStartingPosition(Degrees.of(0))\n            .withExternalEncoder(armMotor.getAbsoluteEncoder())\n            .withExternalEncoderInverted(true)\n            .withExternalGearing(10.71)\n            .withUseExternalFeedbackEncoder(true)\n            .withHorizontalZero(Degrees.of(0));\n        \n        m_arm = new Arm(config);\n    }\n    \n    @Override\n    public void simulationPeriodic() {\n        // Only difference between sim and real code\n        m_arm.simIterate();\n    }\n    \n    public void setTargetAngle(double angleDegrees) {\n        m_arm.setTargetAngle(Degrees.of(angleDegrees));\n    }\n    \n    public double getCurrentAngle() {\n        return m_arm.getCurrentAngle().in(Degrees);\n    }\n}\n\n// Note: This example shows the YAMS configuration pattern.\n// Refer to YAMS documentation for complete API details."
    },
    {
      "type": "text",
      "title": "YALL: Yet Another Limelight Library",
      "content": "YALL is an improved version of LimelightHelpers that provides enhanced functionality for Limelight vision systems:<br><br><strong>Improved API:</strong> YALL provides a simplified and intuitive API for controlling the Limelight camera and retrieving vision data. The API is designed to be easier to use than the standard LimelightHelpers while providing more functionality.<br><br><strong>Easy Configuration:</strong> YALL offers easy-to-use configuration options to fine-tune the vision system according to your robot's needs. Settings can be chained together for convenient configuration, and changes are saved automatically.<br><br><strong>Enhanced Features:</strong> YALL supports advanced Limelight features including MegaTag2 pose estimation, neural classifier targets, and improved pose estimation integration. The library makes it easier to use these advanced features in your robot code.<br><br><strong>Pose Estimation Support:</strong> YALL provides comprehensive support for vision-based pose estimation using MegaTag2. The library handles robot orientation updates and provides easy-to-use pose estimation methods that integrate with WPILib's pose estimators.<br><br><strong>Classifier Support:</strong> YALL supports Limelight's neural classifier functionality, making it easy to detect and track classified objects (like game pieces) using vision processing.<br><br>YALL is particularly valuable for teams using Limelight cameras, as it simplifies vision integration and provides access to advanced Limelight features that might be difficult to use with the standard helpers.<br><br>Learn more: <a href='https://github.com/Yet-Another-Software-Suite/YALL' target='_blank'>YALL GitHub Repository</a>"
    },
    {
      "type": "code",
      "title": "YALL Example: Basic Limelight Usage",
      "content": "package frc.robot.subsystems;\n\nimport limelight.Limelight;\nimport limelight.LimelightResults;\nimport limelight.NeuralClassifier;\nimport limelight.PoseEstimate;\nimport limelight.EstimationMode;\nimport limelight.LEDMode;\nimport edu.wpi.first.math.geometry.Pose3d;\nimport edu.wpi.first.math.geometry.Rotation3d;\nimport edu.wpi.first.units.angularvelocity.DegreesPerSecond;\nimport edu.wpi.first.wpilibj2.command.SubsystemBase;\nimport java.util.Optional;\n\npublic class VisionSubsystem extends SubsystemBase {\n    private final Limelight m_limelight = new Limelight(\"limelight\");\n    \n    public VisionSubsystem() {\n        // Configure Limelight settings\n        m_limelight.getSettings()\n            .withLimelightLEDMode(LEDMode.PipelineControl)\n            .withCameraOffset(Pose3d.kZero)\n            .save();\n    }\n    \n    @Override\n    public void periodic() {\n        Optional<LimelightResults> results = m_limelight.getLatestResults();\n        \n        if (results.isPresent()) {\n            LimelightResults result = results.get();\n            \n            if (result.targets_Classifier != null) {\n                for (NeuralClassifier object : result.targets_Classifier) {\n                    if (object.className.equals(\"algae\")) {\n                        // Process detected object\n                        if (object.ty > -2 && object.ty < 2) {\n                            // Object is valid - do something!\n                            System.out.println(\"Detected algae at ty: \" + object.ty);\n                        }\n                    }\n                }\n            }\n            \n            Optional<PoseEstimate> visionEstimate = m_limelight\n                .createPoseEstimator(EstimationMode.MEGATAG2)\n                .getPoseEstimate();\n            \n            visionEstimate.ifPresent((PoseEstimate poseEstimate) -> {\n                // Add to pose estimator if available\n                // m_poseEstimator.addVisionMeasurement(\n                //     poseEstimate.pose.toPose2d(),\n                //     poseEstimate.timestampSeconds\n                // );\n            });\n        }\n    }\n    \n    public Optional<PoseEstimate> getPoseEstimate() {\n        return m_limelight\n            .createPoseEstimator(EstimationMode.MEGATAG2)\n            .getPoseEstimate();\n    }\n}\n\n// Note: This example shows basic YALL usage.\n// Refer to YALL documentation for complete API details."
    },
    {
      "type": "text",
      "title": "YASS Installation and Setup",
      "content": "Each YASS library has its own installation process. Here's an overview of how to get started with each library:<br><br><strong>YAGSL Installation:</strong> YAGSL is typically installed via WPILib vendordep or as a Gradle dependency. Check the YAGSL documentation for the latest installation instructions and vendordep URL. YAGSL requires configuration for your specific swerve hardware setup.<br><br><strong>YAMG Usage:</strong> YAMG is a web-based tool that doesn't require installation. Simply visit the YAMG website, configure your mechanism, and download the generated code. Add the generated code to your robot project and configure as needed.<br><br><strong>YAMS Installation:</strong> YAMS is installed via WPILib vendordep or Gradle dependency. Add the YAMS vendordep URL to your project, or add the dependency directly to <code>build.gradle</code>. Check the YAMS documentation for the latest vendordep URL and version information.<br><br><strong>YALL Installation:</strong> YALL is installed via WPILib vendordep. Add the YALL vendordep URL (<code>//https:Yet-Another-Software-Suite.github.io/YALL/yall.json</code>) to your project. Alternatively, you can download the library manually from the releases page and add it to your project's <code>src/main</code> directory.<br><br>Each library can be used independently, so you can install only the libraries you need. However, YASS libraries are designed to work well together, so using multiple libraries provides a cohesive development experience."
    },
    {
      "type": "code",
      "title": "Installing YASS Libraries via Vendordep",
      "content": "package frc.robot;\n\nimport limelight.Limelight;\nimport edu.wpi.first.wpilibj2.command.Command;\nimport frc.robot.subsystems.VisionSubsystem;\n\npublic class RobotContainer {\n    private final VisionSubsystem m_vision = new VisionSubsystem();\n    \n    public RobotContainer() {\n        configureButtonBindings();\n    }\n    \n    private void configureButtonBindings() {\n        // Configure button bindings here\n    }\n    \n    public Command getAutonomousCommand() {\n        return null;\n    }\n}\n\n// Note: Always check official documentation for the latest\n// vendordep URLs and installation instructions."
    },
    {
      "type": "text",
      "title": "Using YASS Libraries Together",
      "content": "YASS libraries are designed to work well together, providing a comprehensive development experience:<br><br><strong>YAGSL + YAMS:</strong> Use YAGSL for swerve drive and YAMS for mechanisms. YAMS supports SwerveModule and SwerveDrive mechanisms, which can integrate with YAGSL for comprehensive swerve system management. This combination provides both low-level swerve control (YAGSL) and high-level mechanism abstraction (YAMS).<br><br><strong>YAMG + YAMS:</strong> Use YAMG to generate mechanism code, then enhance it with YAMS features. YAMG generates standard WPILib code that can be adapted to use YAMS patterns, or you can use YAMG-generated code as a starting point and migrate to YAMS for advanced features.<br><br><strong>YALL + YAMS:</strong> Use YALL for vision processing and YAMS for mechanisms. Vision data from YALL can inform mechanism control in YAMS, enabling vision-based autonomous routines. For example, use YALL to detect game pieces and YAMS to control mechanisms that interact with those pieces.<br><br><strong>Complete YASS Stack:</strong> Teams can use all YASS libraries together for comprehensive robot development. YAGSL handles swerve drive, YAMS manages mechanisms, YALL processes vision, and YAMG generates code. This provides a complete, cohesive development experience with consistent patterns and integration."
    },
    {
      "type": "rules-box",
      "title": "Best Practices",
      "subtitle": "Tips for effective YASS library usage:",
      "items": [
        "Read the official documentation for each library you use",
        "Study example code and projects to understand patterns",
        "Adopt YASS libraries incrementally, starting with one library",
        "Engage with the YASS community through Discord or GitHub",
        "Keep YASS libraries updated to benefit from bug fixes and new features",
        "Test updates before deploying to competition code",
        "When using multiple libraries, ensure they work well together",
        "Test integration and understand how libraries interact"
      ]
    },
    {
      "type": "link-grid",
      "title": "Related Topics and Documentation",
      "links": [
        {
          "label": "YASS Official Website",
          "url": "https://yetanothersoftwaresuite.com/"
        },
        {
          "label": "YAMS Documentation",
          "url": "https://yagsl.gitbook.io/yams/documentation/"
        },
        {
          "label": "YALL Documentation",
          "url": "https://github.com/Yet-Another-Software-Suite/YALL"
        },
        {
          "label": "YAGSL Documentation",
          "url": "https://yagsl.gitbook.io/yagsl/"
        }
      ]
    }
  ]
}