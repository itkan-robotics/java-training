{
  "title": "Odometry Basics",
  "sections": [
    {
      "type": "text",
      "title": "Introduction to Odometry",
      "content": "Odometry is a method of pose estimation that uses wheel encoders and a gyroscope to track robot movement over time. By measuring how far each wheel has rotated and the robot's heading, odometry calculates the robot's position through dead reckoning - integrating movement changes to determine current position.<br><br>Odometry provides continuous, fast updates (typically every 20ms robot loop) and doesn't require external references like cameras or field features. However, odometry accumulates error over time (drift) due to wheel slippage, encoder inaccuracy, and measurement errors. Despite this limitation, odometry is the foundation of most FRC pose estimation systems.<br><br>Learn more: <a href='https://docs.wpilib.org/en/stable/docs/software/kinematics-and-odometry/index.html#kinematics-and-odometry' target='_blank'>WPILib: Odometry Documentation</a>"
    },
    {
      "type": "text",
      "title": "Odometry Principles",
      "content": "Odometry works through dead reckoning - calculating position by integrating movement changes:<br><br><strong>Dead Reckoning:</strong> Starting from a known position, odometry tracks how the robot moves and updates position accordingly. Each movement (forward, backward, turning) changes the robot's pose, and these changes are accumulated to determine current position.<br><br><strong>Integrating Wheel Movements:</strong> Encoders measure how far each wheel has rotated. By knowing wheel diameter and encoder counts per revolution, odometry converts encoder readings into distance traveled. For differential drive robots, left and right wheel distances are used to calculate both forward movement and rotation.<br><br><strong>Calculating Position Changes:</strong> From wheel encoder readings and gyro heading, odometry calculates how the robot's X, Y, and heading have changed since the last update. These changes are added to the previous pose to get the new pose."
    },
    {
      "type": "text",
      "title": "Required Sensors",
      "content": "Odometry requires specific sensors to track robot movement:<br><br><strong>Wheel Encoders:</strong> Measure rotation of drive wheels. Can be built into motors (Talon FX, Spark MAX) or external encoders. Provide distance traveled by each wheel. Must be calibrated (encoder counts per revolution, wheel diameter).<br><br><strong>Gyroscope (for Heading):</strong> Measures robot rotation and heading. Can be a dedicated gyro (Pigeon, NavX) or IMU. Provides absolute heading (not just change). Essential for accurate odometry, especially during turns.<br><br><strong>Encoder Setup:</strong> Encoders must be properly configured with correct counts per revolution and wheel diameter. Encoder readings must be converted to meters (or consistent units). Encoder direction must match actual wheel rotation direction."
    },
    {
      "type": "text",
      "title": "Odometry Math",
      "content": "Odometry uses forward kinematics to calculate robot movement from wheel encoder readings:<br><br><strong>Forward Kinematics:</strong> Given wheel encoder readings (left and right distances), calculate how the robot has moved. For differential drive, left and right wheel movements determine both forward/backward movement and rotation.<br><br><strong>Calculating X/Y Changes:</strong> For a differential drive robot:<br>- Average wheel distance = (leftDistance + rightDistance) / 2<br>- This gives forward movement distance<br>- Rotation change = (rightDistance - leftDistance) / trackWidth<br>- X change = forwardDistance × cos(heading)<br>- Y change = forwardDistance × sin(heading)<br><br>These calculations convert wheel movements into field-relative position changes, which are then added to the previous pose to get the new pose."
    },
    {
      "type": "text",
      "title": "Differential Drive Odometry",
      "content": "Differential drive odometry uses two wheel encoders (left and right) plus a gyro:<br><br><strong>Two-Wheel Odometry:</strong> Left and right wheel encoders provide distance measurements. The difference between left and right distances determines rotation. The average of left and right distances determines forward movement.<br><br><strong>Calculating Position and Heading:</strong> Heading comes from the gyroscope (most accurate). Position is calculated from wheel encoder distances and current heading. Forward movement = average of left and right wheel distances. Rotation = (rightDistance - leftDistance) / trackWidth. Position change is calculated in robot coordinates, then rotated to field coordinates based on heading."
    },
    {
      "type": "code",
      "title": "Basic Differential Drive Odometry Setup",
      "content": "This example demonstrates setting up differential drive odometry:\n\npackage frc.robot.subsystems;\n\nimport edu.wpi.first.math.geometry.Pose2d;\nimport edu.wpi.first.math.geometry.Rotation2d;\nimport edu.wpi.first.math.kinematics.DifferentialDriveOdometry;\nimport edu.wpi.first.math.kinematics.DifferentialDriveKinematics;\nimport edu.wpi.first.wpilibj.Encoder;\nimport edu.wpi.first.wpilibj.ADXRS450_Gyro;\n\npublic class DrivetrainOdometry {\n    // Kinematics: converts wheel speeds to robot movement\n    private final DifferentialDriveKinematics m_kinematics;\n    \n    // Odometry: tracks robot pose\n    private DifferentialDriveOdometry m_odometry;\n    \n    // Sensors\n    private final Encoder m_leftEncoder;\n    private final Encoder m_rightEncoder;\n    private final ADXRS450_Gyro m_gyro;\n    \n    // Robot dimensions (in meters)\n    private static final double kTrackWidth = 0.6;  // Distance between wheel centers\n    private static final double kWheelDiameter = 0.1524;  // 6 inches in meters\n    private static final double kEncoderCPR = 2048.0;  // Encoder counts per revolution\n    private static final double kEncoderDistancePerPulse = \n        (kWheelDiameter * Math.PI) / kEncoderCPR;\n    \n    public DrivetrainOdometry() {\n        // Initialize kinematics with track width\n        m_kinematics = new DifferentialDriveKinematics(kTrackWidth);\n        \n        // Initialize encoders\n        m_leftEncoder = new Encoder(0, 1);\n        m_rightEncoder = new Encoder(2, 3);\n        \n        // Configure encoders to return distance in meters\n        m_leftEncoder.setDistancePerPulse(kEncoderDistancePerPulse);\n        m_rightEncoder.setDistancePerPulse(kEncoderDistancePerPulse);\n        \n        // Initialize gyro\n        m_gyro = new ADXRS450_Gyro();\n        m_gyro.calibrate();\n        \n        // Initialize odometry at starting position\n        m_odometry = new DifferentialDriveOdometry(\n            m_gyro.getRotation2d(),\n            new Pose2d()  // Start at origin (0, 0) facing forward\n        );\n    }\n}"
    },
    {
      "type": "text",
      "title": "WPILib Odometry Classes",
      "content": "WPILib provides classes to simplify odometry implementation:<br><br><strong>DifferentialDriveOdometry:</strong> Handles odometry calculations for differential drive robots. Takes gyro heading and wheel encoder distances. Automatically calculates pose updates. Provides current pose estimate.<br><br><strong>Kinematics Classes:</strong> <code>DifferentialDriveKinematics</code> converts wheel speeds to robot movement. Used for both odometry and path following. Requires track width (distance between wheel centers).<br><br>These classes handle the complex math, allowing you to focus on sensor setup and pose usage rather than implementing kinematics calculations yourself."
    },
    {
      "type": "code",
      "title": "Odometry Update in periodic()",
      "content": "This example shows how to update odometry every robot loop:\n\npackage frc.robot.subsystems;\n\nimport edu.wpi.first.math.geometry.Pose2d;\nimport edu.wpi.first.math.kinematics.DifferentialDriveOdometry;\nimport edu.wpi.first.wpilibj.Encoder;\nimport edu.wpi.first.wpilibj.ADXRS450_Gyro;\n\npublic class DrivetrainOdometry {\n    private DifferentialDriveOdometry m_odometry;\n    private final Encoder m_leftEncoder;\n    private final Encoder m_rightEncoder;\n    private final ADXRS450_Gyro m_gyro;\n    \n    // ... initialization code from previous example ...\n    \n    /**\n     * Update odometry - call this in periodic()\n     */\n    public void updateOdometry() {\n        // Get current sensor readings\n        double leftDistance = m_leftEncoder.getDistance();\n        double rightDistance = m_rightEncoder.getDistance();\n        Rotation2d heading = m_gyro.getRotation2d();\n        \n        // Update odometry with new sensor readings\n        // This calculates the new pose based on wheel movements\n        m_odometry.update(heading, leftDistance, rightDistance);\n    }\n    \n    /**\n     * Get current robot pose\n     */\n    public Pose2d getPose() {\n        return m_odometry.getPoseMeters();\n    }\n    \n    /**\n     * Reset odometry to a specific pose\n     * Useful when you know the robot's actual position (e.g., from vision)\n     */\n    public void resetOdometry(Pose2d pose) {\n        m_odometry.resetPosition(\n            m_gyro.getRotation2d(),\n            m_leftEncoder.getDistance(),\n            m_rightEncoder.getDistance(),\n            pose\n        );\n    }\n}"
    },
    {
      "type": "code",
      "title": "Reading and Displaying Pose",
      "content": "This example shows how to read and use the pose estimate:\n\npackage frc.robot.subsystems;\n\nimport edu.wpi.first.math.geometry.Pose2d;\nimport edu.wpi.first.wpilibj.smartdashboard.SmartDashboard;\n\npublic class DrivetrainOdometry {\n    private DifferentialDriveOdometry m_odometry;\n    \n    // ... odometry setup and update code ...\n    \n    public void periodic() {\n        // Update odometry every loop\n        updateOdometry();\n        \n        // Get current pose\n        Pose2d currentPose = getPose();\n        \n        // Display pose on SmartDashboard\n        SmartDashboard.putNumber(\"Robot X\", currentPose.getX());\n        SmartDashboard.putNumber(\"Robot Y\", currentPose.getY());\n        SmartDashboard.putNumber(\"Robot Heading\", \n            currentPose.getRotation().getDegrees());\n        \n        // You can also use the pose for autonomous navigation\n        // For example, check if robot is at target position\n        Pose2d targetPose = new Pose2d(3.0, 2.0, Rotation2d.fromDegrees(90.0));\n        double distanceToTarget = currentPose.getTranslation()\n            .getDistance(targetPose.getTranslation());\n        \n        SmartDashboard.putNumber(\"Distance to Target\", distanceToTarget);\n    }\n}"
    },
    {
      "type": "text",
      "title": "Odometry Limitations",
      "content": "Understanding odometry limitations is crucial for effective use:<br><br><strong>Drift:</strong> Odometry accumulates error over time. Small measurement errors compound, causing the pose estimate to drift from actual position. Drift increases with distance traveled and time. Typical drift: 1-5% of distance traveled.<br><br><strong>Wheel Slippage:</strong> When wheels slip (during acceleration, on slippery surfaces, during collisions), encoder readings don't match actual movement. Slippage causes immediate pose errors that persist until corrected.<br><br><strong>Accuracy Degradation Over Time:</strong> Without correction, odometry accuracy decreases over time. After long autonomous routines or extended operation, pose may be significantly off. This is why sensor fusion with vision is recommended for high-accuracy applications."
    },
    {
      "type": "link-grid",
      "title": "Documentation Resources",
      "links": [
        {
          "label": "WPILib Odometry Overview",
          "url": "https://docs.wpilib.org/en/stable/docs/software/kinematics-and-odometry/index.html#kinematics-and-odometry"
        },
        {
          "label": "DifferentialDriveOdometry",
          "url": "https://docs.wpilib.org/en/stable/docs/software/kinematics-and-odometry/differential-drive-kinematics.html"
        },
        {
          "label": "DifferentialDriveKinematics",
          "url": "https://docs.wpilib.org/en/stable/docs/software/kinematics-and-odometry/differential-drive-kinematics.html"
        }
      ]
    }
  ]
}

