{
  "title": "Odometry",
  "sections": [
    {
      "type": "text",
      "title": "Introduction to Odometry",
      "content": "Odometry is a method of pose estimation that uses wheel encoders and a gyroscope to track robot movement over time. By measuring how far each wheel has rotated and the robot's heading, odometry calculates the robot's position through dead reckoning - integrating movement changes to determine current position.<br><br>Odometry provides continuous, fast updates (typically every 20ms robot loop) and doesn't require external references like cameras or field features. However, odometry accumulates error over time (drift) due to wheel slippage, encoder inaccuracy, and measurement errors. Despite this limitation, odometry is the foundation of most FRC pose estimation systems.<br><br>This lesson covers odometry for both differential drive and swerve drive robots.<br><br>Learn more: <a href='https://docs.wpilib.org/en/stable/docs/software/kinematics-and-odometry/index.html' target='_blank'>WPILib: Odometry Documentation</a>"
    },
    {
      "type": "text",
      "title": "Odometry Principles",
      "content": "Odometry works through dead reckoning - calculating position by integrating movement changes:<br><br><strong>Dead Reckoning:</strong> Starting from a known position, odometry tracks how the robot moves and updates position accordingly. Each movement (forward, backward, turning) changes the robot's pose, and these changes are accumulated to determine current position.<br><br><strong>Integrating Wheel Movements:</strong> Encoders measure how far each wheel has rotated. By knowing wheel diameter and encoder counts per revolution, odometry converts encoder readings into distance traveled.<br><br><strong>Calculating Position Changes:</strong> From wheel encoder readings and gyro heading, odometry calculates how the robot's X, Y, and heading have changed since the last update. These changes are added to the previous pose to get the new pose."
    },
    {
      "type": "text",
      "title": "Required Sensors",
      "content": "Odometry requires specific sensors to track robot movement:<br><br><strong>Wheel Encoders:</strong><br>- Measure rotation of drive wheels<br>- Can be built into motors (Talon FX, SPARK MAX) or external encoders<br>- Provide distance traveled by each wheel<br>- Must be calibrated (encoder counts per revolution, wheel diameter)<br><br><strong>Gyroscope (for Heading):</strong><br>- Measures robot rotation and heading<br>- Can be a dedicated gyro (Pigeon 2, NavX, ADXRS450)<br>- Provides absolute heading (not just change)<br>- Essential for accurate odometry, especially during turns"
    },
    {
      "type": "text",
      "title": "Differential Drive Odometry",
      "content": "Differential drive odometry uses two wheel encoders (left and right) plus a gyroscope to track robot pose.<br><br><strong>How It Works:</strong><br>- Left and right wheel encoders provide distance measurements<br>- The difference between left and right distances determines rotation<br>- The average of left and right distances determines forward movement<br>- Heading comes from the gyroscope (most accurate)<br>- Position is calculated from wheel distances and heading<br><br><strong>WPILib Support:</strong> WPILib provides the <code>DifferentialDriveOdometry</code> class that handles all the complex kinematics calculations for you."
    },
    {
      "type": "code",
      "title": "Differential Drive Odometry Setup",
      "content": "package frc.robot.subsystems;\n\nimport edu.wpi.first.math.geometry.Pose2d;\nimport edu.wpi.first.math.geometry.Rotation2d;\nimport edu.wpi.first.math.kinematics.DifferentialDriveOdometry;\nimport com.ctre.phoenix6.hardware.TalonFX;\nimport com.ctre.phoenix6.hardware.Pigeon2;\nimport com.ctre.phoenix6.StatusSignal;\nimport com.ctre.phoenix6.BaseStatusSignal;\n\npublic class DifferentialDrivetrain {\n    // Motors\n    private final TalonFX m_leftMotor = new TalonFX(1);\n    private final TalonFX m_rightMotor = new TalonFX(2);\n    \n    // Gyro\n    private final Pigeon2 m_gyro = new Pigeon2(0);\n    \n    // Odometry\n    private final DifferentialDriveOdometry m_odometry;\n    \n    // Status signals for efficient reading\n    private final StatusSignal<Double> m_leftPosition = m_leftMotor.getPosition();\n    private final StatusSignal<Double> m_rightPosition = m_rightMotor.getPosition();\n    private final StatusSignal<Double> m_yaw = m_gyro.getYaw();\n    \n    public DifferentialDrivetrain() {\n        // Initialize odometry with starting pose\n        m_odometry = new DifferentialDriveOdometry(\n            Rotation2d.fromDegrees(m_yaw.refresh().getValue()),\n            0.0,  // Left distance\n            0.0,  // Right distance\n            new Pose2d()  // Starting pose (0, 0, 0 degrees)\n        );\n    }\n    \n    public void updateOdometry() {\n        // Refresh all signals efficiently\n        BaseStatusSignal.waitForAll(0.02, m_leftPosition, m_rightPosition, m_yaw);\n        \n        double leftDistance = m_leftPosition.getValue();  // meters\n        double rightDistance = m_rightPosition.getValue();  // meters\n        Rotation2d heading = Rotation2d.fromDegrees(m_yaw.getValue());\n        \n        // Update odometry\n        m_odometry.update(heading, leftDistance, rightDistance);\n    }\n    \n    public Pose2d getPose() {\n        return m_odometry.getPoseMeters();\n    }\n    \n    public void resetOdometry(Pose2d pose) {\n        // Refresh signals\n        BaseStatusSignal.waitForAll(0.02, m_leftPosition, m_rightPosition, m_yaw);\n        \n        m_odometry.resetPosition(\n            Rotation2d.fromDegrees(m_yaw.getValue()),\n            m_leftPosition.getValue(),\n            m_rightPosition.getValue(),\n            pose\n        );\n    }\n}"
    },
    {
      "type": "text",
      "title": "Swerve Drive Odometry",
      "content": "Swerve odometry is similar to differential drive odometry but accounts for the unique movement characteristics of swerve drivetrains. Swerve robots can move in any direction (holonomic movement) and rotate independently, requiring odometry that tracks individual module positions and angles.<br><br><strong>How It Works:</strong><br>- Each swerve module has a drive encoder (distance) and angle encoder (steering direction)<br>- All four module states are combined to calculate overall robot movement<br>- Gyroscope provides heading for accuracy<br>- More measurement points = higher accuracy than differential drive<br><br><strong>WPILib Support:</strong> WPILib provides the <code>SwerveDriveOdometry</code> class that handles all the complex kinematics calculations for you.<br><br>Learn more: <a href='https://docs.wpilib.org/en/stable/docs/software/kinematics-and-odometry/swerve-drive-odometry.html' target='_blank'>WPILib: Swerve Drive Odometry</a>"
    },
    {
      "type": "code",
      "title": "Swerve Drive Odometry Setup",
      "content": "package frc.robot.subsystems;\n\nimport edu.wpi.first.math.geometry.Pose2d;\nimport edu.wpi.first.math.geometry.Rotation2d;\nimport edu.wpi.first.math.geometry.Translation2d;\nimport edu.wpi.first.math.kinematics.SwerveDriveKinematics;\nimport edu.wpi.first.math.kinematics.SwerveDriveOdometry;\nimport edu.wpi.first.math.kinematics.SwerveModulePosition;\nimport com.ctre.phoenix6.hardware.Pigeon2;\nimport com.ctre.phoenix6.StatusSignal;\n\npublic class SwerveDrivetrain {\n    private final Pigeon2 m_gyro = new Pigeon2(0);\n    private final StatusSignal<Double> m_yaw = m_gyro.getYaw();\n    \n    // Swerve modules (implementation not shown)\n    private final SwerveModule[] m_modules = new SwerveModule[4];\n    \n    // Module positions array for odometry\n    private final SwerveModulePosition[] m_modulePositions = new SwerveModulePosition[4];\n    \n    // Kinematics: defines module positions relative to robot center\n    private final SwerveDriveKinematics m_kinematics;\n    \n    // Odometry\n    private final SwerveDriveOdometry m_odometry;\n    \n    // Robot dimensions (meters)\n    private static final double kTrackWidth = 0.5;   // Left-right spacing\n    private static final double kWheelBase = 0.5;    // Front-rear spacing\n    \n    public SwerveDrivetrain() {\n        // Define module positions relative to robot center\n        Translation2d frontLeft = new Translation2d(kWheelBase / 2, kTrackWidth / 2);\n        Translation2d frontRight = new Translation2d(kWheelBase / 2, -kTrackWidth / 2);\n        Translation2d rearLeft = new Translation2d(-kWheelBase / 2, kTrackWidth / 2);\n        Translation2d rearRight = new Translation2d(-kWheelBase / 2, -kTrackWidth / 2);\n        \n        m_kinematics = new SwerveDriveKinematics(\n            frontLeft, frontRight, rearLeft, rearRight\n        );\n        \n        // Initialize module positions\n        for (int i = 0; i < 4; i++) {\n            m_modulePositions[i] = m_modules[i].getPosition();\n        }\n        \n        // Initialize odometry\n        m_odometry = new SwerveDriveOdometry(\n            m_kinematics,\n            Rotation2d.fromDegrees(m_yaw.refresh().getValue()),\n            m_modulePositions,\n            new Pose2d()  // Starting pose\n        );\n    }\n    \n    public void updateOdometry() {\n        // Get current module positions\n        for (int i = 0; i < 4; i++) {\n            m_modulePositions[i] = m_modules[i].getPosition();\n        }\n        \n        // Get heading\n        Rotation2d heading = Rotation2d.fromDegrees(m_yaw.refresh().getValue());\n        \n        // Update odometry\n        m_odometry.update(heading, m_modulePositions);\n    }\n    \n    public Pose2d getPose() {\n        return m_odometry.getPoseMeters();\n    }\n    \n    public void resetOdometry(Pose2d pose) {\n        // Get current module positions and heading\n        for (int i = 0; i < 4; i++) {\n            m_modulePositions[i] = m_modules[i].getPosition();\n        }\n        \n        m_odometry.resetPosition(\n            Rotation2d.fromDegrees(m_yaw.refresh().getValue()),\n            m_modulePositions,\n            pose\n        );\n    }\n}"
    },
    {
      "type": "text",
      "title": "Swerve Module Position",
      "content": "For swerve odometry, each module needs to report its <code>SwerveModulePosition</code> which contains:<br><br><strong>Module Position Components:</strong><br>- <strong>Distance:</strong> How far the module's drive wheel has traveled (meters)<br>- <strong>Angle:</strong> The module's current steering angle (Rotation2d)<br><br><strong>Reading from Modules:</strong> Each swerve module typically has a drive motor with encoder (for distance) and a CANcoder or similar sensor (for steering angle). Combine these readings to create a <code>SwerveModulePosition</code>."
    },
    {
      "type": "code",
      "title": "Swerve Module Position Example",
      "content": "package frc.robot.subsystems.swerve;\n\nimport com.ctre.phoenix6.hardware.TalonFX;\nimport com.ctre.phoenix6.hardware.CANcoder;\nimport com.ctre.phoenix6.StatusSignal;\nimport com.ctre.phoenix6.BaseStatusSignal;\nimport edu.wpi.first.math.geometry.Rotation2d;\nimport edu.wpi.first.math.kinematics.SwerveModulePosition;\nimport edu.wpi.first.math.kinematics.SwerveModuleState;\n\npublic class SwerveModule {\n    private final TalonFX m_driveMotor;\n    private final TalonFX m_steerMotor;\n    private final CANcoder m_angleEncoder;\n    \n    // Status signals for efficient reading\n    private final StatusSignal<Double> m_drivePosition;\n    private final StatusSignal<Double> m_anglePosition;\n    private final StatusSignal<Double> m_driveVelocity;\n    \n    public SwerveModule(int driveID, int steerID, int encoderID) {\n        m_driveMotor = new TalonFX(driveID);\n        m_steerMotor = new TalonFX(steerID);\n        m_angleEncoder = new CANcoder(encoderID);\n        \n        // Get status signals\n        m_drivePosition = m_driveMotor.getPosition();\n        m_anglePosition = m_angleEncoder.getPosition();\n        m_driveVelocity = m_driveMotor.getVelocity();\n    }\n    \n    public SwerveModulePosition getPosition() {\n        // Refresh signals efficiently\n        BaseStatusSignal.waitForAll(0.02, m_drivePosition, m_anglePosition);\n        \n        double distanceMeters = m_drivePosition.getValue();\n        Rotation2d angle = Rotation2d.fromRotations(m_anglePosition.getValue());\n        \n        return new SwerveModulePosition(distanceMeters, angle);\n    }\n    \n    public SwerveModuleState getState() {\n        // Refresh signals efficiently\n        BaseStatusSignal.waitForAll(0.02, m_driveVelocity, m_anglePosition);\n        \n        double velocityMPS = m_driveVelocity.getValue();  // meters per second\n        Rotation2d angle = Rotation2d.fromRotations(m_anglePosition.getValue());\n        \n        return new SwerveModuleState(velocityMPS, angle);\n    }\n}"
    },
    {
      "type": "text",
      "title": "Odometry Limitations",
      "content": "Understanding odometry limitations is crucial for effective use:<br><br><strong>Drift:</strong> Odometry accumulates error over time. Small measurement errors compound, causing the pose estimate to drift from actual position. Drift increases with distance traveled and time. Typical drift: 1-5% of distance traveled.<br><br><strong>Wheel Slippage:</strong> When wheels slip (during acceleration, on slippery surfaces, during collisions), encoder readings don't match actual movement. Slippage causes immediate pose errors that persist until corrected.<br><br><strong>Accuracy Degradation Over Time:</strong> Without correction, odometry accuracy decreases over time. After long autonomous routines or extended operation, pose may be significantly off. This is why sensor fusion with vision is recommended for high-accuracy applications.<br><br><strong>Mitigation Strategies:</strong><br>- Use vision-based pose estimation to periodically correct drift<br>- Implement sensor fusion (see <a href='#vision-pose-estimation-complete' target='_blank'>Vision-Based Pose Estimation</a> lesson)<br>- Design mechanisms to minimize wheel slippage<br>- Calibrate wheel diameter and encoder settings accurately"
    },
    {
      "type": "text",
      "title": "Swerve-Specific Considerations",
      "content": "Swerve odometry has unique considerations compared to differential drive:<br><br><strong>Module Offsets:</strong> Module positions must be accurately measured relative to robot center. Incorrect offsets cause odometry errors. Measure track width and wheelbase carefully (in meters).<br><br><strong>Module Angle Accuracy:</strong> Swerve odometry requires accurate module angle measurements. Absolute encoders (like CANcoder) are strongly recommended for each module. Module angle errors directly affect odometry accuracy.<br><br><strong>Center of Rotation:</strong> Swerve robots can rotate around any point (not just center). Odometry assumes rotation around robot center, which is accurate for most cases.<br><br><strong>Accuracy Advantages:</strong> Swerve odometry is typically more accurate than differential drive because it uses four measurement points instead of two. However, it requires proper calibration of all four modules."
    },
    {
      "type": "code",
      "title": "Complete Swerve Odometry Example",
      "content": "package frc.robot.subsystems;\n\nimport edu.wpi.first.math.geometry.Pose2d;\nimport edu.wpi.first.math.geometry.Rotation2d;\nimport edu.wpi.first.math.geometry.Translation2d;\nimport edu.wpi.first.math.kinematics.SwerveDriveKinematics;\nimport edu.wpi.first.math.kinematics.SwerveDriveOdometry;\nimport edu.wpi.first.math.kinematics.SwerveModulePosition;\nimport edu.wpi.first.wpilibj.smartdashboard.SmartDashboard;\nimport edu.wpi.first.wpilibj2.command.SubsystemBase;\nimport com.ctre.phoenix6.hardware.Pigeon2;\nimport com.ctre.phoenix6.StatusSignal;\n\npublic class SwerveDriveOdometryExample extends SubsystemBase {\n    // Gyro\n    private final Pigeon2 m_gyro = new Pigeon2(0);\n    private final StatusSignal<Double> m_yaw = m_gyro.getYaw();\n    \n    // Swerve modules\n    private final SwerveModule m_frontLeft;\n    private final SwerveModule m_frontRight;\n    private final SwerveModule m_rearLeft;\n    private final SwerveModule m_rearRight;\n    \n    // Kinematics and odometry\n    private final SwerveDriveKinematics m_kinematics;\n    private final SwerveDriveOdometry m_odometry;\n    private final SwerveModulePosition[] m_modulePositions = new SwerveModulePosition[4];\n    \n    // Robot dimensions (meters)\n    private static final double kTrackWidth = 0.5;   // Left-right spacing\n    private static final double kWheelBase = 0.5;    // Front-rear spacing\n    \n    public SwerveDriveOdometryExample() {\n        // Define module positions relative to robot center\n        Translation2d frontLeft = new Translation2d(kWheelBase / 2, kTrackWidth / 2);\n        Translation2d frontRight = new Translation2d(kWheelBase / 2, -kTrackWidth / 2);\n        Translation2d rearLeft = new Translation2d(-kWheelBase / 2, kTrackWidth / 2);\n        Translation2d rearRight = new Translation2d(-kWheelBase / 2, -kTrackWidth / 2);\n        \n        m_kinematics = new SwerveDriveKinematics(\n            frontLeft, frontRight, rearLeft, rearRight\n        );\n        \n        // Initialize modules (IDs are examples)\n        m_frontLeft = new SwerveModule(1, 2, 10);\n        m_frontRight = new SwerveModule(3, 4, 11);\n        m_rearLeft = new SwerveModule(5, 6, 12);\n        m_rearRight = new SwerveModule(7, 8, 13);\n        \n        // Initialize module positions\n        updateModulePositions();\n        \n        // Initialize odometry\n        m_odometry = new SwerveDriveOdometry(\n            m_kinematics,\n            Rotation2d.fromDegrees(m_yaw.refresh().getValue()),\n            m_modulePositions,\n            new Pose2d()\n        );\n    }\n    \n    private void updateModulePositions() {\n        m_modulePositions[0] = m_frontLeft.getPosition();\n        m_modulePositions[1] = m_frontRight.getPosition();\n        m_modulePositions[2] = m_rearLeft.getPosition();\n        m_modulePositions[3] = m_rearRight.getPosition();\n    }\n    \n    @Override\n    public void periodic() {\n        // Update module positions\n        updateModulePositions();\n        \n        // Update odometry\n        m_odometry.update(\n            Rotation2d.fromDegrees(m_yaw.refresh().getValue()),\n            m_modulePositions\n        );\n        \n        // Display pose\n        Pose2d pose = m_odometry.getPoseMeters();\n        SmartDashboard.putNumber(\"Robot X\", pose.getX());\n        SmartDashboard.putNumber(\"Robot Y\", pose.getY());\n        SmartDashboard.putNumber(\"Robot Heading\", pose.getRotation().getDegrees());\n    }\n    \n    public Pose2d getPose() {\n        return m_odometry.getPoseMeters();\n    }\n    \n    public void resetOdometry(Pose2d pose) {\n        updateModulePositions();\n        m_odometry.resetPosition(\n            Rotation2d.fromDegrees(m_yaw.refresh().getValue()),\n            m_modulePositions,\n            pose\n        );\n    }\n}"
    },
    {
      "type": "text",
      "title": "Best Practices for Accurate Odometry",
      "content": "Following these practices ensures the most accurate odometry possible:<br><br><strong>Sensor Calibration:</strong><br>- Accurately measure and configure wheel diameter<br>- Accurately measure and configure track width / wheelbase<br>- Calibrate gyroscope properly<br>- For swerve: Calibrate all module angle offsets<br><br><strong>Update Frequency:</strong><br>- Call <code>update()</code> in every <code>periodic()</code> call (20ms)<br>- Don't skip odometry updates<br>- Use status signal batching for efficiency<br><br><strong>Drift Mitigation:</strong><br>- Combine with vision for periodic corrections<br>- Reset odometry at start of autonomous<br>- Monitor odometry accuracy during testing<br><br><strong>Mechanical Considerations:</strong><br>- Minimize wheel slippage (proper wheel material, avoid aggressive acceleration)<br>- Ensure encoders are securely mounted<br>- Check for mechanical play in drivetrain"
    },
    {
      "type": "link-grid",
      "title": "Related Topics and Documentation",
      "links": [
        {
          "label": "Pose Estimation Introduction",
          "id": "pose-estimation-intro"
        },
        {
          "label": "Vision-Based Pose Estimation",
          "id": "vision-pose-estimation-complete"
        },
        {
          "label": "WPILib Kinematics and Odometry",
          "url": "https://docs.wpilib.org/en/stable/docs/software/kinematics-and-odometry/index.html"
        },
        {
          "label": "CTRE Sensors",
          "id": "ctre-sensors"
        }
      ]
    }
  ]
}

